// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles
parcelRequire = (function (modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error('Cannot find module \'' + name + '\'');
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = cache[name] = new newRequire.Module(name);

      modules[name][0].call(module.exports, localRequire, module, module.exports, this);
    }

    return cache[name].exports;

    function localRequire(x){
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x){
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [function (require, module) {
      module.exports = exports;
    }, {}];
  };

  var error;
  for (var i = 0; i < entry.length; i++) {
    try {
      newRequire(entry[i]);
    } catch (e) {
      // Save first error but execute all entries
      if (!error) {
        error = e;
      }
    }
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
     define(function () {
       return mainExports;
     });

    // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  parcelRequire = newRequire;

  if (error) {
    // throw error from earlier, _after updating parcelRequire_
    throw error;
  }

  return newRequire;
})({"node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/assert.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assert = assert;

function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'loader assertion failed.');
  }
}
},{}],"../../.nvm/versions/node/v16.15.0/lib/node_modules/parcel-bundler/node_modules/process/browser.js":[function(require,module,exports) {

// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};
},{}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/globals.js":[function(require,module,exports) {
var global = arguments[3];
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.window = exports.self = exports.nodeVersion = exports.isWorker = exports.isBrowser = exports.global = exports.document = void 0;
const globals = {
  self: typeof self !== 'undefined' && self,
  window: typeof window !== 'undefined' && window,
  global: typeof global !== 'undefined' && global,
  document: typeof document !== 'undefined' && document
};
const self_ = globals.self || globals.window || globals.global || {};
exports.self = self_;
const window_ = globals.window || globals.self || globals.global || {};
exports.window = window_;
const global_ = globals.global || globals.self || globals.window || {};
exports.global = global_;
const document_ = globals.document || {};
exports.document = document_;
const isBrowser = Boolean(typeof process !== 'object' || String(process) !== '[object process]' || true);
exports.isBrowser = isBrowser;
const isWorker = typeof importScripts === 'function';
exports.isWorker = isWorker;
const matches = typeof process !== 'undefined' && process.version && /v([0-9]*)/.exec(process.version);
const nodeVersion = matches && parseFloat(matches[1]) || 0;
exports.nodeVersion = nodeVersion;
},{"process":"../../.nvm/versions/node/v16.15.0/lib/node_modules/parcel-bundler/node_modules/process/browser.js"}],"node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/version.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VERSION = void 0;
const DEFAULT_VERSION = 'latest';
const VERSION = typeof "3.2.3" !== 'undefined' ? "3.2.3" : DEFAULT_VERSION;
exports.VERSION = VERSION;

if (typeof "3.2.3" === 'undefined') {
  console.error('loaders.gl: The __VERSION__ variable is not injected using babel plugin. Latest unstable workers would be fetched from the CDN.');
}
},{}],"node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/assert.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assert = assert;

function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'loaders.gl assertion failed.');
  }
}
},{}],"node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/globals.js":[function(require,module,exports) {
var global = arguments[3];
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.window = exports.self = exports.nodeVersion = exports.isWorker = exports.isMobile = exports.isBrowser = exports.global = exports.document = void 0;
const globals = {
  self: typeof self !== 'undefined' && self,
  window: typeof window !== 'undefined' && window,
  global: typeof global !== 'undefined' && global,
  document: typeof document !== 'undefined' && document
};
const self_ = globals.self || globals.window || globals.global || {};
exports.self = self_;
const window_ = globals.window || globals.self || globals.global || {};
exports.window = window_;
const global_ = globals.global || globals.self || globals.window || {};
exports.global = global_;
const document_ = globals.document || {};
exports.document = document_;
const isBrowser = typeof process !== 'object' || String(process) !== '[object process]' || true;
exports.isBrowser = isBrowser;
const isWorker = typeof importScripts === 'function';
exports.isWorker = isWorker;
const isMobile = typeof window !== 'undefined' && typeof window.orientation !== 'undefined';
exports.isMobile = isMobile;
const matches = typeof process !== 'undefined' && process.version && /v([0-9]*)/.exec(process.version);
const nodeVersion = matches && parseFloat(matches[1]) || 0;
exports.nodeVersion = nodeVersion;
},{"process":"../../.nvm/versions/node/v16.15.0/lib/node_modules/parcel-bundler/node_modules/process/browser.js"}],"node_modules/@babel/runtime/helpers/esm/defineProperty.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _defineProperty;

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}
},{}],"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-job.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));

var _assert = require("../env-utils/assert");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class WorkerJob {
  constructor(jobName, workerThread) {
    (0, _defineProperty2.default)(this, "name", void 0);
    (0, _defineProperty2.default)(this, "workerThread", void 0);
    (0, _defineProperty2.default)(this, "isRunning", true);
    (0, _defineProperty2.default)(this, "result", void 0);
    (0, _defineProperty2.default)(this, "_resolve", () => {});
    (0, _defineProperty2.default)(this, "_reject", () => {});
    this.name = jobName;
    this.workerThread = workerThread;
    this.result = new Promise((resolve, reject) => {
      this._resolve = resolve;
      this._reject = reject;
    });
  }

  postMessage(type, payload) {
    this.workerThread.postMessage({
      source: 'loaders.gl',
      type,
      payload
    });
  }

  done(value) {
    (0, _assert.assert)(this.isRunning);
    this.isRunning = false;

    this._resolve(value);
  }

  error(error) {
    (0, _assert.assert)(this.isRunning);
    this.isRunning = false;

    this._reject(error);
  }

}

exports.default = WorkerJob;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","../env-utils/assert":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/assert.js"}],"node_modules/@loaders.gl/worker-utils/dist/esm/lib/node/worker_threads-browser.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parentPort = exports.Worker = void 0;

class Worker {}

exports.Worker = Worker;
const parentPort = null;
exports.parentPort = parentPort;
},{}],"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-utils/get-loadable-worker-url.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getLoadableWorkerURL = getLoadableWorkerURL;

var _assert = require("../env-utils/assert");

const workerURLCache = new Map();

function getLoadableWorkerURL(props) {
  (0, _assert.assert)(props.source && !props.url || !props.source && props.url);
  let workerURL = workerURLCache.get(props.source || props.url);

  if (!workerURL) {
    if (props.url) {
      workerURL = getLoadableWorkerURLFromURL(props.url);
      workerURLCache.set(props.url, workerURL);
    }

    if (props.source) {
      workerURL = getLoadableWorkerURLFromSource(props.source);
      workerURLCache.set(props.source, workerURL);
    }
  }

  (0, _assert.assert)(workerURL);
  return workerURL;
}

function getLoadableWorkerURLFromURL(url) {
  if (!url.startsWith('http')) {
    return url;
  }

  const workerSource = buildScriptSource(url);
  return getLoadableWorkerURLFromSource(workerSource);
}

function getLoadableWorkerURLFromSource(workerSource) {
  const blob = new Blob([workerSource], {
    type: 'application/javascript'
  });
  return URL.createObjectURL(blob);
}

function buildScriptSource(workerUrl) {
  return "try {\n  importScripts('".concat(workerUrl, "');\n} catch (error) {\n  console.error(error);\n  throw error;\n}");
}
},{"../env-utils/assert":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/assert.js"}],"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-utils/get-transfer-list.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTransferList = getTransferList;

function getTransferList(object, recursive = true, transfers) {
  const transfersSet = transfers || new Set();

  if (!object) {} else if (isTransferable(object)) {
    transfersSet.add(object);
  } else if (isTransferable(object.buffer)) {
    transfersSet.add(object.buffer);
  } else if (ArrayBuffer.isView(object)) {} else if (recursive && typeof object === 'object') {
    for (const key in object) {
      getTransferList(object[key], recursive, transfersSet);
    }
  }

  return transfers === undefined ? Array.from(transfersSet) : [];
}

function isTransferable(object) {
  if (!object) {
    return false;
  }

  if (object instanceof ArrayBuffer) {
    return true;
  }

  if (typeof MessagePort !== 'undefined' && object instanceof MessagePort) {
    return true;
  }

  if (typeof ImageBitmap !== 'undefined' && object instanceof ImageBitmap) {
    return true;
  }

  if (typeof OffscreenCanvas !== 'undefined' && object instanceof OffscreenCanvas) {
    return true;
  }

  return false;
}
},{}],"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-thread.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));

var _worker_threads = require("../node/worker_threads");

var _globals = require("../env-utils/globals");

var _assert = require("../env-utils/assert");

var _getLoadableWorkerUrl = require("../worker-utils/get-loadable-worker-url");

var _getTransferList = require("../worker-utils/get-transfer-list");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const NOOP = () => {};

class WorkerThread {
  static isSupported() {
    return typeof Worker !== 'undefined' && _globals.isBrowser || typeof _worker_threads.Worker !== undefined;
  }

  constructor(props) {
    (0, _defineProperty2.default)(this, "name", void 0);
    (0, _defineProperty2.default)(this, "source", void 0);
    (0, _defineProperty2.default)(this, "url", void 0);
    (0, _defineProperty2.default)(this, "terminated", false);
    (0, _defineProperty2.default)(this, "worker", void 0);
    (0, _defineProperty2.default)(this, "onMessage", void 0);
    (0, _defineProperty2.default)(this, "onError", void 0);
    (0, _defineProperty2.default)(this, "_loadableURL", '');
    const {
      name,
      source,
      url
    } = props;
    (0, _assert.assert)(source || url);
    this.name = name;
    this.source = source;
    this.url = url;
    this.onMessage = NOOP;

    this.onError = error => console.log(error);

    this.worker = _globals.isBrowser ? this._createBrowserWorker() : this._createNodeWorker();
  }

  destroy() {
    this.onMessage = NOOP;
    this.onError = NOOP;
    this.worker.terminate();
    this.terminated = true;
  }

  get isRunning() {
    return Boolean(this.onMessage);
  }

  postMessage(data, transferList) {
    transferList = transferList || (0, _getTransferList.getTransferList)(data);
    this.worker.postMessage(data, transferList);
  }

  _getErrorFromErrorEvent(event) {
    let message = 'Failed to load ';
    message += "worker ".concat(this.name, " from ").concat(this.url, ". ");

    if (event.message) {
      message += "".concat(event.message, " in ");
    }

    if (event.lineno) {
      message += ":".concat(event.lineno, ":").concat(event.colno);
    }

    return new Error(message);
  }

  _createBrowserWorker() {
    this._loadableURL = (0, _getLoadableWorkerUrl.getLoadableWorkerURL)({
      source: this.source,
      url: this.url
    });
    const worker = new Worker(this._loadableURL, {
      name: this.name
    });

    worker.onmessage = event => {
      if (!event.data) {
        this.onError(new Error('No data received'));
      } else {
        this.onMessage(event.data);
      }
    };

    worker.onerror = error => {
      this.onError(this._getErrorFromErrorEvent(error));
      this.terminated = true;
    };

    worker.onmessageerror = event => console.error(event);

    return worker;
  }

  _createNodeWorker() {
    let worker;

    if (this.url) {
      const absolute = this.url.includes(':/') || this.url.startsWith('/');
      const url = absolute ? this.url : "./".concat(this.url);
      worker = new _worker_threads.Worker(url, {
        eval: false
      });
    } else if (this.source) {
      worker = new _worker_threads.Worker(this.source, {
        eval: true
      });
    } else {
      throw new Error('no worker');
    }

    worker.on('message', data => {
      this.onMessage(data);
    });
    worker.on('error', error => {
      this.onError(error);
    });
    worker.on('exit', code => {});
    return worker;
  }

}

exports.default = WorkerThread;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","../node/worker_threads":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/node/worker_threads-browser.js","../env-utils/globals":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/globals.js","../env-utils/assert":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/assert.js","../worker-utils/get-loadable-worker-url":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-utils/get-loadable-worker-url.js","../worker-utils/get-transfer-list":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-utils/get-transfer-list.js"}],"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-pool.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));

var _globals = require("../env-utils/globals");

var _workerThread = _interopRequireDefault(require("./worker-thread"));

var _workerJob = _interopRequireDefault(require("./worker-job"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class WorkerPool {
  static isSupported() {
    return _workerThread.default.isSupported();
  }

  constructor(props) {
    (0, _defineProperty2.default)(this, "name", 'unnamed');
    (0, _defineProperty2.default)(this, "source", void 0);
    (0, _defineProperty2.default)(this, "url", void 0);
    (0, _defineProperty2.default)(this, "maxConcurrency", 1);
    (0, _defineProperty2.default)(this, "maxMobileConcurrency", 1);
    (0, _defineProperty2.default)(this, "onDebug", () => {});
    (0, _defineProperty2.default)(this, "reuseWorkers", true);
    (0, _defineProperty2.default)(this, "props", {});
    (0, _defineProperty2.default)(this, "jobQueue", []);
    (0, _defineProperty2.default)(this, "idleQueue", []);
    (0, _defineProperty2.default)(this, "count", 0);
    (0, _defineProperty2.default)(this, "isDestroyed", false);
    this.source = props.source;
    this.url = props.url;
    this.setProps(props);
  }

  destroy() {
    this.idleQueue.forEach(worker => worker.destroy());
    this.isDestroyed = true;
  }

  setProps(props) {
    this.props = { ...this.props,
      ...props
    };

    if (props.name !== undefined) {
      this.name = props.name;
    }

    if (props.maxConcurrency !== undefined) {
      this.maxConcurrency = props.maxConcurrency;
    }

    if (props.maxMobileConcurrency !== undefined) {
      this.maxMobileConcurrency = props.maxMobileConcurrency;
    }

    if (props.reuseWorkers !== undefined) {
      this.reuseWorkers = props.reuseWorkers;
    }

    if (props.onDebug !== undefined) {
      this.onDebug = props.onDebug;
    }
  }

  async startJob(name, onMessage = (job, type, data) => job.done(data), onError = (job, error) => job.error(error)) {
    const startPromise = new Promise(onStart => {
      this.jobQueue.push({
        name,
        onMessage,
        onError,
        onStart
      });
      return this;
    });

    this._startQueuedJob();

    return await startPromise;
  }

  async _startQueuedJob() {
    if (!this.jobQueue.length) {
      return;
    }

    const workerThread = this._getAvailableWorker();

    if (!workerThread) {
      return;
    }

    const queuedJob = this.jobQueue.shift();

    if (queuedJob) {
      this.onDebug({
        message: 'Starting job',
        name: queuedJob.name,
        workerThread,
        backlog: this.jobQueue.length
      });
      const job = new _workerJob.default(queuedJob.name, workerThread);

      workerThread.onMessage = data => queuedJob.onMessage(job, data.type, data.payload);

      workerThread.onError = error => queuedJob.onError(job, error);

      queuedJob.onStart(job);

      try {
        await job.result;
      } finally {
        this.returnWorkerToQueue(workerThread);
      }
    }
  }

  returnWorkerToQueue(worker) {
    const shouldDestroyWorker = this.isDestroyed || !this.reuseWorkers || this.count > this._getMaxConcurrency();

    if (shouldDestroyWorker) {
      worker.destroy();
      this.count--;
    } else {
      this.idleQueue.push(worker);
    }

    if (!this.isDestroyed) {
      this._startQueuedJob();
    }
  }

  _getAvailableWorker() {
    if (this.idleQueue.length > 0) {
      return this.idleQueue.shift() || null;
    }

    if (this.count < this._getMaxConcurrency()) {
      this.count++;
      const name = "".concat(this.name.toLowerCase(), " (#").concat(this.count, " of ").concat(this.maxConcurrency, ")");
      return new _workerThread.default({
        name,
        source: this.source,
        url: this.url
      });
    }

    return null;
  }

  _getMaxConcurrency() {
    return _globals.isMobile ? this.maxMobileConcurrency : this.maxConcurrency;
  }

}

exports.default = WorkerPool;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","../env-utils/globals":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/globals.js","./worker-thread":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-thread.js","./worker-job":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-job.js"}],"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-farm.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));

var _workerPool = _interopRequireDefault(require("./worker-pool"));

var _workerThread = _interopRequireDefault(require("./worker-thread"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const DEFAULT_PROPS = {
  maxConcurrency: 3,
  maxMobileConcurrency: 1,
  reuseWorkers: true,
  onDebug: () => {}
};

class WorkerFarm {
  static isSupported() {
    return _workerThread.default.isSupported();
  }

  static getWorkerFarm(props = {}) {
    WorkerFarm._workerFarm = WorkerFarm._workerFarm || new WorkerFarm({});

    WorkerFarm._workerFarm.setProps(props);

    return WorkerFarm._workerFarm;
  }

  constructor(props) {
    (0, _defineProperty2.default)(this, "props", void 0);
    (0, _defineProperty2.default)(this, "workerPools", new Map());
    this.props = { ...DEFAULT_PROPS
    };
    this.setProps(props);
    this.workerPools = new Map();
  }

  destroy() {
    for (const workerPool of this.workerPools.values()) {
      workerPool.destroy();
    }

    this.workerPools = new Map();
  }

  setProps(props) {
    this.props = { ...this.props,
      ...props
    };

    for (const workerPool of this.workerPools.values()) {
      workerPool.setProps(this._getWorkerPoolProps());
    }
  }

  getWorkerPool(options) {
    const {
      name,
      source,
      url
    } = options;
    let workerPool = this.workerPools.get(name);

    if (!workerPool) {
      workerPool = new _workerPool.default({
        name,
        source,
        url
      });
      workerPool.setProps(this._getWorkerPoolProps());
      this.workerPools.set(name, workerPool);
    }

    return workerPool;
  }

  _getWorkerPoolProps() {
    return {
      maxConcurrency: this.props.maxConcurrency,
      maxMobileConcurrency: this.props.maxMobileConcurrency,
      reuseWorkers: this.props.reuseWorkers,
      onDebug: this.props.onDebug
    };
  }

}

exports.default = WorkerFarm;
(0, _defineProperty2.default)(WorkerFarm, "_workerFarm", void 0);
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./worker-pool":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-pool.js","./worker-thread":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-thread.js"}],"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-body.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _getTransferList = require("../worker-utils/get-transfer-list");

function getParentPort() {
  let parentPort;

  try {
    eval('globalThis.parentPort = require(\'worker_threads\').parentPort');
    parentPort = globalThis.parentPort;
  } catch {}

  return parentPort;
}

const onMessageWrapperMap = new Map();

class WorkerBody {
  static inWorkerThread() {
    return typeof self !== 'undefined' || Boolean(getParentPort());
  }

  static set onmessage(onMessage) {
    function handleMessage(message) {
      const parentPort = getParentPort();
      const {
        type,
        payload
      } = parentPort ? message : message.data;
      onMessage(type, payload);
    }

    const parentPort = getParentPort();

    if (parentPort) {
      parentPort.on('message', handleMessage);
      parentPort.on('exit', () => console.debug('Node worker closing'));
    } else {
      globalThis.onmessage = handleMessage;
    }
  }

  static addEventListener(onMessage) {
    let onMessageWrapper = onMessageWrapperMap.get(onMessage);

    if (!onMessageWrapper) {
      onMessageWrapper = message => {
        if (!isKnownMessage(message)) {
          return;
        }

        const parentPort = getParentPort();
        const {
          type,
          payload
        } = parentPort ? message : message.data;
        onMessage(type, payload);
      };
    }

    const parentPort = getParentPort();

    if (parentPort) {
      console.error('not implemented');
    } else {
      globalThis.addEventListener('message', onMessageWrapper);
    }
  }

  static removeEventListener(onMessage) {
    const onMessageWrapper = onMessageWrapperMap.get(onMessage);
    onMessageWrapperMap.delete(onMessage);
    const parentPort = getParentPort();

    if (parentPort) {
      console.error('not implemented');
    } else {
      globalThis.removeEventListener('message', onMessageWrapper);
    }
  }

  static postMessage(type, payload) {
    const data = {
      source: 'loaders.gl',
      type,
      payload
    };
    const transferList = (0, _getTransferList.getTransferList)(payload);
    const parentPort = getParentPort();

    if (parentPort) {
      parentPort.postMessage(data, transferList);
    } else {
      globalThis.postMessage(data, transferList);
    }
  }

}

exports.default = WorkerBody;

function isKnownMessage(message) {
  const {
    type,
    data
  } = message;
  return type === 'message' && data && typeof data.source === 'string' && data.source.startsWith('loaders.gl');
}
},{"../worker-utils/get-transfer-list":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-utils/get-transfer-list.js"}],"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-utils/remove-nontransferable-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.removeNontransferableOptions = removeNontransferableOptions;

function removeNontransferableOptions(object) {
  return JSON.parse(stringifyJSON(object));
}

function stringifyJSON(v) {
  const cache = new Set();
  return JSON.stringify(v, (key, value) => {
    if (typeof value === 'object' && value !== null) {
      if (cache.has(value)) {
        try {
          return JSON.parse(JSON.stringify(value));
        } catch (err) {
          return undefined;
        }
      }

      cache.add(value);
    }

    return value;
  });
}
},{}],"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/get-worker-url.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getWorkerName = getWorkerName;
exports.getWorkerURL = getWorkerURL;

var _assert = require("../env-utils/assert");

var _version = require("../env-utils/version");

const NPM_TAG = 'latest';
const VERSION = typeof "3.2.3" !== 'undefined' ? "3.2.3" : NPM_TAG;

function getWorkerName(worker) {
  const warning = worker.version !== VERSION ? " (worker-utils@".concat(VERSION, ")") : '';
  return "".concat(worker.name, "@").concat(worker.version).concat(warning);
}

function getWorkerURL(worker, options = {}) {
  const workerOptions = options[worker.id] || {};
  const workerFile = "".concat(worker.id, "-worker.js");
  let url = workerOptions.workerUrl;

  if (!url && worker.id === 'compression') {
    url = options.workerUrl;
  }

  if (options._workerType === 'test') {
    url = "modules/".concat(worker.module, "/dist/").concat(workerFile);
  }

  if (!url) {
    let version = worker.version;

    if (version === 'latest') {
      version = NPM_TAG;
    }

    const versionTag = version ? "@".concat(version) : '';
    url = "https://unpkg.com/@loaders.gl/".concat(worker.module).concat(versionTag, "/dist/").concat(workerFile);
  }

  (0, _assert.assert)(url);
  return url;
}
},{"../env-utils/assert":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/assert.js","../env-utils/version":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/version.js"}],"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/process-on-worker.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.canProcessOnWorker = canProcessOnWorker;
exports.processOnWorker = processOnWorker;

var _workerFarm = _interopRequireDefault(require("../worker-farm/worker-farm"));

var _removeNontransferableOptions = require("../worker-utils/remove-nontransferable-options");

var _getWorkerUrl = require("./get-worker-url");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function canProcessOnWorker(worker, options) {
  if (!_workerFarm.default.isSupported()) {
    return false;
  }

  return worker.worker && (options === null || options === void 0 ? void 0 : options.worker);
}

async function processOnWorker(worker, data, options = {}, context = {}) {
  const name = (0, _getWorkerUrl.getWorkerName)(worker);

  const workerFarm = _workerFarm.default.getWorkerFarm(options);

  const {
    source
  } = options;
  const workerPoolProps = {
    name,
    source
  };

  if (!source) {
    workerPoolProps.url = (0, _getWorkerUrl.getWorkerURL)(worker, options);
  }

  const workerPool = workerFarm.getWorkerPool(workerPoolProps);
  const jobName = options.jobName || worker.name;
  const job = await workerPool.startJob(jobName, onMessage.bind(null, context));
  const transferableOptions = (0, _removeNontransferableOptions.removeNontransferableOptions)(options);
  job.postMessage('process', {
    input: data,
    options: transferableOptions
  });
  const result = await job.result;
  return result.result;
}

async function onMessage(context, job, type, payload) {
  switch (type) {
    case 'done':
      job.done(payload);
      break;

    case 'error':
      job.error(new Error(payload.error));
      break;

    case 'process':
      const {
        id,
        input,
        options
      } = payload;

      try {
        if (!context.process) {
          job.postMessage('error', {
            id,
            error: 'Worker not set up to process on main thread'
          });
          return;
        }

        const result = await context.process(input, options);
        job.postMessage('done', {
          id,
          result
        });
      } catch (error) {
        const message = error instanceof Error ? error.message : 'unknown error';
        job.postMessage('error', {
          id,
          error: message
        });
      }

      break;

    default:
      console.warn("process-on-worker: unknown message ".concat(type));
  }
}
},{"../worker-farm/worker-farm":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-farm.js","../worker-utils/remove-nontransferable-options":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-utils/remove-nontransferable-options.js","./get-worker-url":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/get-worker-url.js"}],"node_modules/@loaders.gl/worker-utils/dist/esm/lib/async-queue/async-queue.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

let _Symbol$asyncIterator;

_Symbol$asyncIterator = Symbol.asyncIterator;

class AsyncQueue {
  constructor() {
    (0, _defineProperty2.default)(this, "_values", void 0);
    (0, _defineProperty2.default)(this, "_settlers", void 0);
    (0, _defineProperty2.default)(this, "_closed", void 0);
    this._values = [];
    this._settlers = [];
    this._closed = false;
  }

  [_Symbol$asyncIterator]() {
    return this;
  }

  push(value) {
    return this.enqueue(value);
  }

  enqueue(value) {
    if (this._closed) {
      throw new Error('Closed');
    }

    if (this._settlers.length > 0) {
      if (this._values.length > 0) {
        throw new Error('Illegal internal state');
      }

      const settler = this._settlers.shift();

      if (value instanceof Error) {
        settler.reject(value);
      } else {
        settler.resolve({
          value
        });
      }
    } else {
      this._values.push(value);
    }
  }

  close() {
    while (this._settlers.length > 0) {
      const settler = this._settlers.shift();

      settler.resolve({
        done: true
      });
    }

    this._closed = true;
  }

  next() {
    if (this._values.length > 0) {
      const value = this._values.shift();

      if (value instanceof Error) {
        return Promise.reject(value);
      }

      return Promise.resolve({
        done: false,
        value
      });
    }

    if (this._closed) {
      if (this._settlers.length > 0) {
        throw new Error('Illegal internal state');
      }

      return Promise.resolve({
        done: true,
        value: undefined
      });
    }

    return new Promise((resolve, reject) => {
      this._settlers.push({
        resolve,
        reject
      });
    });
  }

}

exports.default = AsyncQueue;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js"}],"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/create-worker.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createWorker = createWorker;

var _asyncQueue = _interopRequireDefault(require("../async-queue/async-queue"));

var _workerBody = _interopRequireDefault(require("../worker-farm/worker-body"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

let requestId = 0;
let inputBatches;
let options;

function createWorker(process, processInBatches) {
  if (!_workerBody.default.inWorkerThread()) {
    return;
  }

  const context = {
    process: processOnMainThread
  };

  _workerBody.default.onmessage = async (type, payload) => {
    try {
      switch (type) {
        case 'process':
          if (!process) {
            throw new Error('Worker does not support atomic processing');
          }

          const result = await process(payload.input, payload.options || {}, context);

          _workerBody.default.postMessage('done', {
            result
          });

          break;

        case 'process-in-batches':
          if (!processInBatches) {
            throw new Error('Worker does not support batched processing');
          }

          inputBatches = new _asyncQueue.default();
          options = payload.options || {};
          const resultIterator = processInBatches(inputBatches, options, context);

          for await (const batch of resultIterator) {
            _workerBody.default.postMessage('output-batch', {
              result: batch
            });
          }

          _workerBody.default.postMessage('done', {});

          break;

        case 'input-batch':
          inputBatches.push(payload.input);
          break;

        case 'input-done':
          inputBatches.close();
          break;

        default:
      }
    } catch (error) {
      const message = error instanceof Error ? error.message : '';

      _workerBody.default.postMessage('error', {
        error: message
      });
    }
  };
}

function processOnMainThread(arrayBuffer, options = {}) {
  return new Promise((resolve, reject) => {
    const id = requestId++;

    const onMessage = (type, payload) => {
      if (payload.id !== id) {
        return;
      }

      switch (type) {
        case 'done':
          _workerBody.default.removeEventListener(onMessage);

          resolve(payload.result);
          break;

        case 'error':
          _workerBody.default.removeEventListener(onMessage);

          reject(payload.error);
          break;

        default:
      }
    };

    _workerBody.default.addEventListener(onMessage);

    const payload = {
      id,
      input: arrayBuffer,
      options
    };

    _workerBody.default.postMessage('process', payload);
  });
}
},{"../async-queue/async-queue":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/async-queue/async-queue.js","../worker-farm/worker-body":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-body.js"}],"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/validate-worker-version.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validateWorkerVersion = validateWorkerVersion;

var _assert = require("../env-utils/assert");

var _version = require("../env-utils/version");

function validateWorkerVersion(worker, coreVersion = _version.VERSION) {
  (0, _assert.assert)(worker, 'no worker provided');
  const workerVersion = worker.version;

  if (!coreVersion || !workerVersion) {
    return false;
  }

  return true;
}

function parseVersion(version) {
  const parts = version.split('.').map(Number);
  return {
    major: parts[0],
    minor: parts[1]
  };
}
},{"../env-utils/assert":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/assert.js","../env-utils/version":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/version.js"}],"../../.nvm/versions/node/v16.15.0/lib/node_modules/parcel-bundler/src/builtins/_empty.js":[function(require,module,exports) {

},{}],"node_modules/@loaders.gl/worker-utils/dist/esm/lib/library-utils/library-utils.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getLibraryUrl = getLibraryUrl;
exports.loadLibrary = loadLibrary;

var _globals = require("../env-utils/globals");

var node = _interopRequireWildcard(require("../node/require-utils.node"));

var _assert = require("../env-utils/assert");

var _version = require("../env-utils/version");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const LATEST = 'latest';
const VERSION = typeof "3.2.3" !== 'undefined' ? "3.2.3" : LATEST;
const loadLibraryPromises = {};

async function loadLibrary(libraryUrl, moduleName = null, options = {}) {
  if (moduleName) {
    libraryUrl = getLibraryUrl(libraryUrl, moduleName, options);
  }

  loadLibraryPromises[libraryUrl] = loadLibraryPromises[libraryUrl] || loadLibraryFromFile(libraryUrl);
  return await loadLibraryPromises[libraryUrl];
}

function getLibraryUrl(library, moduleName, options) {
  if (library.startsWith('http')) {
    return library;
  }

  const modules = options.modules || {};

  if (modules[library]) {
    return modules[library];
  }

  if (!_globals.isBrowser) {
    return "modules/".concat(moduleName, "/dist/libs/").concat(library);
  }

  if (options.CDN) {
    (0, _assert.assert)(options.CDN.startsWith('http'));
    return "".concat(options.CDN, "/").concat(moduleName, "@").concat(VERSION, "/dist/libs/").concat(library);
  }

  if (_globals.isWorker) {
    return "../src/libs/".concat(library);
  }

  return "modules/".concat(moduleName, "/src/libs/").concat(library);
}

async function loadLibraryFromFile(libraryUrl) {
  if (libraryUrl.endsWith('wasm')) {
    const response = await fetch(libraryUrl);
    return await response.arrayBuffer();
  }

  if (!_globals.isBrowser) {
    try {
      return node && node.requireFromFile && (await node.requireFromFile(libraryUrl));
    } catch {
      return null;
    }
  }

  if (_globals.isWorker) {
    return importScripts(libraryUrl);
  }

  const response = await fetch(libraryUrl);
  const scriptSource = await response.text();
  return loadLibraryFromString(scriptSource, libraryUrl);
}

function loadLibraryFromString(scriptSource, id) {
  if (!_globals.isBrowser) {
    return node.requireFromString && node.requireFromString(scriptSource, id);
  }

  if (_globals.isWorker) {
    eval.call(_globals.global, scriptSource);
    return null;
  }

  const script = document.createElement('script');
  script.id = id;

  try {
    script.appendChild(document.createTextNode(scriptSource));
  } catch (e) {
    script.text = scriptSource;
  }

  document.body.appendChild(script);
  return null;
}
},{"../env-utils/globals":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/globals.js","../node/require-utils.node":"../../.nvm/versions/node/v16.15.0/lib/node_modules/parcel-bundler/src/builtins/_empty.js","../env-utils/assert":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/assert.js","../env-utils/version":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/version.js"}],"node_modules/@loaders.gl/worker-utils/dist/esm/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "AsyncQueue", {
  enumerable: true,
  get: function () {
    return _asyncQueue.default;
  }
});
Object.defineProperty(exports, "ChildProcessProxy", {
  enumerable: true,
  get: function () {
    return _childProcessProxy.default;
  }
});
exports.NullWorker = void 0;
Object.defineProperty(exports, "WorkerBody", {
  enumerable: true,
  get: function () {
    return _workerBody.default;
  }
});
Object.defineProperty(exports, "WorkerFarm", {
  enumerable: true,
  get: function () {
    return _workerFarm.default;
  }
});
Object.defineProperty(exports, "WorkerJob", {
  enumerable: true,
  get: function () {
    return _workerJob.default;
  }
});
Object.defineProperty(exports, "WorkerPool", {
  enumerable: true,
  get: function () {
    return _workerPool.default;
  }
});
Object.defineProperty(exports, "WorkerThread", {
  enumerable: true,
  get: function () {
    return _workerThread.default;
  }
});
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function () {
    return _assert.assert;
  }
});
Object.defineProperty(exports, "canProcessOnWorker", {
  enumerable: true,
  get: function () {
    return _processOnWorker.canProcessOnWorker;
  }
});
Object.defineProperty(exports, "createWorker", {
  enumerable: true,
  get: function () {
    return _createWorker.createWorker;
  }
});
Object.defineProperty(exports, "getLibraryUrl", {
  enumerable: true,
  get: function () {
    return _libraryUtils.getLibraryUrl;
  }
});
Object.defineProperty(exports, "getTransferList", {
  enumerable: true,
  get: function () {
    return _getTransferList.getTransferList;
  }
});
Object.defineProperty(exports, "getWorkerURL", {
  enumerable: true,
  get: function () {
    return _getWorkerUrl.getWorkerURL;
  }
});
Object.defineProperty(exports, "isBrowser", {
  enumerable: true,
  get: function () {
    return _globals.isBrowser;
  }
});
Object.defineProperty(exports, "isWorker", {
  enumerable: true,
  get: function () {
    return _globals.isWorker;
  }
});
Object.defineProperty(exports, "loadLibrary", {
  enumerable: true,
  get: function () {
    return _libraryUtils.loadLibrary;
  }
});
Object.defineProperty(exports, "processOnWorker", {
  enumerable: true,
  get: function () {
    return _processOnWorker.processOnWorker;
  }
});
Object.defineProperty(exports, "validateWorkerVersion", {
  enumerable: true,
  get: function () {
    return _validateWorkerVersion.validateWorkerVersion;
  }
});

var _version = require("./lib/env-utils/version");

var _assert = require("./lib/env-utils/assert");

var _globals = require("./lib/env-utils/globals");

var _workerJob = _interopRequireDefault(require("./lib/worker-farm/worker-job"));

var _workerThread = _interopRequireDefault(require("./lib/worker-farm/worker-thread"));

var _workerFarm = _interopRequireDefault(require("./lib/worker-farm/worker-farm"));

var _workerPool = _interopRequireDefault(require("./lib/worker-farm/worker-pool"));

var _workerBody = _interopRequireDefault(require("./lib/worker-farm/worker-body"));

var _processOnWorker = require("./lib/worker-api/process-on-worker");

var _createWorker = require("./lib/worker-api/create-worker");

var _getWorkerUrl = require("./lib/worker-api/get-worker-url");

var _validateWorkerVersion = require("./lib/worker-api/validate-worker-version");

var _getTransferList = require("./lib/worker-utils/get-transfer-list");

var _libraryUtils = require("./lib/library-utils/library-utils");

var _asyncQueue = _interopRequireDefault(require("./lib/async-queue/async-queue"));

var _childProcessProxy = _interopRequireDefault(require("./lib/process-utils/child-process-proxy"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const NullWorker = {
  id: 'null',
  name: 'null',
  module: 'worker-utils',
  version: _version.VERSION,
  options: {
    null: {}
  }
};
exports.NullWorker = NullWorker;
},{"./lib/env-utils/version":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/version.js","./lib/env-utils/assert":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/assert.js","./lib/env-utils/globals":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/globals.js","./lib/worker-farm/worker-job":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-job.js","./lib/worker-farm/worker-thread":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-thread.js","./lib/worker-farm/worker-farm":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-farm.js","./lib/worker-farm/worker-pool":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-pool.js","./lib/worker-farm/worker-body":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-body.js","./lib/worker-api/process-on-worker":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/process-on-worker.js","./lib/worker-api/create-worker":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/create-worker.js","./lib/worker-api/get-worker-url":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/get-worker-url.js","./lib/worker-api/validate-worker-version":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/validate-worker-version.js","./lib/worker-utils/get-transfer-list":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-utils/get-transfer-list.js","./lib/library-utils/library-utils":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/library-utils/library-utils.js","./lib/async-queue/async-queue":"node_modules/@loaders.gl/worker-utils/dist/esm/lib/async-queue/async-queue.js","./lib/process-utils/child-process-proxy":"../../.nvm/versions/node/v16.15.0/lib/node_modules/parcel-bundler/src/builtins/_empty.js"}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-loader-utils/create-loader-worker.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createLoaderWorker = createLoaderWorker;

var _workerUtils = require("@loaders.gl/worker-utils");

let requestId = 0;

function createLoaderWorker(loader) {
  if (!_workerUtils.WorkerBody.inWorkerThread()) {
    return;
  }

  _workerUtils.WorkerBody.onmessage = async (type, payload) => {
    switch (type) {
      case 'process':
        try {
          const {
            input,
            options = {},
            context = {}
          } = payload;
          const result = await parseData({
            loader,
            arrayBuffer: input,
            options,
            context: { ...context,
              parse: parseOnMainThread
            }
          });

          _workerUtils.WorkerBody.postMessage('done', {
            result
          });
        } catch (error) {
          const message = error instanceof Error ? error.message : '';

          _workerUtils.WorkerBody.postMessage('error', {
            error: message
          });
        }

        break;

      default:
    }
  };
}

function parseOnMainThread(arrayBuffer, options) {
  return new Promise((resolve, reject) => {
    const id = requestId++;

    const onMessage = (type, payload) => {
      if (payload.id !== id) {
        return;
      }

      switch (type) {
        case 'done':
          _workerUtils.WorkerBody.removeEventListener(onMessage);

          resolve(payload.result);
          break;

        case 'error':
          _workerUtils.WorkerBody.removeEventListener(onMessage);

          reject(payload.error);
          break;

        default:
      }
    };

    _workerUtils.WorkerBody.addEventListener(onMessage);

    const payload = {
      id,
      input: arrayBuffer,
      options
    };

    _workerUtils.WorkerBody.postMessage('process', payload);
  });
}

async function parseData({
  loader,
  arrayBuffer,
  options,
  context
}) {
  let data;
  let parser;

  if (loader.parseSync || loader.parse) {
    data = arrayBuffer;
    parser = loader.parseSync || loader.parse;
  } else if (loader.parseTextSync) {
    const textDecoder = new TextDecoder();
    data = textDecoder.decode(arrayBuffer);
    parser = loader.parseTextSync;
  } else {
    throw new Error("Could not load data with ".concat(loader.name, " loader"));
  }

  options = { ...options,
    modules: loader && loader.options && loader.options.modules || {},
    worker: false
  };
  return await parser(data, { ...options
  }, context, loader);
}
},{"@loaders.gl/worker-utils":"node_modules/@loaders.gl/worker-utils/dist/esm/index.js"}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-loader-utils/parse-with-worker.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.canParseWithWorker = canParseWithWorker;
exports.parseWithWorker = parseWithWorker;

var _workerUtils = require("@loaders.gl/worker-utils");

function canParseWithWorker(loader, options) {
  if (!_workerUtils.WorkerFarm.isSupported()) {
    return false;
  }

  if (!_workerUtils.isBrowser && !(options !== null && options !== void 0 && options._nodeWorkers)) {
    return false;
  }

  return loader.worker && (options === null || options === void 0 ? void 0 : options.worker);
}

async function parseWithWorker(loader, data, options, context, parseOnMainThread) {
  const name = loader.id;
  const url = (0, _workerUtils.getWorkerURL)(loader, options);

  const workerFarm = _workerUtils.WorkerFarm.getWorkerFarm(options);

  const workerPool = workerFarm.getWorkerPool({
    name,
    url
  });
  options = JSON.parse(JSON.stringify(options));
  context = JSON.parse(JSON.stringify(context || {}));
  const job = await workerPool.startJob('process-on-worker', onMessage.bind(null, parseOnMainThread));
  job.postMessage('process', {
    input: data,
    options,
    context
  });
  const result = await job.result;
  return await result.result;
}

async function onMessage(parseOnMainThread, job, type, payload) {
  switch (type) {
    case 'done':
      job.done(payload);
      break;

    case 'error':
      job.error(new Error(payload.error));
      break;

    case 'process':
      const {
        id,
        input,
        options
      } = payload;

      try {
        const result = await parseOnMainThread(input, options);
        job.postMessage('done', {
          id,
          result
        });
      } catch (error) {
        const message = error instanceof Error ? error.message : 'unknown error';
        job.postMessage('error', {
          id,
          error: message
        });
      }

      break;

    default:
      console.warn("parse-with-worker unknown message ".concat(type));
  }
}
},{"@loaders.gl/worker-utils":"node_modules/@loaders.gl/worker-utils/dist/esm/index.js"}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-loader-utils/encode-with-worker.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.canEncodeWithWorker = canEncodeWithWorker;

var _workerUtils = require("@loaders.gl/worker-utils");

var _globals = require("../env-utils/globals");

function canEncodeWithWorker(writer, options) {
  if (!_workerUtils.WorkerFarm.isSupported()) {
    return false;
  }

  if (!_globals.isBrowser && !(options !== null && options !== void 0 && options._nodeWorkers)) {
    return false;
  }

  return writer.worker && (options === null || options === void 0 ? void 0 : options.worker);
}
},{"@loaders.gl/worker-utils":"node_modules/@loaders.gl/worker-utils/dist/esm/index.js","../env-utils/globals":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/globals.js"}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/get-first-characters.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getFirstCharacters = getFirstCharacters;
exports.getMagicString = getMagicString;

function getFirstCharacters(data, length = 5) {
  if (typeof data === 'string') {
    return data.slice(0, length);
  } else if (ArrayBuffer.isView(data)) {
    return getMagicString(data.buffer, data.byteOffset, length);
  } else if (data instanceof ArrayBuffer) {
    const byteOffset = 0;
    return getMagicString(data, byteOffset, length);
  }

  return '';
}

function getMagicString(arrayBuffer, byteOffset, length) {
  if (arrayBuffer.byteLength <= byteOffset + length) {
    return '';
  }

  const dataView = new DataView(arrayBuffer);
  let magic = '';

  for (let i = 0; i < length; i++) {
    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));
  }

  return magic;
}
},{}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/parser-utils/parse-json.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseJSON = parseJSON;

var _getFirstCharacters = require("../binary-utils/get-first-characters");

function parseJSON(string) {
  try {
    return JSON.parse(string);
  } catch (_) {
    throw new Error("Failed to parse JSON from data starting with \"".concat((0, _getFirstCharacters.getFirstCharacters)(string), "\""));
  }
}
},{"../binary-utils/get-first-characters":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/get-first-characters.js"}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/buffer-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.bufferToArrayBuffer = bufferToArrayBuffer;
exports.isBuffer = isBuffer;
exports.toBuffer = toBuffer;

var node = _interopRequireWildcard(require("../node/buffer"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function isBuffer(value) {
  return value && typeof value === 'object' && value.isBuffer;
}

function toBuffer(data) {
  return node.toBuffer ? node.toBuffer(data) : data;
}

function bufferToArrayBuffer(buffer) {
  if (isBuffer(buffer)) {
    const typedArray = new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.length);
    return typedArray.slice().buffer;
  }

  return buffer;
}
},{"../node/buffer":"../../.nvm/versions/node/v16.15.0/lib/node_modules/parcel-bundler/src/builtins/_empty.js"}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/array-buffer-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.compareArrayBuffers = compareArrayBuffers;
exports.concatenateArrayBuffers = concatenateArrayBuffers;
exports.concatenateTypedArrays = concatenateTypedArrays;
exports.sliceArrayBuffer = sliceArrayBuffer;
exports.toArrayBuffer = toArrayBuffer;

var _bufferUtils = require("./buffer-utils");

function toArrayBuffer(data) {
  if ((0, _bufferUtils.isBuffer)(data)) {
    return (0, _bufferUtils.bufferToArrayBuffer)(data);
  }

  if (data instanceof ArrayBuffer) {
    return data;
  }

  if (ArrayBuffer.isView(data)) {
    if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {
      return data.buffer;
    }

    return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
  }

  if (typeof data === 'string') {
    const text = data;
    const uint8Array = new TextEncoder().encode(text);
    return uint8Array.buffer;
  }

  if (data && typeof data === 'object' && data._toArrayBuffer) {
    return data._toArrayBuffer();
  }

  throw new Error('toArrayBuffer');
}

function compareArrayBuffers(arrayBuffer1, arrayBuffer2, byteLength) {
  byteLength = byteLength || arrayBuffer1.byteLength;

  if (arrayBuffer1.byteLength < byteLength || arrayBuffer2.byteLength < byteLength) {
    return false;
  }

  const array1 = new Uint8Array(arrayBuffer1);
  const array2 = new Uint8Array(arrayBuffer2);

  for (let i = 0; i < array1.length; ++i) {
    if (array1[i] !== array2[i]) {
      return false;
    }
  }

  return true;
}

function concatenateArrayBuffers(...sources) {
  const sourceArrays = sources.map(source2 => source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2);
  const byteLength = sourceArrays.reduce((length, typedArray) => length + typedArray.byteLength, 0);
  const result = new Uint8Array(byteLength);
  let offset = 0;

  for (const sourceArray of sourceArrays) {
    result.set(sourceArray, offset);
    offset += sourceArray.byteLength;
  }

  return result.buffer;
}

function concatenateTypedArrays(...typedArrays) {
  const arrays = typedArrays;
  const TypedArrayConstructor = arrays && arrays.length > 1 && arrays[0].constructor || null;

  if (!TypedArrayConstructor) {
    throw new Error('"concatenateTypedArrays" - incorrect quantity of arguments or arguments have incompatible data types');
  }

  const sumLength = arrays.reduce((acc, value) => acc + value.length, 0);
  const result = new TypedArrayConstructor(sumLength);
  let offset = 0;

  for (const array of arrays) {
    result.set(array, offset);
    offset += array.length;
  }

  return result;
}

function sliceArrayBuffer(arrayBuffer, byteOffset, byteLength) {
  const subArray = byteLength !== undefined ? new Uint8Array(arrayBuffer).subarray(byteOffset, byteOffset + byteLength) : new Uint8Array(arrayBuffer).subarray(byteOffset);
  const arrayCopy = new Uint8Array(subArray);
  return arrayCopy.buffer;
}
},{"./buffer-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/buffer-utils.js"}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/memory-copy-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.copyArrayBuffer = copyArrayBuffer;
exports.copyToArray = copyToArray;
exports.padToNBytes = padToNBytes;

var _assert = require("../env-utils/assert");

function padToNBytes(byteLength, padding) {
  (0, _assert.assert)(byteLength >= 0);
  (0, _assert.assert)(padding > 0);
  return byteLength + (padding - 1) & ~(padding - 1);
}

function copyArrayBuffer(targetBuffer, sourceBuffer, byteOffset, byteLength = sourceBuffer.byteLength) {
  const targetArray = new Uint8Array(targetBuffer, byteOffset, byteLength);
  const sourceArray = new Uint8Array(sourceBuffer);
  targetArray.set(sourceArray);
  return targetBuffer;
}

function copyToArray(source, target, targetOffset) {
  let sourceArray;

  if (source instanceof ArrayBuffer) {
    sourceArray = new Uint8Array(source);
  } else {
    const srcByteOffset = source.byteOffset;
    const srcByteLength = source.byteLength;
    sourceArray = new Uint8Array(source.buffer || source.arrayBuffer, srcByteOffset, srcByteLength);
  }

  target.set(sourceArray, targetOffset);
  return targetOffset + padToNBytes(sourceArray.byteLength, 4);
}
},{"../env-utils/assert":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/assert.js"}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/binary-copy-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.copyPaddedArrayBufferToDataView = copyPaddedArrayBufferToDataView;
exports.copyPaddedStringToDataView = copyPaddedStringToDataView;

var _memoryCopyUtils = require("./memory-copy-utils");

function copyPaddedArrayBufferToDataView(dataView, byteOffset, sourceBuffer, padding) {
  const paddedLength = (0, _memoryCopyUtils.padToNBytes)(sourceBuffer.byteLength, padding);
  const padLength = paddedLength - sourceBuffer.byteLength;

  if (dataView) {
    const targetArray = new Uint8Array(dataView.buffer, dataView.byteOffset + byteOffset, sourceBuffer.byteLength);
    const sourceArray = new Uint8Array(sourceBuffer);
    targetArray.set(sourceArray);

    for (let i = 0; i < padLength; ++i) {
      dataView.setUint8(byteOffset + sourceBuffer.byteLength + i, 0x20);
    }
  }

  byteOffset += paddedLength;
  return byteOffset;
}

function copyPaddedStringToDataView(dataView, byteOffset, string, padding) {
  const textEncoder = new TextEncoder();
  const stringBuffer = textEncoder.encode(string);
  byteOffset = copyPaddedArrayBufferToDataView(dataView, byteOffset, stringBuffer, padding);
  return byteOffset;
}
},{"./memory-copy-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/memory-copy-utils.js"}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/encode-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.copyBinaryToDataView = copyBinaryToDataView;
exports.copyStringToDataView = copyStringToDataView;
exports.padStringToByteAlignment = padStringToByteAlignment;

function padStringToByteAlignment(string, byteAlignment) {
  const length = string.length;
  const paddedLength = Math.ceil(length / byteAlignment) * byteAlignment;
  const padding = paddedLength - length;
  let whitespace = '';

  for (let i = 0; i < padding; ++i) {
    whitespace += ' ';
  }

  return string + whitespace;
}

function copyStringToDataView(dataView, byteOffset, string, byteLength) {
  if (dataView) {
    for (let i = 0; i < byteLength; i++) {
      dataView.setUint8(byteOffset + i, string.charCodeAt(i));
    }
  }

  return byteOffset + byteLength;
}

function copyBinaryToDataView(dataView, byteOffset, binary, byteLength) {
  if (dataView) {
    for (let i = 0; i < byteLength; i++) {
      dataView.setUint8(byteOffset + i, binary[i]);
    }
  }

  return byteOffset + byteLength;
}
},{}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/iterators/text-iterators.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeLineIterator = makeLineIterator;
exports.makeNumberedLineIterator = makeNumberedLineIterator;
exports.makeTextDecoderIterator = makeTextDecoderIterator;
exports.makeTextEncoderIterator = makeTextEncoderIterator;

async function* makeTextDecoderIterator(arrayBufferIterator, options = {}) {
  const textDecoder = new TextDecoder(undefined, options);

  for await (const arrayBuffer of arrayBufferIterator) {
    yield typeof arrayBuffer === 'string' ? arrayBuffer : textDecoder.decode(arrayBuffer, {
      stream: true
    });
  }
}

async function* makeTextEncoderIterator(textIterator) {
  const textEncoder = new TextEncoder();

  for await (const text of textIterator) {
    yield typeof text === 'string' ? textEncoder.encode(text) : text;
  }
}

async function* makeLineIterator(textIterator) {
  let previous = '';

  for await (const textChunk of textIterator) {
    previous += textChunk;
    let eolIndex;

    while ((eolIndex = previous.indexOf('\n')) >= 0) {
      const line = previous.slice(0, eolIndex + 1);
      previous = previous.slice(eolIndex + 1);
      yield line;
    }
  }

  if (previous.length > 0) {
    yield previous;
  }
}

async function* makeNumberedLineIterator(lineIterator) {
  let counter = 1;

  for await (const line of lineIterator) {
    yield {
      counter,
      line
    };
    counter++;
  }
}
},{}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/iterators/async-iteration.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.concatenateArrayBuffersAsync = concatenateArrayBuffersAsync;
exports.concatenateStringsAsync = concatenateStringsAsync;
exports.forEach = forEach;

var _arrayBufferUtils = require("../binary-utils/array-buffer-utils");

async function forEach(iterator, visitor) {
  while (true) {
    const {
      done,
      value
    } = await iterator.next();

    if (done) {
      iterator.return();
      return;
    }

    const cancel = visitor(value);

    if (cancel) {
      return;
    }
  }
}

async function concatenateArrayBuffersAsync(asyncIterator) {
  const arrayBuffers = [];

  for await (const chunk of asyncIterator) {
    arrayBuffers.push(chunk);
  }

  return (0, _arrayBufferUtils.concatenateArrayBuffers)(...arrayBuffers);
}

async function concatenateStringsAsync(asyncIterator) {
  const strings = [];

  for await (const chunk of asyncIterator) {
    strings.push(chunk);
  }

  return strings.join('');
}
},{"../binary-utils/array-buffer-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/array-buffer-utils.js"}],"node_modules/@probe.gl/stats/dist/esm/utils/hi-res-timestamp.js":[function(require,module,exports) {
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getHiResTimestamp;

function getHiResTimestamp() {
  let timestamp;

  if (typeof window !== 'undefined' && window.performance) {
    timestamp = window.performance.now();
  } else if (typeof process !== 'undefined' && process.hrtime) {
    const timeParts = process.hrtime();
    timestamp = timeParts[0] * 1000 + timeParts[1] / 1e6;
  } else {
    timestamp = Date.now();
  }

  return timestamp;
}
},{"process":"../../.nvm/versions/node/v16.15.0/lib/node_modules/parcel-bundler/node_modules/process/browser.js"}],"node_modules/@probe.gl/stats/dist/esm/lib/stat.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));

var _hiResTimestamp = _interopRequireDefault(require("../utils/hi-res-timestamp"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class Stat {
  constructor(name, type) {
    (0, _defineProperty2.default)(this, "name", void 0);
    (0, _defineProperty2.default)(this, "type", void 0);
    (0, _defineProperty2.default)(this, "sampleSize", 1);
    (0, _defineProperty2.default)(this, "time", void 0);
    (0, _defineProperty2.default)(this, "count", void 0);
    (0, _defineProperty2.default)(this, "samples", void 0);
    (0, _defineProperty2.default)(this, "lastTiming", void 0);
    (0, _defineProperty2.default)(this, "lastSampleTime", void 0);
    (0, _defineProperty2.default)(this, "lastSampleCount", void 0);
    (0, _defineProperty2.default)(this, "_count", 0);
    (0, _defineProperty2.default)(this, "_time", 0);
    (0, _defineProperty2.default)(this, "_samples", 0);
    (0, _defineProperty2.default)(this, "_startTime", 0);
    (0, _defineProperty2.default)(this, "_timerPending", false);
    this.name = name;
    this.type = type;
    this.reset();
  }

  setSampleSize(samples) {
    this.sampleSize = samples;
    return this;
  }

  incrementCount() {
    this.addCount(1);
    return this;
  }

  decrementCount() {
    this.subtractCount(1);
    return this;
  }

  addCount(value) {
    this._count += value;
    this._samples++;

    this._checkSampling();

    return this;
  }

  subtractCount(value) {
    this._count -= value;
    this._samples++;

    this._checkSampling();

    return this;
  }

  addTime(time) {
    this._time += time;
    this.lastTiming = time;
    this._samples++;

    this._checkSampling();

    return this;
  }

  timeStart() {
    this._startTime = (0, _hiResTimestamp.default)();
    this._timerPending = true;
    return this;
  }

  timeEnd() {
    if (!this._timerPending) {
      return this;
    }

    this.addTime((0, _hiResTimestamp.default)() - this._startTime);
    this._timerPending = false;

    this._checkSampling();

    return this;
  }

  getSampleAverageCount() {
    return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;
  }

  getSampleAverageTime() {
    return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;
  }

  getSampleHz() {
    return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1000) : 0;
  }

  getAverageCount() {
    return this.samples > 0 ? this.count / this.samples : 0;
  }

  getAverageTime() {
    return this.samples > 0 ? this.time / this.samples : 0;
  }

  getHz() {
    return this.time > 0 ? this.samples / (this.time / 1000) : 0;
  }

  reset() {
    this.time = 0;
    this.count = 0;
    this.samples = 0;
    this.lastTiming = 0;
    this.lastSampleTime = 0;
    this.lastSampleCount = 0;
    this._count = 0;
    this._time = 0;
    this._samples = 0;
    this._startTime = 0;
    this._timerPending = false;
    return this;
  }

  _checkSampling() {
    if (this._samples === this.sampleSize) {
      this.lastSampleTime = this._time;
      this.lastSampleCount = this._count;
      this.count += this._count;
      this.time += this._time;
      this.samples += this._samples;
      this._time = 0;
      this._count = 0;
      this._samples = 0;
    }
  }

}

exports.default = Stat;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","../utils/hi-res-timestamp":"node_modules/@probe.gl/stats/dist/esm/utils/hi-res-timestamp.js"}],"node_modules/@probe.gl/stats/dist/esm/lib/stats.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));

var _stat = _interopRequireDefault(require("./stat"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class Stats {
  constructor(options) {
    (0, _defineProperty2.default)(this, "id", void 0);
    (0, _defineProperty2.default)(this, "stats", {});
    this.id = options.id;
    this.stats = {};

    this._initializeStats(options.stats);

    Object.seal(this);
  }

  get(name) {
    let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'count';
    return this._getOrCreate({
      name,
      type
    });
  }

  get size() {
    return Object.keys(this.stats).length;
  }

  reset() {
    for (const key in this.stats) {
      this.stats[key].reset();
    }

    return this;
  }

  forEach(fn) {
    for (const key in this.stats) {
      fn(this.stats[key]);
    }
  }

  getTable() {
    const table = {};
    this.forEach(stat => {
      table[stat.name] = {
        time: stat.time || 0,
        count: stat.count || 0,
        average: stat.getAverageTime() || 0,
        hz: stat.getHz() || 0
      };
    });
    return table;
  }

  _initializeStats() {
    let stats = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    stats.forEach(stat => this._getOrCreate(stat));
  }

  _getOrCreate(stat) {
    if (!stat || !stat.name) {
      return null;
    }

    const {
      name,
      type
    } = stat;

    if (!this.stats[name]) {
      if (stat instanceof _stat.default) {
        this.stats[name] = stat;
      } else {
        this.stats[name] = new _stat.default(name, type);
      }
    }

    return this.stats[name];
  }

}

exports.default = Stats;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./stat":"node_modules/@probe.gl/stats/dist/esm/lib/stat.js"}],"node_modules/@probe.gl/stats/dist/esm/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Stat", {
  enumerable: true,
  get: function () {
    return _stat.default;
  }
});
Object.defineProperty(exports, "Stats", {
  enumerable: true,
  get: function () {
    return _stats.default;
  }
});
Object.defineProperty(exports, "_getHiResTimestamp", {
  enumerable: true,
  get: function () {
    return _hiResTimestamp.default;
  }
});

var _stats = _interopRequireDefault(require("./lib/stats"));

var _stat = _interopRequireDefault(require("./lib/stat"));

var _hiResTimestamp = _interopRequireDefault(require("./utils/hi-res-timestamp"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./lib/stats":"node_modules/@probe.gl/stats/dist/esm/lib/stats.js","./lib/stat":"node_modules/@probe.gl/stats/dist/esm/lib/stat.js","./utils/hi-res-timestamp":"node_modules/@probe.gl/stats/dist/esm/utils/hi-res-timestamp.js"}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/request-utils/request-scheduler.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));

var _stats = require("@probe.gl/stats");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const STAT_QUEUED_REQUESTS = 'Queued Requests';
const STAT_ACTIVE_REQUESTS = 'Active Requests';
const STAT_CANCELLED_REQUESTS = 'Cancelled Requests';
const STAT_QUEUED_REQUESTS_EVER = 'Queued Requests Ever';
const STAT_ACTIVE_REQUESTS_EVER = 'Active Requests Ever';
const DEFAULT_PROPS = {
  id: 'request-scheduler',
  throttleRequests: true,
  maxRequests: 6
};

class RequestScheduler {
  constructor(props = {}) {
    (0, _defineProperty2.default)(this, "props", void 0);
    (0, _defineProperty2.default)(this, "stats", void 0);
    (0, _defineProperty2.default)(this, "activeRequestCount", 0);
    (0, _defineProperty2.default)(this, "requestQueue", []);
    (0, _defineProperty2.default)(this, "requestMap", new Map());
    (0, _defineProperty2.default)(this, "deferredUpdate", null);
    this.props = { ...DEFAULT_PROPS,
      ...props
    };
    this.stats = new _stats.Stats({
      id: this.props.id
    });
    this.stats.get(STAT_QUEUED_REQUESTS);
    this.stats.get(STAT_ACTIVE_REQUESTS);
    this.stats.get(STAT_CANCELLED_REQUESTS);
    this.stats.get(STAT_QUEUED_REQUESTS_EVER);
    this.stats.get(STAT_ACTIVE_REQUESTS_EVER);
  }

  scheduleRequest(handle, getPriority = () => 0) {
    if (!this.props.throttleRequests) {
      return Promise.resolve({
        done: () => {}
      });
    }

    if (this.requestMap.has(handle)) {
      return this.requestMap.get(handle);
    }

    const request = {
      handle,
      priority: 0,
      getPriority
    };
    const promise = new Promise(resolve => {
      request.resolve = resolve;
      return request;
    });
    this.requestQueue.push(request);
    this.requestMap.set(handle, promise);

    this._issueNewRequests();

    return promise;
  }

  _issueRequest(request) {
    const {
      handle,
      resolve
    } = request;
    let isDone = false;

    const done = () => {
      if (!isDone) {
        isDone = true;
        this.requestMap.delete(handle);
        this.activeRequestCount--;

        this._issueNewRequests();
      }
    };

    this.activeRequestCount++;
    return resolve ? resolve({
      done
    }) : Promise.resolve({
      done
    });
  }

  _issueNewRequests() {
    if (!this.deferredUpdate) {
      this.deferredUpdate = setTimeout(() => this._issueNewRequestsAsync(), 0);
    }
  }

  _issueNewRequestsAsync() {
    this.deferredUpdate = null;
    const freeSlots = Math.max(this.props.maxRequests - this.activeRequestCount, 0);

    if (freeSlots === 0) {
      return;
    }

    this._updateAllRequests();

    for (let i = 0; i < freeSlots; ++i) {
      const request = this.requestQueue.shift();

      if (request) {
        this._issueRequest(request);
      }
    }
  }

  _updateAllRequests() {
    const requestQueue = this.requestQueue;

    for (let i = 0; i < requestQueue.length; ++i) {
      const request = requestQueue[i];

      if (!this._updateRequest(request)) {
        requestQueue.splice(i, 1);
        this.requestMap.delete(request.handle);
        i--;
      }
    }

    requestQueue.sort((a, b) => a.priority - b.priority);
  }

  _updateRequest(request) {
    request.priority = request.getPriority(request.handle);

    if (request.priority < 0) {
      request.resolve(null);
      return false;
    }

    return true;
  }

}

exports.default = RequestScheduler;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@probe.gl/stats":"node_modules/@probe.gl/stats/dist/esm/index.js"}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/file-aliases.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addAliases = addAliases;
exports.getPathPrefix = getPathPrefix;
exports.resolvePath = resolvePath;
exports.setPathPrefix = setPathPrefix;
let pathPrefix = '';
const fileAliases = {};

function setPathPrefix(prefix) {
  pathPrefix = prefix;
}

function getPathPrefix() {
  return pathPrefix;
}

function addAliases(aliases) {
  Object.assign(fileAliases, aliases);
}

function resolvePath(filename) {
  for (const alias in fileAliases) {
    if (filename.startsWith(alias)) {
      const replacement = fileAliases[alias];
      filename = filename.replace(alias, replacement);
    }
  }

  if (!filename.startsWith('http://') && !filename.startsWith('https://')) {
    filename = "".concat(pathPrefix).concat(filename);
  }

  return filename;
}
},{}],"node_modules/@loaders.gl/loader-utils/dist/esm/json-loader.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._typecheckJSONLoader = exports.JSONLoader = void 0;
const VERSION = typeof "3.2.3" !== 'undefined' ? "3.2.3" : 'latest';
const JSONLoader = {
  name: 'JSON',
  id: 'json',
  module: 'json',
  version: VERSION,
  extensions: ['json', 'geojson'],
  mimeTypes: ['application/json'],
  category: 'json',
  text: true,
  parseTextSync,
  parse: async arrayBuffer => parseTextSync(new TextDecoder().decode(arrayBuffer)),
  options: {}
};
exports.JSONLoader = JSONLoader;

function parseTextSync(text) {
  return JSON.parse(text);
}

const _typecheckJSONLoader = JSONLoader;
exports._typecheckJSONLoader = _typecheckJSONLoader;
},{}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/path.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dirname = dirname;
exports.filename = filename;
exports.join = join;

function filename(url) {
  const slashIndex = url && url.lastIndexOf('/');
  return slashIndex >= 0 ? url.substr(slashIndex + 1) : '';
}

function dirname(url) {
  const slashIndex = url && url.lastIndexOf('/');
  return slashIndex >= 0 ? url.substr(0, slashIndex) : '';
}

function join(...parts) {
  const separator = '/';
  parts = parts.map((part, index) => {
    if (index) {
      part = part.replace(new RegExp("^".concat(separator)), '');
    }

    if (index !== parts.length - 1) {
      part = part.replace(new RegExp("".concat(separator, "$")), '');
    }

    return part;
  });
  return parts.join(separator);
}
},{}],"node_modules/@loaders.gl/loader-utils/dist/esm/lib/filesystems/node-filesystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var fs = _interopRequireWildcard(require("../node/fs"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

class NodeFileSystem {
  constructor(options) {
    this.fetch = options._fetch;
  }

  async readdir(dirname = '.', options) {
    return await fs.readdir(dirname, options);
  }

  async stat(path, options) {
    const info = await fs.stat(path, options);
    return {
      size: Number(info.size),
      isDirectory: () => false,
      info
    };
  }

  async fetch(path, options) {
    const fallbackFetch = options.fetch || this.fetch;
    return fallbackFetch(path, options);
  }

  async open(path, flags, mode) {
    return await fs.open(path, flags);
  }

  async close(fd) {
    return await fs.close(fd);
  }

  async fstat(fd) {
    const info = await fs.fstat(fd);
    return info;
  }

  async read(fd, {
    buffer = null,
    offset = 0,
    length = buffer.byteLength,
    position = null
  }) {
    let totalBytesRead = 0;

    while (totalBytesRead < length) {
      const {
        bytesRead
      } = await fs.read(fd, buffer, offset + totalBytesRead, length - totalBytesRead, position + totalBytesRead);
      totalBytesRead += bytesRead;
    }

    return {
      bytesRead: totalBytesRead,
      buffer
    };
  }

}

exports.default = NodeFileSystem;
},{"../node/fs":"../../.nvm/versions/node/v16.15.0/lib/node_modules/parcel-bundler/src/builtins/_empty.js"}],"node_modules/@loaders.gl/loader-utils/dist/esm/index.js":[function(require,module,exports) {
var global = arguments[3];
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "JSONLoader", {
  enumerable: true,
  get: function () {
    return _jsonLoader.JSONLoader;
  }
});
Object.defineProperty(exports, "RequestScheduler", {
  enumerable: true,
  get: function () {
    return _requestScheduler.default;
  }
});
Object.defineProperty(exports, "_NodeFileSystem", {
  enumerable: true,
  get: function () {
    return _nodeFilesystem.default;
  }
});
Object.defineProperty(exports, "_addAliases", {
  enumerable: true,
  get: function () {
    return _fileAliases.addAliases;
  }
});
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function () {
    return _assert.assert;
  }
});
Object.defineProperty(exports, "bufferToArrayBuffer", {
  enumerable: true,
  get: function () {
    return _bufferUtils.bufferToArrayBuffer;
  }
});
Object.defineProperty(exports, "canEncodeWithWorker", {
  enumerable: true,
  get: function () {
    return _encodeWithWorker.canEncodeWithWorker;
  }
});
Object.defineProperty(exports, "canParseWithWorker", {
  enumerable: true,
  get: function () {
    return _parseWithWorker.canParseWithWorker;
  }
});
Object.defineProperty(exports, "compareArrayBuffers", {
  enumerable: true,
  get: function () {
    return _arrayBufferUtils.compareArrayBuffers;
  }
});
Object.defineProperty(exports, "concatenateArrayBuffers", {
  enumerable: true,
  get: function () {
    return _arrayBufferUtils.concatenateArrayBuffers;
  }
});
Object.defineProperty(exports, "concatenateArrayBuffersAsync", {
  enumerable: true,
  get: function () {
    return _asyncIteration.concatenateArrayBuffersAsync;
  }
});
Object.defineProperty(exports, "concatenateTypedArrays", {
  enumerable: true,
  get: function () {
    return _arrayBufferUtils.concatenateTypedArrays;
  }
});
Object.defineProperty(exports, "copyArrayBuffer", {
  enumerable: true,
  get: function () {
    return _memoryCopyUtils.copyArrayBuffer;
  }
});
Object.defineProperty(exports, "copyBinaryToDataView", {
  enumerable: true,
  get: function () {
    return _encodeUtils.copyBinaryToDataView;
  }
});
Object.defineProperty(exports, "copyPaddedArrayBufferToDataView", {
  enumerable: true,
  get: function () {
    return _binaryCopyUtils.copyPaddedArrayBufferToDataView;
  }
});
Object.defineProperty(exports, "copyPaddedStringToDataView", {
  enumerable: true,
  get: function () {
    return _binaryCopyUtils.copyPaddedStringToDataView;
  }
});
Object.defineProperty(exports, "copyStringToDataView", {
  enumerable: true,
  get: function () {
    return _encodeUtils.copyStringToDataView;
  }
});
Object.defineProperty(exports, "copyToArray", {
  enumerable: true,
  get: function () {
    return _memoryCopyUtils.copyToArray;
  }
});
Object.defineProperty(exports, "createLoaderWorker", {
  enumerable: true,
  get: function () {
    return _createLoaderWorker.createLoaderWorker;
  }
});
Object.defineProperty(exports, "document", {
  enumerable: true,
  get: function () {
    return _globals.document;
  }
});
Object.defineProperty(exports, "forEach", {
  enumerable: true,
  get: function () {
    return _asyncIteration.forEach;
  }
});
exports.fs = void 0;
Object.defineProperty(exports, "getFirstCharacters", {
  enumerable: true,
  get: function () {
    return _getFirstCharacters.getFirstCharacters;
  }
});
Object.defineProperty(exports, "getMagicString", {
  enumerable: true,
  get: function () {
    return _getFirstCharacters.getMagicString;
  }
});
Object.defineProperty(exports, "getPathPrefix", {
  enumerable: true,
  get: function () {
    return _fileAliases.getPathPrefix;
  }
});
Object.defineProperty(exports, "global", {
  enumerable: true,
  get: function () {
    return _globals.global;
  }
});
Object.defineProperty(exports, "isBrowser", {
  enumerable: true,
  get: function () {
    return _globals.isBrowser;
  }
});
Object.defineProperty(exports, "isBuffer", {
  enumerable: true,
  get: function () {
    return _bufferUtils.isBuffer;
  }
});
Object.defineProperty(exports, "isWorker", {
  enumerable: true,
  get: function () {
    return _globals.isWorker;
  }
});
Object.defineProperty(exports, "makeLineIterator", {
  enumerable: true,
  get: function () {
    return _textIterators.makeLineIterator;
  }
});
Object.defineProperty(exports, "makeNumberedLineIterator", {
  enumerable: true,
  get: function () {
    return _textIterators.makeNumberedLineIterator;
  }
});
Object.defineProperty(exports, "makeTextDecoderIterator", {
  enumerable: true,
  get: function () {
    return _textIterators.makeTextDecoderIterator;
  }
});
Object.defineProperty(exports, "makeTextEncoderIterator", {
  enumerable: true,
  get: function () {
    return _textIterators.makeTextEncoderIterator;
  }
});
Object.defineProperty(exports, "nodeVersion", {
  enumerable: true,
  get: function () {
    return _globals.nodeVersion;
  }
});
Object.defineProperty(exports, "padStringToByteAlignment", {
  enumerable: true,
  get: function () {
    return _encodeUtils.padStringToByteAlignment;
  }
});
Object.defineProperty(exports, "padToNBytes", {
  enumerable: true,
  get: function () {
    return _memoryCopyUtils.padToNBytes;
  }
});
Object.defineProperty(exports, "parseJSON", {
  enumerable: true,
  get: function () {
    return _parseJson.parseJSON;
  }
});
Object.defineProperty(exports, "parseWithWorker", {
  enumerable: true,
  get: function () {
    return _parseWithWorker.parseWithWorker;
  }
});
exports.path = void 0;
Object.defineProperty(exports, "promisify", {
  enumerable: true,
  get: function () {
    return util.promisify;
  }
});
Object.defineProperty(exports, "resolvePath", {
  enumerable: true,
  get: function () {
    return _fileAliases.resolvePath;
  }
});
Object.defineProperty(exports, "self", {
  enumerable: true,
  get: function () {
    return _globals.self;
  }
});
Object.defineProperty(exports, "setPathPrefix", {
  enumerable: true,
  get: function () {
    return _fileAliases.setPathPrefix;
  }
});
Object.defineProperty(exports, "sliceArrayBuffer", {
  enumerable: true,
  get: function () {
    return _arrayBufferUtils.sliceArrayBuffer;
  }
});
Object.defineProperty(exports, "toArrayBuffer", {
  enumerable: true,
  get: function () {
    return _arrayBufferUtils.toArrayBuffer;
  }
});
Object.defineProperty(exports, "toBuffer", {
  enumerable: true,
  get: function () {
    return _bufferUtils.toBuffer;
  }
});
exports.util = void 0;
Object.defineProperty(exports, "window", {
  enumerable: true,
  get: function () {
    return _globals.window;
  }
});

var _assert = require("./lib/env-utils/assert");

var _globals = require("./lib/env-utils/globals");

var _createLoaderWorker = require("./lib/worker-loader-utils/create-loader-worker");

var _parseWithWorker = require("./lib/worker-loader-utils/parse-with-worker");

var _encodeWithWorker = require("./lib/worker-loader-utils/encode-with-worker");

var _parseJson = require("./lib/parser-utils/parse-json");

var _arrayBufferUtils = require("./lib/binary-utils/array-buffer-utils");

var _memoryCopyUtils = require("./lib/binary-utils/memory-copy-utils");

var _binaryCopyUtils = require("./lib/binary-utils/binary-copy-utils");

var _encodeUtils = require("./lib/binary-utils/encode-utils");

var _getFirstCharacters = require("./lib/binary-utils/get-first-characters");

var _textIterators = require("./lib/iterators/text-iterators");

var _asyncIteration = require("./lib/iterators/async-iteration");

var _requestScheduler = _interopRequireDefault(require("./lib/request-utils/request-scheduler"));

var _fileAliases = require("./lib/path-utils/file-aliases");

var _jsonLoader = require("./json-loader");

var path = _interopRequireWildcard(require("./lib/path-utils/path"));

exports.path = path;

var _bufferUtils = require("./lib/binary-utils/buffer-utils");

var util = _interopRequireWildcard(require("./lib/node/util"));

exports.util = util;

var fs = _interopRequireWildcard(require("./lib/node/fs"));

exports.fs = fs;

var _nodeFilesystem = _interopRequireDefault(require("./lib/filesystems/node-filesystem"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./lib/env-utils/assert":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/assert.js","./lib/env-utils/globals":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/globals.js","./lib/worker-loader-utils/create-loader-worker":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-loader-utils/create-loader-worker.js","./lib/worker-loader-utils/parse-with-worker":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-loader-utils/parse-with-worker.js","./lib/worker-loader-utils/encode-with-worker":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-loader-utils/encode-with-worker.js","./lib/parser-utils/parse-json":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/parser-utils/parse-json.js","./lib/binary-utils/array-buffer-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/array-buffer-utils.js","./lib/binary-utils/memory-copy-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/memory-copy-utils.js","./lib/binary-utils/binary-copy-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/binary-copy-utils.js","./lib/binary-utils/encode-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/encode-utils.js","./lib/binary-utils/get-first-characters":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/get-first-characters.js","./lib/iterators/text-iterators":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/iterators/text-iterators.js","./lib/iterators/async-iteration":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/iterators/async-iteration.js","./lib/request-utils/request-scheduler":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/request-utils/request-scheduler.js","./lib/path-utils/file-aliases":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/file-aliases.js","./json-loader":"node_modules/@loaders.gl/loader-utils/dist/esm/json-loader.js","./lib/path-utils/path":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/path.js","./lib/binary-utils/buffer-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/buffer-utils.js","./lib/node/util":"../../.nvm/versions/node/v16.15.0/lib/node_modules/parcel-bundler/src/builtins/_empty.js","./lib/node/fs":"../../.nvm/versions/node/v16.15.0/lib/node_modules/parcel-bundler/src/builtins/_empty.js","./lib/filesystems/node-filesystem":"node_modules/@loaders.gl/loader-utils/dist/esm/lib/filesystems/node-filesystem.js"}],"node_modules/@loaders.gl/core/dist/esm/javascript-utils/is-type.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isWritableStream = exports.isWritableNodeStream = exports.isWritableDOMStream = exports.isResponse = exports.isReadableStream = exports.isReadableNodeStream = exports.isReadableDOMStream = exports.isPureObject = exports.isPromise = exports.isObject = exports.isIterator = exports.isIterable = exports.isFile = exports.isBuffer = exports.isBlob = exports.isAsyncIterable = void 0;

const isBoolean = x => typeof x === 'boolean';

const isFunction = x => typeof x === 'function';

const isObject = x => x !== null && typeof x === 'object';

exports.isObject = isObject;

const isPureObject = x => isObject(x) && x.constructor === {}.constructor;

exports.isPureObject = isPureObject;

const isPromise = x => isObject(x) && isFunction(x.then);

exports.isPromise = isPromise;

const isIterable = x => x && typeof x[Symbol.iterator] === 'function';

exports.isIterable = isIterable;

const isAsyncIterable = x => x && typeof x[Symbol.asyncIterator] === 'function';

exports.isAsyncIterable = isAsyncIterable;

const isIterator = x => x && isFunction(x.next);

exports.isIterator = isIterator;

const isResponse = x => typeof Response !== 'undefined' && x instanceof Response || x && x.arrayBuffer && x.text && x.json;

exports.isResponse = isResponse;

const isFile = x => typeof File !== 'undefined' && x instanceof File;

exports.isFile = isFile;

const isBlob = x => typeof Blob !== 'undefined' && x instanceof Blob;

exports.isBlob = isBlob;

const isBuffer = x => x && typeof x === 'object' && x.isBuffer;

exports.isBuffer = isBuffer;

const isWritableDOMStream = x => isObject(x) && isFunction(x.abort) && isFunction(x.getWriter);

exports.isWritableDOMStream = isWritableDOMStream;

const isReadableDOMStream = x => typeof ReadableStream !== 'undefined' && x instanceof ReadableStream || isObject(x) && isFunction(x.tee) && isFunction(x.cancel) && isFunction(x.getReader);

exports.isReadableDOMStream = isReadableDOMStream;

const isWritableNodeStream = x => isObject(x) && isFunction(x.end) && isFunction(x.write) && isBoolean(x.writable);

exports.isWritableNodeStream = isWritableNodeStream;

const isReadableNodeStream = x => isObject(x) && isFunction(x.read) && isFunction(x.pipe) && isBoolean(x.readable);

exports.isReadableNodeStream = isReadableNodeStream;

const isReadableStream = x => isReadableDOMStream(x) || isReadableNodeStream(x);

exports.isReadableStream = isReadableStream;

const isWritableStream = x => isWritableDOMStream(x) || isWritableNodeStream(x);

exports.isWritableStream = isWritableStream;
},{}],"node_modules/@loaders.gl/core/dist/esm/lib/utils/mime-type-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseMIMEType = parseMIMEType;
exports.parseMIMETypeFromURL = parseMIMETypeFromURL;
const DATA_URL_PATTERN = /^data:([-\w.]+\/[-\w.+]+)(;|,)/;
const MIME_TYPE_PATTERN = /^([-\w.]+\/[-\w.+]+)/;

function parseMIMEType(mimeString) {
  const matches = MIME_TYPE_PATTERN.exec(mimeString);

  if (matches) {
    return matches[1];
  }

  return mimeString;
}

function parseMIMETypeFromURL(url) {
  const matches = DATA_URL_PATTERN.exec(url);

  if (matches) {
    return matches[1];
  }

  return '';
}
},{}],"node_modules/@loaders.gl/core/dist/esm/lib/utils/resource-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getResourceContentLength = getResourceContentLength;
exports.getResourceUrlAndType = getResourceUrlAndType;

var _isType = require("../../javascript-utils/is-type");

var _mimeTypeUtils = require("./mime-type-utils");

const QUERY_STRING_PATTERN = /\?.*/;

function getResourceUrlAndType(resource) {
  if ((0, _isType.isResponse)(resource)) {
    const url = stripQueryString(resource.url || '');
    const contentTypeHeader = resource.headers.get('content-type') || '';
    return {
      url,
      type: (0, _mimeTypeUtils.parseMIMEType)(contentTypeHeader) || (0, _mimeTypeUtils.parseMIMETypeFromURL)(url)
    };
  }

  if ((0, _isType.isBlob)(resource)) {
    return {
      url: stripQueryString(resource.name || ''),
      type: resource.type || ''
    };
  }

  if (typeof resource === 'string') {
    return {
      url: stripQueryString(resource),
      type: (0, _mimeTypeUtils.parseMIMETypeFromURL)(resource)
    };
  }

  return {
    url: '',
    type: ''
  };
}

function getResourceContentLength(resource) {
  if ((0, _isType.isResponse)(resource)) {
    return resource.headers['content-length'] || -1;
  }

  if ((0, _isType.isBlob)(resource)) {
    return resource.size;
  }

  if (typeof resource === 'string') {
    return resource.length;
  }

  if (resource instanceof ArrayBuffer) {
    return resource.byteLength;
  }

  if (ArrayBuffer.isView(resource)) {
    return resource.byteLength;
  }

  return -1;
}

function stripQueryString(url) {
  return url.replace(QUERY_STRING_PATTERN, '');
}
},{"../../javascript-utils/is-type":"node_modules/@loaders.gl/core/dist/esm/javascript-utils/is-type.js","./mime-type-utils":"node_modules/@loaders.gl/core/dist/esm/lib/utils/mime-type-utils.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/utils/response-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.checkResponse = checkResponse;
exports.checkResponseSync = checkResponseSync;
exports.makeResponse = makeResponse;

var _isType = require("../../javascript-utils/is-type");

var _resourceUtils = require("./resource-utils");

async function makeResponse(resource) {
  if ((0, _isType.isResponse)(resource)) {
    return resource;
  }

  const headers = {};
  const contentLength = (0, _resourceUtils.getResourceContentLength)(resource);

  if (contentLength >= 0) {
    headers['content-length'] = String(contentLength);
  }

  const {
    url,
    type
  } = (0, _resourceUtils.getResourceUrlAndType)(resource);

  if (type) {
    headers['content-type'] = type;
  }

  const initialDataUrl = await getInitialDataUrl(resource);

  if (initialDataUrl) {
    headers['x-first-bytes'] = initialDataUrl;
  }

  if (typeof resource === 'string') {
    resource = new TextEncoder().encode(resource);
  }

  const response = new Response(resource, {
    headers
  });
  Object.defineProperty(response, 'url', {
    value: url
  });
  return response;
}

async function checkResponse(response) {
  if (!response.ok) {
    const message = await getResponseError(response);
    throw new Error(message);
  }
}

function checkResponseSync(response) {
  if (!response.ok) {
    let message = "".concat(response.status, " ").concat(response.statusText);
    message = message.length > 60 ? "".concat(message.slice(0, 60), "...") : message;
    throw new Error(message);
  }
}

async function getResponseError(response) {
  let message = "Failed to fetch resource ".concat(response.url, " (").concat(response.status, "): ");

  try {
    const contentType = response.headers.get('Content-Type');
    let text = response.statusText;

    if (contentType.includes('application/json')) {
      text += " ".concat(await response.text());
    }

    message += text;
    message = message.length > 60 ? "".concat(message.slice(0, 60), "...") : message;
  } catch (error) {}

  return message;
}

async function getInitialDataUrl(resource) {
  const INITIAL_DATA_LENGTH = 5;

  if (typeof resource === 'string') {
    return "data:,".concat(resource.slice(0, INITIAL_DATA_LENGTH));
  }

  if (resource instanceof Blob) {
    const blobSlice = resource.slice(0, 5);
    return await new Promise(resolve => {
      const reader = new FileReader();

      reader.onload = event => {
        var _event$target;

        return resolve(event === null || event === void 0 ? void 0 : (_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.result);
      };

      reader.readAsDataURL(blobSlice);
    });
  }

  if (resource instanceof ArrayBuffer) {
    const slice = resource.slice(0, INITIAL_DATA_LENGTH);
    const base64 = arrayBufferToBase64(slice);
    return "data:base64,".concat(base64);
  }

  return null;
}

function arrayBufferToBase64(buffer) {
  let binary = '';
  const bytes = new Uint8Array(buffer);

  for (let i = 0; i < bytes.byteLength; i++) {
    binary += String.fromCharCode(bytes[i]);
  }

  return btoa(binary);
}
},{"../../javascript-utils/is-type":"node_modules/@loaders.gl/core/dist/esm/javascript-utils/is-type.js","./resource-utils":"node_modules/@loaders.gl/core/dist/esm/lib/utils/resource-utils.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/fetch/fetch-file.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fetchFile = fetchFile;

var _loaderUtils = require("@loaders.gl/loader-utils");

var _responseUtils = require("../utils/response-utils");

async function fetchFile(url, options) {
  if (typeof url === 'string') {
    url = (0, _loaderUtils.resolvePath)(url);
    let fetchOptions = options;

    if (options !== null && options !== void 0 && options.fetch && typeof (options === null || options === void 0 ? void 0 : options.fetch) !== 'function') {
      fetchOptions = options.fetch;
    }

    return await fetch(url, fetchOptions);
  }

  return await (0, _responseUtils.makeResponse)(url);
}
},{"@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js","../utils/response-utils":"node_modules/@loaders.gl/core/dist/esm/lib/utils/response-utils.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/fetch/read-array-buffer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.readArrayBuffer = readArrayBuffer;
exports.readBlob = readBlob;

var _loaderUtils = require("@loaders.gl/loader-utils");

async function readArrayBuffer(file, start, length) {
  if (typeof file === 'number') {
    return await _loaderUtils.fs._readToArrayBuffer(file, start, length);
  }

  if (!(file instanceof Blob)) {
    file = new Blob([file]);
  }

  const slice = file.slice(start, start + length);
  return await readBlob(slice);
}

async function readBlob(blob) {
  return await new Promise((resolve, reject) => {
    const fileReader = new FileReader();

    fileReader.onload = event => {
      var _event$target;

      return resolve(event === null || event === void 0 ? void 0 : (_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.result);
    };

    fileReader.onerror = error => reject(error);

    fileReader.readAsArrayBuffer(blob);
  });
}
},{"@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/fetch/read-file.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.readFileSync = readFileSync;

var _loaderUtils = require("@loaders.gl/loader-utils");

function readFileSync(url, options = {}) {
  url = (0, _loaderUtils.resolvePath)(url);

  if (!_loaderUtils.isBrowser) {
    const buffer = _loaderUtils.fs.readFileSync(url, options);

    return typeof buffer !== 'string' ? (0, _loaderUtils.toArrayBuffer)(buffer) : buffer;
  }

  if (!options.nothrow) {
    (0, _loaderUtils.assert)(false);
  }

  return null;
}
},{"@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/fetch/write-file.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.writeFile = writeFile;
exports.writeFileSync = writeFileSync;

var _loaderUtils = require("@loaders.gl/loader-utils");

async function writeFile(filePath, arrayBufferOrString, options) {
  filePath = (0, _loaderUtils.resolvePath)(filePath);

  if (!_loaderUtils.isBrowser) {
    await _loaderUtils.fs.writeFile(filePath, (0, _loaderUtils.toBuffer)(arrayBufferOrString), {
      flag: 'w'
    });
  }

  (0, _loaderUtils.assert)(false);
}

function writeFileSync(filePath, arrayBufferOrString, options) {
  filePath = (0, _loaderUtils.resolvePath)(filePath);

  if (!_loaderUtils.isBrowser) {
    _loaderUtils.fs.writeFileSync(filePath, (0, _loaderUtils.toBuffer)(arrayBufferOrString), {
      flag: 'w'
    });
  }

  (0, _loaderUtils.assert)(false);
}
},{"@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js"}],"node_modules/@probe.gl/env/dist/esm/lib/is-electron.js":[function(require,module,exports) {
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isElectron;

function isElectron(mockUserAgent) {
  if (typeof window !== 'undefined' && typeof window.process === 'object' && window.process.type === 'renderer') {
    return true;
  }

  if (typeof process !== 'undefined' && typeof process.versions === 'object' && Boolean(process.versions.electron)) {
    return true;
  }

  const realUserAgent = typeof navigator === 'object' && typeof navigator.userAgent === 'string' && navigator.userAgent;
  const userAgent = mockUserAgent || realUserAgent;

  if (userAgent && userAgent.indexOf('Electron') >= 0) {
    return true;
  }

  return false;
}
},{"process":"../../.nvm/versions/node/v16.15.0/lib/node_modules/parcel-bundler/node_modules/process/browser.js"}],"node_modules/@probe.gl/env/dist/esm/lib/is-browser.js":[function(require,module,exports) {
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isBrowser;
exports.isBrowserMainThread = isBrowserMainThread;

var _isElectron = _interopRequireDefault(require("./is-electron"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isBrowser() {
  const isNode = typeof process === 'object' && String(process) === '[object process]' && !true;
  return !isNode || (0, _isElectron.default)();
}

function isBrowserMainThread() {
  return isBrowser() && typeof document !== 'undefined';
}
},{"./is-electron":"node_modules/@probe.gl/env/dist/esm/lib/is-electron.js","process":"../../.nvm/versions/node/v16.15.0/lib/node_modules/parcel-bundler/node_modules/process/browser.js"}],"node_modules/@probe.gl/env/dist/esm/lib/globals.js":[function(require,module,exports) {
var global = arguments[3];
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.window = exports.self = exports.process = exports.global = exports.document = exports.console = void 0;
const globals = {
  self: typeof self !== 'undefined' && self,
  window: typeof window !== 'undefined' && window,
  global: typeof global !== 'undefined' && global,
  document: typeof document !== 'undefined' && document,
  process: typeof process === 'object' && process
};
const global_ = globalThis;
exports.global = global_;
const self_ = globals.self || globals.window || globals.global;
exports.self = self_;
const window_ = globals.window || globals.self || globals.global;
exports.window = window_;
const document_ = globals.document || {};
exports.document = document_;
const process_ = globals.process || {};
exports.process = process_;
const console_ = console;
exports.console = console_;
},{"process":"../../.nvm/versions/node/v16.15.0/lib/node_modules/parcel-bundler/node_modules/process/browser.js"}],"node_modules/@probe.gl/env/dist/esm/utils/globals.js":[function(require,module,exports) {
var global = arguments[3];
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VERSION = void 0;
Object.defineProperty(exports, "console", {
  enumerable: true,
  get: function () {
    return _globals.console;
  }
});
Object.defineProperty(exports, "document", {
  enumerable: true,
  get: function () {
    return _globals.document;
  }
});
Object.defineProperty(exports, "global", {
  enumerable: true,
  get: function () {
    return _globals.global;
  }
});
exports.isBrowser = void 0;
Object.defineProperty(exports, "process", {
  enumerable: true,
  get: function () {
    return _globals.process;
  }
});
Object.defineProperty(exports, "self", {
  enumerable: true,
  get: function () {
    return _globals.self;
  }
});
Object.defineProperty(exports, "window", {
  enumerable: true,
  get: function () {
    return _globals.window;
  }
});

var _isBrowser = _interopRequireDefault(require("../lib/is-browser"));

var _globals = require("../lib/globals");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'untranspiled source';
exports.VERSION = VERSION;
const isBrowser = (0, _isBrowser.default)();
exports.isBrowser = isBrowser;
},{"../lib/is-browser":"node_modules/@probe.gl/env/dist/esm/lib/is-browser.js","../lib/globals":"node_modules/@probe.gl/env/dist/esm/lib/globals.js","process":"../../.nvm/versions/node/v16.15.0/lib/node_modules/parcel-bundler/node_modules/process/browser.js"}],"node_modules/@probe.gl/env/dist/esm/lib/get-browser.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getBrowser;
exports.isMobile = isMobile;

var _isBrowser = _interopRequireDefault(require("./is-browser"));

var _isElectron = _interopRequireDefault(require("./is-electron"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const window = globalThis;

function isMobile() {
  return typeof window.orientation !== 'undefined';
}

function getBrowser(mockUserAgent) {
  if (!mockUserAgent && !(0, _isBrowser.default)()) {
    return 'Node';
  }

  if ((0, _isElectron.default)(mockUserAgent)) {
    return 'Electron';
  }

  const navigator_ = typeof navigator !== 'undefined' ? navigator : {};
  const userAgent = mockUserAgent || navigator_.userAgent || '';

  if (userAgent.indexOf('Edge') > -1) {
    return 'Edge';
  }

  const isMSIE = userAgent.indexOf('MSIE ') !== -1;
  const isTrident = userAgent.indexOf('Trident/') !== -1;

  if (isMSIE || isTrident) {
    return 'IE';
  }

  if (window.chrome) {
    return 'Chrome';
  }

  if (window.safari) {
    return 'Safari';
  }

  if (window.mozInnerScreenX) {
    return 'Firefox';
  }

  return 'Unknown';
}
},{"./is-browser":"node_modules/@probe.gl/env/dist/esm/lib/is-browser.js","./is-electron":"node_modules/@probe.gl/env/dist/esm/lib/is-electron.js"}],"node_modules/@probe.gl/env/dist/esm/utils/assert.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = assert;

function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'Assertion failed');
  }
}
},{}],"node_modules/@probe.gl/env/dist/esm/index.js":[function(require,module,exports) {
var global = arguments[3];
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "VERSION", {
  enumerable: true,
  get: function () {
    return _globals.VERSION;
  }
});
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function () {
    return _assert.default;
  }
});
Object.defineProperty(exports, "console", {
  enumerable: true,
  get: function () {
    return _globals2.console;
  }
});
Object.defineProperty(exports, "document", {
  enumerable: true,
  get: function () {
    return _globals2.document;
  }
});
Object.defineProperty(exports, "getBrowser", {
  enumerable: true,
  get: function () {
    return _getBrowser.default;
  }
});
Object.defineProperty(exports, "global", {
  enumerable: true,
  get: function () {
    return _globals2.global;
  }
});
Object.defineProperty(exports, "isBrowser", {
  enumerable: true,
  get: function () {
    return _isBrowser.default;
  }
});
Object.defineProperty(exports, "isBrowserMainThread", {
  enumerable: true,
  get: function () {
    return _isBrowser.isBrowserMainThread;
  }
});
Object.defineProperty(exports, "isElectron", {
  enumerable: true,
  get: function () {
    return _isElectron.default;
  }
});
Object.defineProperty(exports, "isMobile", {
  enumerable: true,
  get: function () {
    return _getBrowser.isMobile;
  }
});
Object.defineProperty(exports, "process", {
  enumerable: true,
  get: function () {
    return _globals2.process;
  }
});
Object.defineProperty(exports, "self", {
  enumerable: true,
  get: function () {
    return _globals2.self;
  }
});
Object.defineProperty(exports, "window", {
  enumerable: true,
  get: function () {
    return _globals2.window;
  }
});

var _globals = require("./utils/globals");

var _globals2 = require("./lib/globals");

var _isBrowser = _interopRequireWildcard(require("./lib/is-browser"));

var _getBrowser = _interopRequireWildcard(require("./lib/get-browser"));

var _isElectron = _interopRequireDefault(require("./lib/is-electron"));

var _assert = _interopRequireDefault(require("./utils/assert"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
},{"./utils/globals":"node_modules/@probe.gl/env/dist/esm/utils/globals.js","./lib/globals":"node_modules/@probe.gl/env/dist/esm/lib/globals.js","./lib/is-browser":"node_modules/@probe.gl/env/dist/esm/lib/is-browser.js","./lib/get-browser":"node_modules/@probe.gl/env/dist/esm/lib/get-browser.js","./lib/is-electron":"node_modules/@probe.gl/env/dist/esm/lib/is-electron.js","./utils/assert":"node_modules/@probe.gl/env/dist/esm/utils/assert.js","process":"../../.nvm/versions/node/v16.15.0/lib/node_modules/parcel-bundler/node_modules/process/browser.js"}],"node_modules/@probe.gl/log/dist/esm/utils/local-storage.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getStorage(type) {
  try {
    const storage = window[type];
    const x = '__storage_test__';
    storage.setItem(x, x);
    storage.removeItem(x);
    return storage;
  } catch (e) {
    return null;
  }
}

class LocalStorage {
  constructor(id) {
    let defaultSettings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'sessionStorage';
    (0, _defineProperty2.default)(this, "storage", void 0);
    (0, _defineProperty2.default)(this, "id", void 0);
    (0, _defineProperty2.default)(this, "config", {});
    this.storage = getStorage(type);
    this.id = id;
    this.config = {};
    Object.assign(this.config, defaultSettings);

    this._loadConfiguration();
  }

  getConfiguration() {
    return this.config;
  }

  setConfiguration(configuration) {
    this.config = {};
    return this.updateConfiguration(configuration);
  }

  updateConfiguration(configuration) {
    Object.assign(this.config, configuration);

    if (this.storage) {
      const serialized = JSON.stringify(this.config);
      this.storage.setItem(this.id, serialized);
    }

    return this;
  }

  _loadConfiguration() {
    let configuration = {};

    if (this.storage) {
      const serializedConfiguration = this.storage.getItem(this.id);
      configuration = serializedConfiguration ? JSON.parse(serializedConfiguration) : {};
    }

    Object.assign(this.config, configuration);
    return this;
  }

}

exports.default = LocalStorage;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js"}],"node_modules/@probe.gl/log/dist/esm/utils/formatters.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.formatImage = formatImage;
exports.formatTime = formatTime;
exports.formatValue = formatValue;
exports.leftPad = leftPad;
exports.rightPad = rightPad;

function formatTime(ms) {
  let formatted;

  if (ms < 10) {
    formatted = "".concat(ms.toFixed(2), "ms");
  } else if (ms < 100) {
    formatted = "".concat(ms.toFixed(1), "ms");
  } else if (ms < 1000) {
    formatted = "".concat(ms.toFixed(0), "ms");
  } else {
    formatted = "".concat((ms / 1000).toFixed(2), "s");
  }

  return formatted;
}

function leftPad(string) {
  let length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
  const padLength = Math.max(length - string.length, 0);
  return "".concat(' '.repeat(padLength)).concat(string);
}

function rightPad(string) {
  let length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
  const padLength = Math.max(length - string.length, 0);
  return "".concat(string).concat(' '.repeat(padLength));
}

function formatValue(v) {
  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const EPSILON = 1e-16;
  const {
    isInteger = false
  } = opts;

  if (Array.isArray(v) || ArrayBuffer.isView(v)) {
    return formatArrayValue(v, opts);
  }

  if (!Number.isFinite(v)) {
    return String(v);
  }

  if (Math.abs(v) < EPSILON) {
    return isInteger ? '0' : '0.';
  }

  if (isInteger) {
    return v.toFixed(0);
  }

  if (Math.abs(v) > 100 && Math.abs(v) < 10000) {
    return v.toFixed(0);
  }

  const string = v.toPrecision(2);
  const decimal = string.indexOf('.0');
  return decimal === string.length - 2 ? string.slice(0, -1) : string;
}

function formatArrayValue(v, opts) {
  const {
    maxElts = 16,
    size = 1
  } = opts;
  let string = '[';

  for (let i = 0; i < v.length && i < maxElts; ++i) {
    if (i > 0) {
      string += ",".concat(i % size === 0 ? ' ' : '');
    }

    string += formatValue(v[i], opts);
  }

  const terminator = v.length > maxElts ? '...' : ']';
  return "".concat(string).concat(terminator);
}

function formatImage(image, message, scale) {
  let maxWidth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 600;
  const imageUrl = image.src.replace(/\(/g, '%28').replace(/\)/g, '%29');

  if (image.width > maxWidth) {
    scale = Math.min(scale, maxWidth / image.width);
  }

  const width = image.width * scale;
  const height = image.height * scale;
  const style = ['font-size:1px;', "padding:".concat(Math.floor(height / 2), "px ").concat(Math.floor(width / 2), "px;"), "line-height:".concat(height, "px;"), "background:url(".concat(imageUrl, ");"), "background-size:".concat(width, "px ").concat(height, "px;"), 'color:transparent;'].join('');
  return ["".concat(message, " %c+"), style];
}
},{}],"node_modules/@probe.gl/log/dist/esm/utils/color.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.COLOR = void 0;
exports.addColor = addColor;

var _env = require("@probe.gl/env");

let COLOR;
exports.COLOR = COLOR;

(function (COLOR) {
  COLOR[COLOR["BLACK"] = 30] = "BLACK";
  COLOR[COLOR["RED"] = 31] = "RED";
  COLOR[COLOR["GREEN"] = 32] = "GREEN";
  COLOR[COLOR["YELLOW"] = 33] = "YELLOW";
  COLOR[COLOR["BLUE"] = 34] = "BLUE";
  COLOR[COLOR["MAGENTA"] = 35] = "MAGENTA";
  COLOR[COLOR["CYAN"] = 36] = "CYAN";
  COLOR[COLOR["WHITE"] = 37] = "WHITE";
  COLOR[COLOR["BRIGHT_BLACK"] = 90] = "BRIGHT_BLACK";
  COLOR[COLOR["BRIGHT_RED"] = 91] = "BRIGHT_RED";
  COLOR[COLOR["BRIGHT_GREEN"] = 92] = "BRIGHT_GREEN";
  COLOR[COLOR["BRIGHT_YELLOW"] = 93] = "BRIGHT_YELLOW";
  COLOR[COLOR["BRIGHT_BLUE"] = 94] = "BRIGHT_BLUE";
  COLOR[COLOR["BRIGHT_MAGENTA"] = 95] = "BRIGHT_MAGENTA";
  COLOR[COLOR["BRIGHT_CYAN"] = 96] = "BRIGHT_CYAN";
  COLOR[COLOR["BRIGHT_WHITE"] = 97] = "BRIGHT_WHITE";
})(COLOR || (exports.COLOR = COLOR = {}));

function getColor(color) {
  return typeof color === 'string' ? COLOR[color.toUpperCase()] || COLOR.WHITE : color;
}

function addColor(string, color, background) {
  if (!_env.isBrowser && typeof string === 'string') {
    if (color) {
      color = getColor(color);
      string = "\x1B[".concat(color, "m").concat(string, "\x1B[39m");
    }

    if (background) {
      color = getColor(background);
      string = "\x1B[".concat(background + 10, "m").concat(string, "\x1B[49m");
    }
  }

  return string;
}
},{"@probe.gl/env":"node_modules/@probe.gl/env/dist/esm/index.js"}],"node_modules/@probe.gl/log/dist/esm/utils/autobind.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.autobind = autobind;

function autobind(obj) {
  let predefined = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ['constructor'];
  const proto = Object.getPrototypeOf(obj);
  const propNames = Object.getOwnPropertyNames(proto);

  for (const key of propNames) {
    if (typeof obj[key] === 'function') {
      if (!predefined.find(name => key === name)) {
        obj[key] = obj[key].bind(obj);
      }
    }
  }
}
},{}],"node_modules/@probe.gl/log/dist/esm/utils/assert.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = assert;

function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'Assertion failed');
  }
}
},{}],"node_modules/@probe.gl/log/dist/esm/utils/hi-res-timestamp.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getHiResTimestamp = getHiResTimestamp;

var _env = require("@probe.gl/env");

function getHiResTimestamp() {
  let timestamp;

  if (_env.isBrowser && 'performance' in _env.window) {
    var _window$performance, _window$performance$n;

    timestamp = _env.window === null || _env.window === void 0 ? void 0 : (_window$performance = _env.window.performance) === null || _window$performance === void 0 ? void 0 : (_window$performance$n = _window$performance.now) === null || _window$performance$n === void 0 ? void 0 : _window$performance$n.call(_window$performance);
  } else if ('hrtime' in _env.process) {
    var _process$hrtime;

    const timeParts = _env.process === null || _env.process === void 0 ? void 0 : (_process$hrtime = _env.process.hrtime) === null || _process$hrtime === void 0 ? void 0 : _process$hrtime.call(_env.process);
    timestamp = timeParts[0] * 1000 + timeParts[1] / 1e6;
  } else {
    timestamp = Date.now();
  }

  return timestamp;
}
},{"@probe.gl/env":"node_modules/@probe.gl/env/dist/esm/index.js"}],"node_modules/@probe.gl/log/dist/esm/log.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
exports.normalizeArguments = normalizeArguments;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));

var _env = require("@probe.gl/env");

var _localStorage = _interopRequireDefault(require("./utils/local-storage"));

var _formatters = require("./utils/formatters");

var _color = require("./utils/color");

var _autobind = require("./utils/autobind");

var _assert = _interopRequireDefault(require("./utils/assert"));

var _hiResTimestamp = require("./utils/hi-res-timestamp");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const originalConsole = {
  debug: _env.isBrowser ? console.debug || console.log : console.log,
  log: console.log,
  info: console.info,
  warn: console.warn,
  error: console.error
};
const DEFAULT_SETTINGS = {
  enabled: true,
  level: 0
};

function noop() {}

const cache = {};
const ONCE = {
  once: true
};

class Log {
  constructor() {
    let {
      id
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      id: ''
    };
    (0, _defineProperty2.default)(this, "id", void 0);
    (0, _defineProperty2.default)(this, "VERSION", _env.VERSION);
    (0, _defineProperty2.default)(this, "_startTs", (0, _hiResTimestamp.getHiResTimestamp)());
    (0, _defineProperty2.default)(this, "_deltaTs", (0, _hiResTimestamp.getHiResTimestamp)());
    (0, _defineProperty2.default)(this, "_storage", void 0);
    (0, _defineProperty2.default)(this, "userData", {});
    (0, _defineProperty2.default)(this, "LOG_THROTTLE_TIMEOUT", 0);
    this.id = id;
    this._storage = new _localStorage.default("__probe-".concat(this.id, "__"), DEFAULT_SETTINGS);
    this.userData = {};
    this.timeStamp("".concat(this.id, " started"));
    (0, _autobind.autobind)(this);
    Object.seal(this);
  }

  set level(newLevel) {
    this.setLevel(newLevel);
  }

  get level() {
    return this.getLevel();
  }

  isEnabled() {
    return this._storage.config.enabled;
  }

  getLevel() {
    return this._storage.config.level;
  }

  getTotal() {
    return Number(((0, _hiResTimestamp.getHiResTimestamp)() - this._startTs).toPrecision(10));
  }

  getDelta() {
    return Number(((0, _hiResTimestamp.getHiResTimestamp)() - this._deltaTs).toPrecision(10));
  }

  set priority(newPriority) {
    this.level = newPriority;
  }

  get priority() {
    return this.level;
  }

  getPriority() {
    return this.level;
  }

  enable() {
    let enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

    this._storage.updateConfiguration({
      enabled
    });

    return this;
  }

  setLevel(level) {
    this._storage.updateConfiguration({
      level
    });

    return this;
  }

  get(setting) {
    return this._storage.config[setting];
  }

  set(setting, value) {
    this._storage.updateConfiguration({
      [setting]: value
    });
  }

  settings() {
    if (console.table) {
      console.table(this._storage.config);
    } else {
      console.log(this._storage.config);
    }
  }

  assert(condition, message) {
    (0, _assert.default)(condition, message);
  }

  warn(message) {
    return this._getLogFunction(0, message, originalConsole.warn, arguments, ONCE);
  }

  error(message) {
    return this._getLogFunction(0, message, originalConsole.error, arguments);
  }

  deprecated(oldUsage, newUsage) {
    return this.warn("`".concat(oldUsage, "` is deprecated and will be removed in a later version. Use `").concat(newUsage, "` instead"));
  }

  removed(oldUsage, newUsage) {
    return this.error("`".concat(oldUsage, "` has been removed. Use `").concat(newUsage, "` instead"));
  }

  probe(logLevel, message) {
    return this._getLogFunction(logLevel, message, originalConsole.log, arguments, {
      time: true,
      once: true
    });
  }

  log(logLevel, message) {
    return this._getLogFunction(logLevel, message, originalConsole.debug, arguments);
  }

  info(logLevel, message) {
    return this._getLogFunction(logLevel, message, console.info, arguments);
  }

  once(logLevel, message) {
    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    return this._getLogFunction(logLevel, message, originalConsole.debug || originalConsole.info, arguments, ONCE);
  }

  table(logLevel, table, columns) {
    if (table) {
      return this._getLogFunction(logLevel, table, console.table || noop, columns && [columns], {
        tag: getTableHeader(table)
      });
    }

    return noop;
  }

  image(_ref) {
    let {
      logLevel,
      priority,
      image,
      message = '',
      scale = 1
    } = _ref;

    if (!this._shouldLog(logLevel || priority)) {
      return noop;
    }

    return _env.isBrowser ? logImageInBrowser({
      image,
      message,
      scale
    }) : logImageInNode({
      image,
      message,
      scale
    });
  }

  time(logLevel, message) {
    return this._getLogFunction(logLevel, message, console.time ? console.time : console.info);
  }

  timeEnd(logLevel, message) {
    return this._getLogFunction(logLevel, message, console.timeEnd ? console.timeEnd : console.info);
  }

  timeStamp(logLevel, message) {
    return this._getLogFunction(logLevel, message, console.timeStamp || noop);
  }

  group(logLevel, message) {
    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
      collapsed: false
    };
    const options = normalizeArguments({
      logLevel,
      message,
      opts
    });
    const {
      collapsed
    } = opts;
    options.method = (collapsed ? console.groupCollapsed : console.group) || console.info;
    return this._getLogFunction(options);
  }

  groupCollapsed(logLevel, message) {
    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return this.group(logLevel, message, Object.assign({}, opts, {
      collapsed: true
    }));
  }

  groupEnd(logLevel) {
    return this._getLogFunction(logLevel, '', console.groupEnd || noop);
  }

  withGroup(logLevel, message, func) {
    this.group(logLevel, message)();

    try {
      func();
    } finally {
      this.groupEnd(logLevel)();
    }
  }

  trace() {
    if (console.trace) {
      console.trace();
    }
  }

  _shouldLog(logLevel) {
    return this.isEnabled() && this.getLevel() >= normalizeLogLevel(logLevel);
  }

  _getLogFunction(logLevel, message, method, args, opts) {
    if (this._shouldLog(logLevel)) {
      opts = normalizeArguments({
        logLevel,
        message,
        args,
        opts
      });
      method = method || opts.method;
      (0, _assert.default)(method);
      opts.total = this.getTotal();
      opts.delta = this.getDelta();
      this._deltaTs = (0, _hiResTimestamp.getHiResTimestamp)();
      const tag = opts.tag || opts.message;

      if (opts.once) {
        if (!cache[tag]) {
          cache[tag] = (0, _hiResTimestamp.getHiResTimestamp)();
        } else {
          return noop;
        }
      }

      message = decorateMessage(this.id, opts.message, opts);
      return method.bind(console, message, ...opts.args);
    }

    return noop;
  }

}

exports.default = Log;
(0, _defineProperty2.default)(Log, "VERSION", _env.VERSION);

function normalizeLogLevel(logLevel) {
  if (!logLevel) {
    return 0;
  }

  let resolvedLevel;

  switch (typeof logLevel) {
    case 'number':
      resolvedLevel = logLevel;
      break;

    case 'object':
      resolvedLevel = logLevel.logLevel || logLevel.priority || 0;
      break;

    default:
      return 0;
  }

  (0, _assert.default)(Number.isFinite(resolvedLevel) && resolvedLevel >= 0);
  return resolvedLevel;
}

function normalizeArguments(opts) {
  const {
    logLevel,
    message
  } = opts;
  opts.logLevel = normalizeLogLevel(logLevel);
  const args = opts.args ? Array.from(opts.args) : [];

  while (args.length && args.shift() !== message) {}

  switch (typeof logLevel) {
    case 'string':
    case 'function':
      if (message !== undefined) {
        args.unshift(message);
      }

      opts.message = logLevel;
      break;

    case 'object':
      Object.assign(opts, logLevel);
      break;

    default:
  }

  if (typeof opts.message === 'function') {
    opts.message = opts.message();
  }

  const messageType = typeof opts.message;
  (0, _assert.default)(messageType === 'string' || messageType === 'object');
  return Object.assign(opts, {
    args
  }, opts.opts);
}

function decorateMessage(id, message, opts) {
  if (typeof message === 'string') {
    const time = opts.time ? (0, _formatters.leftPad)((0, _formatters.formatTime)(opts.total)) : '';
    message = opts.time ? "".concat(id, ": ").concat(time, "  ").concat(message) : "".concat(id, ": ").concat(message);
    message = (0, _color.addColor)(message, opts.color, opts.background);
  }

  return message;
}

function logImageInNode(_ref2) {
  let {
    image,
    message = '',
    scale = 1
  } = _ref2;
  let asciify = null;

  try {
    asciify = module.require('asciify-image');
  } catch (error) {}

  if (asciify) {
    return () => asciify(image, {
      fit: 'box',
      width: "".concat(Math.round(80 * scale), "%")
    }).then(data => console.log(data));
  }

  return noop;
}

function logImageInBrowser(_ref3) {
  let {
    image,
    message = '',
    scale = 1
  } = _ref3;

  if (typeof image === 'string') {
    const img = new Image();

    img.onload = () => {
      const args = (0, _formatters.formatImage)(img, message, scale);
      console.log(...args);
    };

    img.src = image;
    return noop;
  }

  const element = image.nodeName || '';

  if (element.toLowerCase() === 'img') {
    console.log(...(0, _formatters.formatImage)(image, message, scale));
    return noop;
  }

  if (element.toLowerCase() === 'canvas') {
    const img = new Image();

    img.onload = () => console.log(...(0, _formatters.formatImage)(img, message, scale));

    img.src = image.toDataURL();
    return noop;
  }

  return noop;
}

function getTableHeader(table) {
  for (const key in table) {
    for (const title in table[key]) {
      return title || 'untitled';
    }
  }

  return 'empty';
}
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@probe.gl/env":"node_modules/@probe.gl/env/dist/esm/index.js","./utils/local-storage":"node_modules/@probe.gl/log/dist/esm/utils/local-storage.js","./utils/formatters":"node_modules/@probe.gl/log/dist/esm/utils/formatters.js","./utils/color":"node_modules/@probe.gl/log/dist/esm/utils/color.js","./utils/autobind":"node_modules/@probe.gl/log/dist/esm/utils/autobind.js","./utils/assert":"node_modules/@probe.gl/log/dist/esm/utils/assert.js","./utils/hi-res-timestamp":"node_modules/@probe.gl/log/dist/esm/utils/hi-res-timestamp.js"}],"node_modules/@probe.gl/log/dist/esm/init.js":[function(require,module,exports) {
globalThis.probe = {};

},{}],"node_modules/@probe.gl/log/dist/esm/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "COLOR", {
  enumerable: true,
  get: function () {
    return _color.COLOR;
  }
});
Object.defineProperty(exports, "LocalStorage", {
  enumerable: true,
  get: function () {
    return _localStorage.default;
  }
});
Object.defineProperty(exports, "Log", {
  enumerable: true,
  get: function () {
    return _log.default;
  }
});
Object.defineProperty(exports, "addColor", {
  enumerable: true,
  get: function () {
    return _color.addColor;
  }
});
Object.defineProperty(exports, "autobind", {
  enumerable: true,
  get: function () {
    return _autobind.autobind;
  }
});
exports.default = void 0;
Object.defineProperty(exports, "getHiResTimestamp", {
  enumerable: true,
  get: function () {
    return _hiResTimestamp.getHiResTimestamp;
  }
});
Object.defineProperty(exports, "leftPad", {
  enumerable: true,
  get: function () {
    return _formatters.leftPad;
  }
});
Object.defineProperty(exports, "rightPad", {
  enumerable: true,
  get: function () {
    return _formatters.rightPad;
  }
});

var _log = _interopRequireDefault(require("./log"));

var _color = require("./utils/color");

var _formatters = require("./utils/formatters");

var _autobind = require("./utils/autobind");

var _localStorage = _interopRequireDefault(require("./utils/local-storage"));

var _hiResTimestamp = require("./utils/hi-res-timestamp");

require("./init");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = new _log.default({
  id: '@probe.gl/log'
});

exports.default = _default;
},{"./log":"node_modules/@probe.gl/log/dist/esm/log.js","./utils/color":"node_modules/@probe.gl/log/dist/esm/utils/color.js","./utils/formatters":"node_modules/@probe.gl/log/dist/esm/utils/formatters.js","./utils/autobind":"node_modules/@probe.gl/log/dist/esm/utils/autobind.js","./utils/local-storage":"node_modules/@probe.gl/log/dist/esm/utils/local-storage.js","./utils/hi-res-timestamp":"node_modules/@probe.gl/log/dist/esm/utils/hi-res-timestamp.js","./init":"node_modules/@probe.gl/log/dist/esm/init.js"}],"node_modules/probe.gl/dist/esm/index.js":[function(require,module,exports) {
var global = arguments[3];
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "COLOR", {
  enumerable: true,
  get: function () {
    return _log.COLOR;
  }
});
Object.defineProperty(exports, "LocalStorage", {
  enumerable: true,
  get: function () {
    return _log.default;
  }
});
Object.defineProperty(exports, "Log", {
  enumerable: true,
  get: function () {
    return _log.Log;
  }
});
Object.defineProperty(exports, "Stat", {
  enumerable: true,
  get: function () {
    return _stats.Stat;
  }
});
Object.defineProperty(exports, "Stats", {
  enumerable: true,
  get: function () {
    return _stats.Stats;
  }
});
Object.defineProperty(exports, "VERSION", {
  enumerable: true,
  get: function () {
    return _env.VERSION;
  }
});
Object.defineProperty(exports, "addColor", {
  enumerable: true,
  get: function () {
    return _log.addColor;
  }
});
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function () {
    return _env.assert;
  }
});
Object.defineProperty(exports, "autobind", {
  enumerable: true,
  get: function () {
    return _log.autobind;
  }
});
Object.defineProperty(exports, "console", {
  enumerable: true,
  get: function () {
    return _env.console;
  }
});
Object.defineProperty(exports, "default", {
  enumerable: true,
  get: function () {
    return _log.default;
  }
});
Object.defineProperty(exports, "document", {
  enumerable: true,
  get: function () {
    return _env.document;
  }
});
Object.defineProperty(exports, "getBrowser", {
  enumerable: true,
  get: function () {
    return _env.getBrowser;
  }
});
Object.defineProperty(exports, "getHiResTimestamp", {
  enumerable: true,
  get: function () {
    return _log.default;
  }
});
Object.defineProperty(exports, "global", {
  enumerable: true,
  get: function () {
    return _env.global;
  }
});
Object.defineProperty(exports, "isBrowser", {
  enumerable: true,
  get: function () {
    return _env.isBrowser;
  }
});
Object.defineProperty(exports, "isBrowserMainThread", {
  enumerable: true,
  get: function () {
    return _env.isBrowserMainThread;
  }
});
Object.defineProperty(exports, "isElectron", {
  enumerable: true,
  get: function () {
    return _env.isElectron;
  }
});
Object.defineProperty(exports, "isMobile", {
  enumerable: true,
  get: function () {
    return _env.isMobile;
  }
});
Object.defineProperty(exports, "leftPad", {
  enumerable: true,
  get: function () {
    return _log.leftPad;
  }
});
Object.defineProperty(exports, "process", {
  enumerable: true,
  get: function () {
    return _env.process;
  }
});
Object.defineProperty(exports, "rightPad", {
  enumerable: true,
  get: function () {
    return _log.rightPad;
  }
});
Object.defineProperty(exports, "self", {
  enumerable: true,
  get: function () {
    return _env.self;
  }
});
Object.defineProperty(exports, "window", {
  enumerable: true,
  get: function () {
    return _env.window;
  }
});

var _env = require("@probe.gl/env");

var _log = _interopRequireWildcard(require("@probe.gl/log"));

var _stats = require("@probe.gl/stats");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
},{"@probe.gl/env":"node_modules/@probe.gl/env/dist/esm/index.js","@probe.gl/log":"node_modules/@probe.gl/log/dist/esm/index.js","@probe.gl/stats":"node_modules/@probe.gl/stats/dist/esm/index.js","process":"../../.nvm/versions/node/v16.15.0/lib/node_modules/parcel-bundler/node_modules/process/browser.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/loggers.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.probeLog = exports.NullLog = exports.ConsoleLog = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));

var _probe = require("probe.gl");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const probeLog = new _probe.Log({
  id: 'loaders.gl'
});
exports.probeLog = probeLog;

class NullLog {
  log() {
    return () => {};
  }

  info() {
    return () => {};
  }

  warn() {
    return () => {};
  }

  error() {
    return () => {};
  }

}

exports.NullLog = NullLog;

class ConsoleLog {
  constructor() {
    (0, _defineProperty2.default)(this, "console", void 0);
    this.console = console;
  }

  log(...args) {
    return this.console.log.bind(this.console, ...args);
  }

  info(...args) {
    return this.console.info.bind(this.console, ...args);
  }

  warn(...args) {
    return this.console.warn.bind(this.console, ...args);
  }

  error(...args) {
    return this.console.error.bind(this.console, ...args);
  }

}

exports.ConsoleLog = ConsoleLog;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","probe.gl":"node_modules/probe.gl/dist/esm/index.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/option-defaults.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.REMOVED_LOADER_OPTIONS = exports.DEFAULT_LOADER_OPTIONS = void 0;

var _loaderUtils = require("@loaders.gl/loader-utils");

var _loggers = require("./loggers");

const DEFAULT_LOADER_OPTIONS = {
  fetch: null,
  mimeType: undefined,
  nothrow: false,
  log: new _loggers.ConsoleLog(),
  CDN: 'https://unpkg.com/@loaders.gl',
  worker: true,
  maxConcurrency: 3,
  maxMobileConcurrency: 1,
  reuseWorkers: _loaderUtils.isBrowser,
  _nodeWorkers: false,
  _workerType: '',
  limit: 0,
  _limitMB: 0,
  batchSize: 'auto',
  batchDebounceMs: 0,
  metadata: false,
  transforms: []
};
exports.DEFAULT_LOADER_OPTIONS = DEFAULT_LOADER_OPTIONS;
const REMOVED_LOADER_OPTIONS = {
  throws: 'nothrow',
  dataType: '(no longer used)',
  uri: 'baseUri',
  method: 'fetch.method',
  headers: 'fetch.headers',
  body: 'fetch.body',
  mode: 'fetch.mode',
  credentials: 'fetch.credentials',
  cache: 'fetch.cache',
  redirect: 'fetch.redirect',
  referrer: 'fetch.referrer',
  referrerPolicy: 'fetch.referrerPolicy',
  integrity: 'fetch.integrity',
  keepalive: 'fetch.keepalive',
  signal: 'fetch.signal'
};
exports.REMOVED_LOADER_OPTIONS = REMOVED_LOADER_OPTIONS;
},{"@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js","./loggers":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/loggers.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/option-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getFetchFunction = getFetchFunction;
exports.getGlobalLoaderOptions = void 0;
exports.getGlobalLoaderState = getGlobalLoaderState;
exports.normalizeOptions = normalizeOptions;
exports.setGlobalOptions = setGlobalOptions;

var _isType = require("../../javascript-utils/is-type");

var _fetchFile = require("../fetch/fetch-file");

var _loggers = require("./loggers");

var _optionDefaults = require("./option-defaults");

function getGlobalLoaderState() {
  globalThis.loaders = globalThis.loaders || {};
  const {
    loaders
  } = globalThis;
  loaders._state = loaders._state || {};
  return loaders._state;
}

const getGlobalLoaderOptions = () => {
  const state = getGlobalLoaderState();
  state.globalOptions = state.globalOptions || { ..._optionDefaults.DEFAULT_LOADER_OPTIONS
  };
  return state.globalOptions;
};

exports.getGlobalLoaderOptions = getGlobalLoaderOptions;

function setGlobalOptions(options) {
  const state = getGlobalLoaderState();
  const globalOptions = getGlobalLoaderOptions();
  state.globalOptions = normalizeOptionsInternal(globalOptions, options);
}

function normalizeOptions(options, loader, loaders, url) {
  loaders = loaders || [];
  loaders = Array.isArray(loaders) ? loaders : [loaders];
  validateOptions(options, loaders);
  return normalizeOptionsInternal(loader, options, url);
}

function getFetchFunction(options, context) {
  const globalOptions = getGlobalLoaderOptions();
  const fetchOptions = options || globalOptions;

  if (typeof fetchOptions.fetch === 'function') {
    return fetchOptions.fetch;
  }

  if ((0, _isType.isObject)(fetchOptions.fetch)) {
    return url => (0, _fetchFile.fetchFile)(url, fetchOptions);
  }

  if (context !== null && context !== void 0 && context.fetch) {
    return context === null || context === void 0 ? void 0 : context.fetch;
  }

  return _fetchFile.fetchFile;
}

function validateOptions(options, loaders) {
  validateOptionsObject(options, null, _optionDefaults.DEFAULT_LOADER_OPTIONS, _optionDefaults.REMOVED_LOADER_OPTIONS, loaders);

  for (const loader of loaders) {
    const idOptions = options && options[loader.id] || {};
    const loaderOptions = loader.options && loader.options[loader.id] || {};
    const deprecatedOptions = loader.deprecatedOptions && loader.deprecatedOptions[loader.id] || {};
    validateOptionsObject(idOptions, loader.id, loaderOptions, deprecatedOptions, loaders);
  }
}

function validateOptionsObject(options, id, defaultOptions, deprecatedOptions, loaders) {
  const loaderName = id || 'Top level';
  const prefix = id ? "".concat(id, ".") : '';

  for (const key in options) {
    const isSubOptions = !id && (0, _isType.isObject)(options[key]);
    const isBaseUriOption = key === 'baseUri' && !id;
    const isWorkerUrlOption = key === 'workerUrl' && id;

    if (!(key in defaultOptions) && !isBaseUriOption && !isWorkerUrlOption) {
      if (key in deprecatedOptions) {
        _loggers.probeLog.warn("".concat(loaderName, " loader option '").concat(prefix).concat(key, "' no longer supported, use '").concat(deprecatedOptions[key], "'"))();
      } else if (!isSubOptions) {
        const suggestion = findSimilarOption(key, loaders);

        _loggers.probeLog.warn("".concat(loaderName, " loader option '").concat(prefix).concat(key, "' not recognized. ").concat(suggestion))();
      }
    }
  }
}

function findSimilarOption(optionKey, loaders) {
  const lowerCaseOptionKey = optionKey.toLowerCase();
  let bestSuggestion = '';

  for (const loader of loaders) {
    for (const key in loader.options) {
      if (optionKey === key) {
        return "Did you mean '".concat(loader.id, ".").concat(key, "'?");
      }

      const lowerCaseKey = key.toLowerCase();
      const isPartialMatch = lowerCaseOptionKey.startsWith(lowerCaseKey) || lowerCaseKey.startsWith(lowerCaseOptionKey);

      if (isPartialMatch) {
        bestSuggestion = bestSuggestion || "Did you mean '".concat(loader.id, ".").concat(key, "'?");
      }
    }
  }

  return bestSuggestion;
}

function normalizeOptionsInternal(loader, options, url) {
  const loaderDefaultOptions = loader.options || {};
  const mergedOptions = { ...loaderDefaultOptions
  };
  addUrlOptions(mergedOptions, url);

  if (mergedOptions.log === null) {
    mergedOptions.log = new _loggers.NullLog();
  }

  mergeNestedFields(mergedOptions, getGlobalLoaderOptions());
  mergeNestedFields(mergedOptions, options);
  return mergedOptions;
}

function mergeNestedFields(mergedOptions, options) {
  for (const key in options) {
    if (key in options) {
      const value = options[key];

      if ((0, _isType.isPureObject)(value) && (0, _isType.isPureObject)(mergedOptions[key])) {
        mergedOptions[key] = { ...mergedOptions[key],
          ...options[key]
        };
      } else {
        mergedOptions[key] = options[key];
      }
    }
  }
}

function addUrlOptions(options, url) {
  if (url && !('baseUri' in options)) {
    options.baseUri = url;
  }
}
},{"../../javascript-utils/is-type":"node_modules/@loaders.gl/core/dist/esm/javascript-utils/is-type.js","../fetch/fetch-file":"node_modules/@loaders.gl/core/dist/esm/lib/fetch/fetch-file.js","./loggers":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/loggers.js","./option-defaults":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/option-defaults.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/api/loader-options.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "getLoaderOptions", {
  enumerable: true,
  get: function () {
    return _optionUtils.getGlobalLoaderOptions;
  }
});
Object.defineProperty(exports, "setLoaderOptions", {
  enumerable: true,
  get: function () {
    return _optionUtils.setGlobalOptions;
  }
});

var _optionUtils = require("../loader-utils/option-utils");
},{"../loader-utils/option-utils":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/option-utils.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/normalize-loader.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isLoaderObject = isLoaderObject;
exports.normalizeLoader = normalizeLoader;

var _loaderUtils = require("@loaders.gl/loader-utils");

function isLoaderObject(loader) {
  var _loader;

  if (!loader) {
    return false;
  }

  if (Array.isArray(loader)) {
    loader = loader[0];
  }

  const hasExtensions = Array.isArray((_loader = loader) === null || _loader === void 0 ? void 0 : _loader.extensions);
  return hasExtensions;
}

function normalizeLoader(loader) {
  var _loader2, _loader3;

  (0, _loaderUtils.assert)(loader, 'null loader');
  (0, _loaderUtils.assert)(isLoaderObject(loader), 'invalid loader');
  let options;

  if (Array.isArray(loader)) {
    options = loader[1];
    loader = loader[0];
    loader = { ...loader,
      options: { ...loader.options,
        ...options
      }
    };
  }

  if ((_loader2 = loader) !== null && _loader2 !== void 0 && _loader2.parseTextSync || (_loader3 = loader) !== null && _loader3 !== void 0 && _loader3.parseText) {
    loader.text = true;
  }

  if (!loader.text) {
    loader.binary = true;
  }

  return loader;
}
},{"@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/api/register-loaders.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._unregisterLoaders = _unregisterLoaders;
exports.getRegisteredLoaders = getRegisteredLoaders;
exports.registerLoaders = registerLoaders;

var _normalizeLoader = require("../loader-utils/normalize-loader");

var _optionUtils = require("../loader-utils/option-utils");

const getGlobalLoaderRegistry = () => {
  const state = (0, _optionUtils.getGlobalLoaderState)();
  state.loaderRegistry = state.loaderRegistry || [];
  return state.loaderRegistry;
};

function registerLoaders(loaders) {
  const loaderRegistry = getGlobalLoaderRegistry();
  loaders = Array.isArray(loaders) ? loaders : [loaders];

  for (const loader of loaders) {
    const normalizedLoader = (0, _normalizeLoader.normalizeLoader)(loader);

    if (!loaderRegistry.find(registeredLoader => normalizedLoader === registeredLoader)) {
      loaderRegistry.unshift(normalizedLoader);
    }
  }
}

function getRegisteredLoaders() {
  return getGlobalLoaderRegistry();
}

function _unregisterLoaders() {
  const state = (0, _optionUtils.getGlobalLoaderState)();
  state.loaderRegistry = [];
}
},{"../loader-utils/normalize-loader":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/normalize-loader.js","../loader-utils/option-utils":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/option-utils.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/utils/log.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.log = void 0;

var _log = require("@probe.gl/log");

const log = new _log.Log({
  id: 'loaders.gl'
});
exports.log = log;
},{"@probe.gl/log":"node_modules/@probe.gl/log/dist/esm/index.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/api/select-loader.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.selectLoader = selectLoader;
exports.selectLoaderSync = selectLoaderSync;

var _loaderUtils = require("@loaders.gl/loader-utils");

var _normalizeLoader = require("../loader-utils/normalize-loader");

var _log = require("../utils/log");

var _resourceUtils = require("../utils/resource-utils");

var _registerLoaders = require("./register-loaders");

var _isType = require("../../javascript-utils/is-type");

const EXT_PATTERN = /\.([^.]+)$/;

async function selectLoader(data, loaders = [], options, context) {
  if (!validHTTPResponse(data)) {
    return null;
  }

  let loader = selectLoaderSync(data, loaders, { ...options,
    nothrow: true
  }, context);

  if (loader) {
    return loader;
  }

  if ((0, _isType.isBlob)(data)) {
    data = await data.slice(0, 10).arrayBuffer();
    loader = selectLoaderSync(data, loaders, options, context);
  }

  if (!loader && !(options !== null && options !== void 0 && options.nothrow)) {
    throw new Error(getNoValidLoaderMessage(data));
  }

  return loader;
}

function selectLoaderSync(data, loaders = [], options, context) {
  if (!validHTTPResponse(data)) {
    return null;
  }

  if (loaders && !Array.isArray(loaders)) {
    return (0, _normalizeLoader.normalizeLoader)(loaders);
  }

  let candidateLoaders = [];

  if (loaders) {
    candidateLoaders = candidateLoaders.concat(loaders);
  }

  if (!(options !== null && options !== void 0 && options.ignoreRegisteredLoaders)) {
    candidateLoaders.push(...(0, _registerLoaders.getRegisteredLoaders)());
  }

  normalizeLoaders(candidateLoaders);
  const loader = selectLoaderInternal(data, candidateLoaders, options, context);

  if (!loader && !(options !== null && options !== void 0 && options.nothrow)) {
    throw new Error(getNoValidLoaderMessage(data));
  }

  return loader;
}

function selectLoaderInternal(data, loaders, options, context) {
  const {
    url,
    type
  } = (0, _resourceUtils.getResourceUrlAndType)(data);
  const testUrl = url || (context === null || context === void 0 ? void 0 : context.url);
  let loader = null;
  let reason = '';

  if (options !== null && options !== void 0 && options.mimeType) {
    loader = findLoaderByMIMEType(loaders, options === null || options === void 0 ? void 0 : options.mimeType);
    reason = "match forced by supplied MIME type ".concat(options === null || options === void 0 ? void 0 : options.mimeType);
  }

  loader = loader || findLoaderByUrl(loaders, testUrl);
  reason = reason || (loader ? "matched url ".concat(testUrl) : '');
  loader = loader || findLoaderByMIMEType(loaders, type);
  reason = reason || (loader ? "matched MIME type ".concat(type) : '');
  loader = loader || findLoaderByInitialBytes(loaders, data);
  reason = reason || (loader ? "matched initial data ".concat(getFirstCharacters(data)) : '');
  loader = loader || findLoaderByMIMEType(loaders, options === null || options === void 0 ? void 0 : options.fallbackMimeType);
  reason = reason || (loader ? "matched fallback MIME type ".concat(type) : '');

  if (reason) {
    var _loader;

    _log.log.log(1, "selectLoader selected ".concat((_loader = loader) === null || _loader === void 0 ? void 0 : _loader.name, ": ").concat(reason, "."));
  }

  return loader;
}

function validHTTPResponse(data) {
  if (data instanceof Response) {
    if (data.status === 204) {
      return false;
    }
  }

  return true;
}

function getNoValidLoaderMessage(data) {
  const {
    url,
    type
  } = (0, _resourceUtils.getResourceUrlAndType)(data);
  let message = 'No valid loader found (';
  message += url ? "".concat(_loaderUtils.path.filename(url), ", ") : 'no url provided, ';
  message += "MIME type: ".concat(type ? "\"".concat(type, "\"") : 'not provided', ", ");
  const firstCharacters = data ? getFirstCharacters(data) : '';
  message += firstCharacters ? " first bytes: \"".concat(firstCharacters, "\"") : 'first bytes: not available';
  message += ')';
  return message;
}

function normalizeLoaders(loaders) {
  for (const loader of loaders) {
    (0, _normalizeLoader.normalizeLoader)(loader);
  }
}

function findLoaderByUrl(loaders, url) {
  const match = url && EXT_PATTERN.exec(url);
  const extension = match && match[1];
  return extension ? findLoaderByExtension(loaders, extension) : null;
}

function findLoaderByExtension(loaders, extension) {
  extension = extension.toLowerCase();

  for (const loader of loaders) {
    for (const loaderExtension of loader.extensions) {
      if (loaderExtension.toLowerCase() === extension) {
        return loader;
      }
    }
  }

  return null;
}

function findLoaderByMIMEType(loaders, mimeType) {
  for (const loader of loaders) {
    if (loader.mimeTypes && loader.mimeTypes.includes(mimeType)) {
      return loader;
    }

    if (mimeType === "application/x.".concat(loader.id)) {
      return loader;
    }
  }

  return null;
}

function findLoaderByInitialBytes(loaders, data) {
  if (!data) {
    return null;
  }

  for (const loader of loaders) {
    if (typeof data === 'string') {
      if (testDataAgainstText(data, loader)) {
        return loader;
      }
    } else if (ArrayBuffer.isView(data)) {
      if (testDataAgainstBinary(data.buffer, data.byteOffset, loader)) {
        return loader;
      }
    } else if (data instanceof ArrayBuffer) {
      const byteOffset = 0;

      if (testDataAgainstBinary(data, byteOffset, loader)) {
        return loader;
      }
    }
  }

  return null;
}

function testDataAgainstText(data, loader) {
  if (loader.testText) {
    return loader.testText(data);
  }

  const tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];
  return tests.some(test => data.startsWith(test));
}

function testDataAgainstBinary(data, byteOffset, loader) {
  const tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];
  return tests.some(test => testBinary(data, byteOffset, loader, test));
}

function testBinary(data, byteOffset, loader, test) {
  if (test instanceof ArrayBuffer) {
    return (0, _loaderUtils.compareArrayBuffers)(test, data, test.byteLength);
  }

  switch (typeof test) {
    case 'function':
      return test(data, loader);

    case 'string':
      const magic = getMagicString(data, byteOffset, test.length);
      return test === magic;

    default:
      return false;
  }
}

function getFirstCharacters(data, length = 5) {
  if (typeof data === 'string') {
    return data.slice(0, length);
  } else if (ArrayBuffer.isView(data)) {
    return getMagicString(data.buffer, data.byteOffset, length);
  } else if (data instanceof ArrayBuffer) {
    const byteOffset = 0;
    return getMagicString(data, byteOffset, length);
  }

  return '';
}

function getMagicString(arrayBuffer, byteOffset, length) {
  if (arrayBuffer.byteLength < byteOffset + length) {
    return '';
  }

  const dataView = new DataView(arrayBuffer);
  let magic = '';

  for (let i = 0; i < length; i++) {
    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));
  }

  return magic;
}
},{"@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js","../loader-utils/normalize-loader":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/normalize-loader.js","../utils/log":"node_modules/@loaders.gl/core/dist/esm/lib/utils/log.js","../utils/resource-utils":"node_modules/@loaders.gl/core/dist/esm/lib/utils/resource-utils.js","./register-loaders":"node_modules/@loaders.gl/core/dist/esm/lib/api/register-loaders.js","../../javascript-utils/is-type":"node_modules/@loaders.gl/core/dist/esm/javascript-utils/is-type.js"}],"node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-string-iterator.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeStringIterator = makeStringIterator;
const DEFAULT_CHUNK_SIZE = 256 * 1024;

function* makeStringIterator(string, options) {
  const chunkSize = (options === null || options === void 0 ? void 0 : options.chunkSize) || DEFAULT_CHUNK_SIZE;
  let offset = 0;
  const textEncoder = new TextEncoder();

  while (offset < string.length) {
    const chunkLength = Math.min(string.length - offset, chunkSize);
    const chunk = string.slice(offset, offset + chunkLength);
    offset += chunkLength;
    yield textEncoder.encode(chunk);
  }
}
},{}],"node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-array-buffer-iterator.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeArrayBufferIterator = makeArrayBufferIterator;
const DEFAULT_CHUNK_SIZE = 256 * 1024;

function* makeArrayBufferIterator(arrayBuffer, options = {}) {
  const {
    chunkSize = DEFAULT_CHUNK_SIZE
  } = options;
  let byteOffset = 0;

  while (byteOffset < arrayBuffer.byteLength) {
    const chunkByteLength = Math.min(arrayBuffer.byteLength - byteOffset, chunkSize);
    const chunk = new ArrayBuffer(chunkByteLength);
    const sourceArray = new Uint8Array(arrayBuffer, byteOffset, chunkByteLength);
    const chunkArray = new Uint8Array(chunk);
    chunkArray.set(sourceArray);
    byteOffset += chunkByteLength;
    yield chunk;
  }
}
},{}],"node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-blob-iterator.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeBlobIterator = makeBlobIterator;
const DEFAULT_CHUNK_SIZE = 1024 * 1024;

async function* makeBlobIterator(blob, options) {
  const chunkSize = (options === null || options === void 0 ? void 0 : options.chunkSize) || DEFAULT_CHUNK_SIZE;
  let offset = 0;

  while (offset < blob.size) {
    const end = offset + chunkSize;
    const chunk = await blob.slice(offset, end).arrayBuffer();
    offset = end;
    yield chunk;
  }
}
},{}],"node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-stream-iterator.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeStreamIterator = makeStreamIterator;

var _loaderUtils = require("@loaders.gl/loader-utils");

function makeStreamIterator(stream, options) {
  return _loaderUtils.isBrowser ? makeBrowserStreamIterator(stream, options) : makeNodeStreamIterator(stream, options);
}

async function* makeBrowserStreamIterator(stream, options) {
  const reader = stream.getReader();
  let nextBatchPromise;

  try {
    while (true) {
      const currentBatchPromise = nextBatchPromise || reader.read();

      if (options !== null && options !== void 0 && options._streamReadAhead) {
        nextBatchPromise = reader.read();
      }

      const {
        done,
        value
      } = await currentBatchPromise;

      if (done) {
        return;
      }

      yield (0, _loaderUtils.toArrayBuffer)(value);
    }
  } catch (error) {
    reader.releaseLock();
  }
}

async function* makeNodeStreamIterator(stream, options) {
  for await (const chunk of stream) {
    yield (0, _loaderUtils.toArrayBuffer)(chunk);
  }
}
},{"@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js"}],"node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-iterator.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeIterator = makeIterator;

var _makeStringIterator = require("./make-string-iterator");

var _makeArrayBufferIterator = require("./make-array-buffer-iterator");

var _makeBlobIterator = require("./make-blob-iterator");

var _makeStreamIterator = require("./make-stream-iterator");

var _isType = require("../../javascript-utils/is-type");

function makeIterator(data, options) {
  if (typeof data === 'string') {
    return (0, _makeStringIterator.makeStringIterator)(data, options);
  }

  if (data instanceof ArrayBuffer) {
    return (0, _makeArrayBufferIterator.makeArrayBufferIterator)(data, options);
  }

  if ((0, _isType.isBlob)(data)) {
    return (0, _makeBlobIterator.makeBlobIterator)(data, options);
  }

  if ((0, _isType.isReadableStream)(data)) {
    return (0, _makeStreamIterator.makeStreamIterator)(data, options);
  }

  if ((0, _isType.isResponse)(data)) {
    const response = data;
    return (0, _makeStreamIterator.makeStreamIterator)(response.body, options);
  }

  throw new Error('makeIterator');
}
},{"./make-string-iterator":"node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-string-iterator.js","./make-array-buffer-iterator":"node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-array-buffer-iterator.js","./make-blob-iterator":"node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-blob-iterator.js","./make-stream-iterator":"node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-stream-iterator.js","../../javascript-utils/is-type":"node_modules/@loaders.gl/core/dist/esm/javascript-utils/is-type.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/get-data.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getArrayBufferOrStringFromData = getArrayBufferOrStringFromData;
exports.getArrayBufferOrStringFromDataSync = getArrayBufferOrStringFromDataSync;
exports.getAsyncIterableFromData = getAsyncIterableFromData;
exports.getReadableStream = getReadableStream;

var _loaderUtils = require("@loaders.gl/loader-utils");

var _isType = require("../../javascript-utils/is-type");

var _makeIterator = require("../../iterators/make-iterator/make-iterator");

var _responseUtils = require("../utils/response-utils");

const ERR_DATA = 'Cannot convert supplied data type';

function getArrayBufferOrStringFromDataSync(data, loader, options) {
  if (loader.text && typeof data === 'string') {
    return data;
  }

  if ((0, _isType.isBuffer)(data)) {
    data = data.buffer;
  }

  if (data instanceof ArrayBuffer) {
    const arrayBuffer = data;

    if (loader.text && !loader.binary) {
      const textDecoder = new TextDecoder('utf8');
      return textDecoder.decode(arrayBuffer);
    }

    return arrayBuffer;
  }

  if (ArrayBuffer.isView(data)) {
    if (loader.text && !loader.binary) {
      const textDecoder = new TextDecoder('utf8');
      return textDecoder.decode(data);
    }

    let arrayBuffer = data.buffer;
    const byteLength = data.byteLength || data.length;

    if (data.byteOffset !== 0 || byteLength !== arrayBuffer.byteLength) {
      arrayBuffer = arrayBuffer.slice(data.byteOffset, data.byteOffset + byteLength);
    }

    return arrayBuffer;
  }

  throw new Error(ERR_DATA);
}

async function getArrayBufferOrStringFromData(data, loader, options) {
  const isArrayBuffer = data instanceof ArrayBuffer || ArrayBuffer.isView(data);

  if (typeof data === 'string' || isArrayBuffer) {
    return getArrayBufferOrStringFromDataSync(data, loader, options);
  }

  if ((0, _isType.isBlob)(data)) {
    data = await (0, _responseUtils.makeResponse)(data);
  }

  if ((0, _isType.isResponse)(data)) {
    const response = data;
    await (0, _responseUtils.checkResponse)(response);
    return loader.binary ? await response.arrayBuffer() : await response.text();
  }

  if ((0, _isType.isReadableStream)(data)) {
    data = (0, _makeIterator.makeIterator)(data, options);
  }

  if ((0, _isType.isIterable)(data) || (0, _isType.isAsyncIterable)(data)) {
    return (0, _loaderUtils.concatenateArrayBuffersAsync)(data);
  }

  throw new Error(ERR_DATA);
}

async function getAsyncIterableFromData(data, options) {
  if ((0, _isType.isIterator)(data)) {
    return data;
  }

  if ((0, _isType.isResponse)(data)) {
    const response = data;
    await (0, _responseUtils.checkResponse)(response);
    const body = await response.body;
    return (0, _makeIterator.makeIterator)(body, options);
  }

  if ((0, _isType.isBlob)(data) || (0, _isType.isReadableStream)(data)) {
    return (0, _makeIterator.makeIterator)(data, options);
  }

  if ((0, _isType.isAsyncIterable)(data)) {
    return data[Symbol.asyncIterator]();
  }

  return getIterableFromData(data);
}

async function getReadableStream(data) {
  if ((0, _isType.isReadableStream)(data)) {
    return data;
  }

  if ((0, _isType.isResponse)(data)) {
    return data.body;
  }

  const response = await (0, _responseUtils.makeResponse)(data);
  return response.body;
}

function getIterableFromData(data) {
  if (ArrayBuffer.isView(data)) {
    return function* oneChunk() {
      yield data.buffer;
    }();
  }

  if (data instanceof ArrayBuffer) {
    return function* oneChunk() {
      yield data;
    }();
  }

  if ((0, _isType.isIterator)(data)) {
    return data;
  }

  if ((0, _isType.isIterable)(data)) {
    return data[Symbol.iterator]();
  }

  throw new Error(ERR_DATA);
}
},{"@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js","../../javascript-utils/is-type":"node_modules/@loaders.gl/core/dist/esm/javascript-utils/is-type.js","../../iterators/make-iterator/make-iterator":"node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-iterator.js","../utils/response-utils":"node_modules/@loaders.gl/core/dist/esm/lib/utils/response-utils.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/loader-context.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getLoaderContext = getLoaderContext;
exports.getLoadersFromContext = getLoadersFromContext;

var _optionUtils = require("./option-utils");

function getLoaderContext(context, options, previousContext = null) {
  if (previousContext) {
    return previousContext;
  }

  const resolvedContext = {
    fetch: (0, _optionUtils.getFetchFunction)(options, context),
    ...context
  };

  if (!Array.isArray(resolvedContext.loaders)) {
    resolvedContext.loaders = null;
  }

  return resolvedContext;
}

function getLoadersFromContext(loaders, context) {
  if (!context && loaders && !Array.isArray(loaders)) {
    return loaders;
  }

  let candidateLoaders;

  if (loaders) {
    candidateLoaders = Array.isArray(loaders) ? loaders : [loaders];
  }

  if (context && context.loaders) {
    const contextLoaders = Array.isArray(context.loaders) ? context.loaders : [context.loaders];
    candidateLoaders = candidateLoaders ? [...candidateLoaders, ...contextLoaders] : contextLoaders;
  }

  return candidateLoaders && candidateLoaders.length ? candidateLoaders : null;
}
},{"./option-utils":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/option-utils.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/api/parse.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parse = parse;

var _workerUtils = require("@loaders.gl/worker-utils");

var _loaderUtils = require("@loaders.gl/loader-utils");

var _normalizeLoader = require("../loader-utils/normalize-loader");

var _isType = require("../../javascript-utils/is-type");

var _optionUtils = require("../loader-utils/option-utils");

var _getData = require("../loader-utils/get-data");

var _loaderContext = require("../loader-utils/loader-context");

var _resourceUtils = require("../utils/resource-utils");

var _selectLoader = require("./select-loader");

async function parse(data, loaders, options, context) {
  (0, _workerUtils.assert)(!context || typeof context === 'object');

  if (loaders && !Array.isArray(loaders) && !(0, _normalizeLoader.isLoaderObject)(loaders)) {
    context = undefined;
    options = loaders;
    loaders = undefined;
  }

  data = await data;
  options = options || {};
  const {
    url
  } = (0, _resourceUtils.getResourceUrlAndType)(data);
  const typedLoaders = loaders;
  const candidateLoaders = (0, _loaderContext.getLoadersFromContext)(typedLoaders, context);
  const loader = await (0, _selectLoader.selectLoader)(data, candidateLoaders, options);

  if (!loader) {
    return null;
  }

  options = (0, _optionUtils.normalizeOptions)(options, loader, candidateLoaders, url);
  context = (0, _loaderContext.getLoaderContext)({
    url,
    parse,
    loaders: candidateLoaders
  }, options, context);
  return await parseWithLoader(loader, data, options, context);
}

async function parseWithLoader(loader, data, options, context) {
  (0, _workerUtils.validateWorkerVersion)(loader);

  if ((0, _isType.isResponse)(data)) {
    const response = data;
    const {
      ok,
      redirected,
      status,
      statusText,
      type,
      url
    } = response;
    const headers = Object.fromEntries(response.headers.entries());
    context.response = {
      headers,
      ok,
      redirected,
      status,
      statusText,
      type,
      url
    };
  }

  data = await (0, _getData.getArrayBufferOrStringFromData)(data, loader, options);

  if (loader.parseTextSync && typeof data === 'string') {
    options.dataType = 'text';
    return loader.parseTextSync(data, options, context, loader);
  }

  if ((0, _loaderUtils.canParseWithWorker)(loader, options)) {
    return await (0, _loaderUtils.parseWithWorker)(loader, data, options, context, parse);
  }

  if (loader.parseText && typeof data === 'string') {
    return await loader.parseText(data, options, context, loader);
  }

  if (loader.parse) {
    return await loader.parse(data, options, context, loader);
  }

  (0, _workerUtils.assert)(!loader.parseSync);
  throw new Error("".concat(loader.id, " loader - no parser found and worker is disabled"));
}
},{"@loaders.gl/worker-utils":"node_modules/@loaders.gl/worker-utils/dist/esm/index.js","@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js","../loader-utils/normalize-loader":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/normalize-loader.js","../../javascript-utils/is-type":"node_modules/@loaders.gl/core/dist/esm/javascript-utils/is-type.js","../loader-utils/option-utils":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/option-utils.js","../loader-utils/get-data":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/get-data.js","../loader-utils/loader-context":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/loader-context.js","../utils/resource-utils":"node_modules/@loaders.gl/core/dist/esm/lib/utils/resource-utils.js","./select-loader":"node_modules/@loaders.gl/core/dist/esm/lib/api/select-loader.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/api/parse-sync.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseSync = parseSync;

var _loaderUtils = require("@loaders.gl/loader-utils");

var _selectLoader = require("./select-loader");

var _normalizeLoader = require("../loader-utils/normalize-loader");

var _optionUtils = require("../loader-utils/option-utils");

var _getData = require("../loader-utils/get-data");

var _loaderContext = require("../loader-utils/loader-context");

var _resourceUtils = require("../utils/resource-utils");

function parseSync(data, loaders, options, context) {
  (0, _loaderUtils.assert)(!context || typeof context === 'object');

  if (!Array.isArray(loaders) && !(0, _normalizeLoader.isLoaderObject)(loaders)) {
    context = undefined;
    options = loaders;
    loaders = undefined;
  }

  options = options || {};
  const typedLoaders = loaders;
  const candidateLoaders = (0, _loaderContext.getLoadersFromContext)(typedLoaders, context);
  const loader = (0, _selectLoader.selectLoaderSync)(data, candidateLoaders, options);

  if (!loader) {
    return null;
  }

  options = (0, _optionUtils.normalizeOptions)(options, loader, candidateLoaders);
  const {
    url
  } = (0, _resourceUtils.getResourceUrlAndType)(data);

  const parse = () => {
    throw new Error('parseSync called parse');
  };

  context = (0, _loaderContext.getLoaderContext)({
    url,
    parseSync,
    parse,
    loaders: loaders
  }, options);
  return parseWithLoaderSync(loader, data, options, context);
}

function parseWithLoaderSync(loader, data, options, context) {
  data = (0, _getData.getArrayBufferOrStringFromDataSync)(data, loader, options);

  if (loader.parseTextSync && typeof data === 'string') {
    return loader.parseTextSync(data, options);
  }

  if (loader.parseSync && data instanceof ArrayBuffer) {
    return loader.parseSync(data, options, context);
  }

  throw new Error("".concat(loader.name, " loader: 'parseSync' not supported by this loader, use 'parse' instead. ").concat(context.url || ''));
}
},{"@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js","./select-loader":"node_modules/@loaders.gl/core/dist/esm/lib/api/select-loader.js","../loader-utils/normalize-loader":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/normalize-loader.js","../loader-utils/option-utils":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/option-utils.js","../loader-utils/get-data":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/get-data.js","../loader-utils/loader-context":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/loader-context.js","../utils/resource-utils":"node_modules/@loaders.gl/core/dist/esm/lib/utils/resource-utils.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/api/parse-in-batches.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseInBatches = parseInBatches;

var _loaderUtils = require("@loaders.gl/loader-utils");

var _normalizeLoader = require("../loader-utils/normalize-loader");

var _optionUtils = require("../loader-utils/option-utils");

var _loaderContext = require("../loader-utils/loader-context");

var _getData = require("../loader-utils/get-data");

var _resourceUtils = require("../utils/resource-utils");

var _selectLoader = require("./select-loader");

var _parse = require("./parse");

async function parseInBatches(data, loaders, options, context) {
  (0, _loaderUtils.assert)(!context || typeof context === 'object');

  if (!Array.isArray(loaders) && !(0, _normalizeLoader.isLoaderObject)(loaders)) {
    context = undefined;
    options = loaders;
    loaders = undefined;
  }

  data = await data;
  options = options || {};
  const {
    url
  } = (0, _resourceUtils.getResourceUrlAndType)(data);
  const loader = await (0, _selectLoader.selectLoader)(data, loaders, options);

  if (!loader) {
    return null;
  }

  options = (0, _optionUtils.normalizeOptions)(options, loader, loaders, url);
  context = (0, _loaderContext.getLoaderContext)({
    url,
    parseInBatches,
    parse: _parse.parse,
    loaders: loaders
  }, options, context);
  return await parseWithLoaderInBatches(loader, data, options, context);
}

async function parseWithLoaderInBatches(loader, data, options, context) {
  const outputIterator = await parseToOutputIterator(loader, data, options, context);

  if (!options.metadata) {
    return outputIterator;
  }

  const metadataBatch = {
    batchType: 'metadata',
    metadata: {
      _loader: loader,
      _context: context
    },
    data: [],
    bytesUsed: 0
  };

  async function* makeMetadataBatchIterator(iterator) {
    yield metadataBatch;
    yield* iterator;
  }

  return makeMetadataBatchIterator(outputIterator);
}

async function parseToOutputIterator(loader, data, options, context) {
  const inputIterator = await (0, _getData.getAsyncIterableFromData)(data, options);
  const transformedIterator = await applyInputTransforms(inputIterator, (options === null || options === void 0 ? void 0 : options.transforms) || []);

  if (loader.parseInBatches) {
    return loader.parseInBatches(transformedIterator, options, context);
  }

  async function* parseChunkInBatches() {
    const arrayBuffer = await (0, _loaderUtils.concatenateArrayBuffersAsync)(transformedIterator);
    const parsedData = await (0, _parse.parse)(arrayBuffer, loader, { ...options,
      mimeType: loader.mimeTypes[0]
    }, context);
    const batch = {
      mimeType: loader.mimeTypes[0],
      shape: Array.isArray(parsedData) ? 'row-table' : 'unknown',
      batchType: 'data',
      data: parsedData,
      length: Array.isArray(parsedData) ? parsedData.length : 1
    };
    yield batch;
  }

  return parseChunkInBatches();
}

async function applyInputTransforms(inputIterator, transforms = []) {
  let iteratorChain = inputIterator;

  for await (const transformBatches of transforms) {
    iteratorChain = transformBatches(iteratorChain);
  }

  return iteratorChain;
}
},{"@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js","../loader-utils/normalize-loader":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/normalize-loader.js","../loader-utils/option-utils":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/option-utils.js","../loader-utils/loader-context":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/loader-context.js","../loader-utils/get-data":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/get-data.js","../utils/resource-utils":"node_modules/@loaders.gl/core/dist/esm/lib/utils/resource-utils.js","./select-loader":"node_modules/@loaders.gl/core/dist/esm/lib/api/select-loader.js","./parse":"node_modules/@loaders.gl/core/dist/esm/lib/api/parse.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/api/load.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.load = load;

var _isType = require("../../javascript-utils/is-type");

var _normalizeLoader = require("../loader-utils/normalize-loader");

var _optionUtils = require("../loader-utils/option-utils");

var _parse = require("./parse");

async function load(url, loaders, options, context) {
  if (!Array.isArray(loaders) && !(0, _normalizeLoader.isLoaderObject)(loaders)) {
    context = undefined;
    options = loaders;
    loaders = undefined;
  }

  const fetch = (0, _optionUtils.getFetchFunction)(options);
  let data = url;

  if (typeof url === 'string') {
    data = await fetch(url);
  }

  if ((0, _isType.isBlob)(url)) {
    data = await fetch(url);
  }

  return await (0, _parse.parse)(data, loaders, options);
}
},{"../../javascript-utils/is-type":"node_modules/@loaders.gl/core/dist/esm/javascript-utils/is-type.js","../loader-utils/normalize-loader":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/normalize-loader.js","../loader-utils/option-utils":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/option-utils.js","./parse":"node_modules/@loaders.gl/core/dist/esm/lib/api/parse.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/api/load-in-batches.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.loadInBatches = loadInBatches;

var _normalizeLoader = require("../loader-utils/normalize-loader");

var _optionUtils = require("../loader-utils/option-utils");

var _parseInBatches = require("./parse-in-batches");

function loadInBatches(files, loaders, options, context) {
  if (!Array.isArray(loaders) && !(0, _normalizeLoader.isLoaderObject)(loaders)) {
    context = undefined;
    options = loaders;
    loaders = null;
  }

  const fetch = (0, _optionUtils.getFetchFunction)(options || {});

  if (!Array.isArray(files)) {
    return loadOneFileInBatches(files, loaders, options, fetch);
  }

  const promises = files.map(file => loadOneFileInBatches(file, loaders, options, fetch));
  return promises;
}

async function loadOneFileInBatches(file, loaders, options, fetch) {
  if (typeof file === 'string') {
    const url = file;
    const response = await fetch(url);
    return await (0, _parseInBatches.parseInBatches)(response, loaders, options);
  }

  return await (0, _parseInBatches.parseInBatches)(file, loaders, options);
}
},{"../loader-utils/normalize-loader":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/normalize-loader.js","../loader-utils/option-utils":"node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/option-utils.js","./parse-in-batches":"node_modules/@loaders.gl/core/dist/esm/lib/api/parse-in-batches.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/api/encode.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.encode = encode;
exports.encodeInBatches = encodeInBatches;
exports.encodeSync = encodeSync;
exports.encodeText = encodeText;
exports.encodeURLtoURL = encodeURLtoURL;

var _loaderUtils = require("@loaders.gl/loader-utils");

var _workerUtils = require("@loaders.gl/worker-utils");

var _writeFile = require("../fetch/write-file");

var _fetchFile = require("../fetch/fetch-file");

var _loaderOptions = require("./loader-options");

async function encode(data, writer, options) {
  const globalOptions = (0, _loaderOptions.getLoaderOptions)();
  options = { ...globalOptions,
    ...options
  };

  if ((0, _loaderUtils.canEncodeWithWorker)(writer, options)) {
    return await (0, _workerUtils.processOnWorker)(writer, data, options);
  }

  if (writer.encode) {
    return await writer.encode(data, options);
  }

  if (writer.encodeSync) {
    return writer.encodeSync(data, options);
  }

  if (writer.encodeText) {
    return new TextEncoder().encode(await writer.encodeText(data, options));
  }

  if (writer.encodeInBatches) {
    const batches = encodeInBatches(data, writer, options);
    const chunks = [];

    for await (const batch of batches) {
      chunks.push(batch);
    }

    return (0, _loaderUtils.concatenateArrayBuffers)(...chunks);
  }

  if (!_loaderUtils.isBrowser && writer.encodeURLtoURL) {
    const tmpInputFilename = getTemporaryFilename('input');
    await (0, _writeFile.writeFile)(tmpInputFilename, data);
    const tmpOutputFilename = getTemporaryFilename('output');
    const outputFilename = await encodeURLtoURL(tmpInputFilename, tmpOutputFilename, writer, options);
    const response = await (0, _fetchFile.fetchFile)(outputFilename);
    return response.arrayBuffer();
  }

  throw new Error('Writer could not encode data');
}

function encodeSync(data, writer, options) {
  if (writer.encodeSync) {
    return writer.encodeSync(data, options);
  }

  throw new Error('Writer could not synchronously encode data');
}

async function encodeText(data, writer, options) {
  if (writer.text && writer.encodeText) {
    return await writer.encodeText(data, options);
  }

  if (writer.text && (writer.encode || writer.encodeInBatches)) {
    const arrayBuffer = await encode(data, writer, options);
    return new TextDecoder().decode(arrayBuffer);
  }

  throw new Error('Writer could not encode data as text');
}

function encodeInBatches(data, writer, options) {
  if (writer.encodeInBatches) {
    const dataIterator = getIterator(data);
    return writer.encodeInBatches(dataIterator, options);
  }

  throw new Error('Writer could not encode data in batches');
}

async function encodeURLtoURL(inputUrl, outputUrl, writer, options) {
  inputUrl = (0, _loaderUtils.resolvePath)(inputUrl);
  outputUrl = (0, _loaderUtils.resolvePath)(outputUrl);

  if (_loaderUtils.isBrowser || !writer.encodeURLtoURL) {
    throw new Error();
  }

  const outputFilename = await writer.encodeURLtoURL(inputUrl, outputUrl, options);
  return outputFilename;
}

function getIterator(data) {
  const dataIterator = [{
    table: data,
    start: 0,
    end: data.length
  }];
  return dataIterator;
}

function getTemporaryFilename(filename) {
  return "/tmp/".concat(filename);
}
},{"@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js","@loaders.gl/worker-utils":"node_modules/@loaders.gl/worker-utils/dist/esm/index.js","../fetch/write-file":"node_modules/@loaders.gl/core/dist/esm/lib/fetch/write-file.js","../fetch/fetch-file":"node_modules/@loaders.gl/core/dist/esm/lib/fetch/fetch-file.js","./loader-options":"node_modules/@loaders.gl/core/dist/esm/lib/api/loader-options.js"}],"node_modules/@loaders.gl/core/dist/esm/lib/api/save.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.save = save;
exports.saveSync = saveSync;

var _encode = require("./encode");

var _writeFile = require("../fetch/write-file");

async function save(data, url, writer, options) {
  const encodedData = await (0, _encode.encode)(data, writer, options);
  return await (0, _writeFile.writeFile)(url, encodedData);
}

function saveSync(data, url, writer, options) {
  const encodedData = (0, _encode.encodeSync)(data, writer, options);
  return (0, _writeFile.writeFileSync)(url, encodedData);
}
},{"./encode":"node_modules/@loaders.gl/core/dist/esm/lib/api/encode.js","../fetch/write-file":"node_modules/@loaders.gl/core/dist/esm/lib/fetch/write-file.js"}],"node_modules/@loaders.gl/core/dist/esm/iterators/make-stream/make-dom-stream.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeStream = makeStream;

function makeStream(source, options) {
  const iterator = source[Symbol.asyncIterator] ? source[Symbol.asyncIterator]() : source[Symbol.iterator]();
  return new ReadableStream({
    type: 'bytes',

    async pull(controller) {
      try {
        const {
          done,
          value
        } = await iterator.next();

        if (done) {
          controller.close();
        } else {
          controller.enqueue(new Uint8Array(value));
        }
      } catch (error) {
        controller.error(error);
      }
    },

    async cancel() {
      var _iterator$return;

      await (iterator === null || iterator === void 0 ? void 0 : (_iterator$return = iterator.return) === null || _iterator$return === void 0 ? void 0 : _iterator$return.call(iterator));
    }

  }, {
    highWaterMark: 2 ** 24,
    ...options
  });
}
},{}],"node_modules/@loaders.gl/core/dist/esm/null-loader.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NullWorkerLoader = exports.NullLoader = void 0;
const VERSION = typeof "3.2.3" !== 'undefined' ? "3.2.3" : 'latest';
const NullWorkerLoader = {
  name: 'Null loader',
  id: 'null',
  module: 'core',
  version: VERSION,
  worker: true,
  mimeTypes: ['application/x.empty'],
  extensions: ['null'],
  tests: [() => false],
  options: {
    null: {}
  }
};
exports.NullWorkerLoader = NullWorkerLoader;

function parseSync(arrayBuffer, options, context) {
  if (!options.null.echoParameters) return null;
  context = context && JSON.parse(JSON.stringify(context));
  return {
    arrayBuffer,
    options,
    context
  };
}

const NullLoader = {
  name: 'Null loader',
  id: 'null',
  module: 'core',
  version: VERSION,
  mimeTypes: ['application/x.empty'],
  extensions: ['null'],
  parse: async (arrayBuffer, options, context) => parseSync(arrayBuffer, options, context),
  parseSync,
  parseInBatches: async function* generator(asyncIterator, options, context) {
    for await (const batch of asyncIterator) {
      yield parseSync(batch, options, context);
    }
  },
  tests: [() => false],
  options: {
    null: {
      echoParameters: false
    }
  }
};
exports.NullLoader = NullLoader;
},{}],"node_modules/@loaders.gl/core/dist/esm/lib/progress/fetch-progress.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = fetchProgress;

async function fetchProgress(response, onProgress, onDone = () => {}, onError = () => {}) {
  response = await response;

  if (!response.ok) {
    return response;
  }

  const body = response.body;

  if (!body) {
    return response;
  }

  const contentLength = response.headers.get('content-length') || 0;
  const totalBytes = contentLength && parseInt(contentLength);

  if (!(contentLength > 0)) {
    return response;
  }

  if (typeof ReadableStream === 'undefined' || !body.getReader) {
    return response;
  }

  const progressStream = new ReadableStream({
    async start(controller) {
      const reader = body.getReader();
      await read(controller, reader, 0, totalBytes, onProgress, onDone, onError);
    }

  });
  return new Response(progressStream);
}

async function read(controller, reader, loadedBytes, totalBytes, onProgress, onDone, onError) {
  try {
    const {
      done,
      value
    } = await reader.read();

    if (done) {
      onDone();
      controller.close();
      return;
    }

    loadedBytes += value.byteLength;
    const percent = Math.round(loadedBytes / totalBytes * 100);
    onProgress(percent, {
      loadedBytes,
      totalBytes
    });
    controller.enqueue(value);
    await read(controller, reader, loadedBytes, totalBytes, onProgress, onDone, onError);
  } catch (error) {
    controller.error(error);
    onError(error);
  }
}
},{}],"node_modules/@loaders.gl/core/dist/esm/lib/filesystems/browser-filesystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class BrowserFileSystem {
  constructor(files, options) {
    (0, _defineProperty2.default)(this, "_fetch", void 0);
    (0, _defineProperty2.default)(this, "files", {});
    (0, _defineProperty2.default)(this, "lowerCaseFiles", {});
    (0, _defineProperty2.default)(this, "usedFiles", {});
    this._fetch = (options === null || options === void 0 ? void 0 : options.fetch) || fetch;

    for (let i = 0; i < files.length; ++i) {
      const file = files[i];
      this.files[file.name] = file;
      this.lowerCaseFiles[file.name.toLowerCase()] = file;
      this.usedFiles[file.name] = false;
    }

    this.fetch = this.fetch.bind(this);
  }

  async fetch(path, options) {
    if (path.includes('://')) {
      return this._fetch(path, options);
    }

    const file = this.files[path];

    if (!file) {
      return new Response(path, {
        status: 400,
        statusText: 'NOT FOUND'
      });
    }

    const headers = new Headers(options === null || options === void 0 ? void 0 : options.headers);
    const range = headers.get('Range');
    const bytes = range && /bytes=($1)-($2)/.exec(range);

    if (bytes) {
      const start = parseInt(bytes[1]);
      const end = parseInt(bytes[2]);
      const data = await file.slice(start, end).arrayBuffer();
      const response = new Response(data);
      Object.defineProperty(response, 'url', {
        value: path
      });
      return response;
    }

    const response = new Response(file);
    Object.defineProperty(response, 'url', {
      value: path
    });
    return response;
  }

  async readdir(dirname) {
    const files = [];

    for (const path in this.files) {
      files.push(path);
    }

    return files;
  }

  async stat(path, options) {
    const file = this.files[path];

    if (!file) {
      throw new Error(path);
    }

    return {
      size: file.size
    };
  }

  async unlink(path) {
    delete this.files[path];
    delete this.lowerCaseFiles[path];
    this.usedFiles[path] = true;
  }

  async open(pathname, flags, mode) {
    return this.files[pathname];
  }

  async read(fd, buffer, offset = 0, length = buffer.byteLength, position = null) {
    const file = fd;
    const startPosition = 0;
    const arrayBuffer = await file.slice(startPosition, startPosition + length).arrayBuffer();
    return {
      bytesRead: length,
      buffer: arrayBuffer
    };
  }

  async close(fd) {}

  _getFile(path, used) {
    const file = this.files[path] || this.lowerCaseFiles[path];

    if (file && used) {
      this.usedFiles[path] = true;
    }

    return file;
  }

}

exports.default = BrowserFileSystem;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js"}],"node_modules/@loaders.gl/core/dist/esm/index.js":[function(require,module,exports) {
var global = arguments[3];
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "JSONLoader", {
  enumerable: true,
  get: function () {
    return _loaderUtils.JSONLoader;
  }
});
Object.defineProperty(exports, "NullLoader", {
  enumerable: true,
  get: function () {
    return _nullLoader.NullLoader;
  }
});
Object.defineProperty(exports, "NullWorkerLoader", {
  enumerable: true,
  get: function () {
    return _nullLoader.NullWorkerLoader;
  }
});
Object.defineProperty(exports, "RequestScheduler", {
  enumerable: true,
  get: function () {
    return _loaderUtils.RequestScheduler;
  }
});
Object.defineProperty(exports, "_BrowserFileSystem", {
  enumerable: true,
  get: function () {
    return _browserFilesystem.default;
  }
});
Object.defineProperty(exports, "_fetchProgress", {
  enumerable: true,
  get: function () {
    return _fetchProgress.default;
  }
});
Object.defineProperty(exports, "_unregisterLoaders", {
  enumerable: true,
  get: function () {
    return _registerLoaders._unregisterLoaders;
  }
});
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function () {
    return _loaderUtils.assert;
  }
});
Object.defineProperty(exports, "concatenateArrayBuffersAsync", {
  enumerable: true,
  get: function () {
    return _loaderUtils.concatenateArrayBuffersAsync;
  }
});
Object.defineProperty(exports, "document", {
  enumerable: true,
  get: function () {
    return _loaderUtils.document;
  }
});
Object.defineProperty(exports, "encode", {
  enumerable: true,
  get: function () {
    return _encode.encode;
  }
});
Object.defineProperty(exports, "encodeInBatches", {
  enumerable: true,
  get: function () {
    return _encode.encodeInBatches;
  }
});
Object.defineProperty(exports, "encodeSync", {
  enumerable: true,
  get: function () {
    return _encode.encodeSync;
  }
});
Object.defineProperty(exports, "encodeText", {
  enumerable: true,
  get: function () {
    return _encode.encodeText;
  }
});
Object.defineProperty(exports, "encodeURLtoURL", {
  enumerable: true,
  get: function () {
    return _encode.encodeURLtoURL;
  }
});
Object.defineProperty(exports, "fetchFile", {
  enumerable: true,
  get: function () {
    return _fetchFile.fetchFile;
  }
});
Object.defineProperty(exports, "forEach", {
  enumerable: true,
  get: function () {
    return _loaderUtils.forEach;
  }
});
Object.defineProperty(exports, "getLoaderOptions", {
  enumerable: true,
  get: function () {
    return _loaderOptions.getLoaderOptions;
  }
});
Object.defineProperty(exports, "getPathPrefix", {
  enumerable: true,
  get: function () {
    return _loaderUtils.getPathPrefix;
  }
});
Object.defineProperty(exports, "global", {
  enumerable: true,
  get: function () {
    return _loaderUtils.global;
  }
});
Object.defineProperty(exports, "isAsyncIterable", {
  enumerable: true,
  get: function () {
    return _isType.isAsyncIterable;
  }
});
Object.defineProperty(exports, "isBrowser", {
  enumerable: true,
  get: function () {
    return _loaderUtils.isBrowser;
  }
});
Object.defineProperty(exports, "isIterable", {
  enumerable: true,
  get: function () {
    return _isType.isIterable;
  }
});
Object.defineProperty(exports, "isIterator", {
  enumerable: true,
  get: function () {
    return _isType.isIterator;
  }
});
Object.defineProperty(exports, "isPromise", {
  enumerable: true,
  get: function () {
    return _isType.isPromise;
  }
});
Object.defineProperty(exports, "isPureObject", {
  enumerable: true,
  get: function () {
    return _isType.isPureObject;
  }
});
Object.defineProperty(exports, "isReadableStream", {
  enumerable: true,
  get: function () {
    return _isType.isReadableStream;
  }
});
Object.defineProperty(exports, "isResponse", {
  enumerable: true,
  get: function () {
    return _isType.isResponse;
  }
});
Object.defineProperty(exports, "isWorker", {
  enumerable: true,
  get: function () {
    return _loaderUtils.isWorker;
  }
});
Object.defineProperty(exports, "isWritableStream", {
  enumerable: true,
  get: function () {
    return _isType.isWritableStream;
  }
});
Object.defineProperty(exports, "load", {
  enumerable: true,
  get: function () {
    return _load.load;
  }
});
Object.defineProperty(exports, "loadInBatches", {
  enumerable: true,
  get: function () {
    return _loadInBatches.loadInBatches;
  }
});
Object.defineProperty(exports, "makeIterator", {
  enumerable: true,
  get: function () {
    return _makeIterator.makeIterator;
  }
});
Object.defineProperty(exports, "makeLineIterator", {
  enumerable: true,
  get: function () {
    return _loaderUtils.makeLineIterator;
  }
});
Object.defineProperty(exports, "makeNumberedLineIterator", {
  enumerable: true,
  get: function () {
    return _loaderUtils.makeNumberedLineIterator;
  }
});
Object.defineProperty(exports, "makeStream", {
  enumerable: true,
  get: function () {
    return _makeNodeStream.makeStream;
  }
});
Object.defineProperty(exports, "makeTextDecoderIterator", {
  enumerable: true,
  get: function () {
    return _loaderUtils.makeTextDecoderIterator;
  }
});
Object.defineProperty(exports, "makeTextEncoderIterator", {
  enumerable: true,
  get: function () {
    return _loaderUtils.makeTextEncoderIterator;
  }
});
Object.defineProperty(exports, "parse", {
  enumerable: true,
  get: function () {
    return _parse.parse;
  }
});
Object.defineProperty(exports, "parseInBatches", {
  enumerable: true,
  get: function () {
    return _parseInBatches.parseInBatches;
  }
});
Object.defineProperty(exports, "parseSync", {
  enumerable: true,
  get: function () {
    return _parseSync.parseSync;
  }
});
Object.defineProperty(exports, "readArrayBuffer", {
  enumerable: true,
  get: function () {
    return _readArrayBuffer.readArrayBuffer;
  }
});
Object.defineProperty(exports, "readFileSync", {
  enumerable: true,
  get: function () {
    return _readFile.readFileSync;
  }
});
Object.defineProperty(exports, "registerLoaders", {
  enumerable: true,
  get: function () {
    return _registerLoaders.registerLoaders;
  }
});
Object.defineProperty(exports, "resolvePath", {
  enumerable: true,
  get: function () {
    return _loaderUtils.resolvePath;
  }
});
Object.defineProperty(exports, "save", {
  enumerable: true,
  get: function () {
    return _save.save;
  }
});
Object.defineProperty(exports, "saveSync", {
  enumerable: true,
  get: function () {
    return _save.saveSync;
  }
});
Object.defineProperty(exports, "selectLoader", {
  enumerable: true,
  get: function () {
    return _selectLoader.selectLoader;
  }
});
Object.defineProperty(exports, "selectLoaderSync", {
  enumerable: true,
  get: function () {
    return _selectLoader.selectLoaderSync;
  }
});
Object.defineProperty(exports, "self", {
  enumerable: true,
  get: function () {
    return _loaderUtils.self;
  }
});
Object.defineProperty(exports, "setLoaderOptions", {
  enumerable: true,
  get: function () {
    return _loaderOptions.setLoaderOptions;
  }
});
Object.defineProperty(exports, "setPathPrefix", {
  enumerable: true,
  get: function () {
    return _loaderUtils.setPathPrefix;
  }
});
Object.defineProperty(exports, "window", {
  enumerable: true,
  get: function () {
    return _loaderUtils.window;
  }
});
Object.defineProperty(exports, "writeFile", {
  enumerable: true,
  get: function () {
    return _writeFile.writeFile;
  }
});
Object.defineProperty(exports, "writeFileSync", {
  enumerable: true,
  get: function () {
    return _writeFile.writeFileSync;
  }
});

var _fetchFile = require("./lib/fetch/fetch-file");

var _readArrayBuffer = require("./lib/fetch/read-array-buffer");

var _readFile = require("./lib/fetch/read-file");

var _writeFile = require("./lib/fetch/write-file");

var _loaderOptions = require("./lib/api/loader-options");

var _registerLoaders = require("./lib/api/register-loaders");

var _selectLoader = require("./lib/api/select-loader");

var _parse = require("./lib/api/parse");

var _parseSync = require("./lib/api/parse-sync");

var _parseInBatches = require("./lib/api/parse-in-batches");

var _load = require("./lib/api/load");

var _loadInBatches = require("./lib/api/load-in-batches");

var _encode = require("./lib/api/encode");

var _save = require("./lib/api/save");

var _loaderUtils = require("@loaders.gl/loader-utils");

var _makeIterator = require("./iterators/make-iterator/make-iterator");

var _makeNodeStream = require("./iterators/make-stream/make-node-stream");

var _nullLoader = require("./null-loader");

var _fetchProgress = _interopRequireDefault(require("./lib/progress/fetch-progress"));

var _browserFilesystem = _interopRequireDefault(require("./lib/filesystems/browser-filesystem"));

var _isType = require("./javascript-utils/is-type");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./lib/fetch/fetch-file":"node_modules/@loaders.gl/core/dist/esm/lib/fetch/fetch-file.js","./lib/fetch/read-array-buffer":"node_modules/@loaders.gl/core/dist/esm/lib/fetch/read-array-buffer.js","./lib/fetch/read-file":"node_modules/@loaders.gl/core/dist/esm/lib/fetch/read-file.js","./lib/fetch/write-file":"node_modules/@loaders.gl/core/dist/esm/lib/fetch/write-file.js","./lib/api/loader-options":"node_modules/@loaders.gl/core/dist/esm/lib/api/loader-options.js","./lib/api/register-loaders":"node_modules/@loaders.gl/core/dist/esm/lib/api/register-loaders.js","./lib/api/select-loader":"node_modules/@loaders.gl/core/dist/esm/lib/api/select-loader.js","./lib/api/parse":"node_modules/@loaders.gl/core/dist/esm/lib/api/parse.js","./lib/api/parse-sync":"node_modules/@loaders.gl/core/dist/esm/lib/api/parse-sync.js","./lib/api/parse-in-batches":"node_modules/@loaders.gl/core/dist/esm/lib/api/parse-in-batches.js","./lib/api/load":"node_modules/@loaders.gl/core/dist/esm/lib/api/load.js","./lib/api/load-in-batches":"node_modules/@loaders.gl/core/dist/esm/lib/api/load-in-batches.js","./lib/api/encode":"node_modules/@loaders.gl/core/dist/esm/lib/api/encode.js","./lib/api/save":"node_modules/@loaders.gl/core/dist/esm/lib/api/save.js","@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js","./iterators/make-iterator/make-iterator":"node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-iterator.js","./iterators/make-stream/make-node-stream":"node_modules/@loaders.gl/core/dist/esm/iterators/make-stream/make-dom-stream.js","./null-loader":"node_modules/@loaders.gl/core/dist/esm/null-loader.js","./lib/progress/fetch-progress":"node_modules/@loaders.gl/core/dist/esm/lib/progress/fetch-progress.js","./lib/filesystems/browser-filesystem":"node_modules/@loaders.gl/core/dist/esm/lib/filesystems/browser-filesystem.js","./javascript-utils/is-type":"node_modules/@loaders.gl/core/dist/esm/javascript-utils/is-type.js"}],"node_modules/@loaders.gl/images/dist/esm/lib/utils/version.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VERSION = void 0;
const VERSION = typeof "3.2.3" !== 'undefined' ? "3.2.3" : 'latest';
exports.VERSION = VERSION;
},{}],"node_modules/@loaders.gl/images/dist/esm/lib/category-api/image-type.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDefaultImageType = getDefaultImageType;
exports.isImageTypeSupported = isImageTypeSupported;

var _loaderUtils = require("@loaders.gl/loader-utils");

const {
  _parseImageNode
} = globalThis;
const IMAGE_SUPPORTED = typeof Image !== 'undefined';
const IMAGE_BITMAP_SUPPORTED = typeof ImageBitmap !== 'undefined';
const NODE_IMAGE_SUPPORTED = Boolean(_parseImageNode);
const DATA_SUPPORTED = _loaderUtils.isBrowser ? true : NODE_IMAGE_SUPPORTED;

function isImageTypeSupported(type) {
  switch (type) {
    case 'auto':
      return IMAGE_BITMAP_SUPPORTED || IMAGE_SUPPORTED || DATA_SUPPORTED;

    case 'imagebitmap':
      return IMAGE_BITMAP_SUPPORTED;

    case 'image':
      return IMAGE_SUPPORTED;

    case 'data':
      return DATA_SUPPORTED;

    default:
      throw new Error("@loaders.gl/images: image ".concat(type, " not supported in this environment"));
  }
}

function getDefaultImageType() {
  if (IMAGE_BITMAP_SUPPORTED) {
    return 'imagebitmap';
  }

  if (IMAGE_SUPPORTED) {
    return 'image';
  }

  if (DATA_SUPPORTED) {
    return 'data';
  }

  throw new Error('Install \'@loaders.gl/polyfills\' to parse images under Node.js');
}
},{"@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js"}],"node_modules/@loaders.gl/images/dist/esm/lib/category-api/parsed-image-api.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deleteImage = deleteImage;
exports.getImageData = getImageData;
exports.getImageSize = getImageSize;
exports.getImageType = getImageType;
exports.isImage = isImage;

function isImage(image) {
  return Boolean(getImageTypeOrNull(image));
}

function deleteImage(image) {
  switch (getImageType(image)) {
    case 'imagebitmap':
      image.close();
      break;

    default:
  }
}

function getImageType(image) {
  const format = getImageTypeOrNull(image);

  if (!format) {
    throw new Error('Not an image');
  }

  return format;
}

function getImageSize(image) {
  return getImageData(image);
}

function getImageData(image) {
  switch (getImageType(image)) {
    case 'data':
      return image;

    case 'image':
    case 'imagebitmap':
      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');

      if (!context) {
        throw new Error('getImageData');
      }

      canvas.width = image.width;
      canvas.height = image.height;
      context.drawImage(image, 0, 0);
      return context.getImageData(0, 0, image.width, image.height);

    default:
      throw new Error('getImageData');
  }
}

function getImageTypeOrNull(image) {
  if (typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
    return 'imagebitmap';
  }

  if (typeof Image !== 'undefined' && image instanceof Image) {
    return 'image';
  }

  if (image && typeof image === 'object' && image.data && image.width && image.height) {
    return 'data';
  }

  return null;
}
},{}],"node_modules/@loaders.gl/images/dist/esm/lib/parsers/svg-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getBlob = getBlob;
exports.getBlobOrSVGDataUrl = getBlobOrSVGDataUrl;
exports.isSVG = isSVG;
const SVG_DATA_URL_PATTERN = /^data:image\/svg\+xml/;
const SVG_URL_PATTERN = /\.svg((\?|#).*)?$/;

function isSVG(url) {
  return url && (SVG_DATA_URL_PATTERN.test(url) || SVG_URL_PATTERN.test(url));
}

function getBlobOrSVGDataUrl(arrayBuffer, url) {
  if (isSVG(url)) {
    const textDecoder = new TextDecoder();
    let xmlText = textDecoder.decode(arrayBuffer);

    try {
      if (typeof unescape === 'function' && typeof encodeURIComponent === 'function') {
        xmlText = unescape(encodeURIComponent(xmlText));
      }
    } catch (error) {
      throw new Error(error.message);
    }

    const src = "data:image/svg+xml;base64,".concat(btoa(xmlText));
    return src;
  }

  return getBlob(arrayBuffer, url);
}

function getBlob(arrayBuffer, url) {
  if (isSVG(url)) {
    throw new Error('SVG cannot be parsed directly to imagebitmap');
  }

  return new Blob([new Uint8Array(arrayBuffer)]);
}
},{}],"node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = parseToImage;
exports.loadToImage = loadToImage;

var _svgUtils = require("./svg-utils");

async function parseToImage(arrayBuffer, options, url) {
  const blobOrDataUrl = (0, _svgUtils.getBlobOrSVGDataUrl)(arrayBuffer, url);
  const URL = self.URL || self.webkitURL;
  const objectUrl = typeof blobOrDataUrl !== 'string' && URL.createObjectURL(blobOrDataUrl);

  try {
    return await loadToImage(objectUrl || blobOrDataUrl, options);
  } finally {
    if (objectUrl) {
      URL.revokeObjectURL(objectUrl);
    }
  }
}

async function loadToImage(url, options) {
  const image = new Image();
  image.src = url;

  if (options.image && options.image.decode && image.decode) {
    await image.decode();
    return image;
  }

  return await new Promise((resolve, reject) => {
    try {
      image.onload = () => resolve(image);

      image.onerror = err => reject(new Error("Could not load image ".concat(url, ": ").concat(err)));
    } catch (error) {
      reject(error);
    }
  });
}
},{"./svg-utils":"node_modules/@loaders.gl/images/dist/esm/lib/parsers/svg-utils.js"}],"node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image-bitmap.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = parseToImageBitmap;

var _svgUtils = require("./svg-utils");

var _parseToImage = _interopRequireDefault(require("./parse-to-image"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const EMPTY_OBJECT = {};
let imagebitmapOptionsSupported = true;

async function parseToImageBitmap(arrayBuffer, options, url) {
  let blob;

  if ((0, _svgUtils.isSVG)(url)) {
    const image = await (0, _parseToImage.default)(arrayBuffer, options, url);
    blob = image;
  } else {
    blob = (0, _svgUtils.getBlob)(arrayBuffer, url);
  }

  const imagebitmapOptions = options && options.imagebitmap;
  return await safeCreateImageBitmap(blob, imagebitmapOptions);
}

async function safeCreateImageBitmap(blob, imagebitmapOptions = null) {
  if (isEmptyObject(imagebitmapOptions) || !imagebitmapOptionsSupported) {
    imagebitmapOptions = null;
  }

  if (imagebitmapOptions) {
    try {
      return await createImageBitmap(blob, imagebitmapOptions);
    } catch (error) {
      console.warn(error);
      imagebitmapOptionsSupported = false;
    }
  }

  return await createImageBitmap(blob);
}

function isEmptyObject(object) {
  for (const key in object || EMPTY_OBJECT) {
    return false;
  }

  return true;
}
},{"./svg-utils":"node_modules/@loaders.gl/images/dist/esm/lib/parsers/svg-utils.js","./parse-to-image":"node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image.js"}],"node_modules/@loaders.gl/images/dist/esm/lib/category-api/binary-image-api.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getBinaryImageMetadata = getBinaryImageMetadata;
exports.getBmpMetadata = getBmpMetadata;
const BIG_ENDIAN = false;
const LITTLE_ENDIAN = true;

function getBinaryImageMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  return getPngMetadata(dataView) || getJpegMetadata(dataView) || getGifMetadata(dataView) || getBmpMetadata(dataView);
}

function getPngMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  const isPng = dataView.byteLength >= 24 && dataView.getUint32(0, BIG_ENDIAN) === 0x89504e47;

  if (!isPng) {
    return null;
  }

  return {
    mimeType: 'image/png',
    width: dataView.getUint32(16, BIG_ENDIAN),
    height: dataView.getUint32(20, BIG_ENDIAN)
  };
}

function getGifMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  const isGif = dataView.byteLength >= 10 && dataView.getUint32(0, BIG_ENDIAN) === 0x47494638;

  if (!isGif) {
    return null;
  }

  return {
    mimeType: 'image/gif',
    width: dataView.getUint16(6, LITTLE_ENDIAN),
    height: dataView.getUint16(8, LITTLE_ENDIAN)
  };
}

function getBmpMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  const isBmp = dataView.byteLength >= 14 && dataView.getUint16(0, BIG_ENDIAN) === 0x424d && dataView.getUint32(2, LITTLE_ENDIAN) === dataView.byteLength;

  if (!isBmp) {
    return null;
  }

  return {
    mimeType: 'image/bmp',
    width: dataView.getUint32(18, LITTLE_ENDIAN),
    height: dataView.getUint32(22, LITTLE_ENDIAN)
  };
}

function getJpegMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  const isJpeg = dataView.byteLength >= 3 && dataView.getUint16(0, BIG_ENDIAN) === 0xffd8 && dataView.getUint8(2) === 0xff;

  if (!isJpeg) {
    return null;
  }

  const {
    tableMarkers,
    sofMarkers
  } = getJpegMarkers();
  let i = 2;

  while (i + 9 < dataView.byteLength) {
    const marker = dataView.getUint16(i, BIG_ENDIAN);

    if (sofMarkers.has(marker)) {
      return {
        mimeType: 'image/jpeg',
        height: dataView.getUint16(i + 5, BIG_ENDIAN),
        width: dataView.getUint16(i + 7, BIG_ENDIAN)
      };
    }

    if (!tableMarkers.has(marker)) {
      return null;
    }

    i += 2;
    i += dataView.getUint16(i, BIG_ENDIAN);
  }

  return null;
}

function getJpegMarkers() {
  const tableMarkers = new Set([0xffdb, 0xffc4, 0xffcc, 0xffdd, 0xfffe]);

  for (let i = 0xffe0; i < 0xfff0; ++i) {
    tableMarkers.add(i);
  }

  const sofMarkers = new Set([0xffc0, 0xffc1, 0xffc2, 0xffc3, 0xffc5, 0xffc6, 0xffc7, 0xffc9, 0xffca, 0xffcb, 0xffcd, 0xffce, 0xffcf, 0xffde]);
  return {
    tableMarkers,
    sofMarkers
  };
}

function toDataView(data) {
  if (data instanceof DataView) {
    return data;
  }

  if (ArrayBuffer.isView(data)) {
    return new DataView(data.buffer);
  }

  if (data instanceof ArrayBuffer) {
    return new DataView(data);
  }

  throw new Error('toDataView');
}
},{}],"node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-node-image.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = parseToNodeImage;

var _loaderUtils = require("@loaders.gl/loader-utils");

var _binaryImageApi = require("../category-api/binary-image-api");

async function parseToNodeImage(arrayBuffer, options) {
  const {
    mimeType
  } = (0, _binaryImageApi.getBinaryImageMetadata)(arrayBuffer) || {};
  const _parseImageNode = globalThis._parseImageNode;
  (0, _loaderUtils.assert)(_parseImageNode);
  return await _parseImageNode(arrayBuffer, mimeType);
}
},{"@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js","../category-api/binary-image-api":"node_modules/@loaders.gl/images/dist/esm/lib/category-api/binary-image-api.js"}],"node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-image.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = parseImage;

var _loaderUtils = require("@loaders.gl/loader-utils");

var _imageType = require("../category-api/image-type");

var _parsedImageApi = require("../category-api/parsed-image-api");

var _parseToImage = _interopRequireDefault(require("./parse-to-image"));

var _parseToImageBitmap = _interopRequireDefault(require("./parse-to-image-bitmap"));

var _parseToNodeImage = _interopRequireDefault(require("./parse-to-node-image"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function parseImage(arrayBuffer, options, context) {
  options = options || {};
  const imageOptions = options.image || {};
  const imageType = imageOptions.type || 'auto';
  const {
    url
  } = context || {};
  const loadType = getLoadableImageType(imageType);
  let image;

  switch (loadType) {
    case 'imagebitmap':
      image = await (0, _parseToImageBitmap.default)(arrayBuffer, options, url);
      break;

    case 'image':
      image = await (0, _parseToImage.default)(arrayBuffer, options, url);
      break;

    case 'data':
      image = await (0, _parseToNodeImage.default)(arrayBuffer, options);
      break;

    default:
      (0, _loaderUtils.assert)(false);
  }

  if (imageType === 'data') {
    image = (0, _parsedImageApi.getImageData)(image);
  }

  return image;
}

function getLoadableImageType(type) {
  switch (type) {
    case 'auto':
    case 'data':
      return (0, _imageType.getDefaultImageType)();

    default:
      (0, _imageType.isImageTypeSupported)(type);
      return type;
  }
}
},{"@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js","../category-api/image-type":"node_modules/@loaders.gl/images/dist/esm/lib/category-api/image-type.js","../category-api/parsed-image-api":"node_modules/@loaders.gl/images/dist/esm/lib/category-api/parsed-image-api.js","./parse-to-image":"node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image.js","./parse-to-image-bitmap":"node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image-bitmap.js","./parse-to-node-image":"node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-node-image.js"}],"node_modules/@loaders.gl/images/dist/esm/image-loader.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._typecheckImageLoader = exports.ImageLoader = void 0;

var _version = require("./lib/utils/version");

var _parseImage = _interopRequireDefault(require("./lib/parsers/parse-image"));

var _binaryImageApi = require("./lib/category-api/binary-image-api");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const EXTENSIONS = ['png', 'jpg', 'jpeg', 'gif', 'webp', 'bmp', 'ico', 'svg'];
const MIME_TYPES = ['image/png', 'image/jpeg', 'image/gif', 'image/webp', 'image/bmp', 'image/vnd.microsoft.icon', 'image/svg+xml'];
const DEFAULT_IMAGE_LOADER_OPTIONS = {
  image: {
    type: 'auto',
    decode: true
  }
};
const ImageLoader = {
  id: 'image',
  module: 'images',
  name: 'Images',
  version: _version.VERSION,
  mimeTypes: MIME_TYPES,
  extensions: EXTENSIONS,
  parse: _parseImage.default,
  tests: [arrayBuffer => Boolean((0, _binaryImageApi.getBinaryImageMetadata)(new DataView(arrayBuffer)))],
  options: DEFAULT_IMAGE_LOADER_OPTIONS
};
exports.ImageLoader = ImageLoader;
const _typecheckImageLoader = ImageLoader;
exports._typecheckImageLoader = _typecheckImageLoader;
},{"./lib/utils/version":"node_modules/@loaders.gl/images/dist/esm/lib/utils/version.js","./lib/parsers/parse-image":"node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-image.js","./lib/category-api/binary-image-api":"node_modules/@loaders.gl/images/dist/esm/lib/category-api/binary-image-api.js"}],"node_modules/@loaders.gl/images/dist/esm/lib/encoders/encode-image.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.encodeImage = encodeImage;

var _parsedImageApi = require("../category-api/parsed-image-api");

const {
  _encodeImageNode
} = globalThis;

async function encodeImage(image, options) {
  options = options || {};
  options.image = options.image || {};
  return _encodeImageNode ? _encodeImageNode(image, {
    type: options.image.mimeType
  }) : encodeImageInBrowser(image, options);
}

let qualityParamSupported = true;

async function encodeImageInBrowser(image, options) {
  const {
    mimeType,
    jpegQuality
  } = options.image;
  const {
    width,
    height
  } = (0, _parsedImageApi.getImageSize)(image);
  const canvas = document.createElement('canvas');
  canvas.width = width;
  canvas.height = height;
  drawImageToCanvas(image, canvas);
  const blob = await new Promise(resolve => {
    if (jpegQuality && qualityParamSupported) {
      try {
        canvas.toBlob(resolve, mimeType, jpegQuality);
        return;
      } catch (error) {
        qualityParamSupported = false;
      }
    }

    canvas.toBlob(resolve, mimeType);
  });

  if (!blob) {
    throw new Error('image encoding failed');
  }

  return await blob.arrayBuffer();
}

function drawImageToCanvas(image, canvas, x = 0, y = 0) {
  if (x === 0 && y === 0 && typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
    const context = canvas.getContext('bitmaprenderer');

    if (context) {
      context.transferFromImageBitmap(image);
      return canvas;
    }
  }

  const context = canvas.getContext('2d');

  if (image.data) {
    const clampedArray = new Uint8ClampedArray(image.data);
    const imageData = new ImageData(clampedArray, image.width, image.height);
    context.putImageData(imageData, 0, 0);
    return canvas;
  }

  context.drawImage(image, 0, 0);
  return canvas;
}
},{"../category-api/parsed-image-api":"node_modules/@loaders.gl/images/dist/esm/lib/category-api/parsed-image-api.js"}],"node_modules/@loaders.gl/images/dist/esm/image-writer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ImageWriter = void 0;

var _version = require("./lib/utils/version");

var _encodeImage = require("./lib/encoders/encode-image");

const ImageWriter = {
  name: 'Images',
  id: 'image',
  module: 'images',
  version: _version.VERSION,
  extensions: ['jpeg'],
  options: {
    image: {
      mimeType: 'image/png',
      jpegQuality: null
    }
  },
  encode: _encodeImage.encodeImage
};
exports.ImageWriter = ImageWriter;
},{"./lib/utils/version":"node_modules/@loaders.gl/images/dist/esm/lib/utils/version.js","./lib/encoders/encode-image":"node_modules/@loaders.gl/images/dist/esm/lib/encoders/encode-image.js"}],"node_modules/@loaders.gl/images/dist/esm/lib/category-api/image-format.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._isImageFormatSupported = _isImageFormatSupported;

var _loaderUtils = require("@loaders.gl/loader-utils");

const NODE_FORMAT_SUPPORT = ['image/png', 'image/jpeg', 'image/gif'];
const mimeTypeSupported = {};

function _isImageFormatSupported(mimeType) {
  if (mimeTypeSupported[mimeType] === undefined) {
    mimeTypeSupported[mimeType] = checkFormatSupport(mimeType);
  }

  return mimeTypeSupported[mimeType];
}

function checkFormatSupport(mimeType) {
  switch (mimeType) {
    case 'image/webp':
      return checkWebPSupport();

    case 'image/svg':
      return _loaderUtils.isBrowser;

    default:
      if (!_loaderUtils.isBrowser) {
        const {
          _parseImageNode
        } = globalThis;
        return Boolean(_parseImageNode) && NODE_FORMAT_SUPPORT.includes(mimeType);
      }

      return true;
  }
}

function checkWebPSupport() {
  if (!_loaderUtils.isBrowser) {
    return false;
  }

  try {
    const element = document.createElement('canvas');
    return element.toDataURL('image/webp').indexOf('data:image/webp') === 0;
  } catch {
    return false;
  }
}
},{"@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js"}],"node_modules/@loaders.gl/images/dist/esm/lib/texture-api/generate-url.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateUrl = generateUrl;

var _loaderUtils = require("@loaders.gl/loader-utils");

function generateUrl(getUrl, options, urlOptions) {
  let url = getUrl;

  if (typeof getUrl === 'function') {
    url = getUrl({ ...options,
      ...urlOptions
    });
  }

  (0, _loaderUtils.assert)(typeof url === 'string');
  const {
    baseUrl
  } = options;

  if (baseUrl) {
    url = baseUrl[baseUrl.length - 1] === '/' ? "".concat(baseUrl).concat(url) : "".concat(baseUrl, "/").concat(url);
  }

  return (0, _loaderUtils.resolvePath)(url);
}
},{"@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js"}],"node_modules/@loaders.gl/images/dist/esm/lib/texture-api/async-deep-map.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.asyncDeepMap = asyncDeepMap;
exports.mapSubtree = mapSubtree;

const isObject = value => value && typeof value === 'object';

async function asyncDeepMap(tree, func, options = {}) {
  return await mapSubtree(tree, func, options);
}

async function mapSubtree(object, func, options) {
  if (Array.isArray(object)) {
    return await mapArray(object, func, options);
  }

  if (isObject(object)) {
    return await mapObject(object, func, options);
  }

  const url = object;
  return await func(url, options);
}

async function mapObject(object, func, options) {
  const promises = [];
  const values = {};

  for (const key in object) {
    const url = object[key];
    const promise = mapSubtree(url, func, options).then(value => {
      values[key] = value;
    });
    promises.push(promise);
  }

  await Promise.all(promises);
  return values;
}

async function mapArray(urlArray, func, options = {}) {
  const promises = urlArray.map(url => mapSubtree(url, func, options));
  return await Promise.all(promises);
}
},{}],"node_modules/@loaders.gl/images/dist/esm/lib/texture-api/deep-load.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deepLoad = deepLoad;
exports.shallowLoad = shallowLoad;

var _asyncDeepMap = require("./async-deep-map");

async function deepLoad(urlTree, load, options) {
  return await (0, _asyncDeepMap.asyncDeepMap)(urlTree, url => shallowLoad(url, load, options));
}

async function shallowLoad(url, load, options) {
  const response = await fetch(url, options.fetch);
  const arrayBuffer = await response.arrayBuffer();
  return await load(arrayBuffer, options);
}
},{"./async-deep-map":"node_modules/@loaders.gl/images/dist/esm/lib/texture-api/async-deep-map.js"}],"node_modules/@loaders.gl/images/dist/esm/lib/texture-api/load-image.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getImageUrls = getImageUrls;
exports.getMipLevels = getMipLevels;
exports.loadImage = loadImage;

var _loaderUtils = require("@loaders.gl/loader-utils");

var _parseImage = _interopRequireDefault(require("../parsers/parse-image"));

var _parsedImageApi = require("../category-api/parsed-image-api");

var _generateUrl = require("./generate-url");

var _deepLoad = require("./deep-load");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function loadImage(getUrl, options = {}) {
  const imageUrls = await getImageUrls(getUrl, options);
  return await (0, _deepLoad.deepLoad)(imageUrls, _parseImage.default, options);
}

async function getImageUrls(getUrl, options, urlOptions = {}) {
  const mipLevels = options && options.image && options.image.mipLevels || 0;
  return mipLevels !== 0 ? await getMipmappedImageUrls(getUrl, mipLevels, options, urlOptions) : (0, _generateUrl.generateUrl)(getUrl, options, urlOptions);
}

async function getMipmappedImageUrls(getUrl, mipLevels, options, urlOptions) {
  const urls = [];

  if (mipLevels === 'auto') {
    const url = (0, _generateUrl.generateUrl)(getUrl, options, { ...urlOptions,
      lod: 0
    });
    const image = await (0, _deepLoad.shallowLoad)(url, _parseImage.default, options);
    const {
      width,
      height
    } = (0, _parsedImageApi.getImageSize)(image);
    mipLevels = getMipLevels({
      width,
      height
    });
    urls.push(url);
  }

  (0, _loaderUtils.assert)(mipLevels > 0);

  for (let mipLevel = urls.length; mipLevel < mipLevels; ++mipLevel) {
    const url = (0, _generateUrl.generateUrl)(getUrl, options, { ...urlOptions,
      lod: mipLevel
    });
    urls.push(url);
  }

  return urls;
}

function getMipLevels({
  width,
  height
}) {
  return 1 + Math.floor(Math.log2(Math.max(width, height)));
}
},{"@loaders.gl/loader-utils":"node_modules/@loaders.gl/loader-utils/dist/esm/index.js","../parsers/parse-image":"node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-image.js","../category-api/parsed-image-api":"node_modules/@loaders.gl/images/dist/esm/lib/category-api/parsed-image-api.js","./generate-url":"node_modules/@loaders.gl/images/dist/esm/lib/texture-api/generate-url.js","./deep-load":"node_modules/@loaders.gl/images/dist/esm/lib/texture-api/deep-load.js"}],"node_modules/@loaders.gl/images/dist/esm/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "ImageLoader", {
  enumerable: true,
  get: function () {
    return _imageLoader.ImageLoader;
  }
});
Object.defineProperty(exports, "ImageWriter", {
  enumerable: true,
  get: function () {
    return _imageWriter.ImageWriter;
  }
});
Object.defineProperty(exports, "_isImageFormatSupported", {
  enumerable: true,
  get: function () {
    return _imageFormat._isImageFormatSupported;
  }
});
Object.defineProperty(exports, "getBinaryImageMetadata", {
  enumerable: true,
  get: function () {
    return _binaryImageApi.getBinaryImageMetadata;
  }
});
Object.defineProperty(exports, "getDefaultImageType", {
  enumerable: true,
  get: function () {
    return _imageType.getDefaultImageType;
  }
});
Object.defineProperty(exports, "getImageData", {
  enumerable: true,
  get: function () {
    return _parsedImageApi.getImageData;
  }
});
Object.defineProperty(exports, "getImageSize", {
  enumerable: true,
  get: function () {
    return _parsedImageApi.getImageSize;
  }
});
Object.defineProperty(exports, "getImageType", {
  enumerable: true,
  get: function () {
    return _parsedImageApi.getImageType;
  }
});
Object.defineProperty(exports, "isImage", {
  enumerable: true,
  get: function () {
    return _parsedImageApi.isImage;
  }
});
Object.defineProperty(exports, "isImageTypeSupported", {
  enumerable: true,
  get: function () {
    return _imageType.isImageTypeSupported;
  }
});
Object.defineProperty(exports, "loadImage", {
  enumerable: true,
  get: function () {
    return _loadImage.loadImage;
  }
});

var _imageLoader = require("./image-loader");

var _imageWriter = require("./image-writer");

var _binaryImageApi = require("./lib/category-api/binary-image-api");

var _imageType = require("./lib/category-api/image-type");

var _parsedImageApi = require("./lib/category-api/parsed-image-api");

var _imageFormat = require("./lib/category-api/image-format");

var _loadImage = require("./lib/texture-api/load-image");
},{"./image-loader":"node_modules/@loaders.gl/images/dist/esm/image-loader.js","./image-writer":"node_modules/@loaders.gl/images/dist/esm/image-writer.js","./lib/category-api/binary-image-api":"node_modules/@loaders.gl/images/dist/esm/lib/category-api/binary-image-api.js","./lib/category-api/image-type":"node_modules/@loaders.gl/images/dist/esm/lib/category-api/image-type.js","./lib/category-api/parsed-image-api":"node_modules/@loaders.gl/images/dist/esm/lib/category-api/parsed-image-api.js","./lib/category-api/image-format":"node_modules/@loaders.gl/images/dist/esm/lib/category-api/image-format.js","./lib/texture-api/load-image":"node_modules/@loaders.gl/images/dist/esm/lib/texture-api/load-image.js"}],"node_modules/@deck.gl/core/dist/esm/utils/log.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _log = require("@probe.gl/log");

var _default = new _log.Log({
  id: 'deck'
});

exports.default = _default;
},{"@probe.gl/log":"node_modules/@probe.gl/log/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/debug/loggers.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getLoggers = void 0;
const logState = {
  attributeUpdateMessages: []
};
const LOG_LEVEL_MAJOR_UPDATE = 1;
const LOG_LEVEL_MINOR_UPDATE = 2;
const LOG_LEVEL_UPDATE_DETAIL = 3;
const LOG_LEVEL_INFO = 4;
const LOG_LEVEL_DRAW = 2;

const getLoggers = log => ({
  'layer.changeFlag': (layer, key, flags) => {
    log.log(LOG_LEVEL_UPDATE_DETAIL, "".concat(layer.id, " ").concat(key, ": "), flags[key])();
  },
  'layer.initialize': layer => {
    log.log(LOG_LEVEL_MAJOR_UPDATE, "Initializing ".concat(layer))();
  },
  'layer.update': (layer, needsUpdate) => {
    if (needsUpdate) {
      const flags = layer.getChangeFlags();
      log.log(LOG_LEVEL_MINOR_UPDATE, "Updating ".concat(layer, " because: ").concat(Object.keys(flags).filter(key => flags[key]).join(', ')))();
    } else {
      log.log(LOG_LEVEL_INFO, "".concat(layer, " does not need update"))();
    }
  },
  'layer.matched': (layer, changed) => {
    if (changed) {
      log.log(LOG_LEVEL_INFO, "Matched ".concat(layer, ", state transfered"))();
    }
  },
  'layer.finalize': layer => {
    log.log(LOG_LEVEL_MAJOR_UPDATE, "Finalizing ".concat(layer))();
  },
  'compositeLayer.renderLayers': (layer, updated, subLayers) => {
    if (updated) {
      log.log(LOG_LEVEL_MINOR_UPDATE, "Composite layer rendered new subLayers ".concat(layer), subLayers)();
    } else {
      log.log(LOG_LEVEL_INFO, "Composite layer reused subLayers ".concat(layer), subLayers)();
    }
  },
  'layerManager.setLayers': (layerManager, updated, layers) => {
    if (updated) {
      log.log(LOG_LEVEL_MINOR_UPDATE, "Updating ".concat(layers.length, " deck layers"))();
    }
  },
  'layerManager.activateViewport': (layerManager, viewport) => {
    log.log(LOG_LEVEL_UPDATE_DETAIL, 'Viewport changed', viewport)();
  },
  'attributeManager.invalidate': (attributeManager, trigger, attributeNames) => {
    log.log(LOG_LEVEL_MAJOR_UPDATE, attributeNames ? "invalidated attributes ".concat(attributeNames, " (").concat(trigger, ") for ").concat(attributeManager.id) : "invalidated all attributes for ".concat(attributeManager.id))();
  },
  'attributeManager.updateStart': attributeManager => {
    logState.attributeUpdateMessages.length = 0;
    logState.attributeManagerUpdateStart = Date.now();
  },
  'attributeManager.updateEnd': (attributeManager, numInstances) => {
    const timeMs = Math.round(Date.now() - logState.attributeManagerUpdateStart);
    log.groupCollapsed(LOG_LEVEL_MINOR_UPDATE, "Updated attributes for ".concat(numInstances, " instances in ").concat(attributeManager.id, " in ").concat(timeMs, "ms"))();

    for (const updateMessage of logState.attributeUpdateMessages) {
      log.log(LOG_LEVEL_UPDATE_DETAIL, updateMessage)();
    }

    log.groupEnd(LOG_LEVEL_MINOR_UPDATE)();
  },
  'attribute.updateStart': attribute => {
    logState.attributeUpdateStart = Date.now();
  },
  'attribute.allocate': (attribute, numInstances) => {
    const message = "".concat(attribute.id, " allocated ").concat(numInstances);
    logState.attributeUpdateMessages.push(message);
  },
  'attribute.updateEnd': (attribute, numInstances) => {
    const timeMs = Math.round(Date.now() - logState.attributeUpdateStart);
    const message = "".concat(attribute.id, " updated ").concat(numInstances, " in ").concat(timeMs, "ms");
    logState.attributeUpdateMessages.push(message);
  },
  'deckRenderer.renderLayers': (deckRenderer, renderStats, opts) => {
    const {
      pass,
      redrawReason,
      stats
    } = opts;

    for (const status of renderStats) {
      const {
        totalCount,
        visibleCount,
        compositeCount,
        pickableCount
      } = status;
      const primitiveCount = totalCount - compositeCount;
      const hiddenCount = primitiveCount - visibleCount;
      log.log(LOG_LEVEL_DRAW, "RENDER #".concat(deckRenderer.renderCount, "   ").concat(visibleCount, " (of ").concat(totalCount, " layers) to ").concat(pass, " because ").concat(redrawReason, "   (").concat(hiddenCount, " hidden, ").concat(compositeCount, " composite ").concat(pickableCount, " pickable)"))();

      if (stats) {
        stats.get('Redraw Layers').add(visibleCount);
      }
    }
  }
});

exports.getLoggers = getLoggers;
},{}],"node_modules/@deck.gl/core/dist/esm/debug/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = debug;
exports.register = register;

var _log = _interopRequireDefault(require("../utils/log"));

var _loggers = require("./loggers");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

let loggers = {};

if ("development" !== 'production') {
  loggers = (0, _loggers.getLoggers)(_log.default);
}

function register(handlers) {
  loggers = handlers;
}

function debug(eventType) {
  if (_log.default.level > 0 && loggers[eventType]) {
    loggers[eventType].call(...arguments);
  }
}
},{"../utils/log":"node_modules/@deck.gl/core/dist/esm/utils/log.js","./loggers":"node_modules/@deck.gl/core/dist/esm/debug/loggers.js"}],"node_modules/@deck.gl/core/dist/esm/utils/json-loader.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function isJSON(text) {
  const firstChar = text[0];
  const lastChar = text[text.length - 1];
  return firstChar === '{' && lastChar === '}' || firstChar === '[' && lastChar === ']';
}

var _default = {
  name: 'JSON',
  extensions: ['json', 'geojson'],
  mimeTypes: ['application/json', 'application/geo+json'],
  testText: isJSON,
  parseTextSync: JSON.parse
};
exports.default = _default;
},{}],"node_modules/@deck.gl/core/dist/esm/lib/init.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _core = require("@loaders.gl/core");

var _images = require("@loaders.gl/images");

var _log = _interopRequireDefault(require("../utils/log"));

var _debug = require("../debug");

var _jsonLoader = _interopRequireDefault(require("../utils/json-loader"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const version = typeof "8.7.10" !== 'undefined' ? "8.7.10" : globalThis.DECK_VERSION || 'untranspiled source';
const existingVersion = globalThis.deck && globalThis.deck.VERSION;

if (existingVersion && existingVersion !== version) {
  throw new Error("deck.gl - multiple versions detected: ".concat(existingVersion, " vs ").concat(version));
}

if (!existingVersion) {
  _log.default.log(1, "deck.gl ".concat(version))();

  globalThis.deck = { ...globalThis.deck,
    VERSION: version,
    version,
    log: _log.default,
    _registerLoggers: _debug.register
  };
  (0, _core.registerLoaders)([_jsonLoader.default, [_images.ImageLoader, {
    imagebitmap: {
      premultiplyAlpha: 'none'
    }
  }]]);
}

var _default = globalThis.deck;
exports.default = _default;
},{"@loaders.gl/core":"node_modules/@loaders.gl/core/dist/esm/index.js","@loaders.gl/images":"node_modules/@loaders.gl/images/dist/esm/index.js","../utils/log":"node_modules/@deck.gl/core/dist/esm/utils/log.js","../debug":"node_modules/@deck.gl/core/dist/esm/debug/index.js","../utils/json-loader":"node_modules/@deck.gl/core/dist/esm/utils/json-loader.js"}],"node_modules/@luma.gl/gltools/dist/esm/utils/log.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.log = void 0;

var _probe = require("probe.gl");

const log = new _probe.Log({
  id: 'luma.gl'
});
exports.log = log;
},{"probe.gl":"node_modules/probe.gl/dist/esm/index.js"}],"node_modules/@luma.gl/gltools/dist/esm/utils/assert.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assert = assert;

function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'luma.gl: assertion failed.');
  }
}
},{}],"node_modules/@luma.gl/gltools/dist/esm/utils/webgl-checks.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ERR_WEBGL2 = exports.ERR_WEBGL = void 0;
exports.assertWebGL2Context = assertWebGL2Context;
exports.assertWebGLContext = assertWebGLContext;
exports.getWebGL2Context = getWebGL2Context;
exports.isWebGL = isWebGL;
exports.isWebGL2 = isWebGL2;

var _assert = require("./assert");

const ERR_CONTEXT = 'Invalid WebGLRenderingContext';
const ERR_WEBGL = ERR_CONTEXT;
exports.ERR_WEBGL = ERR_WEBGL;
const ERR_WEBGL2 = 'Requires WebGL2';
exports.ERR_WEBGL2 = ERR_WEBGL2;

function isWebGL(gl) {
  if (typeof WebGLRenderingContext !== 'undefined' && gl instanceof WebGLRenderingContext) {
    return true;
  }

  if (typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext) {
    return true;
  }

  return Boolean(gl && Number.isFinite(gl._version));
}

function isWebGL2(gl) {
  if (typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext) {
    return true;
  }

  return Boolean(gl && gl._version === 2);
}

function getWebGL2Context(gl) {
  return isWebGL2(gl) ? gl : null;
}

function assertWebGLContext(gl) {
  (0, _assert.assert)(isWebGL(gl), ERR_CONTEXT);
  return gl;
}

function assertWebGL2Context(gl) {
  (0, _assert.assert)(isWebGL2(gl), ERR_WEBGL2);
  return gl;
}
},{"./assert":"node_modules/@luma.gl/gltools/dist/esm/utils/assert.js"}],"node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-vertex-array-object.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.polyfillVertexArrayObject = polyfillVertexArrayObject;
const glErrorShadow = {};

function error(msg) {
  if (globalThis.console && globalThis.console.error) {
    globalThis.console.error(msg);
  }
}

function log(msg) {
  if (globalThis.console && globalThis.console.log) {
    globalThis.console.log(msg);
  }
}

function synthesizeGLError(err, opt_msg) {
  glErrorShadow[err] = true;

  if (opt_msg !== undefined) {
    error(opt_msg);
  }
}

function wrapGLError(gl) {
  const f = gl.getError;

  gl.getError = function getError() {
    let err;

    do {
      err = f.apply(gl);

      if (err !== 0) {
        glErrorShadow[err] = true;
      }
    } while (err !== 0);

    for (err in glErrorShadow) {
      if (glErrorShadow[err]) {
        delete glErrorShadow[err];
        return parseInt(err, 10);
      }
    }

    return 0;
  };
}

const WebGLVertexArrayObjectOES = function WebGLVertexArrayObjectOES(ext) {
  const gl = ext.gl;
  this.ext = ext;
  this.isAlive = true;
  this.hasBeenBound = false;
  this.elementArrayBuffer = null;
  this.attribs = new Array(ext.maxVertexAttribs);

  for (let n = 0; n < this.attribs.length; n++) {
    const attrib = new WebGLVertexArrayObjectOES.VertexAttrib(gl);
    this.attribs[n] = attrib;
  }

  this.maxAttrib = 0;
};

WebGLVertexArrayObjectOES.VertexAttrib = function VertexAttrib(gl) {
  this.enabled = false;
  this.buffer = null;
  this.size = 4;
  this.type = 5126;
  this.normalized = false;
  this.stride = 16;
  this.offset = 0;
  this.cached = '';
  this.recache();
};

WebGLVertexArrayObjectOES.VertexAttrib.prototype.recache = function recache() {
  this.cached = [this.size, this.type, this.normalized, this.stride, this.offset].join(':');
};

const OESVertexArrayObject = function OESVertexArrayObject(gl) {
  const self = this;
  this.gl = gl;
  wrapGLError(gl);
  const original = this.original = {
    getParameter: gl.getParameter,
    enableVertexAttribArray: gl.enableVertexAttribArray,
    disableVertexAttribArray: gl.disableVertexAttribArray,
    bindBuffer: gl.bindBuffer,
    getVertexAttrib: gl.getVertexAttrib,
    vertexAttribPointer: gl.vertexAttribPointer
  };

  gl.getParameter = function getParameter(pname) {
    if (pname === self.VERTEX_ARRAY_BINDING_OES) {
      if (self.currentVertexArrayObject === self.defaultVertexArrayObject) {
        return null;
      }

      return self.currentVertexArrayObject;
    }

    return original.getParameter.apply(this, arguments);
  };

  gl.enableVertexAttribArray = function enableVertexAttribArray(index) {
    const vao = self.currentVertexArrayObject;
    vao.maxAttrib = Math.max(vao.maxAttrib, index);
    const attrib = vao.attribs[index];
    attrib.enabled = true;
    return original.enableVertexAttribArray.apply(this, arguments);
  };

  gl.disableVertexAttribArray = function disableVertexAttribArray(index) {
    const vao = self.currentVertexArrayObject;
    vao.maxAttrib = Math.max(vao.maxAttrib, index);
    const attrib = vao.attribs[index];
    attrib.enabled = false;
    return original.disableVertexAttribArray.apply(this, arguments);
  };

  gl.bindBuffer = function bindBuffer(target, buffer) {
    switch (target) {
      case 34962:
        self.currentArrayBuffer = buffer;
        break;

      case 34963:
        self.currentVertexArrayObject.elementArrayBuffer = buffer;
        break;

      default:
    }

    return original.bindBuffer.apply(this, arguments);
  };

  gl.getVertexAttrib = function getVertexAttrib(index, pname) {
    const vao = self.currentVertexArrayObject;
    const attrib = vao.attribs[index];

    switch (pname) {
      case 34975:
        return attrib.buffer;

      case 34338:
        return attrib.enabled;

      case 34339:
        return attrib.size;

      case 34340:
        return attrib.stride;

      case 34341:
        return attrib.type;

      case 34922:
        return attrib.normalized;

      default:
        return original.getVertexAttrib.apply(this, arguments);
    }
  };

  gl.vertexAttribPointer = function vertexAttribPointer(indx, size, type, normalized, stride, offset) {
    const vao = self.currentVertexArrayObject;
    vao.maxAttrib = Math.max(vao.maxAttrib, indx);
    const attrib = vao.attribs[indx];
    attrib.buffer = self.currentArrayBuffer;
    attrib.size = size;
    attrib.type = type;
    attrib.normalized = normalized;
    attrib.stride = stride;
    attrib.offset = offset;
    attrib.recache();
    return original.vertexAttribPointer.apply(this, arguments);
  };

  if (gl.instrumentExtension) {
    gl.instrumentExtension(this, 'OES_vertex_array_object');
  }

  if (gl.canvas) {
    gl.canvas.addEventListener('webglcontextrestored', () => {
      log('OESVertexArrayObject emulation library context restored');
      self.reset_();
    }, true);
  }

  this.reset_();
};

OESVertexArrayObject.prototype.VERTEX_ARRAY_BINDING_OES = 0x85b5;

OESVertexArrayObject.prototype.reset_ = function reset_() {
  const contextWasLost = this.vertexArrayObjects !== undefined;

  if (contextWasLost) {
    for (let ii = 0; ii < this.vertexArrayObjects.length; ++ii) {
      this.vertexArrayObjects.isAlive = false;
    }
  }

  const gl = this.gl;
  this.maxVertexAttribs = gl.getParameter(34921);
  this.defaultVertexArrayObject = new WebGLVertexArrayObjectOES(this);
  this.currentVertexArrayObject = null;
  this.currentArrayBuffer = null;
  this.vertexArrayObjects = [this.defaultVertexArrayObject];
  this.bindVertexArrayOES(null);
};

OESVertexArrayObject.prototype.createVertexArrayOES = function createVertexArrayOES() {
  const arrayObject = new WebGLVertexArrayObjectOES(this);
  this.vertexArrayObjects.push(arrayObject);
  return arrayObject;
};

OESVertexArrayObject.prototype.deleteVertexArrayOES = function deleteVertexArrayOES(arrayObject) {
  arrayObject.isAlive = false;
  this.vertexArrayObjects.splice(this.vertexArrayObjects.indexOf(arrayObject), 1);

  if (this.currentVertexArrayObject === arrayObject) {
    this.bindVertexArrayOES(null);
  }
};

OESVertexArrayObject.prototype.isVertexArrayOES = function isVertexArrayOES(arrayObject) {
  if (arrayObject && arrayObject instanceof WebGLVertexArrayObjectOES) {
    if (arrayObject.hasBeenBound && arrayObject.ext === this) {
      return true;
    }
  }

  return false;
};

OESVertexArrayObject.prototype.bindVertexArrayOES = function bindVertexArrayOES(arrayObject) {
  const gl = this.gl;

  if (arrayObject && !arrayObject.isAlive) {
    synthesizeGLError(1282, 'bindVertexArrayOES: attempt to bind deleted arrayObject');
    return;
  }

  const original = this.original;
  const oldVAO = this.currentVertexArrayObject;
  this.currentVertexArrayObject = arrayObject || this.defaultVertexArrayObject;
  this.currentVertexArrayObject.hasBeenBound = true;
  const newVAO = this.currentVertexArrayObject;

  if (oldVAO === newVAO) {
    return;
  }

  if (!oldVAO || newVAO.elementArrayBuffer !== oldVAO.elementArrayBuffer) {
    original.bindBuffer.call(gl, 34963, newVAO.elementArrayBuffer);
  }

  let currentBinding = this.currentArrayBuffer;
  const maxAttrib = Math.max(oldVAO ? oldVAO.maxAttrib : 0, newVAO.maxAttrib);

  for (let n = 0; n <= maxAttrib; n++) {
    const attrib = newVAO.attribs[n];
    const oldAttrib = oldVAO ? oldVAO.attribs[n] : null;

    if (!oldVAO || attrib.enabled !== oldAttrib.enabled) {
      if (attrib.enabled) {
        original.enableVertexAttribArray.call(gl, n);
      } else {
        original.disableVertexAttribArray.call(gl, n);
      }
    }

    if (attrib.enabled) {
      let bufferChanged = false;

      if (!oldVAO || attrib.buffer !== oldAttrib.buffer) {
        if (currentBinding !== attrib.buffer) {
          original.bindBuffer.call(gl, 34962, attrib.buffer);
          currentBinding = attrib.buffer;
        }

        bufferChanged = true;
      }

      if (bufferChanged || attrib.cached !== oldAttrib.cached) {
        original.vertexAttribPointer.call(gl, n, attrib.size, attrib.type, attrib.normalized, attrib.stride, attrib.offset);
      }
    }
  }

  if (this.currentArrayBuffer !== currentBinding) {
    original.bindBuffer.call(gl, 34962, this.currentArrayBuffer);
  }
};

function polyfillVertexArrayObject(gl) {
  if (typeof gl.createVertexArray === 'function') {
    return;
  }

  const original_getSupportedExtensions = gl.getSupportedExtensions;

  gl.getSupportedExtensions = function getSupportedExtensions() {
    const list = original_getSupportedExtensions.call(this) || [];

    if (list.indexOf('OES_vertex_array_object') < 0) {
      list.push('OES_vertex_array_object');
    }

    return list;
  };

  const original_getExtension = gl.getExtension;

  gl.getExtension = function getExtension(name) {
    const ext = original_getExtension.call(this, name);

    if (ext) {
      return ext;
    }

    if (name !== 'OES_vertex_array_object') {
      return null;
    }

    if (!gl.__OESVertexArrayObject) {
      this.__OESVertexArrayObject = new OESVertexArrayObject(this);
    }

    return this.__OESVertexArrayObject;
  };
}
},{}],"node_modules/@luma.gl/gltools/dist/esm/polyfill/get-parameter-polyfill.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getParameterPolyfill = getParameterPolyfill;

var _webglChecks = require("../utils/webgl-checks");

const OES_element_index = 'OES_element_index';
const WEBGL_draw_buffers = 'WEBGL_draw_buffers';
const EXT_disjoint_timer_query = 'EXT_disjoint_timer_query';
const EXT_disjoint_timer_query_webgl2 = 'EXT_disjoint_timer_query_webgl2';
const EXT_texture_filter_anisotropic = 'EXT_texture_filter_anisotropic';
const WEBGL_debug_renderer_info = 'WEBGL_debug_renderer_info';
const GL_FRAGMENT_SHADER_DERIVATIVE_HINT = 0x8b8b;
const GL_DONT_CARE = 0x1100;
const GL_GPU_DISJOINT_EXT = 0x8fbb;
const GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT = 0x84ff;
const GL_UNMASKED_VENDOR_WEBGL = 0x9245;
const GL_UNMASKED_RENDERER_WEBGL = 0x9246;

const getWebGL2ValueOrZero = gl => !(0, _webglChecks.isWebGL2)(gl) ? 0 : undefined;

const WEBGL_PARAMETERS = {
  [3074]: gl => !(0, _webglChecks.isWebGL2)(gl) ? 36064 : undefined,
  [GL_FRAGMENT_SHADER_DERIVATIVE_HINT]: gl => !(0, _webglChecks.isWebGL2)(gl) ? GL_DONT_CARE : undefined,
  [35977]: getWebGL2ValueOrZero,
  [32937]: getWebGL2ValueOrZero,
  [GL_GPU_DISJOINT_EXT]: (gl, getParameter) => {
    const ext = (0, _webglChecks.isWebGL2)(gl) ? gl.getExtension(EXT_disjoint_timer_query_webgl2) : gl.getExtension(EXT_disjoint_timer_query);
    return ext && ext.GPU_DISJOINT_EXT ? getParameter(ext.GPU_DISJOINT_EXT) : 0;
  },
  [GL_UNMASKED_VENDOR_WEBGL]: (gl, getParameter) => {
    const ext = gl.getExtension(WEBGL_debug_renderer_info);
    return getParameter(ext && ext.UNMASKED_VENDOR_WEBGL || 7936);
  },
  [GL_UNMASKED_RENDERER_WEBGL]: (gl, getParameter) => {
    const ext = gl.getExtension(WEBGL_debug_renderer_info);
    return getParameter(ext && ext.UNMASKED_RENDERER_WEBGL || 7937);
  },
  [GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT]: (gl, getParameter) => {
    const ext = gl.luma.extensions[EXT_texture_filter_anisotropic];
    return ext ? getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1.0;
  },
  [32883]: getWebGL2ValueOrZero,
  [35071]: getWebGL2ValueOrZero,
  [37447]: getWebGL2ValueOrZero,
  [36063]: (gl, getParameter) => {
    if (!(0, _webglChecks.isWebGL2)(gl)) {
      const ext = gl.getExtension(WEBGL_draw_buffers);
      return ext ? getParameter(ext.MAX_COLOR_ATTACHMENTS_WEBGL) : 0;
    }

    return undefined;
  },
  [35379]: getWebGL2ValueOrZero,
  [35374]: getWebGL2ValueOrZero,
  [35377]: getWebGL2ValueOrZero,
  [34852]: gl => {
    if (!(0, _webglChecks.isWebGL2)(gl)) {
      const ext = gl.getExtension(WEBGL_draw_buffers);
      return ext ? ext.MAX_DRAW_BUFFERS_WEBGL : 0;
    }

    return undefined;
  },
  [36203]: gl => gl.getExtension(OES_element_index) ? 2147483647 : 65535,
  [33001]: gl => gl.getExtension(OES_element_index) ? 16777216 : 65535,
  [33000]: gl => 16777216,
  [37157]: getWebGL2ValueOrZero,
  [35373]: getWebGL2ValueOrZero,
  [35657]: getWebGL2ValueOrZero,
  [36183]: getWebGL2ValueOrZero,
  [37137]: getWebGL2ValueOrZero,
  [34045]: getWebGL2ValueOrZero,
  [35978]: getWebGL2ValueOrZero,
  [35979]: getWebGL2ValueOrZero,
  [35968]: getWebGL2ValueOrZero,
  [35376]: getWebGL2ValueOrZero,
  [35375]: getWebGL2ValueOrZero,
  [35659]: getWebGL2ValueOrZero,
  [37154]: getWebGL2ValueOrZero,
  [35371]: getWebGL2ValueOrZero,
  [35658]: getWebGL2ValueOrZero,
  [35076]: getWebGL2ValueOrZero,
  [35077]: getWebGL2ValueOrZero,
  [35380]: getWebGL2ValueOrZero
};

function getParameterPolyfill(gl, originalGetParameter, pname) {
  const limit = WEBGL_PARAMETERS[pname];
  const value = typeof limit === 'function' ? limit(gl, originalGetParameter, pname) : limit;
  const result = value !== undefined ? value : originalGetParameter(pname);
  return result;
}
},{"../utils/webgl-checks":"node_modules/@luma.gl/gltools/dist/esm/utils/webgl-checks.js"}],"node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-table.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WEBGL2_CONTEXT_POLYFILLS = exports.WEBGL2_CONTEXT_OVERRIDES = void 0;

var _assert = require("../utils/assert");

var _webglChecks = require("../utils/webgl-checks");

var _getParameterPolyfill = require("./get-parameter-polyfill");

const OES_vertex_array_object = 'OES_vertex_array_object';
const ANGLE_instanced_arrays = 'ANGLE_instanced_arrays';
const WEBGL_draw_buffers = 'WEBGL_draw_buffers';
const EXT_disjoint_timer_query = 'EXT_disjoint_timer_query';
const EXT_texture_filter_anisotropic = 'EXT_texture_filter_anisotropic';
const ERR_VAO_NOT_SUPPORTED = 'VertexArray requires WebGL2 or OES_vertex_array_object extension';

function getExtensionData(gl, extension) {
  return {
    webgl2: (0, _webglChecks.isWebGL2)(gl),
    ext: gl.getExtension(extension)
  };
}

const WEBGL2_CONTEXT_POLYFILLS = {
  [OES_vertex_array_object]: {
    meta: {
      suffix: 'OES'
    },
    createVertexArray: () => {
      (0, _assert.assert)(false, ERR_VAO_NOT_SUPPORTED);
    },
    deleteVertexArray: () => {},
    bindVertexArray: () => {},
    isVertexArray: () => false
  },
  [ANGLE_instanced_arrays]: {
    meta: {
      suffix: 'ANGLE'
    },

    vertexAttribDivisor(location, divisor) {
      (0, _assert.assert)(divisor === 0, 'WebGL instanced rendering not supported');
    },

    drawElementsInstanced: () => {},
    drawArraysInstanced: () => {}
  },
  [WEBGL_draw_buffers]: {
    meta: {
      suffix: 'WEBGL'
    },
    drawBuffers: () => {
      (0, _assert.assert)(false);
    }
  },
  [EXT_disjoint_timer_query]: {
    meta: {
      suffix: 'EXT'
    },
    createQuery: () => {
      (0, _assert.assert)(false);
    },
    deleteQuery: () => {
      (0, _assert.assert)(false);
    },
    beginQuery: () => {
      (0, _assert.assert)(false);
    },
    endQuery: () => {},

    getQuery(handle, pname) {
      return this.getQueryObject(handle, pname);
    },

    getQueryParameter(handle, pname) {
      return this.getQueryObject(handle, pname);
    },

    getQueryObject: () => {}
  }
};
exports.WEBGL2_CONTEXT_POLYFILLS = WEBGL2_CONTEXT_POLYFILLS;
const WEBGL2_CONTEXT_OVERRIDES = {
  readBuffer: (gl, originalFunc, attachment) => {
    if ((0, _webglChecks.isWebGL2)(gl)) {
      originalFunc(attachment);
    } else {}
  },
  getVertexAttrib: (gl, originalFunc, location, pname) => {
    const {
      webgl2,
      ext
    } = getExtensionData(gl, ANGLE_instanced_arrays);
    let result;

    switch (pname) {
      case 35069:
        result = !webgl2 ? false : undefined;
        break;

      case 35070:
        result = !webgl2 && !ext ? 0 : undefined;
        break;

      default:
    }

    return result !== undefined ? result : originalFunc(location, pname);
  },
  getProgramParameter: (gl, originalFunc, program, pname) => {
    if (!(0, _webglChecks.isWebGL2)(gl)) {
      switch (pname) {
        case 35967:
          return 35981;

        case 35971:
          return 0;

        case 35382:
          return 0;

        default:
      }
    }

    return originalFunc(program, pname);
  },
  getInternalformatParameter: (gl, originalFunc, target, format, pname) => {
    if (!(0, _webglChecks.isWebGL2)(gl)) {
      switch (pname) {
        case 32937:
          return new Int32Array([0]);

        default:
      }
    }

    return gl.getInternalformatParameter(target, format, pname);
  },

  getTexParameter(gl, originalFunc, target, pname) {
    switch (pname) {
      case 34046:
        const {
          extensions
        } = gl.luma;
        const ext = extensions[EXT_texture_filter_anisotropic];
        pname = ext && ext.TEXTURE_MAX_ANISOTROPY_EXT || 34046;
        break;

      default:
    }

    return originalFunc(target, pname);
  },

  getParameter: _getParameterPolyfill.getParameterPolyfill,

  hint(gl, originalFunc, pname, value) {
    return originalFunc(pname, value);
  }

};
exports.WEBGL2_CONTEXT_OVERRIDES = WEBGL2_CONTEXT_OVERRIDES;
},{"../utils/assert":"node_modules/@luma.gl/gltools/dist/esm/utils/assert.js","../utils/webgl-checks":"node_modules/@luma.gl/gltools/dist/esm/utils/webgl-checks.js","./get-parameter-polyfill":"node_modules/@luma.gl/gltools/dist/esm/polyfill/get-parameter-polyfill.js"}],"node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-context.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.polyfillContext = polyfillContext;

var _polyfillVertexArrayObject = require("./polyfill-vertex-array-object");

var _assert = require("../utils/assert");

var _polyfillTable = require("./polyfill-table");

function polyfillContext(gl) {
  gl.luma = gl.luma || {};
  const {
    luma
  } = gl;

  if (!luma.polyfilled) {
    (0, _polyfillVertexArrayObject.polyfillVertexArrayObject)(gl);
    initializeExtensions(gl);
    installPolyfills(gl, _polyfillTable.WEBGL2_CONTEXT_POLYFILLS);
    installOverrides(gl, {
      target: luma,
      target2: gl
    });
    luma.polyfilled = true;
  }

  return gl;
}

globalThis.polyfillContext = polyfillContext;

function initializeExtensions(gl) {
  gl.luma.extensions = {};
  const EXTENSIONS = gl.getSupportedExtensions() || [];

  for (const extension of EXTENSIONS) {
    gl.luma[extension] = gl.getExtension(extension);
  }
}

function installOverrides(gl, {
  target,
  target2
}) {
  Object.keys(_polyfillTable.WEBGL2_CONTEXT_OVERRIDES).forEach(key => {
    if (typeof _polyfillTable.WEBGL2_CONTEXT_OVERRIDES[key] === 'function') {
      const originalFunc = gl[key] ? gl[key].bind(gl) : () => {};

      const polyfill = _polyfillTable.WEBGL2_CONTEXT_OVERRIDES[key].bind(null, gl, originalFunc);

      target[key] = polyfill;
      target2[key] = polyfill;
    }
  });
}

function installPolyfills(gl, polyfills) {
  for (const extension of Object.getOwnPropertyNames(polyfills)) {
    if (extension !== 'overrides') {
      polyfillExtension(gl, {
        extension,
        target: gl.luma,
        target2: gl
      });
    }
  }
}

function polyfillExtension(gl, {
  extension,
  target,
  target2
}) {
  const defaults = _polyfillTable.WEBGL2_CONTEXT_POLYFILLS[extension];
  (0, _assert.assert)(defaults);
  const {
    meta = {}
  } = defaults;
  const {
    suffix = ''
  } = meta;
  const ext = gl.getExtension(extension);

  for (const key of Object.keys(defaults)) {
    const extKey = `${key}${suffix}`;
    let polyfill = null;

    if (key === 'meta') {} else if (typeof gl[key] === 'function') {} else if (ext && typeof ext[extKey] === 'function') {
      polyfill = (...args) => ext[extKey](...args);
    } else if (typeof defaults[key] === 'function') {
      polyfill = defaults[key].bind(target);
    }

    if (polyfill) {
      target[key] = polyfill;
      target2[key] = polyfill;
    }
  }
}
},{"./polyfill-vertex-array-object":"node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-vertex-array-object.js","../utils/assert":"node_modules/@luma.gl/gltools/dist/esm/utils/assert.js","./polyfill-table":"node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-table.js"}],"node_modules/@luma.gl/gltools/dist/esm/state-tracker/webgl-parameter-tables.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GL_PARAMETER_SETTERS = exports.GL_PARAMETER_GETTERS = exports.GL_PARAMETER_DEFAULTS = exports.GL_HOOKED_SETTERS = exports.GL_COMPOSITE_PARAMETER_SETTERS = void 0;

var _webglChecks = require("../utils/webgl-checks");

const GL_PARAMETER_DEFAULTS = {
  [3042]: false,
  [32773]: new Float32Array([0, 0, 0, 0]),
  [32777]: 32774,
  [34877]: 32774,
  [32969]: 1,
  [32968]: 0,
  [32971]: 1,
  [32970]: 0,
  [3106]: new Float32Array([0, 0, 0, 0]),
  [3107]: [true, true, true, true],
  [2884]: false,
  [2885]: 1029,
  [2929]: false,
  [2931]: 1,
  [2932]: 513,
  [2928]: new Float32Array([0, 1]),
  [2930]: true,
  [3024]: true,
  [36006]: null,
  [2886]: 2305,
  [33170]: 4352,
  [2849]: 1,
  [32823]: false,
  [32824]: 0,
  [10752]: 0,
  [32938]: 1.0,
  [32939]: false,
  [3089]: false,
  [3088]: new Int32Array([0, 0, 1024, 1024]),
  [2960]: false,
  [2961]: 0,
  [2968]: 0xffffffff,
  [36005]: 0xffffffff,
  [2962]: 519,
  [2967]: 0,
  [2963]: 0xffffffff,
  [34816]: 519,
  [36003]: 0,
  [36004]: 0xffffffff,
  [2964]: 7680,
  [2965]: 7680,
  [2966]: 7680,
  [34817]: 7680,
  [34818]: 7680,
  [34819]: 7680,
  [2978]: [0, 0, 1024, 1024],
  [3333]: 4,
  [3317]: 4,
  [37440]: false,
  [37441]: false,
  [37443]: 37444,
  [35723]: 4352,
  [36010]: null,
  [35977]: false,
  [3330]: 0,
  [3332]: 0,
  [3331]: 0,
  [3314]: 0,
  [32878]: 0,
  [3316]: 0,
  [3315]: 0,
  [32877]: 0
};
exports.GL_PARAMETER_DEFAULTS = GL_PARAMETER_DEFAULTS;

const enable = (gl, value, key) => value ? gl.enable(key) : gl.disable(key);

const hint = (gl, value, key) => gl.hint(key, value);

const pixelStorei = (gl, value, key) => gl.pixelStorei(key, value);

const drawFramebuffer = (gl, value) => {
  const target = (0, _webglChecks.isWebGL2)(gl) ? 36009 : 36160;
  return gl.bindFramebuffer(target, value);
};

const readFramebuffer = (gl, value) => {
  return gl.bindFramebuffer(36008, value);
};

function isArray(array) {
  return Array.isArray(array) || ArrayBuffer.isView(array);
}

const GL_PARAMETER_SETTERS = {
  [3042]: enable,
  [32773]: (gl, value) => gl.blendColor(...value),
  [32777]: 'blendEquation',
  [34877]: 'blendEquation',
  [32969]: 'blendFunc',
  [32968]: 'blendFunc',
  [32971]: 'blendFunc',
  [32970]: 'blendFunc',
  [3106]: (gl, value) => gl.clearColor(...value),
  [3107]: (gl, value) => gl.colorMask(...value),
  [2884]: enable,
  [2885]: (gl, value) => gl.cullFace(value),
  [2929]: enable,
  [2931]: (gl, value) => gl.clearDepth(value),
  [2932]: (gl, value) => gl.depthFunc(value),
  [2928]: (gl, value) => gl.depthRange(...value),
  [2930]: (gl, value) => gl.depthMask(value),
  [3024]: enable,
  [35723]: hint,
  [36006]: drawFramebuffer,
  [2886]: (gl, value) => gl.frontFace(value),
  [33170]: hint,
  [2849]: (gl, value) => gl.lineWidth(value),
  [32823]: enable,
  [32824]: 'polygonOffset',
  [10752]: 'polygonOffset',
  [35977]: enable,
  [32938]: 'sampleCoverage',
  [32939]: 'sampleCoverage',
  [3089]: enable,
  [3088]: (gl, value) => gl.scissor(...value),
  [2960]: enable,
  [2961]: (gl, value) => gl.clearStencil(value),
  [2968]: (gl, value) => gl.stencilMaskSeparate(1028, value),
  [36005]: (gl, value) => gl.stencilMaskSeparate(1029, value),
  [2962]: 'stencilFuncFront',
  [2967]: 'stencilFuncFront',
  [2963]: 'stencilFuncFront',
  [34816]: 'stencilFuncBack',
  [36003]: 'stencilFuncBack',
  [36004]: 'stencilFuncBack',
  [2964]: 'stencilOpFront',
  [2965]: 'stencilOpFront',
  [2966]: 'stencilOpFront',
  [34817]: 'stencilOpBack',
  [34818]: 'stencilOpBack',
  [34819]: 'stencilOpBack',
  [2978]: (gl, value) => gl.viewport(...value),
  [3333]: pixelStorei,
  [3317]: pixelStorei,
  [37440]: pixelStorei,
  [37441]: pixelStorei,
  [37443]: pixelStorei,
  [3330]: pixelStorei,
  [3332]: pixelStorei,
  [3331]: pixelStorei,
  [36010]: readFramebuffer,
  [3314]: pixelStorei,
  [32878]: pixelStorei,
  [3316]: pixelStorei,
  [3315]: pixelStorei,
  [32877]: pixelStorei,
  framebuffer: (gl, framebuffer) => {
    const handle = framebuffer && 'handle' in framebuffer ? framebuffer.handle : framebuffer;
    return gl.bindFramebuffer(36160, handle);
  },
  blend: (gl, value) => value ? gl.enable(3042) : gl.disable(3042),
  blendColor: (gl, value) => gl.blendColor(...value),
  blendEquation: (gl, args) => {
    args = isArray(args) ? args : [args, args];
    gl.blendEquationSeparate(...args);
  },
  blendFunc: (gl, args) => {
    args = isArray(args) && args.length === 2 ? [...args, ...args] : args;
    gl.blendFuncSeparate(...args);
  },
  clearColor: (gl, value) => gl.clearColor(...value),
  clearDepth: (gl, value) => gl.clearDepth(value),
  clearStencil: (gl, value) => gl.clearStencil(value),
  colorMask: (gl, value) => gl.colorMask(...value),
  cull: (gl, value) => value ? gl.enable(2884) : gl.disable(2884),
  cullFace: (gl, value) => gl.cullFace(value),
  depthTest: (gl, value) => value ? gl.enable(2929) : gl.disable(2929),
  depthFunc: (gl, value) => gl.depthFunc(value),
  depthMask: (gl, value) => gl.depthMask(value),
  depthRange: (gl, value) => gl.depthRange(...value),
  dither: (gl, value) => value ? gl.enable(3024) : gl.disable(3024),
  derivativeHint: (gl, value) => {
    gl.hint(35723, value);
  },
  frontFace: (gl, value) => gl.frontFace(value),
  mipmapHint: (gl, value) => gl.hint(33170, value),
  lineWidth: (gl, value) => gl.lineWidth(value),
  polygonOffsetFill: (gl, value) => value ? gl.enable(32823) : gl.disable(32823),
  polygonOffset: (gl, value) => gl.polygonOffset(...value),
  sampleCoverage: (gl, value) => gl.sampleCoverage(...value),
  scissorTest: (gl, value) => value ? gl.enable(3089) : gl.disable(3089),
  scissor: (gl, value) => gl.scissor(...value),
  stencilTest: (gl, value) => value ? gl.enable(2960) : gl.disable(2960),
  stencilMask: (gl, value) => {
    value = isArray(value) ? value : [value, value];
    const [mask, backMask] = value;
    gl.stencilMaskSeparate(1028, mask);
    gl.stencilMaskSeparate(1029, backMask);
  },
  stencilFunc: (gl, args) => {
    args = isArray(args) && args.length === 3 ? [...args, ...args] : args;
    const [func, ref, mask, backFunc, backRef, backMask] = args;
    gl.stencilFuncSeparate(1028, func, ref, mask);
    gl.stencilFuncSeparate(1029, backFunc, backRef, backMask);
  },
  stencilOp: (gl, args) => {
    args = isArray(args) && args.length === 3 ? [...args, ...args] : args;
    const [sfail, dpfail, dppass, backSfail, backDpfail, backDppass] = args;
    gl.stencilOpSeparate(1028, sfail, dpfail, dppass);
    gl.stencilOpSeparate(1029, backSfail, backDpfail, backDppass);
  },
  viewport: (gl, value) => gl.viewport(...value)
};
exports.GL_PARAMETER_SETTERS = GL_PARAMETER_SETTERS;

function getValue(glEnum, values, cache) {
  return values[glEnum] !== undefined ? values[glEnum] : cache[glEnum];
}

const GL_COMPOSITE_PARAMETER_SETTERS = {
  blendEquation: (gl, values, cache) => gl.blendEquationSeparate(getValue(32777, values, cache), getValue(34877, values, cache)),
  blendFunc: (gl, values, cache) => gl.blendFuncSeparate(getValue(32969, values, cache), getValue(32968, values, cache), getValue(32971, values, cache), getValue(32970, values, cache)),
  polygonOffset: (gl, values, cache) => gl.polygonOffset(getValue(32824, values, cache), getValue(10752, values, cache)),
  sampleCoverage: (gl, values, cache) => gl.sampleCoverage(getValue(32938, values, cache), getValue(32939, values, cache)),
  stencilFuncFront: (gl, values, cache) => gl.stencilFuncSeparate(1028, getValue(2962, values, cache), getValue(2967, values, cache), getValue(2963, values, cache)),
  stencilFuncBack: (gl, values, cache) => gl.stencilFuncSeparate(1029, getValue(34816, values, cache), getValue(36003, values, cache), getValue(36004, values, cache)),
  stencilOpFront: (gl, values, cache) => gl.stencilOpSeparate(1028, getValue(2964, values, cache), getValue(2965, values, cache), getValue(2966, values, cache)),
  stencilOpBack: (gl, values, cache) => gl.stencilOpSeparate(1029, getValue(34817, values, cache), getValue(34818, values, cache), getValue(34819, values, cache))
};
exports.GL_COMPOSITE_PARAMETER_SETTERS = GL_COMPOSITE_PARAMETER_SETTERS;
const GL_HOOKED_SETTERS = {
  enable: (update, capability) => update({
    [capability]: true
  }),
  disable: (update, capability) => update({
    [capability]: false
  }),
  pixelStorei: (update, pname, value) => update({
    [pname]: value
  }),
  hint: (update, pname, hint) => update({
    [pname]: hint
  }),
  bindFramebuffer: (update, target, framebuffer) => {
    switch (target) {
      case 36160:
        return update({
          [36006]: framebuffer,
          [36010]: framebuffer
        });

      case 36009:
        return update({
          [36006]: framebuffer
        });

      case 36008:
        return update({
          [36010]: framebuffer
        });

      default:
        return null;
    }
  },
  blendColor: (update, r, g, b, a) => update({
    [32773]: new Float32Array([r, g, b, a])
  }),
  blendEquation: (update, mode) => update({
    [32777]: mode,
    [34877]: mode
  }),
  blendEquationSeparate: (update, modeRGB, modeAlpha) => update({
    [32777]: modeRGB,
    [34877]: modeAlpha
  }),
  blendFunc: (update, src, dst) => update({
    [32969]: src,
    [32968]: dst,
    [32971]: src,
    [32970]: dst
  }),
  blendFuncSeparate: (update, srcRGB, dstRGB, srcAlpha, dstAlpha) => update({
    [32969]: srcRGB,
    [32968]: dstRGB,
    [32971]: srcAlpha,
    [32970]: dstAlpha
  }),
  clearColor: (update, r, g, b, a) => update({
    [3106]: new Float32Array([r, g, b, a])
  }),
  clearDepth: (update, depth) => update({
    [2931]: depth
  }),
  clearStencil: (update, s) => update({
    [2961]: s
  }),
  colorMask: (update, r, g, b, a) => update({
    [3107]: [r, g, b, a]
  }),
  cullFace: (update, mode) => update({
    [2885]: mode
  }),
  depthFunc: (update, func) => update({
    [2932]: func
  }),
  depthRange: (update, zNear, zFar) => update({
    [2928]: new Float32Array([zNear, zFar])
  }),
  depthMask: (update, mask) => update({
    [2930]: mask
  }),
  frontFace: (update, face) => update({
    [2886]: face
  }),
  lineWidth: (update, width) => update({
    [2849]: width
  }),
  polygonOffset: (update, factor, units) => update({
    [32824]: factor,
    [10752]: units
  }),
  sampleCoverage: (update, value, invert) => update({
    [32938]: value,
    [32939]: invert
  }),
  scissor: (update, x, y, width, height) => update({
    [3088]: new Int32Array([x, y, width, height])
  }),
  stencilMask: (update, mask) => update({
    [2968]: mask,
    [36005]: mask
  }),
  stencilMaskSeparate: (update, face, mask) => update({
    [face === 1028 ? 2968 : 36005]: mask
  }),
  stencilFunc: (update, func, ref, mask) => update({
    [2962]: func,
    [2967]: ref,
    [2963]: mask,
    [34816]: func,
    [36003]: ref,
    [36004]: mask
  }),
  stencilFuncSeparate: (update, face, func, ref, mask) => update({
    [face === 1028 ? 2962 : 34816]: func,
    [face === 1028 ? 2967 : 36003]: ref,
    [face === 1028 ? 2963 : 36004]: mask
  }),
  stencilOp: (update, fail, zfail, zpass) => update({
    [2964]: fail,
    [2965]: zfail,
    [2966]: zpass,
    [34817]: fail,
    [34818]: zfail,
    [34819]: zpass
  }),
  stencilOpSeparate: (update, face, fail, zfail, zpass) => update({
    [face === 1028 ? 2964 : 34817]: fail,
    [face === 1028 ? 2965 : 34818]: zfail,
    [face === 1028 ? 2966 : 34819]: zpass
  }),
  viewport: (update, x, y, width, height) => update({
    [2978]: [x, y, width, height]
  })
};
exports.GL_HOOKED_SETTERS = GL_HOOKED_SETTERS;

const isEnabled = (gl, key) => gl.isEnabled(key);

const GL_PARAMETER_GETTERS = {
  [3042]: isEnabled,
  [2884]: isEnabled,
  [2929]: isEnabled,
  [3024]: isEnabled,
  [32823]: isEnabled,
  [32926]: isEnabled,
  [32928]: isEnabled,
  [3089]: isEnabled,
  [2960]: isEnabled,
  [35977]: isEnabled
};
exports.GL_PARAMETER_GETTERS = GL_PARAMETER_GETTERS;
},{"../utils/webgl-checks":"node_modules/@luma.gl/gltools/dist/esm/utils/webgl-checks.js"}],"node_modules/@luma.gl/gltools/dist/esm/utils/utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deepArrayEqual = deepArrayEqual;
exports.isObjectEmpty = isObjectEmpty;

function isObjectEmpty(object) {
  for (const key in object) {
    return false;
  }

  return true;
}

function deepArrayEqual(x, y) {
  if (x === y) {
    return true;
  }

  const isArrayX = Array.isArray(x) || ArrayBuffer.isView(x);
  const isArrayY = Array.isArray(y) || ArrayBuffer.isView(y);

  if (isArrayX && isArrayY && x.length === y.length) {
    for (let i = 0; i < x.length; ++i) {
      if (x[i] !== y[i]) {
        return false;
      }
    }

    return true;
  }

  return false;
}
},{}],"node_modules/@luma.gl/gltools/dist/esm/state-tracker/track-context-state.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.popContextState = popContextState;
exports.pushContextState = pushContextState;
exports.trackContextState = trackContextState;

var _webglParameterTables = require("./webgl-parameter-tables");

var _unifiedParameterApi = require("./unified-parameter-api");

var _assert = require("../utils/assert");

var _utils = require("../utils/utils");

function installGetterOverride(gl, functionName) {
  const originalGetterFunc = gl[functionName].bind(gl);

  gl[functionName] = function get(...params) {
    const pname = params[0];

    if (!(pname in gl.state.cache)) {
      return originalGetterFunc(...params);
    }

    return gl.state.enable ? gl.state.cache[pname] : originalGetterFunc(...params);
  };

  Object.defineProperty(gl[functionName], 'name', {
    value: `${functionName}-from-cache`,
    configurable: false
  });
}

function installSetterSpy(gl, functionName, setter) {
  const originalSetterFunc = gl[functionName].bind(gl);

  gl[functionName] = function set(...params) {
    const {
      valueChanged,
      oldValue
    } = setter(gl.state._updateCache, ...params);

    if (valueChanged) {
      originalSetterFunc(...params);
    }

    return oldValue;
  };

  Object.defineProperty(gl[functionName], 'name', {
    value: `${functionName}-to-cache`,
    configurable: false
  });
}

function installProgramSpy(gl) {
  const originalUseProgram = gl.useProgram.bind(gl);

  gl.useProgram = function useProgramLuma(handle) {
    if (gl.state.program !== handle) {
      originalUseProgram(handle);
      gl.state.program = handle;
    }
  };
}

class GLState {
  constructor(gl, {
    copyState = false,
    log = () => {}
  } = {}) {
    this.gl = gl;
    this.program = null;
    this.stateStack = [];
    this.enable = true;
    this.cache = copyState ? (0, _unifiedParameterApi.getParameters)(gl) : Object.assign({}, _webglParameterTables.GL_PARAMETER_DEFAULTS);
    this.log = log;
    this._updateCache = this._updateCache.bind(this);
    Object.seal(this);
  }

  push(values = {}) {
    this.stateStack.push({});
  }

  pop() {
    (0, _assert.assert)(this.stateStack.length > 0);
    const oldValues = this.stateStack[this.stateStack.length - 1];
    (0, _unifiedParameterApi.setParameters)(this.gl, oldValues);
    this.stateStack.pop();
  }

  _updateCache(values) {
    let valueChanged = false;
    let oldValue;
    const oldValues = this.stateStack.length > 0 && this.stateStack[this.stateStack.length - 1];

    for (const key in values) {
      (0, _assert.assert)(key !== undefined);
      const value = values[key];
      const cached = this.cache[key];

      if (!(0, _utils.deepArrayEqual)(value, cached)) {
        valueChanged = true;
        oldValue = cached;

        if (oldValues && !(key in oldValues)) {
          oldValues[key] = cached;
        }

        this.cache[key] = value;
      }
    }

    return {
      valueChanged,
      oldValue
    };
  }

}

function trackContextState(gl, options = {}) {
  const {
    enable = true,
    copyState
  } = options;
  (0, _assert.assert)(copyState !== undefined);

  if (!gl.state) {
    const {
      polyfillContext
    } = globalThis;

    if (polyfillContext) {
      polyfillContext(gl);
    }

    gl.state = new GLState(gl, {
      copyState
    });
    installProgramSpy(gl);

    for (const key in _webglParameterTables.GL_HOOKED_SETTERS) {
      const setter = _webglParameterTables.GL_HOOKED_SETTERS[key];
      installSetterSpy(gl, key, setter);
    }

    installGetterOverride(gl, 'getParameter');
    installGetterOverride(gl, 'isEnabled');
  }

  gl.state.enable = enable;
  return gl;
}

function pushContextState(gl) {
  if (!gl.state) {
    trackContextState(gl, {
      copyState: false
    });
  }

  gl.state.push();
}

function popContextState(gl) {
  (0, _assert.assert)(gl.state);
  gl.state.pop();
}
},{"./webgl-parameter-tables":"node_modules/@luma.gl/gltools/dist/esm/state-tracker/webgl-parameter-tables.js","./unified-parameter-api":"node_modules/@luma.gl/gltools/dist/esm/state-tracker/unified-parameter-api.js","../utils/assert":"node_modules/@luma.gl/gltools/dist/esm/utils/assert.js","../utils/utils":"node_modules/@luma.gl/gltools/dist/esm/utils/utils.js"}],"node_modules/@luma.gl/gltools/dist/esm/state-tracker/unified-parameter-api.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getParameters = getParameters;
exports.resetParameters = resetParameters;
exports.setParameters = setParameters;
exports.withParameters = withParameters;

var _webglParameterTables = require("./webgl-parameter-tables");

var _trackContextState = require("./track-context-state");

var _assert = require("../utils/assert");

var _webglChecks = require("../utils/webgl-checks");

var _utils = require("../utils/utils");

function setParameters(gl, values) {
  (0, _assert.assert)((0, _webglChecks.isWebGL)(gl), 'setParameters requires a WebGL context');

  if ((0, _utils.isObjectEmpty)(values)) {
    return;
  }

  const compositeSetters = {};

  for (const key in values) {
    const glConstant = Number(key);
    const setter = _webglParameterTables.GL_PARAMETER_SETTERS[key];

    if (setter) {
      if (typeof setter === 'string') {
        compositeSetters[setter] = true;
      } else {
        setter(gl, values[key], glConstant);
      }
    }
  }

  const cache = gl.state && gl.state.cache;

  if (cache) {
    for (const key in compositeSetters) {
      const compositeSetter = _webglParameterTables.GL_COMPOSITE_PARAMETER_SETTERS[key];
      compositeSetter(gl, values, cache);
    }
  }
}

function getParameters(gl, parameters) {
  parameters = parameters || _webglParameterTables.GL_PARAMETER_DEFAULTS;

  if (typeof parameters === 'number') {
    const key = parameters;
    const getter = _webglParameterTables.GL_PARAMETER_GETTERS[key];
    return getter ? getter(gl, key) : gl.getParameter(key);
  }

  const parameterKeys = Array.isArray(parameters) ? parameters : Object.keys(parameters);
  const state = {};

  for (const key of parameterKeys) {
    const getter = _webglParameterTables.GL_PARAMETER_GETTERS[key];
    state[key] = getter ? getter(gl, Number(key)) : gl.getParameter(Number(key));
  }

  return state;
}

function resetParameters(gl) {
  setParameters(gl, _webglParameterTables.GL_PARAMETER_DEFAULTS);
}

function withParameters(gl, parameters, func) {
  if ((0, _utils.isObjectEmpty)(parameters)) {
    return func(gl);
  }

  const {
    nocatch = true
  } = parameters;
  (0, _trackContextState.pushContextState)(gl);
  setParameters(gl, parameters);
  let value;

  if (nocatch) {
    value = func(gl);
    (0, _trackContextState.popContextState)(gl);
  } else {
    try {
      value = func(gl);
    } finally {
      (0, _trackContextState.popContextState)(gl);
    }
  }

  return value;
}
},{"./webgl-parameter-tables":"node_modules/@luma.gl/gltools/dist/esm/state-tracker/webgl-parameter-tables.js","./track-context-state":"node_modules/@luma.gl/gltools/dist/esm/state-tracker/track-context-state.js","../utils/assert":"node_modules/@luma.gl/gltools/dist/esm/utils/assert.js","../utils/webgl-checks":"node_modules/@luma.gl/gltools/dist/esm/utils/webgl-checks.js","../utils/utils":"node_modules/@luma.gl/gltools/dist/esm/utils/utils.js"}],"node_modules/@luma.gl/gltools/dist/esm/utils/device-pixels.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cssToDevicePixels = cssToDevicePixels;
exports.cssToDeviceRatio = cssToDeviceRatio;
exports.getDevicePixelRatio = getDevicePixelRatio;

function cssToDeviceRatio(gl) {
  const {
    luma
  } = gl;

  if (gl.canvas && luma) {
    const {
      clientWidth
    } = luma.canvasSizeInfo;
    return clientWidth ? gl.drawingBufferWidth / clientWidth : 1;
  }

  return 1;
}

function cssToDevicePixels(gl, cssPixel, yInvert = true) {
  const ratio = cssToDeviceRatio(gl);
  const width = gl.drawingBufferWidth;
  const height = gl.drawingBufferHeight;
  return scalePixels(cssPixel, ratio, width, height, yInvert);
}

function getDevicePixelRatio(useDevicePixels) {
  const windowRatio = typeof window === 'undefined' ? 1 : window.devicePixelRatio || 1;

  if (Number.isFinite(useDevicePixels)) {
    return useDevicePixels <= 0 ? 1 : useDevicePixels;
  }

  return useDevicePixels ? windowRatio : 1;
}

function scalePixels(pixel, ratio, width, height, yInvert) {
  const x = scaleX(pixel[0], ratio, width);
  let y = scaleY(pixel[1], ratio, height, yInvert);
  let t = scaleX(pixel[0] + 1, ratio, width);
  const xHigh = t === width - 1 ? t : t - 1;
  t = scaleY(pixel[1] + 1, ratio, height, yInvert);
  let yHigh;

  if (yInvert) {
    t = t === 0 ? t : t + 1;
    yHigh = y;
    y = t;
  } else {
    yHigh = t === height - 1 ? t : t - 1;
  }

  return {
    x,
    y,
    width: Math.max(xHigh - x + 1, 1),
    height: Math.max(yHigh - y + 1, 1)
  };
}

function scaleX(x, ratio, width) {
  const r = Math.min(Math.round(x * ratio), width - 1);
  return r;
}

function scaleY(y, ratio, height, yInvert) {
  return yInvert ? Math.max(0, height - 1 - Math.round(y * ratio)) : Math.min(Math.round(y * ratio), height - 1);
}
},{}],"node_modules/@luma.gl/gltools/dist/esm/context/context.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createGLContext = createGLContext;
exports.getContextDebugInfo = getContextDebugInfo;
exports.instrumentGLContext = instrumentGLContext;
exports.resizeGLContext = resizeGLContext;

var _env = require("@probe.gl/env");

var _trackContextState = require("../state-tracker/track-context-state");

var _log = require("../utils/log");

var _assert = require("../utils/assert");

var _devicePixels = require("../utils/device-pixels");

var _webglChecks = require("../utils/webgl-checks");

const isBrowser = (0, _env.isBrowser)();
const isPage = isBrowser && typeof document !== 'undefined';
const CONTEXT_DEFAULTS = {
  webgl2: true,
  webgl1: true,
  throwOnError: true,
  manageState: true,
  canvas: null,
  debug: false,
  width: 800,
  height: 600
};

function createGLContext(options = {}) {
  (0, _assert.assert)(isBrowser, "createGLContext only available in the browser.\nCreate your own headless context or use 'createHeadlessContext' from @luma.gl/test-utils");
  options = Object.assign({}, CONTEXT_DEFAULTS, options);
  const {
    width,
    height
  } = options;

  function onError(message) {
    if (options.throwOnError) {
      throw new Error(message);
    }

    console.error(message);
    return null;
  }

  options.onError = onError;
  let gl;
  const {
    canvas
  } = options;
  const targetCanvas = getCanvas({
    canvas,
    width,
    height,
    onError
  });
  gl = createBrowserContext(targetCanvas, options);

  if (!gl) {
    return null;
  }

  gl = instrumentGLContext(gl, options);
  logInfo(gl);
  return gl;
}

function instrumentGLContext(gl, options = {}) {
  if (!gl || gl._instrumented) {
    return gl;
  }

  gl._version = gl._version || getVersion(gl);
  gl.luma = gl.luma || {};
  gl.luma.canvasSizeInfo = gl.luma.canvasSizeInfo || {};
  options = Object.assign({}, CONTEXT_DEFAULTS, options);
  const {
    manageState,
    debug
  } = options;

  if (manageState) {
    (0, _trackContextState.trackContextState)(gl, {
      copyState: false,
      log: (...args) => _log.log.log(1, ...args)()
    });
  }

  if (isBrowser && debug) {
    if (!globalThis.makeDebugContext) {
      _log.log.warn('WebGL debug mode not activated. import "@luma.gl/debug" to enable.')();
    } else {
      gl = globalThis.makeDebugContext(gl, options);
      _log.log.level = Math.max(_log.log.level, 1);
    }
  }

  gl._instrumented = true;
  return gl;
}

function getContextDebugInfo(gl) {
  const vendorMasked = gl.getParameter(7936);
  const rendererMasked = gl.getParameter(7937);
  const ext = gl.getExtension('WEBGL_debug_renderer_info');
  const vendorUnmasked = ext && gl.getParameter(ext.UNMASKED_VENDOR_WEBGL || 7936);
  const rendererUnmasked = ext && gl.getParameter(ext.UNMASKED_RENDERER_WEBGL || 7937);
  return {
    vendor: vendorUnmasked || vendorMasked,
    renderer: rendererUnmasked || rendererMasked,
    vendorMasked,
    rendererMasked,
    version: gl.getParameter(7938),
    shadingLanguageVersion: gl.getParameter(35724)
  };
}

function resizeGLContext(gl, options = {}) {
  if (gl.canvas) {
    const devicePixelRatio = (0, _devicePixels.getDevicePixelRatio)(options.useDevicePixels);
    setDevicePixelRatio(gl, devicePixelRatio, options);
    return;
  }

  const ext = gl.getExtension('STACKGL_resize_drawingbuffer');

  if (ext && `width` in options && `height` in options) {
    ext.resize(options.width, options.height);
  }
}

function createBrowserContext(canvas, options) {
  const {
    onError
  } = options;
  let errorMessage = null;

  const onCreateError = error => errorMessage = error.statusMessage || errorMessage;

  canvas.addEventListener('webglcontextcreationerror', onCreateError, false);
  const {
    webgl1 = true,
    webgl2 = true
  } = options;
  let gl = null;

  if (webgl2) {
    gl = gl || canvas.getContext('webgl2', options);
    gl = gl || canvas.getContext('experimental-webgl2', options);
  }

  if (webgl1) {
    gl = gl || canvas.getContext('webgl', options);
    gl = gl || canvas.getContext('experimental-webgl', options);
  }

  canvas.removeEventListener('webglcontextcreationerror', onCreateError, false);

  if (!gl) {
    return onError(`Failed to create ${webgl2 && !webgl1 ? 'WebGL2' : 'WebGL'} context: ${errorMessage || 'Unknown error'}`);
  }

  if (options.onContextLost) {
    canvas.addEventListener('webglcontextlost', options.onContextLost, false);
  }

  if (options.onContextRestored) {
    canvas.addEventListener('webglcontextrestored', options.onContextRestored, false);
  }

  return gl;
}

function getCanvas({
  canvas,
  width = 800,
  height = 600,
  onError
}) {
  let targetCanvas;

  if (typeof canvas === 'string') {
    const isPageLoaded = isPage && document.readyState === 'complete';

    if (!isPageLoaded) {
      onError(`createGLContext called on canvas '${canvas}' before page was loaded`);
    }

    targetCanvas = document.getElementById(canvas);
  } else if (canvas) {
    targetCanvas = canvas;
  } else {
    targetCanvas = document.createElement('canvas');
    targetCanvas.id = 'lumagl-canvas';
    targetCanvas.style.width = Number.isFinite(width) ? `${width}px` : '100%';
    targetCanvas.style.height = Number.isFinite(height) ? `${height}px` : '100%';
    document.body.insertBefore(targetCanvas, document.body.firstChild);
  }

  return targetCanvas;
}

function logInfo(gl) {
  const webGL = (0, _webglChecks.isWebGL2)(gl) ? 'WebGL2' : 'WebGL1';
  const info = getContextDebugInfo(gl);
  const driver = info ? `(${info.vendor},${info.renderer})` : '';
  const debug = gl.debug ? ' debug' : '';

  _log.log.info(1, `${webGL}${debug} context ${driver}`)();
}

function getVersion(gl) {
  if (typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext) {
    return 2;
  }

  return 1;
}

function setDevicePixelRatio(gl, devicePixelRatio, options) {
  let clientWidth = 'width' in options ? options.width : gl.canvas.clientWidth;
  let clientHeight = 'height' in options ? options.height : gl.canvas.clientHeight;

  if (!clientWidth || !clientHeight) {
    _log.log.log(1, 'Canvas clientWidth/clientHeight is 0')();

    devicePixelRatio = 1;
    clientWidth = gl.canvas.width || 1;
    clientHeight = gl.canvas.height || 1;
  }

  gl.luma = gl.luma || {};
  gl.luma.canvasSizeInfo = gl.luma.canvasSizeInfo || {};
  const cachedSize = gl.luma.canvasSizeInfo;

  if (cachedSize.clientWidth !== clientWidth || cachedSize.clientHeight !== clientHeight || cachedSize.devicePixelRatio !== devicePixelRatio) {
    let clampedPixelRatio = devicePixelRatio;
    const canvasWidth = Math.floor(clientWidth * clampedPixelRatio);
    const canvasHeight = Math.floor(clientHeight * clampedPixelRatio);
    gl.canvas.width = canvasWidth;
    gl.canvas.height = canvasHeight;

    if (gl.drawingBufferWidth !== canvasWidth || gl.drawingBufferHeight !== canvasHeight) {
      _log.log.warn(`Device pixel ratio clamped`)();

      clampedPixelRatio = Math.min(gl.drawingBufferWidth / clientWidth, gl.drawingBufferHeight / clientHeight);
      gl.canvas.width = Math.floor(clientWidth * clampedPixelRatio);
      gl.canvas.height = Math.floor(clientHeight * clampedPixelRatio);
    }

    Object.assign(gl.luma.canvasSizeInfo, {
      clientWidth,
      clientHeight,
      devicePixelRatio
    });
  }
}
},{"@probe.gl/env":"node_modules/@probe.gl/env/dist/esm/index.js","../state-tracker/track-context-state":"node_modules/@luma.gl/gltools/dist/esm/state-tracker/track-context-state.js","../utils/log":"node_modules/@luma.gl/gltools/dist/esm/utils/log.js","../utils/assert":"node_modules/@luma.gl/gltools/dist/esm/utils/assert.js","../utils/device-pixels":"node_modules/@luma.gl/gltools/dist/esm/utils/device-pixels.js","../utils/webgl-checks":"node_modules/@luma.gl/gltools/dist/esm/utils/webgl-checks.js"}],"node_modules/@luma.gl/gltools/dist/esm/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "assertWebGL2Context", {
  enumerable: true,
  get: function () {
    return _webglChecks.assertWebGL2Context;
  }
});
Object.defineProperty(exports, "assertWebGLContext", {
  enumerable: true,
  get: function () {
    return _webglChecks.assertWebGLContext;
  }
});
Object.defineProperty(exports, "createGLContext", {
  enumerable: true,
  get: function () {
    return _context.createGLContext;
  }
});
Object.defineProperty(exports, "cssToDevicePixels", {
  enumerable: true,
  get: function () {
    return _devicePixels.cssToDevicePixels;
  }
});
Object.defineProperty(exports, "cssToDeviceRatio", {
  enumerable: true,
  get: function () {
    return _devicePixels.cssToDeviceRatio;
  }
});
Object.defineProperty(exports, "getContextDebugInfo", {
  enumerable: true,
  get: function () {
    return _context.getContextDebugInfo;
  }
});
Object.defineProperty(exports, "getParameters", {
  enumerable: true,
  get: function () {
    return _unifiedParameterApi.getParameters;
  }
});
Object.defineProperty(exports, "getWebGL2Context", {
  enumerable: true,
  get: function () {
    return _webglChecks.getWebGL2Context;
  }
});
Object.defineProperty(exports, "instrumentGLContext", {
  enumerable: true,
  get: function () {
    return _context.instrumentGLContext;
  }
});
Object.defineProperty(exports, "isWebGL", {
  enumerable: true,
  get: function () {
    return _webglChecks.isWebGL;
  }
});
Object.defineProperty(exports, "isWebGL2", {
  enumerable: true,
  get: function () {
    return _webglChecks.isWebGL2;
  }
});
Object.defineProperty(exports, "log", {
  enumerable: true,
  get: function () {
    return _log.log;
  }
});
Object.defineProperty(exports, "polyfillContext", {
  enumerable: true,
  get: function () {
    return _polyfillContext.polyfillContext;
  }
});
Object.defineProperty(exports, "popContextState", {
  enumerable: true,
  get: function () {
    return _trackContextState.popContextState;
  }
});
Object.defineProperty(exports, "pushContextState", {
  enumerable: true,
  get: function () {
    return _trackContextState.pushContextState;
  }
});
Object.defineProperty(exports, "resetParameters", {
  enumerable: true,
  get: function () {
    return _unifiedParameterApi.resetParameters;
  }
});
Object.defineProperty(exports, "resizeGLContext", {
  enumerable: true,
  get: function () {
    return _context.resizeGLContext;
  }
});
Object.defineProperty(exports, "setParameters", {
  enumerable: true,
  get: function () {
    return _unifiedParameterApi.setParameters;
  }
});
Object.defineProperty(exports, "trackContextState", {
  enumerable: true,
  get: function () {
    return _trackContextState.trackContextState;
  }
});
Object.defineProperty(exports, "withParameters", {
  enumerable: true,
  get: function () {
    return _unifiedParameterApi.withParameters;
  }
});

var _log = require("./utils/log");

var _webglChecks = require("./utils/webgl-checks");

var _polyfillContext = require("./polyfill/polyfill-context");

var _unifiedParameterApi = require("./state-tracker/unified-parameter-api");

var _trackContextState = require("./state-tracker/track-context-state");

var _context = require("./context/context");

var _devicePixels = require("./utils/device-pixels");
},{"./utils/log":"node_modules/@luma.gl/gltools/dist/esm/utils/log.js","./utils/webgl-checks":"node_modules/@luma.gl/gltools/dist/esm/utils/webgl-checks.js","./polyfill/polyfill-context":"node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-context.js","./state-tracker/unified-parameter-api":"node_modules/@luma.gl/gltools/dist/esm/state-tracker/unified-parameter-api.js","./state-tracker/track-context-state":"node_modules/@luma.gl/gltools/dist/esm/state-tracker/track-context-state.js","./context/context":"node_modules/@luma.gl/gltools/dist/esm/context/context.js","./utils/device-pixels":"node_modules/@luma.gl/gltools/dist/esm/utils/device-pixels.js"}],"node_modules/@luma.gl/webgl/dist/esm/init.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.lumaStats = exports.default = void 0;

var _gltools = require("@luma.gl/gltools");

var _probe = require("probe.gl");

var _env = require("@probe.gl/env");

const VERSION = typeof "8.5.13" !== 'undefined' ? "8.5.13" : 'untranspiled source';
const STARTUP_MESSAGE = 'set luma.log.level=1 (or higher) to trace rendering';

class StatsManager {
  constructor() {
    this.stats = new Map();
  }

  get(name) {
    if (!this.stats.has(name)) {
      this.stats.set(name, new _probe.Stats({
        id: name
      }));
    }

    return this.stats.get(name);
  }

}

const lumaStats = new StatsManager();
exports.lumaStats = lumaStats;

if (globalThis.luma && globalThis.luma.VERSION !== VERSION) {
  throw new Error(`luma.gl - multiple VERSIONs detected: ${globalThis.luma.VERSION} vs ${VERSION}`);
}

if (!globalThis.luma) {
  if ((0, _env.isBrowser)()) {
    _gltools.log.log(1, `luma.gl ${VERSION} - ${STARTUP_MESSAGE}`)();
  }

  globalThis.luma = globalThis.luma || {
    VERSION,
    version: VERSION,
    log: _gltools.log,
    stats: lumaStats,
    globals: {
      modules: {},
      nodeIO: {}
    }
  };
}

var _default = globalThis.luma;
exports.default = _default;
},{"@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","probe.gl":"node_modules/probe.gl/dist/esm/index.js","@probe.gl/env":"node_modules/@probe.gl/env/dist/esm/index.js"}],"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/request-animation-frame.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cancelAnimationFrame = cancelAnimationFrame;
exports.requestAnimationFrame = requestAnimationFrame;

function requestAnimationFrame(callback) {
  return typeof window !== 'undefined' && window.requestAnimationFrame ? window.requestAnimationFrame(callback) : setTimeout(callback, 1000 / 60);
}

function cancelAnimationFrame(timerId) {
  return typeof window !== 'undefined' && window.cancelAnimationFrame ? window.cancelAnimationFrame(timerId) : clearTimeout(timerId);
}
},{}],"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assert = assert;

function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'luma.gl: assertion failed.');
  }
}
},{}],"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/constants-to-keys.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getKey = getKey;
exports.getKeyType = getKeyType;
exports.getKeyValue = getKeyValue;

var _assert = require("../utils/assert");

function getKeyValue(gl, name) {
  if (typeof name !== 'string') {
    return name;
  }

  const number = Number(name);

  if (!isNaN(number)) {
    return number;
  }

  name = name.replace(/^.*\./, '');
  const value = gl[name];
  (0, _assert.assert)(value !== undefined, `Accessing undefined constant GL.${name}`);
  return value;
}

function getKey(gl, value) {
  value = Number(value);

  for (const key in gl) {
    if (gl[key] === value) {
      return `GL.${key}`;
    }
  }

  return String(value);
}

function getKeyType(gl, value) {
  (0, _assert.assert)(value !== undefined, 'undefined key');
  value = Number(value);

  for (const key in gl) {
    if (gl[key] === value) {
      return `GL.${key}`;
    }
  }

  return String(value);
}
},{"../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js"}],"node_modules/@luma.gl/webgl/dist/esm/utils/utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isObjectEmpty = isObjectEmpty;
exports.isPowerOfTwo = isPowerOfTwo;
exports.uid = uid;

var _assert = require("./assert");

const uidCounters = {};

function uid(id = 'id') {
  uidCounters[id] = uidCounters[id] || 1;
  const count = uidCounters[id]++;
  return `${id}-${count}`;
}

function isPowerOfTwo(n) {
  (0, _assert.assert)(typeof n === 'number', 'Input must be a number');
  return n && (n & n - 1) === 0;
}

function isObjectEmpty(obj) {
  let isEmpty = true;

  for (const key in obj) {
    isEmpty = false;
    break;
  }

  return isEmpty;
}
},{"./assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js"}],"node_modules/@luma.gl/webgl/dist/esm/utils/stub-methods.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.stubRemovedMethods = stubRemovedMethods;

var _gltools = require("@luma.gl/gltools");

function stubRemovedMethods(instance, className, version, methodNames) {
  const upgradeMessage = `See luma.gl ${version} Upgrade Guide at \
https://luma.gl/docs/upgrade-guide`;
  const prototype = Object.getPrototypeOf(instance);
  methodNames.forEach(methodName => {
    if (prototype.methodName) {
      return;
    }

    prototype[methodName] = () => {
      _gltools.log.removed(`Calling removed method ${className}.${methodName}: `, upgradeMessage)();

      throw new Error(methodName);
    };
  });
}
},{"@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/resource.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _gltools = require("@luma.gl/gltools");

var _init = require("../init");

var _constantsToKeys = require("../webgl-utils/constants-to-keys");

var _assert = require("../utils/assert");

var _utils = require("../utils/utils");

var _stubMethods = require("../utils/stub-methods");

const ERR_RESOURCE_METHOD_UNDEFINED = 'Resource subclass must define virtual methods';

class Resource {
  get [Symbol.toStringTag]() {
    return 'Resource';
  }

  constructor(gl, opts = {}) {
    (0, _gltools.assertWebGLContext)(gl);
    const {
      id,
      userData = {}
    } = opts;
    this.gl = gl;
    this.gl2 = gl;
    this.id = id || (0, _utils.uid)(this[Symbol.toStringTag]);
    this.userData = userData;
    this._bound = false;
    this._handle = opts.handle;

    if (this._handle === undefined) {
      this._handle = this._createHandle();
    }

    this.byteLength = 0;

    this._addStats();
  }

  toString() {
    return `${this[Symbol.toStringTag] || this.constructor.name}(${this.id})`;
  }

  get handle() {
    return this._handle;
  }

  delete({
    deleteChildren = false
  } = {}) {
    const children = this._handle && this._deleteHandle(this._handle);

    if (this._handle) {
      this._removeStats();
    }

    this._handle = null;

    if (children && deleteChildren) {
      children.filter(Boolean).forEach(child => child.delete());
    }

    return this;
  }

  bind(funcOrHandle = this.handle) {
    if (typeof funcOrHandle !== 'function') {
      this._bindHandle(funcOrHandle);

      return this;
    }

    let value;

    if (!this._bound) {
      this._bindHandle(this.handle);

      this._bound = true;
      value = funcOrHandle();
      this._bound = false;

      this._bindHandle(null);
    } else {
      value = funcOrHandle();
    }

    return value;
  }

  unbind() {
    this.bind(null);
  }

  getParameter(pname, opts = {}) {
    pname = (0, _constantsToKeys.getKeyValue)(this.gl, pname);
    (0, _assert.assert)(pname);
    const parameters = this.constructor.PARAMETERS || {};
    const parameter = parameters[pname];

    if (parameter) {
      const isWebgl2 = (0, _gltools.isWebGL2)(this.gl);
      const parameterAvailable = (!('webgl2' in parameter) || isWebgl2) && (!('extension' in parameter) || this.gl.getExtension(parameter.extension));

      if (!parameterAvailable) {
        const webgl1Default = parameter.webgl1;
        const webgl2Default = 'webgl2' in parameter ? parameter.webgl2 : parameter.webgl1;
        const defaultValue = isWebgl2 ? webgl2Default : webgl1Default;
        return defaultValue;
      }
    }

    return this._getParameter(pname, opts);
  }

  getParameters(options = {}) {
    const {
      parameters,
      keys
    } = options;
    const PARAMETERS = this.constructor.PARAMETERS || {};
    const isWebgl2 = (0, _gltools.isWebGL2)(this.gl);
    const values = {};
    const parameterKeys = parameters || Object.keys(PARAMETERS);

    for (const pname of parameterKeys) {
      const parameter = PARAMETERS[pname];
      const parameterAvailable = parameter && (!('webgl2' in parameter) || isWebgl2) && (!('extension' in parameter) || this.gl.getExtension(parameter.extension));

      if (parameterAvailable) {
        const key = keys ? (0, _constantsToKeys.getKey)(this.gl, pname) : pname;
        values[key] = this.getParameter(pname, options);

        if (keys && parameter.type === 'GLenum') {
          values[key] = (0, _constantsToKeys.getKey)(this.gl, values[key]);
        }
      }
    }

    return values;
  }

  setParameter(pname, value) {
    pname = (0, _constantsToKeys.getKeyValue)(this.gl, pname);
    (0, _assert.assert)(pname);
    const parameters = this.constructor.PARAMETERS || {};
    const parameter = parameters[pname];

    if (parameter) {
      const isWebgl2 = (0, _gltools.isWebGL2)(this.gl);
      const parameterAvailable = (!('webgl2' in parameter) || isWebgl2) && (!('extension' in parameter) || this.gl.getExtension(parameter.extension));

      if (!parameterAvailable) {
        throw new Error('Parameter not available on this platform');
      }

      if (parameter.type === 'GLenum') {
        value = (0, _constantsToKeys.getKeyValue)(value);
      }
    }

    this._setParameter(pname, value);

    return this;
  }

  setParameters(parameters) {
    for (const pname in parameters) {
      this.setParameter(pname, parameters[pname]);
    }

    return this;
  }

  stubRemovedMethods(className, version, methodNames) {
    return (0, _stubMethods.stubRemovedMethods)(this, className, version, methodNames);
  }

  initialize(opts) {}

  _createHandle() {
    throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
  }

  _deleteHandle() {
    throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
  }

  _bindHandle(handle) {
    throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
  }

  _getOptsFromHandle() {
    throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
  }

  _getParameter(pname, opts) {
    throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
  }

  _setParameter(pname, value) {
    throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
  }

  _context() {
    this.gl.luma = this.gl.luma || {};
    return this.gl.luma;
  }

  _addStats() {
    const name = this[Symbol.toStringTag];

    const stats = _init.lumaStats.get('Resource Counts');

    stats.get('Resources Created').incrementCount();
    stats.get(`${name}s Created`).incrementCount();
    stats.get(`${name}s Active`).incrementCount();
  }

  _removeStats() {
    const name = this[Symbol.toStringTag];

    const stats = _init.lumaStats.get('Resource Counts');

    stats.get(`${name}s Active`).decrementCount();
  }

  _trackAllocatedMemory(bytes, name = this[Symbol.toStringTag]) {
    const stats = _init.lumaStats.get('Memory Usage');

    stats.get('GPU Memory').addCount(bytes);
    stats.get(`${name} Memory`).addCount(bytes);
    this.byteLength = bytes;
  }

  _trackDeallocatedMemory(name = this[Symbol.toStringTag]) {
    const stats = _init.lumaStats.get('Memory Usage');

    stats.get('GPU Memory').subtractCount(this.byteLength);
    stats.get(`${name} Memory`).subtractCount(this.byteLength);
    this.byteLength = 0;
  }

}

exports.default = Resource;
},{"@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","../init":"node_modules/@luma.gl/webgl/dist/esm/init.js","../webgl-utils/constants-to-keys":"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/constants-to-keys.js","../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js","../utils/utils":"node_modules/@luma.gl/webgl/dist/esm/utils/utils.js","../utils/stub-methods":"node_modules/@luma.gl/webgl/dist/esm/utils/stub-methods.js"}],"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/typed-array-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.flipRows = flipRows;
exports.getGLTypeFromTypedArray = getGLTypeFromTypedArray;
exports.getTypedArrayFromGLType = getTypedArrayFromGLType;
exports.scalePixels = scalePixels;
const ERR_TYPE_DEDUCTION = 'Failed to deduce GL constant from typed array';

function getGLTypeFromTypedArray(arrayOrType) {
  const type = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;

  switch (type) {
    case Float32Array:
      return 5126;

    case Uint16Array:
      return 5123;

    case Uint32Array:
      return 5125;

    case Uint8Array:
      return 5121;

    case Uint8ClampedArray:
      return 5121;

    case Int8Array:
      return 5120;

    case Int16Array:
      return 5122;

    case Int32Array:
      return 5124;

    default:
      throw new Error(ERR_TYPE_DEDUCTION);
  }
}

function getTypedArrayFromGLType(glType, {
  clamped = true
} = {}) {
  switch (glType) {
    case 5126:
      return Float32Array;

    case 5123:
    case 33635:
    case 32819:
    case 32820:
      return Uint16Array;

    case 5125:
      return Uint32Array;

    case 5121:
      return clamped ? Uint8ClampedArray : Uint8Array;

    case 5120:
      return Int8Array;

    case 5122:
      return Int16Array;

    case 5124:
      return Int32Array;

    default:
      throw new Error('Failed to deduce typed array type from GL constant');
  }
}

function flipRows({
  data,
  width,
  height,
  bytesPerPixel = 4,
  temp
}) {
  const bytesPerRow = width * bytesPerPixel;
  temp = temp || new Uint8Array(bytesPerRow);

  for (let y = 0; y < height / 2; ++y) {
    const topOffset = y * bytesPerRow;
    const bottomOffset = (height - y - 1) * bytesPerRow;
    temp.set(data.subarray(topOffset, topOffset + bytesPerRow));
    data.copyWithin(topOffset, bottomOffset, bottomOffset + bytesPerRow);
    data.set(temp, bottomOffset);
  }
}

function scalePixels({
  data,
  width,
  height
}) {
  const newWidth = Math.round(width / 2);
  const newHeight = Math.round(height / 2);
  const newData = new Uint8Array(newWidth * newHeight * 4);

  for (let y = 0; y < newHeight; y++) {
    for (let x = 0; x < newWidth; x++) {
      for (let c = 0; c < 4; c++) {
        newData[(y * newWidth + x) * 4 + c] = data[(y * 2 * width + x * 2) * 4 + c];
      }
    }
  }

  return {
    data: newData,
    width: newWidth,
    height: newHeight
  };
}
},{}],"node_modules/@luma.gl/webgl/dist/esm/utils/check-props.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.checkProps = checkProps;

var _gltools = require("@luma.gl/gltools");

function checkProps(className, props, propChecks) {
  const {
    removedProps = {},
    deprecatedProps = {},
    replacedProps = {}
  } = propChecks;

  for (const propName in removedProps) {
    if (propName in props) {
      const replacementProp = removedProps[propName];
      const replacement = replacementProp ? `${className}.${removedProps[propName]}` : 'N/A';

      _gltools.log.removed(`${className}.${propName}`, replacement)();
    }
  }

  for (const propName in deprecatedProps) {
    if (propName in props) {
      const replacementProp = deprecatedProps[propName];

      _gltools.log.deprecated(`${className}.${propName}`, `${className}.${replacementProp}`)();
    }
  }

  let newProps = null;

  for (const propName in replacedProps) {
    if (propName in props) {
      const replacementProp = replacedProps[propName];

      _gltools.log.deprecated(`${className}.${propName}`, `${className}.${replacementProp}`)();

      newProps = newProps || Object.assign({}, props);
      newProps[replacementProp] = props[propName];
      delete newProps[propName];
    }
  }

  return newProps || props;
}
},{"@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/accessor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.DEFAULT_ACCESSOR_VALUES = void 0;

var _typedArrayUtils = require("../webgl-utils/typed-array-utils");

var _assert = require("../utils/assert");

var _checkProps = require("../utils/check-props");

const DEFAULT_ACCESSOR_VALUES = {
  offset: 0,
  stride: 0,
  type: 5126,
  size: 1,
  divisor: 0,
  normalized: false,
  integer: false
};
exports.DEFAULT_ACCESSOR_VALUES = DEFAULT_ACCESSOR_VALUES;
const PROP_CHECKS = {
  deprecatedProps: {
    instanced: 'divisor',
    isInstanced: 'divisor'
  }
};

class Accessor {
  static getBytesPerElement(accessor) {
    const ArrayType = (0, _typedArrayUtils.getTypedArrayFromGLType)(accessor.type || 5126);
    return ArrayType.BYTES_PER_ELEMENT;
  }

  static getBytesPerVertex(accessor) {
    (0, _assert.assert)(accessor.size);
    const ArrayType = (0, _typedArrayUtils.getTypedArrayFromGLType)(accessor.type || 5126);
    return ArrayType.BYTES_PER_ELEMENT * accessor.size;
  }

  static resolve(...accessors) {
    return new Accessor(...[DEFAULT_ACCESSOR_VALUES, ...accessors]);
  }

  constructor(...accessors) {
    accessors.forEach(accessor => this._assign(accessor));
    Object.freeze(this);
  }

  toString() {
    return JSON.stringify(this);
  }

  get BYTES_PER_ELEMENT() {
    return Accessor.getBytesPerElement(this);
  }

  get BYTES_PER_VERTEX() {
    return Accessor.getBytesPerVertex(this);
  }

  _assign(props = {}) {
    props = (0, _checkProps.checkProps)('Accessor', props, PROP_CHECKS);

    if (props.type !== undefined) {
      this.type = props.type;

      if (props.type === 5124 || props.type === 5125) {
        this.integer = true;
      }
    }

    if (props.size !== undefined) {
      this.size = props.size;
    }

    if (props.offset !== undefined) {
      this.offset = props.offset;
    }

    if (props.stride !== undefined) {
      this.stride = props.stride;
    }

    if (props.normalized !== undefined) {
      this.normalized = props.normalized;
    }

    if (props.integer !== undefined) {
      this.integer = props.integer;
    }

    if (props.divisor !== undefined) {
      this.divisor = props.divisor;
    }

    if (props.buffer !== undefined) {
      this.buffer = props.buffer;
    }

    if (props.index !== undefined) {
      if (typeof props.index === 'boolean') {
        this.index = props.index ? 1 : 0;
      } else {
        this.index = props.index;
      }
    }

    if (props.instanced !== undefined) {
      this.divisor = props.instanced ? 1 : 0;
    }

    if (props.isInstanced !== undefined) {
      this.divisor = props.isInstanced ? 1 : 0;
    }

    return this;
  }

}

exports.default = Accessor;
},{"../webgl-utils/typed-array-utils":"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/typed-array-utils.js","../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js","../utils/check-props":"node_modules/@luma.gl/webgl/dist/esm/utils/check-props.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _resource = _interopRequireDefault(require("./resource"));

var _accessor = _interopRequireDefault(require("./accessor"));

var _typedArrayUtils = require("../webgl-utils/typed-array-utils");

var _gltools = require("@luma.gl/gltools");

var _assert = require("../utils/assert");

var _checkProps = require("../utils/check-props");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const DEBUG_DATA_LENGTH = 10;
const DEPRECATED_PROPS = {
  offset: 'accessor.offset',
  stride: 'accessor.stride',
  type: 'accessor.type',
  size: 'accessor.size',
  divisor: 'accessor.divisor',
  normalized: 'accessor.normalized',
  integer: 'accessor.integer',
  instanced: 'accessor.divisor',
  isInstanced: 'accessor.divisor'
};
const PROP_CHECKS_INITIALIZE = {
  removedProps: {},
  replacedProps: {
    bytes: 'byteLength'
  },
  deprecatedProps: DEPRECATED_PROPS
};
const PROP_CHECKS_SET_PROPS = {
  removedProps: DEPRECATED_PROPS
};

class Buffer extends _resource.default {
  get [Symbol.toStringTag]() {
    return 'Buffer';
  }

  constructor(gl, props = {}) {
    super(gl, props);
    this.stubRemovedMethods('Buffer', 'v6.0', ['layout', 'setLayout', 'getIndexedParameter']);
    this.target = props.target || (this.gl.webgl2 ? 36662 : 34962);
    this.initialize(props);
    Object.seal(this);
  }

  getElementCount(accessor = this.accessor) {
    return Math.round(this.byteLength / _accessor.default.getBytesPerElement(accessor));
  }

  getVertexCount(accessor = this.accessor) {
    return Math.round(this.byteLength / _accessor.default.getBytesPerVertex(accessor));
  }

  initialize(props = {}) {
    if (ArrayBuffer.isView(props)) {
      props = {
        data: props
      };
    }

    if (Number.isFinite(props)) {
      props = {
        byteLength: props
      };
    }

    props = (0, _checkProps.checkProps)('Buffer', props, PROP_CHECKS_INITIALIZE);
    this.usage = props.usage || 35044;
    this.debugData = null;
    this.setAccessor(Object.assign({}, props, props.accessor));

    if (props.data) {
      this._setData(props.data, props.offset, props.byteLength);
    } else {
      this._setByteLength(props.byteLength || 0);
    }

    return this;
  }

  setProps(props) {
    props = (0, _checkProps.checkProps)('Buffer', props, PROP_CHECKS_SET_PROPS);

    if ('accessor' in props) {
      this.setAccessor(props.accessor);
    }

    return this;
  }

  setAccessor(accessor) {
    accessor = Object.assign({}, accessor);
    delete accessor.buffer;
    this.accessor = new _accessor.default(accessor);
    return this;
  }

  reallocate(byteLength) {
    if (byteLength > this.byteLength) {
      this._setByteLength(byteLength);

      return true;
    }

    this.bytesUsed = byteLength;
    return false;
  }

  setData(props) {
    return this.initialize(props);
  }

  subData(props) {
    if (ArrayBuffer.isView(props)) {
      props = {
        data: props
      };
    }

    const {
      data,
      offset = 0,
      srcOffset = 0
    } = props;
    const byteLength = props.byteLength || props.length;
    (0, _assert.assert)(data);
    const target = this.gl.webgl2 ? 36663 : this.target;
    this.gl.bindBuffer(target, this.handle);

    if (srcOffset !== 0 || byteLength !== undefined) {
      (0, _gltools.assertWebGL2Context)(this.gl);
      this.gl.bufferSubData(this.target, offset, data, srcOffset, byteLength);
    } else {
      this.gl.bufferSubData(target, offset, data);
    }

    this.gl.bindBuffer(target, null);
    this.debugData = null;

    this._inferType(data);

    return this;
  }

  copyData({
    sourceBuffer,
    readOffset = 0,
    writeOffset = 0,
    size
  }) {
    const {
      gl
    } = this;
    (0, _gltools.assertWebGL2Context)(gl);
    gl.bindBuffer(36662, sourceBuffer.handle);
    gl.bindBuffer(36663, this.handle);
    gl.copyBufferSubData(36662, 36663, readOffset, writeOffset, size);
    gl.bindBuffer(36662, null);
    gl.bindBuffer(36663, null);
    this.debugData = null;
    return this;
  }

  getData({
    dstData = null,
    srcByteOffset = 0,
    dstOffset = 0,
    length = 0
  } = {}) {
    (0, _gltools.assertWebGL2Context)(this.gl);
    const ArrayType = (0, _typedArrayUtils.getTypedArrayFromGLType)(this.accessor.type || 5126, {
      clamped: false
    });

    const sourceAvailableElementCount = this._getAvailableElementCount(srcByteOffset);

    const dstElementOffset = dstOffset;
    let dstAvailableElementCount;
    let dstElementCount;

    if (dstData) {
      dstElementCount = dstData.length;
      dstAvailableElementCount = dstElementCount - dstElementOffset;
    } else {
      dstAvailableElementCount = Math.min(sourceAvailableElementCount, length || sourceAvailableElementCount);
      dstElementCount = dstElementOffset + dstAvailableElementCount;
    }

    const copyElementCount = Math.min(sourceAvailableElementCount, dstAvailableElementCount);
    length = length || copyElementCount;
    (0, _assert.assert)(length <= copyElementCount);
    dstData = dstData || new ArrayType(dstElementCount);
    this.gl.bindBuffer(36662, this.handle);
    this.gl.getBufferSubData(36662, srcByteOffset, dstData, dstOffset, length);
    this.gl.bindBuffer(36662, null);
    return dstData;
  }

  bind({
    target = this.target,
    index = this.accessor && this.accessor.index,
    offset = 0,
    size
  } = {}) {
    if (target === 35345 || target === 35982) {
      if (size !== undefined) {
        this.gl.bindBufferRange(target, index, this.handle, offset, size);
      } else {
        (0, _assert.assert)(offset === 0);
        this.gl.bindBufferBase(target, index, this.handle);
      }
    } else {
      this.gl.bindBuffer(target, this.handle);
    }

    return this;
  }

  unbind({
    target = this.target,
    index = this.accessor && this.accessor.index
  } = {}) {
    const isIndexedBuffer = target === 35345 || target === 35982;

    if (isIndexedBuffer) {
      this.gl.bindBufferBase(target, index, null);
    } else {
      this.gl.bindBuffer(target, null);
    }

    return this;
  }

  getDebugData() {
    if (!this.debugData) {
      this.debugData = this.getData({
        length: Math.min(DEBUG_DATA_LENGTH, this.byteLength)
      });
      return {
        data: this.debugData,
        changed: true
      };
    }

    return {
      data: this.debugData,
      changed: false
    };
  }

  invalidateDebugData() {
    this.debugData = null;
  }

  _setData(data, offset = 0, byteLength = data.byteLength + offset) {
    (0, _assert.assert)(ArrayBuffer.isView(data));

    this._trackDeallocatedMemory();

    const target = this._getTarget();

    this.gl.bindBuffer(target, this.handle);
    this.gl.bufferData(target, byteLength, this.usage);
    this.gl.bufferSubData(target, offset, data);
    this.gl.bindBuffer(target, null);
    this.debugData = data.slice(0, DEBUG_DATA_LENGTH);
    this.bytesUsed = byteLength;

    this._trackAllocatedMemory(byteLength);

    const type = (0, _typedArrayUtils.getGLTypeFromTypedArray)(data);
    (0, _assert.assert)(type);
    this.setAccessor(new _accessor.default(this.accessor, {
      type
    }));
    return this;
  }

  _setByteLength(byteLength, usage = this.usage) {
    (0, _assert.assert)(byteLength >= 0);

    this._trackDeallocatedMemory();

    let data = byteLength;

    if (byteLength === 0) {
      data = new Float32Array(0);
    }

    const target = this._getTarget();

    this.gl.bindBuffer(target, this.handle);
    this.gl.bufferData(target, data, usage);
    this.gl.bindBuffer(target, null);
    this.usage = usage;
    this.debugData = null;
    this.bytesUsed = byteLength;

    this._trackAllocatedMemory(byteLength);

    return this;
  }

  _getTarget() {
    return this.gl.webgl2 ? 36663 : this.target;
  }

  _getAvailableElementCount(srcByteOffset) {
    const ArrayType = (0, _typedArrayUtils.getTypedArrayFromGLType)(this.accessor.type || 5126, {
      clamped: false
    });
    const sourceElementOffset = srcByteOffset / ArrayType.BYTES_PER_ELEMENT;
    return this.getElementCount() - sourceElementOffset;
  }

  _inferType(data) {
    if (!this.accessor.type) {
      this.setAccessor(new _accessor.default(this.accessor, {
        type: (0, _typedArrayUtils.getGLTypeFromTypedArray)(data)
      }));
    }
  }

  _createHandle() {
    return this.gl.createBuffer();
  }

  _deleteHandle() {
    this.gl.deleteBuffer(this.handle);

    this._trackDeallocatedMemory();
  }

  _getParameter(pname) {
    this.gl.bindBuffer(this.target, this.handle);
    const value = this.gl.getBufferParameter(this.target, pname);
    this.gl.bindBuffer(this.target, null);
    return value;
  }

  get type() {
    _gltools.log.deprecated('Buffer.type', 'Buffer.accessor.type')();

    return this.accessor.type;
  }

  get bytes() {
    _gltools.log.deprecated('Buffer.bytes', 'Buffer.byteLength')();

    return this.byteLength;
  }

  setByteLength(byteLength) {
    _gltools.log.deprecated('setByteLength', 'reallocate')();

    return this.reallocate(byteLength);
  }

  updateAccessor(opts) {
    _gltools.log.deprecated('updateAccessor(...)', 'setAccessor(new Accessor(buffer.accessor, ...)')();

    this.accessor = new _accessor.default(this.accessor, opts);
    return this;
  }

}

exports.default = Buffer;
},{"./resource":"node_modules/@luma.gl/webgl/dist/esm/classes/resource.js","./accessor":"node_modules/@luma.gl/webgl/dist/esm/classes/accessor.js","../webgl-utils/typed-array-utils":"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/typed-array-utils.js","@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js","../utils/check-props":"node_modules/@luma.gl/webgl/dist/esm/utils/check-props.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/texture-formats.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TYPE_SIZES = exports.TEXTURE_FORMATS = exports.DATA_FORMAT_CHANNELS = void 0;
exports.isFormatSupported = isFormatSupported;
exports.isLinearFilteringSupported = isLinearFilteringSupported;

var _gltools = require("@luma.gl/gltools");

const TEXTURE_FORMATS = {
  [6407]: {
    dataFormat: 6407,
    types: [5121, 33635]
  },
  [6408]: {
    dataFormat: 6408,
    types: [5121, 32819, 32820]
  },
  [6406]: {
    dataFormat: 6406,
    types: [5121]
  },
  [6409]: {
    dataFormat: 6409,
    types: [5121]
  },
  [6410]: {
    dataFormat: 6410,
    types: [5121]
  },
  [33326]: {
    dataFormat: 6403,
    types: [5126],
    gl2: true
  },
  [33328]: {
    dataFormat: 33319,
    types: [5126],
    gl2: true
  },
  [34837]: {
    dataFormat: 6407,
    types: [5126],
    gl2: true
  },
  [34836]: {
    dataFormat: 6408,
    types: [5126],
    gl2: true
  }
};
exports.TEXTURE_FORMATS = TEXTURE_FORMATS;
const DATA_FORMAT_CHANNELS = {
  [6403]: 1,
  [36244]: 1,
  [33319]: 2,
  [33320]: 2,
  [6407]: 3,
  [36248]: 3,
  [6408]: 4,
  [36249]: 4,
  [6402]: 1,
  [34041]: 1,
  [6406]: 1,
  [6409]: 1,
  [6410]: 2
};
exports.DATA_FORMAT_CHANNELS = DATA_FORMAT_CHANNELS;
const TYPE_SIZES = {
  [5126]: 4,
  [5125]: 4,
  [5124]: 4,
  [5123]: 2,
  [5122]: 2,
  [5131]: 2,
  [5120]: 1,
  [5121]: 1
};
exports.TYPE_SIZES = TYPE_SIZES;

function isFormatSupported(gl, format) {
  const info = TEXTURE_FORMATS[format];

  if (!info) {
    return false;
  }

  if (info.gl1 === undefined && info.gl2 === undefined) {
    return true;
  }

  const value = (0, _gltools.isWebGL2)(gl) ? info.gl2 || info.gl1 : info.gl1;
  return typeof value === 'string' ? gl.getExtension(value) : value;
}

function isLinearFilteringSupported(gl, format) {
  const info = TEXTURE_FORMATS[format];

  switch (info && info.types[0]) {
    case 5126:
      return gl.getExtension('OES_texture_float_linear');

    case 5131:
      return gl.getExtension('OES_texture_half_float_linear');

    default:
      return true;
  }
}
},{"@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/texture.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _gltools = require("@luma.gl/gltools");

var _resource = _interopRequireDefault(require("./resource"));

var _buffer = _interopRequireDefault(require("./buffer"));

var _textureFormats = require("./texture-formats");

var _assert = require("../utils/assert");

var _utils = require("../utils/utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const NPOT_MIN_FILTERS = [9729, 9728];

const WebGLBuffer = globalThis.WebGLBuffer || function WebGLBuffer() {};

class Texture extends _resource.default {
  get [Symbol.toStringTag]() {
    return 'Texture';
  }

  static isSupported(gl, opts = {}) {
    const {
      format,
      linearFiltering
    } = opts;
    let supported = true;

    if (format) {
      supported = supported && (0, _textureFormats.isFormatSupported)(gl, format);
      supported = supported && (!linearFiltering || (0, _textureFormats.isLinearFilteringSupported)(gl, format));
    }

    return supported;
  }

  constructor(gl, props) {
    const {
      id = (0, _utils.uid)('texture'),
      handle,
      target
    } = props;
    super(gl, {
      id,
      handle
    });
    this.target = target;
    this.textureUnit = undefined;
    this.loaded = false;
    this.width = undefined;
    this.height = undefined;
    this.depth = undefined;
    this.format = undefined;
    this.type = undefined;
    this.dataFormat = undefined;
    this.border = undefined;
    this.textureUnit = undefined;
    this.mipmaps = undefined;
  }

  toString() {
    return `Texture(${this.id},${this.width}x${this.height})`;
  }

  initialize(props = {}) {
    let data = props.data;

    if (data instanceof Promise) {
      data.then(resolvedImageData => this.initialize(Object.assign({}, props, {
        pixels: resolvedImageData,
        data: resolvedImageData
      })));
      return this;
    }

    const isVideo = typeof HTMLVideoElement !== 'undefined' && data instanceof HTMLVideoElement;

    if (isVideo && data.readyState < HTMLVideoElement.HAVE_METADATA) {
      this._video = null;
      data.addEventListener('loadeddata', () => this.initialize(props));
      return this;
    }

    const {
      pixels = null,
      format = 6408,
      border = 0,
      recreate = false,
      parameters = {},
      pixelStore = {},
      textureUnit = undefined
    } = props;

    if (!data) {
      data = pixels;
    }

    let {
      width,
      height,
      dataFormat,
      type,
      compressed = false,
      mipmaps = true
    } = props;
    const {
      depth = 0
    } = props;
    ({
      width,
      height,
      compressed,
      dataFormat,
      type
    } = this._deduceParameters({
      format,
      type,
      dataFormat,
      compressed,
      data,
      width,
      height
    }));
    this.width = width;
    this.height = height;
    this.depth = depth;
    this.format = format;
    this.type = type;
    this.dataFormat = dataFormat;
    this.border = border;
    this.textureUnit = textureUnit;

    if (Number.isFinite(this.textureUnit)) {
      this.gl.activeTexture(33984 + this.textureUnit);
      this.gl.bindTexture(this.target, this.handle);
    }

    if (mipmaps && this._isNPOT()) {
      _gltools.log.warn(`texture: ${this} is Non-Power-Of-Two, disabling mipmaping`)();

      mipmaps = false;

      this._updateForNPOT(parameters);
    }

    this.mipmaps = mipmaps;
    this.setImageData({
      data,
      width,
      height,
      depth,
      format,
      type,
      dataFormat,
      border,
      mipmaps,
      parameters: pixelStore,
      compressed
    });

    if (mipmaps) {
      this.generateMipmap();
    }

    this.setParameters(parameters);

    if (recreate) {
      this.data = data;
    }

    if (isVideo) {
      this._video = {
        video: data,
        parameters,
        lastTime: data.readyState >= HTMLVideoElement.HAVE_CURRENT_DATA ? data.currentTime : -1
      };
    }

    return this;
  }

  update() {
    if (this._video) {
      const {
        video,
        parameters,
        lastTime
      } = this._video;

      if (lastTime === video.currentTime || video.readyState < HTMLVideoElement.HAVE_CURRENT_DATA) {
        return;
      }

      this.setSubImageData({
        data: video,
        parameters
      });

      if (this.mipmaps) {
        this.generateMipmap();
      }

      this._video.lastTime = video.currentTime;
    }
  }

  resize({
    height,
    width,
    mipmaps = false
  }) {
    if (width !== this.width || height !== this.height) {
      return this.initialize({
        width,
        height,
        format: this.format,
        type: this.type,
        dataFormat: this.dataFormat,
        border: this.border,
        mipmaps
      });
    }

    return this;
  }

  generateMipmap(params = {}) {
    if (this._isNPOT()) {
      _gltools.log.warn(`texture: ${this} is Non-Power-Of-Two, disabling mipmaping`)();

      return this;
    }

    this.mipmaps = true;
    this.gl.bindTexture(this.target, this.handle);
    (0, _gltools.withParameters)(this.gl, params, () => {
      this.gl.generateMipmap(this.target);
    });
    this.gl.bindTexture(this.target, null);
    return this;
  }

  setImageData(options) {
    this._trackDeallocatedMemory('Texture');

    const {
      target = this.target,
      pixels = null,
      level = 0,
      format = this.format,
      border = this.border,
      offset = 0,
      parameters = {}
    } = options;
    let {
      data = null,
      type = this.type,
      width = this.width,
      height = this.height,
      dataFormat = this.dataFormat,
      compressed = false
    } = options;

    if (!data) {
      data = pixels;
    }

    ({
      type,
      dataFormat,
      compressed,
      width,
      height
    } = this._deduceParameters({
      format,
      type,
      dataFormat,
      compressed,
      data,
      width,
      height
    }));
    const {
      gl
    } = this;
    gl.bindTexture(this.target, this.handle);
    let dataType = null;
    ({
      data,
      dataType
    } = this._getDataType({
      data,
      compressed
    }));
    let gl2;
    let compressedTextureSize = 0;
    (0, _gltools.withParameters)(this.gl, parameters, () => {
      switch (dataType) {
        case 'null':
          gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data);
          break;

        case 'typed-array':
          gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data, offset);
          break;

        case 'buffer':
          gl2 = (0, _gltools.assertWebGL2Context)(gl);
          gl2.bindBuffer(35052, data.handle || data);
          gl2.texImage2D(target, level, format, width, height, border, dataFormat, type, offset);
          gl2.bindBuffer(35052, null);
          break;

        case 'browser-object':
          if ((0, _gltools.isWebGL2)(gl)) {
            gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data);
          } else {
            gl.texImage2D(target, level, format, dataFormat, type, data);
          }

          break;

        case 'compressed':
          for (const [levelIndex, levelData] of data.entries()) {
            gl.compressedTexImage2D(target, levelIndex, levelData.format, levelData.width, levelData.height, border, levelData.data);
            compressedTextureSize += levelData.levelSize;
          }

          break;

        default:
          (0, _assert.assert)(false, 'Unknown image data type');
      }
    });

    if (dataType === 'compressed') {
      this._trackAllocatedMemory(compressedTextureSize, 'Texture');
    } else if (data && data.byteLength) {
      this._trackAllocatedMemory(data.byteLength, 'Texture');
    } else {
      const channels = _textureFormats.DATA_FORMAT_CHANNELS[this.dataFormat] || 4;
      const channelSize = _textureFormats.TYPE_SIZES[this.type] || 1;

      this._trackAllocatedMemory(this.width * this.height * channels * channelSize, 'Texture');
    }

    this.loaded = true;
    return this;
  }

  setSubImageData({
    target = this.target,
    pixels = null,
    data = null,
    x = 0,
    y = 0,
    width = this.width,
    height = this.height,
    level = 0,
    format = this.format,
    type = this.type,
    dataFormat = this.dataFormat,
    compressed = false,
    offset = 0,
    border = this.border,
    parameters = {}
  }) {
    ({
      type,
      dataFormat,
      compressed,
      width,
      height
    } = this._deduceParameters({
      format,
      type,
      dataFormat,
      compressed,
      data,
      width,
      height
    }));
    (0, _assert.assert)(this.depth === 0, 'texSubImage not supported for 3D textures');

    if (!data) {
      data = pixels;
    }

    if (data && data.data) {
      const ndarray = data;
      data = ndarray.data;
      width = ndarray.shape[0];
      height = ndarray.shape[1];
    }

    if (data instanceof _buffer.default) {
      data = data.handle;
    }

    this.gl.bindTexture(this.target, this.handle);
    (0, _gltools.withParameters)(this.gl, parameters, () => {
      if (compressed) {
        this.gl.compressedTexSubImage2D(target, level, x, y, width, height, format, data);
      } else if (data === null) {
        this.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, null);
      } else if (ArrayBuffer.isView(data)) {
        this.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, data, offset);
      } else if (data instanceof WebGLBuffer) {
        const gl2 = (0, _gltools.assertWebGL2Context)(this.gl);
        gl2.bindBuffer(35052, data);
        gl2.texSubImage2D(target, level, x, y, width, height, dataFormat, type, offset);
        gl2.bindBuffer(35052, null);
      } else if ((0, _gltools.isWebGL2)(this.gl)) {
        const gl2 = (0, _gltools.assertWebGL2Context)(this.gl);
        gl2.texSubImage2D(target, level, x, y, width, height, dataFormat, type, data);
      } else {
        this.gl.texSubImage2D(target, level, x, y, dataFormat, type, data);
      }
    });
    this.gl.bindTexture(this.target, null);
  }

  copyFramebuffer(opts = {}) {
    _gltools.log.error('Texture.copyFramebuffer({...}) is no logner supported, use copyToTexture(source, target, opts})')();

    return null;
  }

  getActiveUnit() {
    return this.gl.getParameter(34016) - 33984;
  }

  bind(textureUnit = this.textureUnit) {
    const {
      gl
    } = this;

    if (textureUnit !== undefined) {
      this.textureUnit = textureUnit;
      gl.activeTexture(33984 + textureUnit);
    }

    gl.bindTexture(this.target, this.handle);
    return textureUnit;
  }

  unbind(textureUnit = this.textureUnit) {
    const {
      gl
    } = this;

    if (textureUnit !== undefined) {
      this.textureUnit = textureUnit;
      gl.activeTexture(33984 + textureUnit);
    }

    gl.bindTexture(this.target, null);
    return textureUnit;
  }

  _getDataType({
    data,
    compressed = false
  }) {
    if (compressed) {
      return {
        data,
        dataType: 'compressed'
      };
    }

    if (data === null) {
      return {
        data,
        dataType: 'null'
      };
    }

    if (ArrayBuffer.isView(data)) {
      return {
        data,
        dataType: 'typed-array'
      };
    }

    if (data instanceof _buffer.default) {
      return {
        data: data.handle,
        dataType: 'buffer'
      };
    }

    if (data instanceof WebGLBuffer) {
      return {
        data,
        dataType: 'buffer'
      };
    }

    return {
      data,
      dataType: 'browser-object'
    };
  }

  _deduceParameters(opts) {
    const {
      format,
      data
    } = opts;
    let {
      width,
      height,
      dataFormat,
      type,
      compressed
    } = opts;
    const textureFormat = _textureFormats.TEXTURE_FORMATS[format];
    dataFormat = dataFormat || textureFormat && textureFormat.dataFormat;
    type = type || textureFormat && textureFormat.types[0];
    compressed = compressed || textureFormat && textureFormat.compressed;
    ({
      width,
      height
    } = this._deduceImageSize(data, width, height));
    return {
      dataFormat,
      type,
      compressed,
      width,
      height,
      format,
      data
    };
  }

  _deduceImageSize(data, width, height) {
    let size;

    if (typeof ImageData !== 'undefined' && data instanceof ImageData) {
      size = {
        width: data.width,
        height: data.height
      };
    } else if (typeof HTMLImageElement !== 'undefined' && data instanceof HTMLImageElement) {
      size = {
        width: data.naturalWidth,
        height: data.naturalHeight
      };
    } else if (typeof HTMLCanvasElement !== 'undefined' && data instanceof HTMLCanvasElement) {
      size = {
        width: data.width,
        height: data.height
      };
    } else if (typeof ImageBitmap !== 'undefined' && data instanceof ImageBitmap) {
      size = {
        width: data.width,
        height: data.height
      };
    } else if (typeof HTMLVideoElement !== 'undefined' && data instanceof HTMLVideoElement) {
      size = {
        width: data.videoWidth,
        height: data.videoHeight
      };
    } else if (!data) {
      size = {
        width: width >= 0 ? width : 1,
        height: height >= 0 ? height : 1
      };
    } else {
      size = {
        width,
        height
      };
    }

    (0, _assert.assert)(size, 'Could not deduced texture size');
    (0, _assert.assert)(width === undefined || size.width === width, 'Deduced texture width does not match supplied width');
    (0, _assert.assert)(height === undefined || size.height === height, 'Deduced texture height does not match supplied height');
    return size;
  }

  _createHandle() {
    return this.gl.createTexture();
  }

  _deleteHandle() {
    this.gl.deleteTexture(this.handle);

    this._trackDeallocatedMemory('Texture');
  }

  _getParameter(pname) {
    switch (pname) {
      case 4096:
        return this.width;

      case 4097:
        return this.height;

      default:
        this.gl.bindTexture(this.target, this.handle);
        const value = this.gl.getTexParameter(this.target, pname);
        this.gl.bindTexture(this.target, null);
        return value;
    }
  }

  _setParameter(pname, param) {
    this.gl.bindTexture(this.target, this.handle);
    param = this._getNPOTParam(pname, param);

    switch (pname) {
      case 33082:
      case 33083:
        this.gl.texParameterf(this.handle, pname, param);
        break;

      case 4096:
      case 4097:
        (0, _assert.assert)(false);
        break;

      default:
        this.gl.texParameteri(this.target, pname, param);
        break;
    }

    this.gl.bindTexture(this.target, null);
    return this;
  }

  _isNPOT() {
    if ((0, _gltools.isWebGL2)(this.gl)) {
      return false;
    }

    if (!this.width || !this.height) {
      return false;
    }

    return !(0, _utils.isPowerOfTwo)(this.width) || !(0, _utils.isPowerOfTwo)(this.height);
  }

  _updateForNPOT(parameters) {
    if (parameters[this.gl.TEXTURE_MIN_FILTER] === undefined) {
      parameters[this.gl.TEXTURE_MIN_FILTER] = this.gl.LINEAR;
    }

    if (parameters[this.gl.TEXTURE_WRAP_S] === undefined) {
      parameters[this.gl.TEXTURE_WRAP_S] = this.gl.CLAMP_TO_EDGE;
    }

    if (parameters[this.gl.TEXTURE_WRAP_T] === undefined) {
      parameters[this.gl.TEXTURE_WRAP_T] = this.gl.CLAMP_TO_EDGE;
    }
  }

  _getNPOTParam(pname, param) {
    if (this._isNPOT()) {
      switch (pname) {
        case 10241:
          if (NPOT_MIN_FILTERS.indexOf(param) === -1) {
            param = 9729;
          }

          break;

        case 10242:
        case 10243:
          if (param !== 33071) {
            param = 33071;
          }

          break;

        default:
          break;
      }
    }

    return param;
  }

}

exports.default = Texture;
},{"@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","./resource":"node_modules/@luma.gl/webgl/dist/esm/classes/resource.js","./buffer":"node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js","./texture-formats":"node_modules/@luma.gl/webgl/dist/esm/classes/texture-formats.js","../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js","../utils/utils":"node_modules/@luma.gl/webgl/dist/esm/utils/utils.js"}],"node_modules/@luma.gl/webgl/dist/esm/utils/load-file.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.loadFile = loadFile;
exports.loadImage = loadImage;
exports.setPathPrefix = setPathPrefix;

var _assert = require("../utils/assert");

let pathPrefix = '';

function setPathPrefix(prefix) {
  pathPrefix = prefix;
}

function loadFile(url, options = {}) {
  (0, _assert.assert)(typeof url === 'string');
  url = pathPrefix + url;
  const dataType = options.dataType || 'text';
  return fetch(url, options).then(res => res[dataType]());
}

function loadImage(url, opts) {
  (0, _assert.assert)(typeof url === 'string');
  url = pathPrefix + url;
  return new Promise((resolve, reject) => {
    try {
      const image = new Image();

      image.onload = () => resolve(image);

      image.onerror = () => reject(new Error(`Could not load image ${url}.`));

      image.crossOrigin = opts && opts.crossOrigin || 'anonymous';
      image.src = url;
    } catch (error) {
      reject(error);
    }
  });
}
},{"../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/texture-2d.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _gltools = require("@luma.gl/gltools");

var _texture = _interopRequireDefault(require("./texture"));

var _loadFile = require("../utils/load-file");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class Texture2D extends _texture.default {
  get [Symbol.toStringTag]() {
    return 'Texture2D';
  }

  static isSupported(gl, opts) {
    return _texture.default.isSupported(gl, opts);
  }

  constructor(gl, props = {}) {
    (0, _gltools.assertWebGLContext)(gl);

    if (props instanceof Promise || typeof props === 'string') {
      props = {
        data: props
      };
    }

    if (typeof props.data === 'string') {
      props = Object.assign({}, props, {
        data: (0, _loadFile.loadImage)(props.data)
      });
    }

    super(gl, Object.assign({}, props, {
      target: 3553
    }));
    this.initialize(props);
    Object.seal(this);
  }

}

exports.default = Texture2D;
},{"@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","./texture":"node_modules/@luma.gl/webgl/dist/esm/classes/texture.js","../utils/load-file":"node_modules/@luma.gl/webgl/dist/esm/utils/load-file.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/texture-cube.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _gltools = require("@luma.gl/gltools");

var _texture = _interopRequireDefault(require("./texture"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const FACES = [34069, 34070, 34071, 34072, 34073, 34074];

class TextureCube extends _texture.default {
  get [Symbol.toStringTag]() {
    return 'TextureCube';
  }

  constructor(gl, props = {}) {
    (0, _gltools.assertWebGLContext)(gl);
    super(gl, Object.assign({}, props, {
      target: 34067
    }));
    this.initialize(props);
    Object.seal(this);
  }

  initialize(props = {}) {
    const {
      mipmaps = true,
      parameters = {}
    } = props;
    this.opts = props;
    this.setCubeMapImageData(props).then(() => {
      this.loaded = true;

      if (mipmaps) {
        this.generateMipmap(props);
      }

      this.setParameters(parameters);
    });
    return this;
  }

  subImage({
    face,
    data,
    x = 0,
    y = 0,
    mipmapLevel = 0
  }) {
    return this._subImage({
      target: face,
      data,
      x,
      y,
      mipmapLevel
    });
  }

  async setCubeMapImageData({
    width,
    height,
    pixels,
    data,
    border = 0,
    format = 6408,
    type = 5121
  }) {
    const {
      gl
    } = this;
    const imageDataMap = pixels || data;
    const resolvedFaces = await Promise.all(FACES.map(face => {
      const facePixels = imageDataMap[face];
      return Promise.all(Array.isArray(facePixels) ? facePixels : [facePixels]);
    }));
    this.bind();
    FACES.forEach((face, index) => {
      if (resolvedFaces[index].length > 1 && this.opts.mipmaps !== false) {
        _gltools.log.warn(`${this.id} has mipmap and multiple LODs.`)();
      }

      resolvedFaces[index].forEach((image, lodLevel) => {
        if (width && height) {
          gl.texImage2D(face, lodLevel, format, width, height, border, format, type, image);
        } else {
          gl.texImage2D(face, lodLevel, format, format, type, image);
        }
      });
    });
    this.unbind();
  }

  setImageDataForFace(options) {
    const {
      face,
      width,
      height,
      pixels,
      data,
      border = 0,
      format = 6408,
      type = 5121
    } = options;
    const {
      gl
    } = this;
    const imageData = pixels || data;
    this.bind();

    if (imageData instanceof Promise) {
      imageData.then(resolvedImageData => this.setImageDataForFace(Object.assign({}, options, {
        face,
        data: resolvedImageData,
        pixels: resolvedImageData
      })));
    } else if (this.width || this.height) {
      gl.texImage2D(face, 0, format, width, height, border, format, type, imageData);
    } else {
      gl.texImage2D(face, 0, format, format, type, imageData);
    }

    return this;
  }

}

exports.default = TextureCube;
TextureCube.FACES = FACES;
},{"@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","./texture":"node_modules/@luma.gl/webgl/dist/esm/classes/texture.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/texture-3d.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _gltools = require("@luma.gl/gltools");

var _texture = _interopRequireDefault(require("./texture"));

var _textureFormats = require("./texture-formats");

var _buffer = _interopRequireDefault(require("./buffer"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class Texture3D extends _texture.default {
  get [Symbol.toStringTag]() {
    return 'Texture3D';
  }

  static isSupported(gl) {
    return (0, _gltools.isWebGL2)(gl);
  }

  constructor(gl, props = {}) {
    (0, _gltools.assertWebGL2Context)(gl);
    props = Object.assign({
      depth: 1
    }, props, {
      target: 32879,
      unpackFlipY: false
    });
    super(gl, props);
    this.initialize(props);
    Object.seal(this);
  }

  setImageData({
    level = 0,
    dataFormat = 6408,
    width,
    height,
    depth = 1,
    border = 0,
    format,
    type = 5121,
    offset = 0,
    data,
    parameters = {}
  }) {
    this._trackDeallocatedMemory('Texture');

    this.gl.bindTexture(this.target, this.handle);
    (0, _gltools.withParameters)(this.gl, parameters, () => {
      if (ArrayBuffer.isView(data)) {
        this.gl.texImage3D(this.target, level, dataFormat, width, height, depth, border, format, type, data);
      }

      if (data instanceof _buffer.default) {
        this.gl.bindBuffer(35052, data.handle);
        this.gl.texImage3D(this.target, level, dataFormat, width, height, depth, border, format, type, offset);
      }
    });

    if (data && data.byteLength) {
      this._trackAllocatedMemory(data.byteLength, 'Texture');
    } else {
      const channels = _textureFormats.DATA_FORMAT_CHANNELS[this.dataFormat] || 4;
      const channelSize = _textureFormats.TYPE_SIZES[this.type] || 1;

      this._trackAllocatedMemory(this.width * this.height * this.depth * channels * channelSize, 'Texture');
    }

    this.loaded = true;
    return this;
  }

}

exports.default = Texture3D;
},{"@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","./texture":"node_modules/@luma.gl/webgl/dist/esm/classes/texture.js","./texture-formats":"node_modules/@luma.gl/webgl/dist/esm/classes/texture-formats.js","./buffer":"node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/renderbuffer-formats.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
const EXT_FLOAT_WEBGL2 = 'EXT_color_buffer_float';
var _default = {
  [33189]: {
    bpp: 2
  },
  [33190]: {
    gl2: true,
    bpp: 3
  },
  [36012]: {
    gl2: true,
    bpp: 4
  },
  [36168]: {
    bpp: 1
  },
  [34041]: {
    bpp: 4
  },
  [35056]: {
    gl2: true,
    bpp: 4
  },
  [36013]: {
    gl2: true,
    bpp: 5
  },
  [32854]: {
    bpp: 2
  },
  [36194]: {
    bpp: 2
  },
  [32855]: {
    bpp: 2
  },
  [33321]: {
    gl2: true,
    bpp: 1
  },
  [33330]: {
    gl2: true,
    bpp: 1
  },
  [33329]: {
    gl2: true,
    bpp: 1
  },
  [33332]: {
    gl2: true,
    bpp: 2
  },
  [33331]: {
    gl2: true,
    bpp: 2
  },
  [33334]: {
    gl2: true,
    bpp: 4
  },
  [33333]: {
    gl2: true,
    bpp: 4
  },
  [33323]: {
    gl2: true,
    bpp: 2
  },
  [33336]: {
    gl2: true,
    bpp: 2
  },
  [33335]: {
    gl2: true,
    bpp: 2
  },
  [33338]: {
    gl2: true,
    bpp: 4
  },
  [33337]: {
    gl2: true,
    bpp: 4
  },
  [33340]: {
    gl2: true,
    bpp: 8
  },
  [33339]: {
    gl2: true,
    bpp: 8
  },
  [32849]: {
    gl2: true,
    bpp: 3
  },
  [32856]: {
    gl2: true,
    bpp: 4
  },
  [32857]: {
    gl2: true,
    bpp: 4
  },
  [36220]: {
    gl2: true,
    bpp: 4
  },
  [36238]: {
    gl2: true,
    bpp: 4
  },
  [36975]: {
    gl2: true,
    bpp: 4
  },
  [36214]: {
    gl2: true,
    bpp: 8
  },
  [36232]: {
    gl2: true,
    bpp: 8
  },
  [36226]: {
    gl2: true,
    bpp: 16
  },
  [36208]: {
    gl2: true,
    bpp: 16
  },
  [33325]: {
    gl2: EXT_FLOAT_WEBGL2,
    bpp: 2
  },
  [33327]: {
    gl2: EXT_FLOAT_WEBGL2,
    bpp: 4
  },
  [34842]: {
    gl2: EXT_FLOAT_WEBGL2,
    bpp: 8
  },
  [33326]: {
    gl2: EXT_FLOAT_WEBGL2,
    bpp: 4
  },
  [33328]: {
    gl2: EXT_FLOAT_WEBGL2,
    bpp: 8
  },
  [34836]: {
    gl2: EXT_FLOAT_WEBGL2,
    bpp: 16
  },
  [35898]: {
    gl2: EXT_FLOAT_WEBGL2,
    bpp: 4
  }
};
exports.default = _default;
},{}],"node_modules/@luma.gl/webgl/dist/esm/classes/renderbuffer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _resource = _interopRequireDefault(require("./resource"));

var _renderbufferFormats = _interopRequireDefault(require("./renderbuffer-formats"));

var _gltools = require("@luma.gl/gltools");

var _assert = require("../utils/assert");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isFormatSupported(gl, format, formats) {
  const info = formats[format];

  if (!info) {
    return false;
  }

  const value = (0, _gltools.isWebGL2)(gl) ? info.gl2 || info.gl1 : info.gl1;

  if (typeof value === 'string') {
    return gl.getExtension(value);
  }

  return value;
}

class Renderbuffer extends _resource.default {
  get [Symbol.toStringTag]() {
    return 'Renderbuffer';
  }

  static isSupported(gl, {
    format
  } = {
    format: null
  }) {
    return !format || isFormatSupported(gl, format, _renderbufferFormats.default);
  }

  static getSamplesForFormat(gl, {
    format
  }) {
    return gl.getInternalformatParameter(36161, format, 32937);
  }

  constructor(gl, opts = {}) {
    super(gl, opts);
    this.initialize(opts);
    Object.seal(this);
  }

  initialize({
    format,
    width = 1,
    height = 1,
    samples = 0
  }) {
    (0, _assert.assert)(format, 'Needs format');

    this._trackDeallocatedMemory();

    this.gl.bindRenderbuffer(36161, this.handle);

    if (samples !== 0 && (0, _gltools.isWebGL2)(this.gl)) {
      this.gl.renderbufferStorageMultisample(36161, samples, format, width, height);
    } else {
      this.gl.renderbufferStorage(36161, format, width, height);
    }

    this.format = format;
    this.width = width;
    this.height = height;
    this.samples = samples;

    this._trackAllocatedMemory(this.width * this.height * (this.samples || 1) * _renderbufferFormats.default[this.format].bpp);

    return this;
  }

  resize({
    width,
    height
  }) {
    if (width !== this.width || height !== this.height) {
      return this.initialize({
        width,
        height,
        format: this.format,
        samples: this.samples
      });
    }

    return this;
  }

  _createHandle() {
    return this.gl.createRenderbuffer();
  }

  _deleteHandle() {
    this.gl.deleteRenderbuffer(this.handle);

    this._trackDeallocatedMemory();
  }

  _bindHandle(handle) {
    this.gl.bindRenderbuffer(36161, handle);
  }

  _syncHandle(handle) {
    this.format = this.getParameter(36164);
    this.width = this.getParameter(36162);
    this.height = this.getParameter(36163);
    this.samples = this.getParameter(36011);
  }

  _getParameter(pname) {
    this.gl.bindRenderbuffer(36161, this.handle);
    const value = this.gl.getRenderbufferParameter(36161, pname);
    return value;
  }

}

exports.default = Renderbuffer;
},{"./resource":"node_modules/@luma.gl/webgl/dist/esm/classes/resource.js","./renderbuffer-formats":"node_modules/@luma.gl/webgl/dist/esm/classes/renderbuffer-formats.js","@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/clear.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clear = clear;
exports.clearBuffer = clearBuffer;

var _gltools = require("@luma.gl/gltools");

var _assert = require("../utils/assert");

const GL_DEPTH_BUFFER_BIT = 0x00000100;
const GL_STENCIL_BUFFER_BIT = 0x00000400;
const GL_COLOR_BUFFER_BIT = 0x00004000;
const GL_COLOR = 0x1800;
const GL_DEPTH = 0x1801;
const GL_STENCIL = 0x1802;
const GL_DEPTH_STENCIL = 0x84f9;
const ERR_ARGUMENTS = 'clear: bad arguments';

function clear(gl, {
  framebuffer = null,
  color = null,
  depth = null,
  stencil = null
} = {}) {
  const parameters = {};

  if (framebuffer) {
    parameters.framebuffer = framebuffer;
  }

  let clearFlags = 0;

  if (color) {
    clearFlags |= GL_COLOR_BUFFER_BIT;

    if (color !== true) {
      parameters.clearColor = color;
    }
  }

  if (depth) {
    clearFlags |= GL_DEPTH_BUFFER_BIT;

    if (depth !== true) {
      parameters.clearDepth = depth;
    }
  }

  if (stencil) {
    clearFlags |= GL_STENCIL_BUFFER_BIT;

    if (depth !== true) {
      parameters.clearStencil = depth;
    }
  }

  (0, _assert.assert)(clearFlags !== 0, ERR_ARGUMENTS);
  (0, _gltools.withParameters)(gl, parameters, () => {
    gl.clear(clearFlags);
  });
}

function clearBuffer(gl, {
  framebuffer = null,
  buffer = GL_COLOR,
  drawBuffer = 0,
  value = [0, 0, 0, 0]
} = {}) {
  (0, _gltools.assertWebGL2Context)(gl);
  (0, _gltools.withParameters)(gl, {
    framebuffer
  }, () => {
    switch (buffer) {
      case GL_COLOR:
        switch (value.constructor) {
          case Int32Array:
            gl.clearBufferiv(buffer, drawBuffer, value);
            break;

          case Uint32Array:
            gl.clearBufferuiv(buffer, drawBuffer, value);
            break;

          case Float32Array:
          default:
            gl.clearBufferfv(buffer, drawBuffer, value);
        }

        break;

      case GL_DEPTH:
        gl.clearBufferfv(GL_DEPTH, 0, [value]);
        break;

      case GL_STENCIL:
        gl.clearBufferiv(GL_STENCIL, 0, [value]);
        break;

      case GL_DEPTH_STENCIL:
        const [depth, stencil] = value;
        gl.clearBufferfi(GL_DEPTH_STENCIL, 0, depth, stencil);
        break;

      default:
        (0, _assert.assert)(false, ERR_ARGUMENTS);
    }
  });
}
},{"@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js"}],"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/format-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.glFormatToComponents = glFormatToComponents;
exports.glTypeToBytes = glTypeToBytes;

var _assert = require("../utils/assert");

function glFormatToComponents(format) {
  switch (format) {
    case 6406:
    case 33326:
    case 6403:
      return 1;

    case 33328:
    case 33319:
      return 2;

    case 6407:
    case 34837:
      return 3;

    case 6408:
    case 34836:
      return 4;

    default:
      (0, _assert.assert)(false);
      return 0;
  }
}

function glTypeToBytes(type) {
  switch (type) {
    case 5121:
      return 1;

    case 33635:
    case 32819:
    case 32820:
      return 2;

    case 5126:
      return 4;

    default:
      (0, _assert.assert)(false);
      return 0;
  }
}
},{"../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/copy-and-blit.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.blit = blit;
exports.copyToDataUrl = copyToDataUrl;
exports.copyToImage = copyToImage;
exports.copyToTexture = copyToTexture;
exports.readPixelsToArray = readPixelsToArray;
exports.readPixelsToBuffer = readPixelsToBuffer;

var _buffer = _interopRequireDefault(require("./buffer"));

var _framebuffer = _interopRequireDefault(require("./framebuffer"));

var _texture = _interopRequireDefault(require("./texture"));

var _gltools = require("@luma.gl/gltools");

var _typedArrayUtils = require("../webgl-utils/typed-array-utils");

var _formatUtils = require("../webgl-utils/format-utils");

var _textureUtils = require("../webgl-utils/texture-utils");

var _assert = require("../utils/assert");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function readPixelsToArray(source, options = {}) {
  const {
    sourceX = 0,
    sourceY = 0,
    sourceFormat = 6408
  } = options;
  let {
    sourceAttachment = 36064,
    target = null,
    sourceWidth,
    sourceHeight,
    sourceType
  } = options;
  const {
    framebuffer,
    deleteFramebuffer
  } = getFramebuffer(source);
  (0, _assert.assert)(framebuffer);
  const {
    gl,
    handle,
    attachments
  } = framebuffer;
  sourceWidth = sourceWidth || framebuffer.width;
  sourceHeight = sourceHeight || framebuffer.height;

  if (sourceAttachment === 36064 && handle === null) {
    sourceAttachment = 1028;
  }

  (0, _assert.assert)(attachments[sourceAttachment]);
  sourceType = sourceType || attachments[sourceAttachment].type;
  target = getPixelArray(target, sourceType, sourceFormat, sourceWidth, sourceHeight);
  sourceType = sourceType || (0, _typedArrayUtils.getGLTypeFromTypedArray)(target);
  const prevHandle = gl.bindFramebuffer(36160, handle);
  gl.readPixels(sourceX, sourceY, sourceWidth, sourceHeight, sourceFormat, sourceType, target);
  gl.bindFramebuffer(36160, prevHandle || null);

  if (deleteFramebuffer) {
    framebuffer.delete();
  }

  return target;
}

function readPixelsToBuffer(source, {
  sourceX = 0,
  sourceY = 0,
  sourceFormat = 6408,
  target = null,
  targetByteOffset = 0,
  sourceWidth,
  sourceHeight,
  sourceType
}) {
  const {
    framebuffer,
    deleteFramebuffer
  } = getFramebuffer(source);
  (0, _assert.assert)(framebuffer);
  sourceWidth = sourceWidth || framebuffer.width;
  sourceHeight = sourceHeight || framebuffer.height;
  const gl2 = (0, _gltools.assertWebGL2Context)(framebuffer.gl);
  sourceType = sourceType || (target ? target.type : 5121);

  if (!target) {
    const components = (0, _formatUtils.glFormatToComponents)(sourceFormat);
    const byteCount = (0, _formatUtils.glTypeToBytes)(sourceType);
    const byteLength = targetByteOffset + sourceWidth * sourceHeight * components * byteCount;
    target = new _buffer.default(gl2, {
      byteLength,
      accessor: {
        type: sourceType,
        size: components
      }
    });
  }

  target.bind({
    target: 35051
  });
  (0, _gltools.withParameters)(gl2, {
    framebuffer
  }, () => {
    gl2.readPixels(sourceX, sourceY, sourceWidth, sourceHeight, sourceFormat, sourceType, targetByteOffset);
  });
  target.unbind({
    target: 35051
  });

  if (deleteFramebuffer) {
    framebuffer.delete();
  }

  return target;
}

function copyToDataUrl(source, {
  sourceAttachment = 36064,
  targetMaxHeight = Number.MAX_SAFE_INTEGER
} = {}) {
  let data = readPixelsToArray(source, {
    sourceAttachment
  });
  let {
    width,
    height
  } = source;

  while (height > targetMaxHeight) {
    ({
      data,
      width,
      height
    } = (0, _typedArrayUtils.scalePixels)({
      data,
      width,
      height
    }));
  }

  (0, _typedArrayUtils.flipRows)({
    data,
    width,
    height
  });
  const canvas = document.createElement('canvas');
  canvas.width = width;
  canvas.height = height;
  const context = canvas.getContext('2d');
  const imageData = context.createImageData(width, height);
  imageData.data.set(data);
  context.putImageData(imageData, 0, 0);
  return canvas.toDataURL();
}

function copyToImage(source, {
  sourceAttachment = 36064,
  targetImage = null
} = {}) {
  const dataUrl = copyToDataUrl(source, {
    sourceAttachment
  });
  targetImage = targetImage || new Image();
  targetImage.src = dataUrl;
  return targetImage;
}

function copyToTexture(source, target, options = {}) {
  const {
    sourceX = 0,
    sourceY = 0,
    targetMipmaplevel = 0,
    targetInternalFormat = 6408
  } = options;
  let {
    targetX,
    targetY,
    targetZ,
    width,
    height
  } = options;
  const {
    framebuffer,
    deleteFramebuffer
  } = getFramebuffer(source);
  (0, _assert.assert)(framebuffer);
  const {
    gl,
    handle
  } = framebuffer;
  const isSubCopy = typeof targetX !== 'undefined' || typeof targetY !== 'undefined' || typeof targetZ !== 'undefined';
  targetX = targetX || 0;
  targetY = targetY || 0;
  targetZ = targetZ || 0;
  const prevHandle = gl.bindFramebuffer(36160, handle);
  (0, _assert.assert)(target);
  let texture = null;

  if (target instanceof _texture.default) {
    texture = target;
    width = Number.isFinite(width) ? width : texture.width;
    height = Number.isFinite(height) ? height : texture.height;
    texture.bind(0);
    target = texture.target;
  }

  if (!isSubCopy) {
    gl.copyTexImage2D(target, targetMipmaplevel, targetInternalFormat, sourceX, sourceY, width, height, 0);
  } else {
    switch (target) {
      case 3553:
      case 34067:
        gl.copyTexSubImage2D(target, targetMipmaplevel, targetX, targetY, sourceX, sourceY, width, height);
        break;

      case 35866:
      case 32879:
        const gl2 = (0, _gltools.assertWebGL2Context)(gl);
        gl2.copyTexSubImage3D(target, targetMipmaplevel, targetX, targetY, targetZ, sourceX, sourceY, width, height);
        break;

      default:
    }
  }

  if (texture) {
    texture.unbind();
  }

  gl.bindFramebuffer(36160, prevHandle || null);

  if (deleteFramebuffer) {
    framebuffer.delete();
  }

  return texture;
}

function blit(source, target, options = {}) {
  const {
    sourceX0 = 0,
    sourceY0 = 0,
    targetX0 = 0,
    targetY0 = 0,
    color = true,
    depth = false,
    stencil = false,
    filter = 9728
  } = options;
  let {
    sourceX1,
    sourceY1,
    targetX1,
    targetY1,
    sourceAttachment = 36064,
    mask = 0
  } = options;
  const {
    framebuffer: srcFramebuffer,
    deleteFramebuffer: deleteSrcFramebuffer
  } = getFramebuffer(source);
  const {
    framebuffer: dstFramebuffer,
    deleteFramebuffer: deleteDstFramebuffer
  } = getFramebuffer(target);
  (0, _assert.assert)(srcFramebuffer);
  (0, _assert.assert)(dstFramebuffer);
  const {
    gl,
    handle,
    width,
    height,
    readBuffer
  } = dstFramebuffer;
  const gl2 = (0, _gltools.assertWebGL2Context)(gl);

  if (!srcFramebuffer.handle && sourceAttachment === 36064) {
    sourceAttachment = 1028;
  }

  if (color) {
    mask |= 16384;
  }

  if (depth) {
    mask |= 256;
  }

  if (stencil) {
    mask |= 1024;
  }

  if (deleteSrcFramebuffer || deleteDstFramebuffer) {
    if (mask & (256 | 1024)) {
      mask = 16384;

      _gltools.log.warn('Blitting from or into a Texture object, forcing mask to GL.COLOR_BUFFER_BIT')();
    }
  }

  (0, _assert.assert)(mask);
  sourceX1 = sourceX1 === undefined ? srcFramebuffer.width : sourceX1;
  sourceY1 = sourceY1 === undefined ? srcFramebuffer.height : sourceY1;
  targetX1 = targetX1 === undefined ? width : targetX1;
  targetY1 = targetY1 === undefined ? height : targetY1;
  const prevDrawHandle = gl.bindFramebuffer(36009, handle);
  const prevReadHandle = gl.bindFramebuffer(36008, srcFramebuffer.handle);
  gl2.readBuffer(sourceAttachment);
  gl2.blitFramebuffer(sourceX0, sourceY0, sourceX1, sourceY1, targetX0, targetY0, targetX1, targetY1, mask, filter);
  gl2.readBuffer(readBuffer);
  gl2.bindFramebuffer(36008, prevReadHandle || null);
  gl2.bindFramebuffer(36009, prevDrawHandle || null);

  if (deleteSrcFramebuffer) {
    srcFramebuffer.delete();
  }

  if (deleteDstFramebuffer) {
    dstFramebuffer.delete();
  }

  return dstFramebuffer;
}

function getFramebuffer(source) {
  if (!(source instanceof _framebuffer.default)) {
    return {
      framebuffer: (0, _textureUtils.toFramebuffer)(source),
      deleteFramebuffer: true
    };
  }

  return {
    framebuffer: source,
    deleteFramebuffer: false
  };
}

function getPixelArray(pixelArray, type, format, width, height) {
  if (pixelArray) {
    return pixelArray;
  }

  type = type || 5121;
  const ArrayType = (0, _typedArrayUtils.getTypedArrayFromGLType)(type, {
    clamped: false
  });
  const components = (0, _formatUtils.glFormatToComponents)(format);
  return new ArrayType(width * height * components);
}
},{"./buffer":"node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js","./framebuffer":"node_modules/@luma.gl/webgl/dist/esm/classes/framebuffer.js","./texture":"node_modules/@luma.gl/webgl/dist/esm/classes/texture.js","@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","../webgl-utils/typed-array-utils":"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/typed-array-utils.js","../webgl-utils/format-utils":"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/format-utils.js","../webgl-utils/texture-utils":"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/texture-utils.js","../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js"}],"node_modules/@luma.gl/webgl/dist/esm/features/webgl-limits-table.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = {
  [33902]: {
    gl1: new Float32Array([1, 1])
  },
  [33901]: {
    gl1: new Float32Array([1, 1])
  },
  [3379]: {
    gl1: 64,
    gl2: 2048
  },
  [34076]: {
    gl1: 16
  },
  [34930]: {
    gl1: 8
  },
  [35661]: {
    gl1: 8
  },
  [35660]: {
    gl1: 0
  },
  [34024]: {
    gl1: 1
  },
  [36348]: {
    gl1: 8
  },
  [34921]: {
    gl1: 8
  },
  [36347]: {
    gl1: 128
  },
  [36349]: {
    gl1: 16
  },
  [3386]: {
    gl1: new Int32Array([0, 0])
  },
  [32883]: {
    gl1: 0,
    gl2: 256
  },
  [35071]: {
    gl1: 0,
    gl2: 256
  },
  [37447]: {
    gl1: 0,
    gl2: 0
  },
  [36063]: {
    gl1: 0,
    gl2: 4
  },
  [35379]: {
    gl1: 0,
    gl2: 0
  },
  [35374]: {
    gl1: 0,
    gl2: 0
  },
  [35377]: {
    gl1: 0,
    gl2: 0
  },
  [34852]: {
    gl1: 0,
    gl2: 4
  },
  [36203]: {
    gl1: 0,
    gl2: 0
  },
  [33001]: {
    gl1: 0,
    gl2: 0
  },
  [33000]: {
    gl1: 0,
    gl2: 0
  },
  [37157]: {
    gl1: 0,
    gl2: 0
  },
  [35373]: {
    gl1: 0,
    gl2: 0
  },
  [35657]: {
    gl1: 0,
    gl2: 0
  },
  [36183]: {
    gl1: 0,
    gl2: 0
  },
  [37137]: {
    gl1: 0,
    gl2: 0
  },
  [34045]: {
    gl1: 0,
    gl2: 0
  },
  [35978]: {
    gl1: 0,
    gl2: 0
  },
  [35979]: {
    gl1: 0,
    gl2: 0
  },
  [35968]: {
    gl1: 0,
    gl2: 0
  },
  [35376]: {
    gl1: 0,
    gl2: 0
  },
  [35375]: {
    gl1: 0,
    gl2: 0
  },
  [35659]: {
    gl1: 0,
    gl2: 0
  },
  [37154]: {
    gl1: 0,
    gl2: 0
  },
  [35371]: {
    gl1: 0,
    gl2: 0
  },
  [35658]: {
    gl1: 0,
    gl2: 0
  },
  [35076]: {
    gl1: 0,
    gl2: -8,
    negative: true
  },
  [35077]: {
    gl1: 0,
    gl2: 7
  },
  [35380]: {
    gl1: 0,
    gl2: 0
  }
};
exports.default = _default;
},{}],"node_modules/@luma.gl/webgl/dist/esm/features/limits.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getContextInfo = getContextInfo;
exports.getContextLimits = getContextLimits;
exports.getGLContextInfo = getGLContextInfo;

var _webglLimitsTable = _interopRequireDefault(require("./webgl-limits-table"));

var _gltools = require("@luma.gl/gltools");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getContextLimits(gl) {
  gl.luma = gl.luma || {};

  if (!gl.luma.limits) {
    gl.luma.limits = {};
    gl.luma.webgl1MinLimits = {};
    gl.luma.webgl2MinLimits = {};
    const isWebgl2 = (0, _gltools.isWebGL2)(gl);

    for (const parameter in _webglLimitsTable.default) {
      const limit = _webglLimitsTable.default[parameter];
      const webgl1MinLimit = limit.gl1;
      const webgl2MinLimit = 'gl2' in limit ? limit.gl2 : limit.gl1;
      const minLimit = isWebgl2 ? webgl2MinLimit : webgl1MinLimit;
      const limitNotAvailable = 'gl2' in limit && !isWebgl2 || 'extension' in limit && !gl.getExtension(limit.extension);
      const value = limitNotAvailable ? minLimit : gl.getParameter(parameter);
      gl.luma.limits[parameter] = value;
      gl.luma.webgl1MinLimits[parameter] = webgl1MinLimit;
      gl.luma.webgl2MinLimits[parameter] = webgl2MinLimit;
    }
  }

  return gl.luma.limits;
}

function getGLContextInfo(gl) {
  gl.luma = gl.luma || {};
  const info = (0, _gltools.getContextDebugInfo)(gl);

  if (!gl.luma.info) {
    gl.luma.info = {
      [37445]: info.vendor,
      [37446]: info.renderer,
      [7936]: info.vendorMasked,
      [7937]: info.rendererMasked,
      [7938]: info.version,
      [35724]: info.shadingLanguageVersion
    };
  }

  return gl.luma.info;
}

function getContextInfo(gl) {
  return Object.assign((0, _gltools.getContextDebugInfo)(gl), {
    limits: getContextLimits(gl),
    info: getGLContextInfo(gl),
    webgl1MinLimits: gl.luma.webgl1MinLimits,
    webgl2MinLimits: gl.luma.webgl2MinLimits
  });
}
},{"./webgl-limits-table":"node_modules/@luma.gl/webgl/dist/esm/features/webgl-limits-table.js","@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js"}],"node_modules/@luma.gl/webgl/dist/esm/features/webgl-features-table.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.FEATURES = void 0;

var _framebuffer = _interopRequireDefault(require("../classes/framebuffer"));

var _texture2d = _interopRequireDefault(require("../classes/texture-2d"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const FEATURES = {
  WEBGL2: 'WEBGL2',
  VERTEX_ARRAY_OBJECT: 'VERTEX_ARRAY_OBJECT',
  TIMER_QUERY: 'TIMER_QUERY',
  INSTANCED_RENDERING: 'INSTANCED_RENDERING',
  MULTIPLE_RENDER_TARGETS: 'MULTIPLE_RENDER_TARGETS',
  ELEMENT_INDEX_UINT32: 'ELEMENT_INDEX_UINT32',
  BLEND_EQUATION_MINMAX: 'BLEND_EQUATION_MINMAX',
  FLOAT_BLEND: 'FLOAT_BLEND',
  COLOR_ENCODING_SRGB: 'COLOR_ENCODING_SRGB',
  TEXTURE_DEPTH: 'TEXTURE_DEPTH',
  TEXTURE_FLOAT: 'TEXTURE_FLOAT',
  TEXTURE_HALF_FLOAT: 'TEXTURE_HALF_FLOAT',
  TEXTURE_FILTER_LINEAR_FLOAT: 'TEXTURE_FILTER_LINEAR_FLOAT',
  TEXTURE_FILTER_LINEAR_HALF_FLOAT: 'TEXTURE_FILTER_LINEAR_HALF_FLOAT',
  TEXTURE_FILTER_ANISOTROPIC: 'TEXTURE_FILTER_ANISOTROPIC',
  COLOR_ATTACHMENT_RGBA32F: 'COLOR_ATTACHMENT_RGBA32F',
  COLOR_ATTACHMENT_FLOAT: 'COLOR_ATTACHMENT_FLOAT',
  COLOR_ATTACHMENT_HALF_FLOAT: 'COLOR_ATTACHMENT_HALF_FLOAT',
  GLSL_FRAG_DATA: 'GLSL_FRAG_DATA',
  GLSL_FRAG_DEPTH: 'GLSL_FRAG_DEPTH',
  GLSL_DERIVATIVES: 'GLSL_DERIVATIVES',
  GLSL_TEXTURE_LOD: 'GLSL_TEXTURE_LOD'
};
exports.FEATURES = FEATURES;

function checkFloat32ColorAttachment(gl) {
  const testTexture = new _texture2d.default(gl, {
    format: 6408,
    type: 5126,
    dataFormat: 6408
  });
  const testFb = new _framebuffer.default(gl, {
    id: `test-framebuffer`,
    check: false,
    attachments: {
      [36064]: testTexture
    }
  });
  const status = testFb.getStatus();
  testTexture.delete();
  testFb.delete();
  return status === 36053;
}

var _default = {
  [FEATURES.WEBGL2]: [false, true],
  [FEATURES.VERTEX_ARRAY_OBJECT]: ['OES_vertex_array_object', true],
  [FEATURES.TIMER_QUERY]: ['EXT_disjoint_timer_query', 'EXT_disjoint_timer_query_webgl2'],
  [FEATURES.INSTANCED_RENDERING]: ['ANGLE_instanced_arrays', true],
  [FEATURES.MULTIPLE_RENDER_TARGETS]: ['WEBGL_draw_buffers', true],
  [FEATURES.ELEMENT_INDEX_UINT32]: ['OES_element_index_uint', true],
  [FEATURES.BLEND_EQUATION_MINMAX]: ['EXT_blend_minmax', true],
  [FEATURES.FLOAT_BLEND]: ['EXT_float_blend'],
  [FEATURES.COLOR_ENCODING_SRGB]: ['EXT_sRGB', true],
  [FEATURES.TEXTURE_DEPTH]: ['WEBGL_depth_texture', true],
  [FEATURES.TEXTURE_FLOAT]: ['OES_texture_float', true],
  [FEATURES.TEXTURE_HALF_FLOAT]: ['OES_texture_half_float', true],
  [FEATURES.TEXTURE_FILTER_LINEAR_FLOAT]: ['OES_texture_float_linear'],
  [FEATURES.TEXTURE_FILTER_LINEAR_HALF_FLOAT]: ['OES_texture_half_float_linear'],
  [FEATURES.TEXTURE_FILTER_ANISOTROPIC]: ['EXT_texture_filter_anisotropic'],
  [FEATURES.COLOR_ATTACHMENT_RGBA32F]: [checkFloat32ColorAttachment, 'EXT_color_buffer_float'],
  [FEATURES.COLOR_ATTACHMENT_FLOAT]: [false, 'EXT_color_buffer_float'],
  [FEATURES.COLOR_ATTACHMENT_HALF_FLOAT]: ['EXT_color_buffer_half_float'],
  [FEATURES.GLSL_FRAG_DATA]: ['WEBGL_draw_buffers', true],
  [FEATURES.GLSL_FRAG_DEPTH]: ['EXT_frag_depth', true],
  [FEATURES.GLSL_DERIVATIVES]: ['OES_standard_derivatives', true],
  [FEATURES.GLSL_TEXTURE_LOD]: ['EXT_shader_texture_lod', true]
};
exports.default = _default;
},{"../classes/framebuffer":"node_modules/@luma.gl/webgl/dist/esm/classes/framebuffer.js","../classes/texture-2d":"node_modules/@luma.gl/webgl/dist/esm/classes/texture-2d.js"}],"node_modules/@luma.gl/webgl/dist/esm/features/features.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getFeatures = getFeatures;
exports.hasFeature = hasFeature;
exports.hasFeatures = hasFeatures;

var _webglFeaturesTable = _interopRequireDefault(require("./webgl-features-table"));

var _gltools = require("@luma.gl/gltools");

var _assert = require("../utils/assert");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const LOG_UNSUPPORTED_FEATURE = 2;

function hasFeature(gl, feature) {
  return hasFeatures(gl, feature);
}

function hasFeatures(gl, features) {
  features = Array.isArray(features) ? features : [features];
  return features.every(feature => {
    return isFeatureSupported(gl, feature);
  });
}

function getFeatures(gl) {
  gl.luma = gl.luma || {};
  gl.luma.caps = gl.luma.caps || {};

  for (const cap in _webglFeaturesTable.default) {
    if (gl.luma.caps[cap] === undefined) {
      gl.luma.caps[cap] = isFeatureSupported(gl, cap);
    }
  }

  return gl.luma.caps;
}

function isFeatureSupported(gl, cap) {
  gl.luma = gl.luma || {};
  gl.luma.caps = gl.luma.caps || {};

  if (gl.luma.caps[cap] === undefined) {
    gl.luma.caps[cap] = queryFeature(gl, cap);
  }

  if (!gl.luma.caps[cap]) {
    _gltools.log.log(LOG_UNSUPPORTED_FEATURE, `Feature: ${cap} not supported`)();
  }

  return gl.luma.caps[cap];
}

function queryFeature(gl, cap) {
  const feature = _webglFeaturesTable.default[cap];
  (0, _assert.assert)(feature, cap);
  let isSupported;
  const featureDefinition = (0, _gltools.isWebGL2)(gl) ? feature[1] || feature[0] : feature[0];

  if (typeof featureDefinition === 'function') {
    isSupported = featureDefinition(gl);
  } else if (Array.isArray(featureDefinition)) {
    isSupported = true;

    for (const extension of featureDefinition) {
      isSupported = isSupported && Boolean(gl.getExtension(extension));
    }
  } else if (typeof featureDefinition === 'string') {
    isSupported = Boolean(gl.getExtension(featureDefinition));
  } else if (typeof featureDefinition === 'boolean') {
    isSupported = featureDefinition;
  } else {
    (0, _assert.assert)(false);
  }

  return isSupported;
}
},{"./webgl-features-table":"node_modules/@luma.gl/webgl/dist/esm/features/webgl-features-table.js","@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js"}],"node_modules/@luma.gl/webgl/dist/esm/features/check-old-ie.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isOldIE;

function isOldIE(opts = {}) {
  const navigator = typeof window !== 'undefined' && window.navigator || {};
  const userAgent = opts.userAgent || navigator.userAgent || '';
  const isMSIE = userAgent.indexOf('MSIE ') !== -1;
  const isTrident = userAgent.indexOf('Trident/') !== -1;
  return isMSIE || isTrident;
}
},{}],"node_modules/@luma.gl/webgl/dist/esm/features/check-glsl-extension.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = canCompileGLGSExtension;

var _checkOldIe = _interopRequireDefault(require("./check-old-ie"));

var _webglFeaturesTable = _interopRequireDefault(require("./webgl-features-table"));

var _assert = require("../utils/assert");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const compiledGlslExtensions = {};

function canCompileGLGSExtension(gl, cap, options = {}) {
  const feature = _webglFeaturesTable.default[cap];
  (0, _assert.assert)(feature, cap);

  if (!(0, _checkOldIe.default)(options)) {
    return true;
  }

  if (cap in compiledGlslExtensions) {
    return compiledGlslExtensions[cap];
  }

  const extensionName = feature[0];
  const source = `#extension GL_${extensionName} : enable\nvoid main(void) {}`;
  const shader = gl.createShader(35633);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  const canCompile = gl.getShaderParameter(shader, 35713);
  gl.deleteShader(shader);
  compiledGlslExtensions[cap] = canCompile;
  return canCompile;
}
},{"./check-old-ie":"node_modules/@luma.gl/webgl/dist/esm/features/check-old-ie.js","./webgl-features-table":"node_modules/@luma.gl/webgl/dist/esm/features/webgl-features-table.js","../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js"}],"node_modules/@luma.gl/webgl/dist/esm/features/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "FEATURES", {
  enumerable: true,
  get: function () {
    return _webglFeaturesTable.FEATURES;
  }
});
Object.defineProperty(exports, "canCompileGLGSExtension", {
  enumerable: true,
  get: function () {
    return _checkGlslExtension.default;
  }
});
Object.defineProperty(exports, "getContextInfo", {
  enumerable: true,
  get: function () {
    return _limits.getContextInfo;
  }
});
Object.defineProperty(exports, "getContextLimits", {
  enumerable: true,
  get: function () {
    return _limits.getContextLimits;
  }
});
Object.defineProperty(exports, "getFeatures", {
  enumerable: true,
  get: function () {
    return _features.getFeatures;
  }
});
Object.defineProperty(exports, "getGLContextInfo", {
  enumerable: true,
  get: function () {
    return _limits.getGLContextInfo;
  }
});
Object.defineProperty(exports, "hasFeature", {
  enumerable: true,
  get: function () {
    return _features.hasFeature;
  }
});
Object.defineProperty(exports, "hasFeatures", {
  enumerable: true,
  get: function () {
    return _features.hasFeatures;
  }
});

var _limits = require("./limits");

var _webglFeaturesTable = require("./webgl-features-table");

var _features = require("./features");

var _checkGlslExtension = _interopRequireDefault(require("./check-glsl-extension"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./limits":"node_modules/@luma.gl/webgl/dist/esm/features/limits.js","./webgl-features-table":"node_modules/@luma.gl/webgl/dist/esm/features/webgl-features-table.js","./features":"node_modules/@luma.gl/webgl/dist/esm/features/features.js","./check-glsl-extension":"node_modules/@luma.gl/webgl/dist/esm/features/check-glsl-extension.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/framebuffer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.FRAMEBUFFER_ATTACHMENT_PARAMETERS = void 0;

var _gltools = require("@luma.gl/gltools");

var _resource = _interopRequireDefault(require("./resource"));

var _texture2d = _interopRequireDefault(require("./texture-2d"));

var _renderbuffer = _interopRequireDefault(require("./renderbuffer"));

var _clear = require("./clear");

var _copyAndBlit = require("./copy-and-blit.js");

var _features = require("../features");

var _constantsToKeys = require("../webgl-utils/constants-to-keys");

var _assert = require("../utils/assert");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const ERR_MULTIPLE_RENDERTARGETS = 'Multiple render targets not supported';

class Framebuffer extends _resource.default {
  get [Symbol.toStringTag]() {
    return 'Framebuffer';
  }

  static isSupported(gl, options = {}) {
    const {
      colorBufferFloat,
      colorBufferHalfFloat
    } = options;
    let supported = true;

    if (colorBufferFloat) {
      supported = Boolean(gl.getExtension('EXT_color_buffer_float') || gl.getExtension('WEBGL_color_buffer_float') || gl.getExtension('OES_texture_float'));
    }

    if (colorBufferHalfFloat) {
      supported = supported && Boolean(gl.getExtension('EXT_color_buffer_float') || gl.getExtension('EXT_color_buffer_half_float'));
    }

    return supported;
  }

  static getDefaultFramebuffer(gl) {
    gl.luma = gl.luma || {};
    gl.luma.defaultFramebuffer = gl.luma.defaultFramebuffer || new Framebuffer(gl, {
      id: 'default-framebuffer',
      handle: null,
      attachments: {}
    });
    return gl.luma.defaultFramebuffer;
  }

  get MAX_COLOR_ATTACHMENTS() {
    const gl2 = (0, _gltools.assertWebGL2Context)(this.gl);
    return gl2.getParameter(gl2.MAX_COLOR_ATTACHMENTS);
  }

  get MAX_DRAW_BUFFERS() {
    const gl2 = (0, _gltools.assertWebGL2Context)(this.gl);
    return gl2.getParameter(gl2.MAX_DRAW_BUFFERS);
  }

  constructor(gl, opts = {}) {
    super(gl, opts);
    this.width = null;
    this.height = null;
    this.attachments = {};
    this.readBuffer = 36064;
    this.drawBuffers = [36064];
    this.ownResources = [];
    this.initialize(opts);
    Object.seal(this);
  }

  get color() {
    return this.attachments[36064] || null;
  }

  get texture() {
    return this.attachments[36064] || null;
  }

  get depth() {
    return this.attachments[36096] || this.attachments[33306] || null;
  }

  get stencil() {
    return this.attachments[36128] || this.attachments[33306] || null;
  }

  initialize({
    width = 1,
    height = 1,
    attachments = null,
    color = true,
    depth = true,
    stencil = false,
    check = true,
    readBuffer = undefined,
    drawBuffers = undefined
  }) {
    (0, _assert.assert)(width >= 0 && height >= 0, 'Width and height need to be integers');
    this.width = width;
    this.height = height;

    if (attachments) {
      for (const attachment in attachments) {
        const target = attachments[attachment];
        const object = Array.isArray(target) ? target[0] : target;
        object.resize({
          width,
          height
        });
      }
    } else {
      attachments = this._createDefaultAttachments(color, depth, stencil, width, height);
    }

    this.update({
      clearAttachments: true,
      attachments,
      readBuffer,
      drawBuffers
    });

    if (attachments && check) {
      this.checkStatus();
    }
  }

  delete() {
    for (const resource of this.ownResources) {
      resource.delete();
    }

    super.delete();
    return this;
  }

  update({
    attachments = {},
    readBuffer,
    drawBuffers,
    clearAttachments = false,
    resizeAttachments = true
  }) {
    this.attach(attachments, {
      clearAttachments,
      resizeAttachments
    });
    const {
      gl
    } = this;
    const prevHandle = gl.bindFramebuffer(36160, this.handle);

    if (readBuffer) {
      this._setReadBuffer(readBuffer);
    }

    if (drawBuffers) {
      this._setDrawBuffers(drawBuffers);
    }

    gl.bindFramebuffer(36160, prevHandle || null);
    return this;
  }

  resize(options = {}) {
    let {
      width,
      height
    } = options;

    if (this.handle === null) {
      (0, _assert.assert)(width === undefined && height === undefined);
      this.width = this.gl.drawingBufferWidth;
      this.height = this.gl.drawingBufferHeight;
      return this;
    }

    if (width === undefined) {
      width = this.gl.drawingBufferWidth;
    }

    if (height === undefined) {
      height = this.gl.drawingBufferHeight;
    }

    if (width !== this.width && height !== this.height) {
      _gltools.log.log(2, `Resizing framebuffer ${this.id} to ${width}x${height}`)();
    }

    for (const attachmentPoint in this.attachments) {
      this.attachments[attachmentPoint].resize({
        width,
        height
      });
    }

    this.width = width;
    this.height = height;
    return this;
  }

  attach(attachments, {
    clearAttachments = false,
    resizeAttachments = true
  } = {}) {
    const newAttachments = {};

    if (clearAttachments) {
      Object.keys(this.attachments).forEach(key => {
        newAttachments[key] = null;
      });
    }

    Object.assign(newAttachments, attachments);
    const prevHandle = this.gl.bindFramebuffer(36160, this.handle);

    for (const key in newAttachments) {
      (0, _assert.assert)(key !== undefined, 'Misspelled framebuffer binding point?');
      const attachment = Number(key);
      const descriptor = newAttachments[attachment];
      let object = descriptor;

      if (!object) {
        this._unattach(attachment);
      } else if (object instanceof _renderbuffer.default) {
        this._attachRenderbuffer({
          attachment,
          renderbuffer: object
        });
      } else if (Array.isArray(descriptor)) {
        const [texture, layer = 0, level = 0] = descriptor;
        object = texture;

        this._attachTexture({
          attachment,
          texture,
          layer,
          level
        });
      } else {
        this._attachTexture({
          attachment,
          texture: object,
          layer: 0,
          level: 0
        });
      }

      if (resizeAttachments && object) {
        object.resize({
          width: this.width,
          height: this.height
        });
      }
    }

    this.gl.bindFramebuffer(36160, prevHandle || null);
    Object.assign(this.attachments, attachments);
    Object.keys(this.attachments).filter(key => !this.attachments[key]).forEach(key => {
      delete this.attachments[key];
    });
  }

  checkStatus() {
    const {
      gl
    } = this;
    const status = this.getStatus();

    if (status !== 36053) {
      throw new Error(_getFrameBufferStatus(status));
    }

    return this;
  }

  getStatus() {
    const {
      gl
    } = this;
    const prevHandle = gl.bindFramebuffer(36160, this.handle);
    const status = gl.checkFramebufferStatus(36160);
    gl.bindFramebuffer(36160, prevHandle || null);
    return status;
  }

  clear(options = {}) {
    const {
      color,
      depth,
      stencil,
      drawBuffers = []
    } = options;
    const prevHandle = this.gl.bindFramebuffer(36160, this.handle);

    if (color || depth || stencil) {
      (0, _clear.clear)(this.gl, {
        color,
        depth,
        stencil
      });
    }

    drawBuffers.forEach((value, drawBuffer) => {
      (0, _clear.clearBuffer)(this.gl, {
        drawBuffer,
        value
      });
    });
    this.gl.bindFramebuffer(36160, prevHandle || null);
    return this;
  }

  readPixels(opts = {}) {
    _gltools.log.error('Framebuffer.readPixels() is no logner supported, use readPixelsToArray(framebuffer)')();

    return null;
  }

  readPixelsToBuffer(opts = {}) {
    _gltools.log.error('Framebuffer.readPixelsToBuffer()is no logner supported, use readPixelsToBuffer(framebuffer)')();

    return null;
  }

  copyToDataUrl(opts = {}) {
    _gltools.log.error('Framebuffer.copyToDataUrl() is no logner supported, use copyToDataUrl(framebuffer)')();

    return null;
  }

  copyToImage(opts = {}) {
    _gltools.log.error('Framebuffer.copyToImage() is no logner supported, use copyToImage(framebuffer)')();

    return null;
  }

  copyToTexture(opts = {}) {
    _gltools.log.error('Framebuffer.copyToTexture({...}) is no logner supported, use copyToTexture(source, target, opts})')();

    return null;
  }

  blit(opts = {}) {
    _gltools.log.error('Framebuffer.blit({...}) is no logner supported, use blit(source, target, opts)')();

    return null;
  }

  invalidate({
    attachments = [],
    x = 0,
    y = 0,
    width,
    height
  }) {
    const gl2 = (0, _gltools.assertWebGL2Context)(this.gl);
    const prevHandle = gl2.bindFramebuffer(36008, this.handle);
    const invalidateAll = x === 0 && y === 0 && width === undefined && height === undefined;

    if (invalidateAll) {
      gl2.invalidateFramebuffer(36008, attachments);
    } else {
      gl2.invalidateFramebuffer(36008, attachments, x, y, width, height);
    }

    gl2.bindFramebuffer(36008, prevHandle);
    return this;
  }

  getAttachmentParameter(attachment, pname, keys) {
    let value = this._getAttachmentParameterFallback(pname);

    if (value === null) {
      this.gl.bindFramebuffer(36160, this.handle);
      value = this.gl.getFramebufferAttachmentParameter(36160, attachment, pname);
      this.gl.bindFramebuffer(36160, null);
    }

    if (keys && value > 1000) {
      value = (0, _constantsToKeys.getKey)(this.gl, value);
    }

    return value;
  }

  getAttachmentParameters(attachment = 36064, keys, parameters = this.constructor.ATTACHMENT_PARAMETERS || []) {
    const values = {};

    for (const pname of parameters) {
      const key = keys ? (0, _constantsToKeys.getKey)(this.gl, pname) : pname;
      values[key] = this.getAttachmentParameter(attachment, pname, keys);
    }

    return values;
  }

  getParameters(keys = true) {
    const attachments = Object.keys(this.attachments);
    const parameters = {};

    for (const attachmentName of attachments) {
      const attachment = Number(attachmentName);
      const key = keys ? (0, _constantsToKeys.getKey)(this.gl, attachment) : attachment;
      parameters[key] = this.getAttachmentParameters(attachment, keys);
    }

    return parameters;
  }

  show() {
    if (typeof window !== 'undefined') {
      window.open((0, _copyAndBlit.copyToDataUrl)(this), 'luma-debug-texture');
    }

    return this;
  }

  log(logLevel = 0, message = '') {
    if (logLevel > _gltools.log.level || typeof window === 'undefined') {
      return this;
    }

    message = message || `Framebuffer ${this.id}`;
    const image = (0, _copyAndBlit.copyToDataUrl)(this, {
      targetMaxHeight: 100
    });

    _gltools.log.image({
      logLevel,
      message,
      image
    }, message)();

    return this;
  }

  bind({
    target = 36160
  } = {}) {
    this.gl.bindFramebuffer(target, this.handle);
    return this;
  }

  unbind({
    target = 36160
  } = {}) {
    this.gl.bindFramebuffer(target, null);
    return this;
  }

  _createDefaultAttachments(color, depth, stencil, width, height) {
    let defaultAttachments = null;

    if (color) {
      defaultAttachments = defaultAttachments || {};
      defaultAttachments[36064] = new _texture2d.default(this.gl, {
        id: `${this.id}-color0`,
        pixels: null,
        format: 6408,
        type: 5121,
        width,
        height,
        mipmaps: false,
        parameters: {
          [10241]: 9729,
          [10240]: 9729,
          [10242]: 33071,
          [10243]: 33071
        }
      });
      this.ownResources.push(defaultAttachments[36064]);
    }

    if (depth && stencil) {
      defaultAttachments = defaultAttachments || {};
      defaultAttachments[33306] = new _renderbuffer.default(this.gl, {
        id: `${this.id}-depth-stencil`,
        format: 35056,
        width,
        height: 111
      });
      this.ownResources.push(defaultAttachments[33306]);
    } else if (depth) {
      defaultAttachments = defaultAttachments || {};
      defaultAttachments[36096] = new _renderbuffer.default(this.gl, {
        id: `${this.id}-depth`,
        format: 33189,
        width,
        height
      });
      this.ownResources.push(defaultAttachments[36096]);
    } else if (stencil) {
      (0, _assert.assert)(false);
    }

    return defaultAttachments;
  }

  _unattach(attachment) {
    const oldAttachment = this.attachments[attachment];

    if (!oldAttachment) {
      return;
    }

    if (oldAttachment instanceof _renderbuffer.default) {
      this.gl.framebufferRenderbuffer(36160, attachment, 36161, null);
    } else {
      this.gl.framebufferTexture2D(36160, attachment, 3553, null, 0);
    }

    delete this.attachments[attachment];
  }

  _attachRenderbuffer({
    attachment = 36064,
    renderbuffer
  }) {
    const {
      gl
    } = this;
    gl.framebufferRenderbuffer(36160, attachment, 36161, renderbuffer.handle);
    this.attachments[attachment] = renderbuffer;
  }

  _attachTexture({
    attachment = 36064,
    texture,
    layer,
    level
  }) {
    const {
      gl
    } = this;
    gl.bindTexture(texture.target, texture.handle);

    switch (texture.target) {
      case 35866:
      case 32879:
        const gl2 = (0, _gltools.assertWebGL2Context)(gl);
        gl2.framebufferTextureLayer(36160, attachment, texture.target, level, layer);
        break;

      case 34067:
        const face = mapIndexToCubeMapFace(layer);
        gl.framebufferTexture2D(36160, attachment, face, texture.handle, level);
        break;

      case 3553:
        gl.framebufferTexture2D(36160, attachment, 3553, texture.handle, level);
        break;

      default:
        (0, _assert.assert)(false, 'Illegal texture type');
    }

    gl.bindTexture(texture.target, null);
    this.attachments[attachment] = texture;
  }

  _setReadBuffer(readBuffer) {
    const gl2 = (0, _gltools.getWebGL2Context)(this.gl);

    if (gl2) {
      gl2.readBuffer(readBuffer);
    } else {
      (0, _assert.assert)(readBuffer === 36064 || readBuffer === 1029, ERR_MULTIPLE_RENDERTARGETS);
    }

    this.readBuffer = readBuffer;
  }

  _setDrawBuffers(drawBuffers) {
    const {
      gl
    } = this;
    const gl2 = (0, _gltools.assertWebGL2Context)(gl);

    if (gl2) {
      gl2.drawBuffers(drawBuffers);
    } else {
      const ext = gl.getExtension('WEBGL_draw_buffers');

      if (ext) {
        ext.drawBuffersWEBGL(drawBuffers);
      } else {
        (0, _assert.assert)(drawBuffers.length === 1 && (drawBuffers[0] === 36064 || drawBuffers[0] === 1029), ERR_MULTIPLE_RENDERTARGETS);
      }
    }

    this.drawBuffers = drawBuffers;
  }

  _getAttachmentParameterFallback(pname) {
    const caps = (0, _features.getFeatures)(this.gl);

    switch (pname) {
      case 36052:
        return !caps.WEBGL2 ? 0 : null;

      case 33298:
      case 33299:
      case 33300:
      case 33301:
      case 33302:
      case 33303:
        return !caps.WEBGL2 ? 8 : null;

      case 33297:
        return !caps.WEBGL2 ? 5125 : null;

      case 33296:
        return !caps.WEBGL2 && !caps.EXT_sRGB ? 9729 : null;

      default:
        return null;
    }
  }

  _createHandle() {
    return this.gl.createFramebuffer();
  }

  _deleteHandle() {
    this.gl.deleteFramebuffer(this.handle);
  }

  _bindHandle(handle) {
    return this.gl.bindFramebuffer(36160, handle);
  }

}

exports.default = Framebuffer;

function mapIndexToCubeMapFace(layer) {
  return layer < 34069 ? layer + 34069 : layer;
}

function _getFrameBufferStatus(status) {
  const STATUS = Framebuffer.STATUS || {};
  return STATUS[status] || `Framebuffer error ${status}`;
}

const FRAMEBUFFER_ATTACHMENT_PARAMETERS = [36049, 36048, 33296, 33298, 33299, 33300, 33301, 33302, 33303];
exports.FRAMEBUFFER_ATTACHMENT_PARAMETERS = FRAMEBUFFER_ATTACHMENT_PARAMETERS;
Framebuffer.ATTACHMENT_PARAMETERS = FRAMEBUFFER_ATTACHMENT_PARAMETERS;
},{"@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","./resource":"node_modules/@luma.gl/webgl/dist/esm/classes/resource.js","./texture-2d":"node_modules/@luma.gl/webgl/dist/esm/classes/texture-2d.js","./renderbuffer":"node_modules/@luma.gl/webgl/dist/esm/classes/renderbuffer.js","./clear":"node_modules/@luma.gl/webgl/dist/esm/classes/clear.js","./copy-and-blit.js":"node_modules/@luma.gl/webgl/dist/esm/classes/copy-and-blit.js","../features":"node_modules/@luma.gl/webgl/dist/esm/features/index.js","../webgl-utils/constants-to-keys":"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/constants-to-keys.js","../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js"}],"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/texture-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cloneTextureFrom = cloneTextureFrom;
exports.toFramebuffer = toFramebuffer;

var _texture2d = _interopRequireDefault(require("../classes/texture-2d"));

var _textureCube = _interopRequireDefault(require("../classes/texture-cube"));

var _texture3d = _interopRequireDefault(require("../classes/texture-3d"));

var _framebuffer = _interopRequireDefault(require("../classes/framebuffer"));

var _assert = require("../utils/assert");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function cloneTextureFrom(refTexture, overrides) {
  (0, _assert.assert)(refTexture instanceof _texture2d.default || refTexture instanceof _textureCube.default || refTexture instanceof _texture3d.default);
  const TextureType = refTexture.constructor;
  const {
    gl,
    width,
    height,
    format,
    type,
    dataFormat,
    border,
    mipmaps
  } = refTexture;
  const textureOptions = Object.assign({
    width,
    height,
    format,
    type,
    dataFormat,
    border,
    mipmaps
  }, overrides);
  return new TextureType(gl, textureOptions);
}

function toFramebuffer(texture, opts) {
  const {
    gl,
    width,
    height,
    id
  } = texture;
  const framebuffer = new _framebuffer.default(gl, Object.assign({}, opts, {
    id: `framebuffer-for-${id}`,
    width,
    height,
    attachments: {
      [36064]: texture
    }
  }));
  return framebuffer;
}
},{"../classes/texture-2d":"node_modules/@luma.gl/webgl/dist/esm/classes/texture-2d.js","../classes/texture-cube":"node_modules/@luma.gl/webgl/dist/esm/classes/texture-cube.js","../classes/texture-3d":"node_modules/@luma.gl/webgl/dist/esm/classes/texture-3d.js","../classes/framebuffer":"node_modules/@luma.gl/webgl/dist/esm/classes/framebuffer.js","../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js"}],"node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-name.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getShaderName;

function getShaderName(shader, defaultName = 'unnamed') {
  const SHADER_NAME_REGEXP = /#define[\s*]SHADER_NAME[\s*]([A-Za-z0-9_-]+)[\s*]/;
  const match = shader.match(SHADER_NAME_REGEXP);
  return match ? match[1] : defaultName;
}
},{}],"node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-type-name.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getShaderTypeName;
const GL_FRAGMENT_SHADER = 0x8b30;
const GL_VERTEX_SHADER = 0x8b31;

function getShaderTypeName(type) {
  switch (type) {
    case GL_FRAGMENT_SHADER:
      return 'fragment';

    case GL_VERTEX_SHADER:
      return 'vertex';

    default:
      return 'unknown type';
  }
}
},{}],"node_modules/@luma.gl/webgl/dist/esm/glsl-utils/format-glsl-error.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = formatGLSLCompilerError;
exports.parseGLSLCompilerError = parseGLSLCompilerError;

var _getShaderName = _interopRequireDefault(require("./get-shader-name"));

var _getShaderTypeName = _interopRequireDefault(require("./get-shader-type-name"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function formatGLSLCompilerError(errLog, src, shaderType) {
  const {
    shaderName,
    errors,
    warnings
  } = parseGLSLCompilerError(errLog, src, shaderType);
  return `GLSL compilation error in ${shaderName}\n\n${errors}\n${warnings}`;
}

function parseGLSLCompilerError(errLog, src, shaderType, shaderName) {
  const errorStrings = errLog.split(/\r?\n/);
  const errors = {};
  const warnings = {};
  const name = shaderName || (0, _getShaderName.default)(src) || '(unnamed)';
  const shaderDescription = `${(0, _getShaderTypeName.default)(shaderType)} shader ${name}`;

  for (let i = 0; i < errorStrings.length; i++) {
    const errorString = errorStrings[i];

    if (errorString.length <= 1) {
      continue;
    }

    const segments = errorString.split(':');
    const type = segments[0];
    const line = parseInt(segments[2], 10);

    if (isNaN(line)) {
      throw new Error(`GLSL compilation error in ${shaderDescription}: ${errLog}`);
    }

    if (type !== 'WARNING') {
      errors[line] = errorString;
    } else {
      warnings[line] = errorString;
    }
  }

  const lines = addLineNumbers(src);
  return {
    shaderName: shaderDescription,
    errors: formatErrors(errors, lines),
    warnings: formatErrors(warnings, lines)
  };
}

function formatErrors(errors, lines) {
  let message = '';

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];

    if (!errors[i + 3] && !errors[i + 2] && !errors[i + 1]) {
      continue;
    }

    message += `${line}\n`;

    if (errors[i + 1]) {
      const error = errors[i + 1];
      const segments = error.split(':', 3);
      const type = segments[0];
      const column = parseInt(segments[1], 10) || 0;
      const err = error.substring(segments.join(':').length + 1).trim();
      message += padLeft(`^^^ ${type}: ${err}\n\n`, column);
    }
  }

  return message;
}

function addLineNumbers(string, start = 1, delim = ': ') {
  const lines = string.split(/\r?\n/);
  const maxDigits = String(lines.length + start - 1).length;
  return lines.map((line, i) => {
    const lineNumber = String(i + start);
    const digits = lineNumber.length;
    const prefix = padLeft(lineNumber, maxDigits - digits);
    return prefix + delim + line;
  });
}

function padLeft(string, digits) {
  let result = '';

  for (let i = 0; i < digits; ++i) {
    result += ' ';
  }

  return `${result}${string}`;
}
},{"./get-shader-name":"node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-name.js","./get-shader-type-name":"node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-type-name.js"}],"node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-version.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getShaderVersion;

function getShaderVersion(source) {
  let version = 100;
  const words = source.match(/[^\s]+/g);

  if (words.length >= 2 && words[0] === '#version') {
    const v = parseInt(words[1], 10);

    if (Number.isFinite(v)) {
      version = v;
    }
  }

  return version;
}
},{}],"node_modules/@luma.gl/webgl/dist/esm/glsl-utils/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "formatGLSLCompilerError", {
  enumerable: true,
  get: function () {
    return _formatGlslError.default;
  }
});
Object.defineProperty(exports, "getShaderName", {
  enumerable: true,
  get: function () {
    return _getShaderName.default;
  }
});
Object.defineProperty(exports, "getShaderTypeName", {
  enumerable: true,
  get: function () {
    return _getShaderTypeName.default;
  }
});
Object.defineProperty(exports, "getShaderVersion", {
  enumerable: true,
  get: function () {
    return _getShaderVersion.default;
  }
});
Object.defineProperty(exports, "parseGLSLCompilerError", {
  enumerable: true,
  get: function () {
    return _formatGlslError.parseGLSLCompilerError;
  }
});

var _formatGlslError = _interopRequireWildcard(require("./format-glsl-error"));

var _getShaderName = _interopRequireDefault(require("./get-shader-name"));

var _getShaderVersion = _interopRequireDefault(require("./get-shader-version"));

var _getShaderTypeName = _interopRequireDefault(require("./get-shader-type-name"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
},{"./format-glsl-error":"node_modules/@luma.gl/webgl/dist/esm/glsl-utils/format-glsl-error.js","./get-shader-name":"node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-name.js","./get-shader-version":"node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-version.js","./get-shader-type-name":"node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-type-name.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/shader.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VertexShader = exports.Shader = exports.FragmentShader = void 0;

var _gltools = require("@luma.gl/gltools");

var _glslUtils = require("../glsl-utils");

var _assert = require("../utils/assert");

var _utils = require("../utils/utils");

var _resource = _interopRequireDefault(require("./resource"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const ERR_SOURCE = 'Shader: GLSL source code must be a JavaScript string';

class Shader extends _resource.default {
  get [Symbol.toStringTag]() {
    return 'Shader';
  }

  static getTypeName(shaderType) {
    switch (shaderType) {
      case 35633:
        return 'vertex-shader';

      case 35632:
        return 'fragment-shader';

      default:
        (0, _assert.assert)(false);
        return 'unknown';
    }
  }

  constructor(gl, props) {
    (0, _gltools.assertWebGLContext)(gl);
    (0, _assert.assert)(typeof props.source === 'string', ERR_SOURCE);
    const id = (0, _glslUtils.getShaderName)(props.source, null) || props.id || (0, _utils.uid)(`unnamed ${Shader.getTypeName(props.shaderType)}`);
    super(gl, {
      id
    });
    this.shaderType = props.shaderType;
    this.source = props.source;
    this.initialize(props);
  }

  initialize({
    source
  }) {
    const shaderName = (0, _glslUtils.getShaderName)(source, null);

    if (shaderName) {
      this.id = (0, _utils.uid)(shaderName);
    }

    this._compile(source);
  }

  getParameter(pname) {
    return this.gl.getShaderParameter(this.handle, pname);
  }

  toString() {
    return `${Shader.getTypeName(this.shaderType)}:${this.id}`;
  }

  getName() {
    return (0, _glslUtils.getShaderName)(this.source) || 'unnamed-shader';
  }

  getSource() {
    return this.gl.getShaderSource(this.handle);
  }

  getTranslatedSource() {
    const extension = this.gl.getExtension('WEBGL_debug_shaders');
    return extension ? extension.getTranslatedShaderSource(this.handle) : 'No translated source available. WEBGL_debug_shaders not implemented';
  }

  _compile(source = this.source) {
    if (!source.startsWith('#version ')) {
      source = `#version 100\n${source}`;
    }

    this.source = source;
    this.gl.shaderSource(this.handle, this.source);
    this.gl.compileShader(this.handle);
    const compileStatus = this.getParameter(35713);

    if (!compileStatus) {
      const infoLog = this.gl.getShaderInfoLog(this.handle);
      const {
        shaderName,
        errors,
        warnings
      } = (0, _glslUtils.parseGLSLCompilerError)(infoLog, this.source, this.shaderType, this.id);

      _gltools.log.error(`GLSL compilation errors in ${shaderName}\n${errors}`)();

      _gltools.log.warn(`GLSL compilation warnings in ${shaderName}\n${warnings}`)();

      throw new Error(`GLSL compilation errors in ${shaderName}`);
    }
  }

  _deleteHandle() {
    this.gl.deleteShader(this.handle);
  }

  _getOptsFromHandle() {
    return {
      type: this.getParameter(35663),
      source: this.getSource()
    };
  }

}

exports.Shader = Shader;

class VertexShader extends Shader {
  get [Symbol.toStringTag]() {
    return 'VertexShader';
  }

  constructor(gl, props) {
    if (typeof props === 'string') {
      props = {
        source: props
      };
    }

    super(gl, Object.assign({}, props, {
      shaderType: 35633
    }));
  }

  _createHandle() {
    return this.gl.createShader(35633);
  }

}

exports.VertexShader = VertexShader;

class FragmentShader extends Shader {
  get [Symbol.toStringTag]() {
    return 'FragmentShader';
  }

  constructor(gl, props) {
    if (typeof props === 'string') {
      props = {
        source: props
      };
    }

    super(gl, Object.assign({}, props, {
      shaderType: 35632
    }));
  }

  _createHandle() {
    return this.gl.createShader(35632);
  }

}

exports.FragmentShader = FragmentShader;
},{"@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","../glsl-utils":"node_modules/@luma.gl/webgl/dist/esm/glsl-utils/index.js","../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js","../utils/utils":"node_modules/@luma.gl/webgl/dist/esm/utils/utils.js","./resource":"node_modules/@luma.gl/webgl/dist/esm/classes/resource.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/uniforms.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.checkUniformValues = checkUniformValues;
exports.copyUniform = copyUniform;
exports.getUniformSetter = getUniformSetter;
exports.parseUniformName = parseUniformName;

var _gltools = require("@luma.gl/gltools");

var _framebuffer = _interopRequireDefault(require("./framebuffer"));

var _renderbuffer = _interopRequireDefault(require("./renderbuffer"));

var _texture = _interopRequireDefault(require("./texture"));

var _assert = require("../utils/assert");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const UNIFORM_SETTERS = {
  [5126]: getArraySetter.bind(null, 'uniform1fv', toFloatArray, 1, setVectorUniform),
  [35664]: getArraySetter.bind(null, 'uniform2fv', toFloatArray, 2, setVectorUniform),
  [35665]: getArraySetter.bind(null, 'uniform3fv', toFloatArray, 3, setVectorUniform),
  [35666]: getArraySetter.bind(null, 'uniform4fv', toFloatArray, 4, setVectorUniform),
  [5124]: getArraySetter.bind(null, 'uniform1iv', toIntArray, 1, setVectorUniform),
  [35667]: getArraySetter.bind(null, 'uniform2iv', toIntArray, 2, setVectorUniform),
  [35668]: getArraySetter.bind(null, 'uniform3iv', toIntArray, 3, setVectorUniform),
  [35669]: getArraySetter.bind(null, 'uniform4iv', toIntArray, 4, setVectorUniform),
  [35670]: getArraySetter.bind(null, 'uniform1iv', toIntArray, 1, setVectorUniform),
  [35671]: getArraySetter.bind(null, 'uniform2iv', toIntArray, 2, setVectorUniform),
  [35672]: getArraySetter.bind(null, 'uniform3iv', toIntArray, 3, setVectorUniform),
  [35673]: getArraySetter.bind(null, 'uniform4iv', toIntArray, 4, setVectorUniform),
  [35674]: getArraySetter.bind(null, 'uniformMatrix2fv', toFloatArray, 4, setMatrixUniform),
  [35675]: getArraySetter.bind(null, 'uniformMatrix3fv', toFloatArray, 9, setMatrixUniform),
  [35676]: getArraySetter.bind(null, 'uniformMatrix4fv', toFloatArray, 16, setMatrixUniform),
  [35678]: getSamplerSetter,
  [35680]: getSamplerSetter,
  [5125]: getArraySetter.bind(null, 'uniform1uiv', toUIntArray, 1, setVectorUniform),
  [36294]: getArraySetter.bind(null, 'uniform2uiv', toUIntArray, 2, setVectorUniform),
  [36295]: getArraySetter.bind(null, 'uniform3uiv', toUIntArray, 3, setVectorUniform),
  [36296]: getArraySetter.bind(null, 'uniform4uiv', toUIntArray, 4, setVectorUniform),
  [35685]: getArraySetter.bind(null, 'uniformMatrix2x3fv', toFloatArray, 6, setMatrixUniform),
  [35686]: getArraySetter.bind(null, 'uniformMatrix2x4fv', toFloatArray, 8, setMatrixUniform),
  [35687]: getArraySetter.bind(null, 'uniformMatrix3x2fv', toFloatArray, 6, setMatrixUniform),
  [35688]: getArraySetter.bind(null, 'uniformMatrix3x4fv', toFloatArray, 12, setMatrixUniform),
  [35689]: getArraySetter.bind(null, 'uniformMatrix4x2fv', toFloatArray, 8, setMatrixUniform),
  [35690]: getArraySetter.bind(null, 'uniformMatrix4x3fv', toFloatArray, 12, setMatrixUniform),
  [35678]: getSamplerSetter,
  [35680]: getSamplerSetter,
  [35679]: getSamplerSetter,
  [35682]: getSamplerSetter,
  [36289]: getSamplerSetter,
  [36292]: getSamplerSetter,
  [36293]: getSamplerSetter,
  [36298]: getSamplerSetter,
  [36299]: getSamplerSetter,
  [36300]: getSamplerSetter,
  [36303]: getSamplerSetter,
  [36306]: getSamplerSetter,
  [36307]: getSamplerSetter,
  [36308]: getSamplerSetter,
  [36311]: getSamplerSetter
};
const FLOAT_ARRAY = {};
const INT_ARRAY = {};
const UINT_ARRAY = {};
const array1 = [0];

function toTypedArray(value, uniformLength, Type, cache) {
  if (uniformLength === 1 && typeof value === 'boolean') {
    value = value ? 1 : 0;
  }

  if (Number.isFinite(value)) {
    array1[0] = value;
    value = array1;
  }

  const length = value.length;

  if (length % uniformLength) {
    _gltools.log.warn(`Uniform size should be multiples of ${uniformLength}`, value)();
  }

  if (value instanceof Type) {
    return value;
  }

  let result = cache[length];

  if (!result) {
    result = new Type(length);
    cache[length] = result;
  }

  for (let i = 0; i < length; i++) {
    result[i] = value[i];
  }

  return result;
}

function toFloatArray(value, uniformLength) {
  return toTypedArray(value, uniformLength, Float32Array, FLOAT_ARRAY);
}

function toIntArray(value, uniformLength) {
  return toTypedArray(value, uniformLength, Int32Array, INT_ARRAY);
}

function toUIntArray(value, uniformLength) {
  return toTypedArray(value, uniformLength, Uint32Array, UINT_ARRAY);
}

function getUniformSetter(gl, location, info) {
  const setter = UNIFORM_SETTERS[info.type];

  if (!setter) {
    throw new Error(`Unknown GLSL uniform type ${info.type}`);
  }

  return setter().bind(null, gl, location);
}

function parseUniformName(name) {
  if (name[name.length - 1] !== ']') {
    return {
      name,
      length: 1,
      isArray: false
    };
  }

  const UNIFORM_NAME_REGEXP = /([^[]*)(\[[0-9]+\])?/;
  const matches = name.match(UNIFORM_NAME_REGEXP);

  if (!matches || matches.length < 2) {
    throw new Error(`Failed to parse GLSL uniform name ${name}`);
  }

  return {
    name: matches[1],
    length: matches[2] || 1,
    isArray: Boolean(matches[2])
  };
}

function checkUniformValues(uniforms, source, uniformMap) {
  for (const uniformName in uniforms) {
    const value = uniforms[uniformName];
    const shouldCheck = !uniformMap || Boolean(uniformMap[uniformName]);

    if (shouldCheck && !checkUniformValue(value)) {
      source = source ? `${source} ` : '';
      console.error(`${source} Bad uniform ${uniformName}`, value);
      throw new Error(`${source} Bad uniform ${uniformName}`);
    }
  }

  return true;
}

function checkUniformValue(value) {
  if (Array.isArray(value) || ArrayBuffer.isView(value)) {
    return checkUniformArray(value);
  }

  if (isFinite(value)) {
    return true;
  } else if (value === true || value === false) {
    return true;
  } else if (value instanceof _texture.default) {
    return true;
  } else if (value instanceof _renderbuffer.default) {
    return true;
  } else if (value instanceof _framebuffer.default) {
    return Boolean(value.texture);
  }

  return false;
}

function copyUniform(uniforms, key, value) {
  if (Array.isArray(value) || ArrayBuffer.isView(value)) {
    if (uniforms[key]) {
      const dest = uniforms[key];

      for (let i = 0, len = value.length; i < len; ++i) {
        dest[i] = value[i];
      }
    } else {
      uniforms[key] = value.slice();
    }
  } else {
    uniforms[key] = value;
  }
}

function checkUniformArray(value) {
  if (value.length === 0) {
    return false;
  }

  const checkLength = Math.min(value.length, 16);

  for (let i = 0; i < checkLength; ++i) {
    if (!Number.isFinite(value[i])) {
      return false;
    }
  }

  return true;
}

function getSamplerSetter() {
  let cache = null;
  return (gl, location, value) => {
    const update = cache !== value;

    if (update) {
      gl.uniform1i(location, value);
      cache = value;
    }

    return update;
  };
}

function getArraySetter(functionName, toArray, size, uniformSetter) {
  let cache = null;
  let cacheLength = null;
  return (gl, location, value) => {
    const arrayValue = toArray(value, size);
    const length = arrayValue.length;
    let update = false;

    if (cache === null) {
      cache = new Float32Array(length);
      cacheLength = length;
      update = true;
    } else {
      (0, _assert.assert)(cacheLength === length, 'Uniform length cannot change.');

      for (let i = 0; i < length; ++i) {
        if (arrayValue[i] !== cache[i]) {
          update = true;
          break;
        }
      }
    }

    if (update) {
      uniformSetter(gl, functionName, location, arrayValue);
      cache.set(arrayValue);
    }

    return update;
  };
}

function setVectorUniform(gl, functionName, location, value) {
  gl[functionName](location, value);
}

function setMatrixUniform(gl, functionName, location, value) {
  gl[functionName](location, false, value);
}
},{"@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","./framebuffer":"node_modules/@luma.gl/webgl/dist/esm/classes/framebuffer.js","./renderbuffer":"node_modules/@luma.gl/webgl/dist/esm/classes/renderbuffer.js","./texture":"node_modules/@luma.gl/webgl/dist/esm/classes/texture.js","../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js"}],"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/attribute-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decomposeCompositeGLType = decomposeCompositeGLType;
exports.getCompositeGLType = getCompositeGLType;
exports.getPrimitiveCount = getPrimitiveCount;
exports.getPrimitiveDrawMode = getPrimitiveDrawMode;
exports.getVertexCount = getVertexCount;

var _assert = require("../utils/assert");

const GL_BYTE = 0x1400;
const GL_UNSIGNED_BYTE = 0x1401;
const GL_SHORT = 0x1402;
const GL_UNSIGNED_SHORT = 0x1403;
const GL_POINTS = 0x0;
const GL_LINES = 0x1;
const GL_LINE_LOOP = 0x2;
const GL_LINE_STRIP = 0x3;
const GL_TRIANGLES = 0x4;
const GL_TRIANGLE_STRIP = 0x5;
const GL_TRIANGLE_FAN = 0x6;
const GL_FLOAT = 0x1406;
const GL_FLOAT_VEC2 = 0x8b50;
const GL_FLOAT_VEC3 = 0x8b51;
const GL_FLOAT_VEC4 = 0x8b52;
const GL_INT = 0x1404;
const GL_INT_VEC2 = 0x8b53;
const GL_INT_VEC3 = 0x8b54;
const GL_INT_VEC4 = 0x8b55;
const GL_UNSIGNED_INT = 0x1405;
const GL_UNSIGNED_INT_VEC2 = 0x8dc6;
const GL_UNSIGNED_INT_VEC3 = 0x8dc7;
const GL_UNSIGNED_INT_VEC4 = 0x8dc8;
const GL_BOOL = 0x8b56;
const GL_BOOL_VEC2 = 0x8b57;
const GL_BOOL_VEC3 = 0x8b58;
const GL_BOOL_VEC4 = 0x8b59;
const GL_FLOAT_MAT2 = 0x8b5a;
const GL_FLOAT_MAT3 = 0x8b5b;
const GL_FLOAT_MAT4 = 0x8b5c;
const GL_FLOAT_MAT2x3 = 0x8b65;
const GL_FLOAT_MAT2x4 = 0x8b66;
const GL_FLOAT_MAT3x2 = 0x8b67;
const GL_FLOAT_MAT3x4 = 0x8b68;
const GL_FLOAT_MAT4x2 = 0x8b69;
const GL_FLOAT_MAT4x3 = 0x8b6a;
const COMPOSITE_GL_TYPES = {
  [GL_FLOAT]: [GL_FLOAT, 1, 'float'],
  [GL_FLOAT_VEC2]: [GL_FLOAT, 2, 'vec2'],
  [GL_FLOAT_VEC3]: [GL_FLOAT, 3, 'vec3'],
  [GL_FLOAT_VEC4]: [GL_FLOAT, 4, 'vec4'],
  [GL_INT]: [GL_INT, 1, 'int'],
  [GL_INT_VEC2]: [GL_INT, 2, 'ivec2'],
  [GL_INT_VEC3]: [GL_INT, 3, 'ivec3'],
  [GL_INT_VEC4]: [GL_INT, 4, 'ivec4'],
  [GL_UNSIGNED_INT]: [GL_UNSIGNED_INT, 1, 'uint'],
  [GL_UNSIGNED_INT_VEC2]: [GL_UNSIGNED_INT, 2, 'uvec2'],
  [GL_UNSIGNED_INT_VEC3]: [GL_UNSIGNED_INT, 3, 'uvec3'],
  [GL_UNSIGNED_INT_VEC4]: [GL_UNSIGNED_INT, 4, 'uvec4'],
  [GL_BOOL]: [GL_FLOAT, 1, 'bool'],
  [GL_BOOL_VEC2]: [GL_FLOAT, 2, 'bvec2'],
  [GL_BOOL_VEC3]: [GL_FLOAT, 3, 'bvec3'],
  [GL_BOOL_VEC4]: [GL_FLOAT, 4, 'bvec4'],
  [GL_FLOAT_MAT2]: [GL_FLOAT, 8, 'mat2'],
  [GL_FLOAT_MAT2x3]: [GL_FLOAT, 8, 'mat2x3'],
  [GL_FLOAT_MAT2x4]: [GL_FLOAT, 8, 'mat2x4'],
  [GL_FLOAT_MAT3]: [GL_FLOAT, 12, 'mat3'],
  [GL_FLOAT_MAT3x2]: [GL_FLOAT, 12, 'mat3x2'],
  [GL_FLOAT_MAT3x4]: [GL_FLOAT, 12, 'mat3x4'],
  [GL_FLOAT_MAT4]: [GL_FLOAT, 16, 'mat4'],
  [GL_FLOAT_MAT4x2]: [GL_FLOAT, 16, 'mat4x2'],
  [GL_FLOAT_MAT4x3]: [GL_FLOAT, 16, 'mat4x3']
};

function getPrimitiveDrawMode(drawMode) {
  switch (drawMode) {
    case GL_POINTS:
      return GL_POINTS;

    case GL_LINES:
      return GL_LINES;

    case GL_LINE_STRIP:
      return GL_LINES;

    case GL_LINE_LOOP:
      return GL_LINES;

    case GL_TRIANGLES:
      return GL_TRIANGLES;

    case GL_TRIANGLE_STRIP:
      return GL_TRIANGLES;

    case GL_TRIANGLE_FAN:
      return GL_TRIANGLES;

    default:
      (0, _assert.assert)(false);
      return 0;
  }
}

function getPrimitiveCount({
  drawMode,
  vertexCount
}) {
  switch (drawMode) {
    case GL_POINTS:
    case GL_LINE_LOOP:
      return vertexCount;

    case GL_LINES:
      return vertexCount / 2;

    case GL_LINE_STRIP:
      return vertexCount - 1;

    case GL_TRIANGLES:
      return vertexCount / 3;

    case GL_TRIANGLE_STRIP:
    case GL_TRIANGLE_FAN:
      return vertexCount - 2;

    default:
      (0, _assert.assert)(false);
      return 0;
  }
}

function getVertexCount({
  drawMode,
  vertexCount
}) {
  const primitiveCount = getPrimitiveCount({
    drawMode,
    vertexCount
  });

  switch (getPrimitiveDrawMode(drawMode)) {
    case GL_POINTS:
      return primitiveCount;

    case GL_LINES:
      return primitiveCount * 2;

    case GL_TRIANGLES:
      return primitiveCount * 3;

    default:
      (0, _assert.assert)(false);
      return 0;
  }
}

function decomposeCompositeGLType(compositeGLType) {
  const typeAndSize = COMPOSITE_GL_TYPES[compositeGLType];

  if (!typeAndSize) {
    return null;
  }

  const [type, components] = typeAndSize;
  return {
    type,
    components
  };
}

function getCompositeGLType(type, components) {
  switch (type) {
    case GL_BYTE:
    case GL_UNSIGNED_BYTE:
    case GL_SHORT:
    case GL_UNSIGNED_SHORT:
      type = GL_FLOAT;
      break;

    default:
  }

  for (const glType in COMPOSITE_GL_TYPES) {
    const [compType, compComponents, name] = COMPOSITE_GL_TYPES[glType];

    if (compType === type && compComponents === components) {
      return {
        glType,
        name
      };
    }
  }

  return null;
}
},{"../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/program-configuration.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _accessor = _interopRequireDefault(require("./accessor"));

var _gltools = require("@luma.gl/gltools");

var _attributeUtils = require("../webgl-utils/attribute-utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class ProgramConfiguration {
  constructor(program) {
    this.id = program.id;
    this.attributeInfos = [];
    this.attributeInfosByName = {};
    this.attributeInfosByLocation = [];
    this.varyingInfos = [];
    this.varyingInfosByName = {};
    Object.seal(this);

    this._readAttributesFromProgram(program);

    this._readVaryingsFromProgram(program);
  }

  getAttributeInfo(locationOrName) {
    const location = Number(locationOrName);

    if (Number.isFinite(location)) {
      return this.attributeInfosByLocation[location];
    }

    return this.attributeInfosByName[locationOrName] || null;
  }

  getAttributeLocation(locationOrName) {
    const attributeInfo = this.getAttributeInfo(locationOrName);
    return attributeInfo ? attributeInfo.location : -1;
  }

  getAttributeAccessor(locationOrName) {
    const attributeInfo = this.getAttributeInfo(locationOrName);
    return attributeInfo ? attributeInfo.accessor : null;
  }

  getVaryingInfo(locationOrName) {
    const location = Number(locationOrName);

    if (Number.isFinite(location)) {
      return this.varyingInfos[location];
    }

    return this.varyingInfosByName[locationOrName] || null;
  }

  getVaryingIndex(locationOrName) {
    const varying = this.getVaryingInfo();
    return varying ? varying.location : -1;
  }

  getVaryingAccessor(locationOrName) {
    const varying = this.getVaryingInfo();
    return varying ? varying.accessor : null;
  }

  _readAttributesFromProgram(program) {
    const {
      gl
    } = program;
    const count = gl.getProgramParameter(program.handle, 35721);

    for (let index = 0; index < count; index++) {
      const {
        name,
        type,
        size
      } = gl.getActiveAttrib(program.handle, index);
      const location = gl.getAttribLocation(program.handle, name);

      if (location >= 0) {
        this._addAttribute(location, name, type, size);
      }
    }

    this.attributeInfos.sort((a, b) => a.location - b.location);
  }

  _readVaryingsFromProgram(program) {
    const {
      gl
    } = program;

    if (!(0, _gltools.isWebGL2)(gl)) {
      return;
    }

    const count = gl.getProgramParameter(program.handle, 35971);

    for (let location = 0; location < count; location++) {
      const {
        name,
        type,
        size
      } = gl.getTransformFeedbackVarying(program.handle, location);

      this._addVarying(location, name, type, size);
    }

    this.varyingInfos.sort((a, b) => a.location - b.location);
  }

  _addAttribute(location, name, compositeType, size) {
    const {
      type,
      components
    } = (0, _attributeUtils.decomposeCompositeGLType)(compositeType);
    const accessor = {
      type,
      size: size * components
    };

    this._inferProperties(location, name, accessor);

    const attributeInfo = {
      location,
      name,
      accessor: new _accessor.default(accessor)
    };
    this.attributeInfos.push(attributeInfo);
    this.attributeInfosByLocation[location] = attributeInfo;
    this.attributeInfosByName[attributeInfo.name] = attributeInfo;
  }

  _inferProperties(location, name, accessor) {
    if (/instance/i.test(name)) {
      accessor.divisor = 1;
    }
  }

  _addVarying(location, name, compositeType, size) {
    const {
      type,
      components
    } = (0, _attributeUtils.decomposeCompositeGLType)(compositeType);
    const accessor = new _accessor.default({
      type,
      size: size * components
    });
    const varying = {
      location,
      name,
      accessor
    };
    this.varyingInfos.push(varying);
    this.varyingInfosByName[varying.name] = varying;
  }

}

exports.default = ProgramConfiguration;
},{"./accessor":"node_modules/@luma.gl/webgl/dist/esm/classes/accessor.js","@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","../webgl-utils/attribute-utils":"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/attribute-utils.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/program.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _resource = _interopRequireDefault(require("./resource"));

var _texture = _interopRequireDefault(require("./texture"));

var _framebuffer = _interopRequireDefault(require("./framebuffer"));

var _uniforms = require("./uniforms");

var _shader = require("./shader");

var _programConfiguration = _interopRequireDefault(require("./program-configuration"));

var _gltools = require("@luma.gl/gltools");

var _constantsToKeys = require("../webgl-utils/constants-to-keys");

var _attributeUtils = require("../webgl-utils/attribute-utils");

var _assert = require("../utils/assert");

var _utils = require("../utils/utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const LOG_PROGRAM_PERF_PRIORITY = 4;
const GL_SEPARATE_ATTRIBS = 0x8c8d;
const V6_DEPRECATED_METHODS = ['setVertexArray', 'setAttributes', 'setBuffers', 'unsetBuffers', 'use', 'getUniformCount', 'getUniformInfo', 'getUniformLocation', 'getUniformValue', 'getVarying', 'getFragDataLocation', 'getAttachedShaders', 'getAttributeCount', 'getAttributeLocation', 'getAttributeInfo'];

class Program extends _resource.default {
  get [Symbol.toStringTag]() {
    return 'Program';
  }

  constructor(gl, props = {}) {
    super(gl, props);
    this.stubRemovedMethods('Program', 'v6.0', V6_DEPRECATED_METHODS);
    this._isCached = false;
    this.initialize(props);
    Object.seal(this);

    this._setId(props.id);
  }

  initialize(props = {}) {
    const {
      hash,
      vs,
      fs,
      varyings,
      bufferMode = GL_SEPARATE_ATTRIBS
    } = props;
    this.hash = hash || '';
    this.vs = typeof vs === 'string' ? new _shader.VertexShader(this.gl, {
      id: `${props.id}-vs`,
      source: vs
    }) : vs;
    this.fs = typeof fs === 'string' ? new _shader.FragmentShader(this.gl, {
      id: `${props.id}-fs`,
      source: fs
    }) : fs;
    (0, _assert.assert)(this.vs instanceof _shader.VertexShader);
    (0, _assert.assert)(this.fs instanceof _shader.FragmentShader);
    this.uniforms = {};
    this._textureUniforms = {};

    if (varyings && varyings.length > 0) {
      (0, _gltools.assertWebGL2Context)(this.gl);
      this.varyings = varyings;
      this.gl2.transformFeedbackVaryings(this.handle, varyings, bufferMode);
    }

    this._compileAndLink();

    this._readUniformLocationsFromLinkedProgram();

    this.configuration = new _programConfiguration.default(this);
    return this.setProps(props);
  }

  delete(options = {}) {
    if (this._isCached) {
      return this;
    }

    return super.delete(options);
  }

  setProps(props) {
    if ('uniforms' in props) {
      this.setUniforms(props.uniforms);
    }

    return this;
  }

  draw({
    logPriority,
    drawMode = 4,
    vertexCount,
    offset = 0,
    start,
    end,
    isIndexed = false,
    indexType = 5123,
    instanceCount = 0,
    isInstanced = instanceCount > 0,
    vertexArray = null,
    transformFeedback,
    framebuffer,
    parameters = {},
    uniforms,
    samplers
  }) {
    if (uniforms || samplers) {
      _gltools.log.deprecated('Program.draw({uniforms})', 'Program.setUniforms(uniforms)')();

      this.setUniforms(uniforms || {});
    }

    if (_gltools.log.priority >= logPriority) {
      const fb = framebuffer ? framebuffer.id : 'default';
      const message = `mode=${(0, _constantsToKeys.getKey)(this.gl, drawMode)} verts=${vertexCount} ` + `instances=${instanceCount} indexType=${(0, _constantsToKeys.getKey)(this.gl, indexType)} ` + `isInstanced=${isInstanced} isIndexed=${isIndexed} ` + `Framebuffer=${fb}`;

      _gltools.log.log(logPriority, message)();
    }

    (0, _assert.assert)(vertexArray);
    this.gl.useProgram(this.handle);

    if (!this._areTexturesRenderable() || vertexCount === 0 || isInstanced && instanceCount === 0) {
      return false;
    }

    vertexArray.bindForDraw(vertexCount, instanceCount, () => {
      if (framebuffer !== undefined) {
        parameters = Object.assign({}, parameters, {
          framebuffer
        });
      }

      if (transformFeedback) {
        const primitiveMode = (0, _attributeUtils.getPrimitiveDrawMode)(drawMode);
        transformFeedback.begin(primitiveMode);
      }

      this._bindTextures();

      (0, _gltools.withParameters)(this.gl, parameters, () => {
        if (isIndexed && isInstanced) {
          this.gl2.drawElementsInstanced(drawMode, vertexCount, indexType, offset, instanceCount);
        } else if (isIndexed && (0, _gltools.isWebGL2)(this.gl) && !isNaN(start) && !isNaN(end)) {
          this.gl2.drawRangeElements(drawMode, start, end, vertexCount, indexType, offset);
        } else if (isIndexed) {
          this.gl.drawElements(drawMode, vertexCount, indexType, offset);
        } else if (isInstanced) {
          this.gl2.drawArraysInstanced(drawMode, offset, vertexCount, instanceCount);
        } else {
          this.gl.drawArrays(drawMode, offset, vertexCount);
        }
      });

      if (transformFeedback) {
        transformFeedback.end();
      }
    });
    return true;
  }

  setUniforms(uniforms = {}) {
    if (_gltools.log.priority >= 2) {
      (0, _uniforms.checkUniformValues)(uniforms, this.id, this._uniformSetters);
    }

    this.gl.useProgram(this.handle);

    for (const uniformName in uniforms) {
      const uniform = uniforms[uniformName];
      const uniformSetter = this._uniformSetters[uniformName];

      if (uniformSetter) {
        let value = uniform;
        let textureUpdate = false;

        if (value instanceof _framebuffer.default) {
          value = value.texture;
        }

        if (value instanceof _texture.default) {
          textureUpdate = this.uniforms[uniformName] !== uniform;

          if (textureUpdate) {
            if (uniformSetter.textureIndex === undefined) {
              uniformSetter.textureIndex = this._textureIndexCounter++;
            }

            const texture = value;
            const {
              textureIndex
            } = uniformSetter;
            texture.bind(textureIndex);
            value = textureIndex;
            this._textureUniforms[uniformName] = texture;
          } else {
            value = uniformSetter.textureIndex;
          }
        } else if (this._textureUniforms[uniformName]) {
          delete this._textureUniforms[uniformName];
        }

        if (uniformSetter(value) || textureUpdate) {
          (0, _uniforms.copyUniform)(this.uniforms, uniformName, uniform);
        }
      }
    }

    return this;
  }

  _areTexturesRenderable() {
    let texturesRenderable = true;

    for (const uniformName in this._textureUniforms) {
      const texture = this._textureUniforms[uniformName];
      texture.update();
      texturesRenderable = texturesRenderable && texture.loaded;
    }

    return texturesRenderable;
  }

  _bindTextures() {
    for (const uniformName in this._textureUniforms) {
      const textureIndex = this._uniformSetters[uniformName].textureIndex;

      this._textureUniforms[uniformName].bind(textureIndex);
    }
  }

  _createHandle() {
    return this.gl.createProgram();
  }

  _deleteHandle() {
    this.gl.deleteProgram(this.handle);
  }

  _getOptionsFromHandle(handle) {
    const shaderHandles = this.gl.getAttachedShaders(handle);
    const opts = {};

    for (const shaderHandle of shaderHandles) {
      const type = this.gl.getShaderParameter(this.handle, 35663);

      switch (type) {
        case 35633:
          opts.vs = new _shader.VertexShader({
            handle: shaderHandle
          });
          break;

        case 35632:
          opts.fs = new _shader.FragmentShader({
            handle: shaderHandle
          });
          break;

        default:
      }
    }

    return opts;
  }

  _getParameter(pname) {
    return this.gl.getProgramParameter(this.handle, pname);
  }

  _setId(id) {
    if (!id) {
      const programName = this._getName();

      this.id = (0, _utils.uid)(programName);
    }
  }

  _getName() {
    let programName = this.vs.getName() || this.fs.getName();
    programName = programName.replace(/shader/i, '');
    programName = programName ? `${programName}-program` : 'program';
    return programName;
  }

  _compileAndLink() {
    const {
      gl
    } = this;
    gl.attachShader(this.handle, this.vs.handle);
    gl.attachShader(this.handle, this.fs.handle);

    _gltools.log.time(LOG_PROGRAM_PERF_PRIORITY, `linkProgram for ${this._getName()}`)();

    gl.linkProgram(this.handle);

    _gltools.log.timeEnd(LOG_PROGRAM_PERF_PRIORITY, `linkProgram for ${this._getName()}`)();

    if (gl.debug || _gltools.log.level > 0) {
      const linked = gl.getProgramParameter(this.handle, 35714);

      if (!linked) {
        throw new Error(`Error linking: ${gl.getProgramInfoLog(this.handle)}`);
      }

      gl.validateProgram(this.handle);
      const validated = gl.getProgramParameter(this.handle, 35715);

      if (!validated) {
        throw new Error(`Error validating: ${gl.getProgramInfoLog(this.handle)}`);
      }
    }
  }

  _readUniformLocationsFromLinkedProgram() {
    const {
      gl
    } = this;
    this._uniformSetters = {};
    this._uniformCount = this._getParameter(35718);

    for (let i = 0; i < this._uniformCount; i++) {
      const info = this.gl.getActiveUniform(this.handle, i);
      const {
        name
      } = (0, _uniforms.parseUniformName)(info.name);
      let location = gl.getUniformLocation(this.handle, name);
      this._uniformSetters[name] = (0, _uniforms.getUniformSetter)(gl, location, info);

      if (info.size > 1) {
        for (let l = 0; l < info.size; l++) {
          location = gl.getUniformLocation(this.handle, `${name}[${l}]`);
          this._uniformSetters[`${name}[${l}]`] = (0, _uniforms.getUniformSetter)(gl, location, info);
        }
      }
    }

    this._textureIndexCounter = 0;
  }

  getActiveUniforms(uniformIndices, pname) {
    return this.gl2.getActiveUniforms(this.handle, uniformIndices, pname);
  }

  getUniformBlockIndex(blockName) {
    return this.gl2.getUniformBlockIndex(this.handle, blockName);
  }

  getActiveUniformBlockParameter(blockIndex, pname) {
    return this.gl2.getActiveUniformBlockParameter(this.handle, blockIndex, pname);
  }

  uniformBlockBinding(blockIndex, blockBinding) {
    this.gl2.uniformBlockBinding(this.handle, blockIndex, blockBinding);
  }

}

exports.default = Program;
},{"./resource":"node_modules/@luma.gl/webgl/dist/esm/classes/resource.js","./texture":"node_modules/@luma.gl/webgl/dist/esm/classes/texture.js","./framebuffer":"node_modules/@luma.gl/webgl/dist/esm/classes/framebuffer.js","./uniforms":"node_modules/@luma.gl/webgl/dist/esm/classes/uniforms.js","./shader":"node_modules/@luma.gl/webgl/dist/esm/classes/shader.js","./program-configuration":"node_modules/@luma.gl/webgl/dist/esm/classes/program-configuration.js","@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","../webgl-utils/constants-to-keys":"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/constants-to-keys.js","../webgl-utils/attribute-utils":"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/attribute-utils.js","../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js","../utils/utils":"node_modules/@luma.gl/webgl/dist/esm/utils/utils.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/query.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _resource = _interopRequireDefault(require("./resource"));

var _features = require("../features");

var _gltools = require("@luma.gl/gltools");

var _assert = require("../utils/assert");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const GL_QUERY_RESULT = 0x8866;
const GL_QUERY_RESULT_AVAILABLE = 0x8867;
const GL_TIME_ELAPSED_EXT = 0x88bf;
const GL_GPU_DISJOINT_EXT = 0x8fbb;
const GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = 0x8c88;
const GL_ANY_SAMPLES_PASSED = 0x8c2f;
const GL_ANY_SAMPLES_PASSED_CONSERVATIVE = 0x8d6a;

class Query extends _resource.default {
  get [Symbol.toStringTag]() {
    return 'Query';
  }

  static isSupported(gl, opts = []) {
    const webgl2 = (0, _gltools.isWebGL2)(gl);
    const hasTimerQuery = (0, _features.hasFeatures)(gl, _features.FEATURES.TIMER_QUERY);
    let supported = webgl2 || hasTimerQuery;

    for (const key of opts) {
      switch (key) {
        case 'queries':
          supported = supported && webgl2;
          break;

        case 'timers':
          supported = supported && hasTimerQuery;
          break;

        default:
          (0, _assert.assert)(false);
      }
    }

    return supported;
  }

  constructor(gl, opts = {}) {
    super(gl, opts);
    this.target = null;
    this._queryPending = false;
    this._pollingPromise = null;
    Object.seal(this);
  }

  beginTimeElapsedQuery() {
    return this.begin(GL_TIME_ELAPSED_EXT);
  }

  beginOcclusionQuery({
    conservative = false
  } = {}) {
    return this.begin(conservative ? GL_ANY_SAMPLES_PASSED_CONSERVATIVE : GL_ANY_SAMPLES_PASSED);
  }

  beginTransformFeedbackQuery() {
    return this.begin(GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN);
  }

  begin(target) {
    if (this._queryPending) {
      return this;
    }

    this.target = target;
    this.gl2.beginQuery(this.target, this.handle);
    return this;
  }

  end() {
    if (this._queryPending) {
      return this;
    }

    if (this.target) {
      this.gl2.endQuery(this.target);
      this.target = null;
      this._queryPending = true;
    }

    return this;
  }

  isResultAvailable() {
    if (!this._queryPending) {
      return false;
    }

    const resultAvailable = this.gl2.getQueryParameter(this.handle, GL_QUERY_RESULT_AVAILABLE);

    if (resultAvailable) {
      this._queryPending = false;
    }

    return resultAvailable;
  }

  isTimerDisjoint() {
    return this.gl2.getParameter(GL_GPU_DISJOINT_EXT);
  }

  getResult() {
    return this.gl2.getQueryParameter(this.handle, GL_QUERY_RESULT);
  }

  getTimerMilliseconds() {
    return this.getResult() / 1e6;
  }

  createPoll(limit = Number.POSITIVE_INFINITY) {
    if (this._pollingPromise) {
      return this._pollingPromise;
    }

    let counter = 0;
    this._pollingPromise = new Promise((resolve, reject) => {
      const poll = () => {
        if (this.isResultAvailable()) {
          resolve(this.getResult());
          this._pollingPromise = null;
        } else if (counter++ > limit) {
          reject('Timed out');
          this._pollingPromise = null;
        } else {
          requestAnimationFrame(poll);
        }
      };

      requestAnimationFrame(poll);
    });
    return this._pollingPromise;
  }

  _createHandle() {
    return Query.isSupported(this.gl) ? this.gl2.createQuery() : null;
  }

  _deleteHandle() {
    this.gl2.deleteQuery(this.handle);
  }

}

exports.default = Query;
},{"./resource":"node_modules/@luma.gl/webgl/dist/esm/classes/resource.js","../features":"node_modules/@luma.gl/webgl/dist/esm/features/index.js","@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/transform-feedback.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _gltools = require("@luma.gl/gltools");

var _resource = _interopRequireDefault(require("./resource"));

var _buffer = _interopRequireDefault(require("./buffer"));

var _utils = require("../utils/utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class TransformFeedback extends _resource.default {
  get [Symbol.toStringTag]() {
    return 'TransformFeedback';
  }

  static isSupported(gl) {
    return (0, _gltools.isWebGL2)(gl);
  }

  constructor(gl, props = {}) {
    (0, _gltools.assertWebGL2Context)(gl);
    super(gl, props);
    this.initialize(props);
    this.stubRemovedMethods('TransformFeedback', 'v6.0', ['pause', 'resume']);
    Object.seal(this);
  }

  initialize(props = {}) {
    this.buffers = {};
    this.unused = {};
    this.configuration = null;
    this.bindOnUse = true;

    if (!(0, _utils.isObjectEmpty)(this.buffers)) {
      this.bind(() => this._unbindBuffers());
    }

    this.setProps(props);
    return this;
  }

  setProps(props) {
    if ('program' in props) {
      this.configuration = props.program && props.program.configuration;
    }

    if ('configuration' in props) {
      this.configuration = props.configuration;
    }

    if ('bindOnUse' in props) {
      props = props.bindOnUse;
    }

    if ('buffers' in props) {
      this.setBuffers(props.buffers);
    }
  }

  setBuffers(buffers = {}) {
    this.bind(() => {
      for (const bufferName in buffers) {
        this.setBuffer(bufferName, buffers[bufferName]);
      }
    });
    return this;
  }

  setBuffer(locationOrName, bufferOrParams) {
    const location = this._getVaryingIndex(locationOrName);

    const {
      buffer,
      byteSize,
      byteOffset
    } = this._getBufferParams(bufferOrParams);

    if (location < 0) {
      this.unused[locationOrName] = buffer;

      _gltools.log.warn(() => `${this.id} unused varying buffer ${locationOrName}`)();

      return this;
    }

    this.buffers[location] = bufferOrParams;

    if (!this.bindOnUse) {
      this._bindBuffer(location, buffer, byteOffset, byteSize);
    }

    return this;
  }

  begin(primitiveMode = 0) {
    this.gl.bindTransformFeedback(36386, this.handle);

    this._bindBuffers();

    this.gl.beginTransformFeedback(primitiveMode);
    return this;
  }

  end() {
    this.gl.endTransformFeedback();

    this._unbindBuffers();

    this.gl.bindTransformFeedback(36386, null);
    return this;
  }

  _getBufferParams(bufferOrParams) {
    let byteOffset;
    let byteSize;
    let buffer;

    if (bufferOrParams instanceof _buffer.default === false) {
      buffer = bufferOrParams.buffer;
      byteSize = bufferOrParams.byteSize;
      byteOffset = bufferOrParams.byteOffset;
    } else {
      buffer = bufferOrParams;
    }

    if (byteOffset !== undefined || byteSize !== undefined) {
      byteOffset = byteOffset || 0;
      byteSize = byteSize || buffer.byteLength - byteOffset;
    }

    return {
      buffer,
      byteOffset,
      byteSize
    };
  }

  _getVaryingInfo(locationOrName) {
    return this.configuration && this.configuration.getVaryingInfo(locationOrName);
  }

  _getVaryingIndex(locationOrName) {
    if (this.configuration) {
      return this.configuration.getVaryingInfo(locationOrName).location;
    }

    const location = Number(locationOrName);
    return Number.isFinite(location) ? location : -1;
  }

  _bindBuffers() {
    if (this.bindOnUse) {
      for (const bufferIndex in this.buffers) {
        const {
          buffer,
          byteSize,
          byteOffset
        } = this._getBufferParams(this.buffers[bufferIndex]);

        this._bindBuffer(bufferIndex, buffer, byteOffset, byteSize);
      }
    }
  }

  _unbindBuffers() {
    if (this.bindOnUse) {
      for (const bufferIndex in this.buffers) {
        this._bindBuffer(bufferIndex, null);
      }
    }
  }

  _bindBuffer(index, buffer, byteOffset = 0, byteSize) {
    const handle = buffer && buffer.handle;

    if (!handle || byteSize === undefined) {
      this.gl.bindBufferBase(35982, index, handle);
    } else {
      this.gl.bindBufferRange(35982, index, handle, byteOffset, byteSize);
    }

    return this;
  }

  _createHandle() {
    return this.gl.createTransformFeedback();
  }

  _deleteHandle() {
    this.gl.deleteTransformFeedback(this.handle);
  }

  _bindHandle(handle) {
    this.gl.bindTransformFeedback(36386, this.handle);
  }

}

exports.default = TransformFeedback;
},{"@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","./resource":"node_modules/@luma.gl/webgl/dist/esm/classes/resource.js","./buffer":"node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js","../utils/utils":"node_modules/@luma.gl/webgl/dist/esm/utils/utils.js"}],"node_modules/@luma.gl/webgl/dist/esm/utils/array-utils-flat.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fillArray = fillArray;
exports.getScratchArray = getScratchArray;
exports.getScratchArrayBuffer = getScratchArrayBuffer;
let arrayBuffer = null;

function getScratchArrayBuffer(byteLength) {
  if (!arrayBuffer || arrayBuffer.byteLength < byteLength) {
    arrayBuffer = new ArrayBuffer(byteLength);
  }

  return arrayBuffer;
}

function getScratchArray(Type, length) {
  const scratchArrayBuffer = getScratchArrayBuffer(Type.BYTES_PER_ELEMENT * length);
  return new Type(scratchArrayBuffer, 0, length);
}

function fillArray({
  target,
  source,
  start = 0,
  count = 1
}) {
  const length = source.length;
  const total = count * length;
  let copied = 0;

  for (let i = start; copied < length; copied++) {
    target[i++] = source[copied];
  }

  while (copied < total) {
    if (copied < total - copied) {
      target.copyWithin(start + copied, start, start + copied);
      copied *= 2;
    } else {
      target.copyWithin(start + copied, start, start + total - copied);
      copied = total;
    }
  }

  return target;
}
},{}],"node_modules/@luma.gl/webgl/dist/esm/classes/vertex-array-object.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _resource = _interopRequireDefault(require("./resource"));

var _buffer = _interopRequireDefault(require("./buffer"));

var _gltools = require("@luma.gl/gltools");

var _arrayUtilsFlat = require("../utils/array-utils-flat");

var _assert = require("../utils/assert");

var _probe = require("probe.gl");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const ERR_ELEMENTS = 'elements must be GL.ELEMENT_ARRAY_BUFFER';

class VertexArrayObject extends _resource.default {
  get [Symbol.toStringTag]() {
    return 'VertexArrayObject';
  }

  static isSupported(gl, options = {}) {
    if (options.constantAttributeZero) {
      return (0, _gltools.isWebGL2)(gl) || (0, _probe.getBrowser)() === 'Chrome';
    }

    return true;
  }

  static getDefaultArray(gl) {
    gl.luma = gl.luma || {};

    if (!gl.luma.defaultVertexArray) {
      gl.luma.defaultVertexArray = new VertexArrayObject(gl, {
        handle: null,
        isDefaultArray: true
      });
    }

    return gl.luma.defaultVertexArray;
  }

  static getMaxAttributes(gl) {
    VertexArrayObject.MAX_ATTRIBUTES = VertexArrayObject.MAX_ATTRIBUTES || gl.getParameter(34921);
    return VertexArrayObject.MAX_ATTRIBUTES;
  }

  static setConstant(gl, location, array) {
    switch (array.constructor) {
      case Float32Array:
        VertexArrayObject._setConstantFloatArray(gl, location, array);

        break;

      case Int32Array:
        VertexArrayObject._setConstantIntArray(gl, location, array);

        break;

      case Uint32Array:
        VertexArrayObject._setConstantUintArray(gl, location, array);

        break;

      default:
        (0, _assert.assert)(false);
    }
  }

  constructor(gl, opts = {}) {
    const id = opts.id || opts.program && opts.program.id;
    super(gl, Object.assign({}, opts, {
      id
    }));
    this.buffer = null;
    this.bufferValue = null;
    this.isDefaultArray = opts.isDefaultArray || false;
    this.gl2 = gl;
    this.initialize(opts);
    Object.seal(this);
  }

  delete() {
    super.delete();

    if (this.buffer) {
      this.buffer.delete();
    }

    return this;
  }

  get MAX_ATTRIBUTES() {
    return VertexArrayObject.getMaxAttributes(this.gl);
  }

  initialize(props = {}) {
    return this.setProps(props);
  }

  setProps(props) {
    return this;
  }

  setElementBuffer(elementBuffer = null, opts = {}) {
    (0, _assert.assert)(!elementBuffer || elementBuffer.target === 34963, ERR_ELEMENTS);
    this.bind(() => {
      this.gl.bindBuffer(34963, elementBuffer ? elementBuffer.handle : null);
    });
    return this;
  }

  setBuffer(location, buffer, accessor) {
    if (buffer.target === 34963) {
      return this.setElementBuffer(buffer, accessor);
    }

    const {
      size,
      type,
      stride,
      offset,
      normalized,
      integer,
      divisor
    } = accessor;
    const {
      gl,
      gl2
    } = this;
    location = Number(location);
    this.bind(() => {
      gl.bindBuffer(34962, buffer.handle);

      if (integer) {
        (0, _assert.assert)((0, _gltools.isWebGL2)(gl));
        gl2.vertexAttribIPointer(location, size, type, stride, offset);
      } else {
        gl.vertexAttribPointer(location, size, type, normalized, stride, offset);
      }

      gl.enableVertexAttribArray(location);
      gl2.vertexAttribDivisor(location, divisor || 0);
    });
    return this;
  }

  enable(location, enable = true) {
    const disablingAttributeZero = !enable && location === 0 && !VertexArrayObject.isSupported(this.gl, {
      constantAttributeZero: true
    });

    if (!disablingAttributeZero) {
      location = Number(location);
      this.bind(() => enable ? this.gl.enableVertexAttribArray(location) : this.gl.disableVertexAttribArray(location));
    }

    return this;
  }

  getConstantBuffer(elementCount, value) {
    const constantValue = this._normalizeConstantArrayValue(value);

    const byteLength = constantValue.byteLength * elementCount;
    const length = constantValue.length * elementCount;
    let updateNeeded = !this.buffer;
    this.buffer = this.buffer || new _buffer.default(this.gl, byteLength);
    updateNeeded = updateNeeded || this.buffer.reallocate(byteLength);
    updateNeeded = updateNeeded || !this._compareConstantArrayValues(constantValue, this.bufferValue);

    if (updateNeeded) {
      const typedArray = (0, _arrayUtilsFlat.getScratchArray)(value.constructor, length);
      (0, _arrayUtilsFlat.fillArray)({
        target: typedArray,
        source: constantValue,
        start: 0,
        count: length
      });
      this.buffer.subData(typedArray);
      this.bufferValue = value;
    }

    return this.buffer;
  }

  _normalizeConstantArrayValue(arrayValue) {
    if (Array.isArray(arrayValue)) {
      return new Float32Array(arrayValue);
    }

    return arrayValue;
  }

  _compareConstantArrayValues(v1, v2) {
    if (!v1 || !v2 || v1.length !== v2.length || v1.constructor !== v2.constructor) {
      return false;
    }

    for (let i = 0; i < v1.length; ++i) {
      if (v1[i] !== v2[i]) {
        return false;
      }
    }

    return true;
  }

  static _setConstantFloatArray(gl, location, array) {
    switch (array.length) {
      case 1:
        gl.vertexAttrib1fv(location, array);
        break;

      case 2:
        gl.vertexAttrib2fv(location, array);
        break;

      case 3:
        gl.vertexAttrib3fv(location, array);
        break;

      case 4:
        gl.vertexAttrib4fv(location, array);
        break;

      default:
        (0, _assert.assert)(false);
    }
  }

  static _setConstantIntArray(gl, location, array) {
    (0, _assert.assert)((0, _gltools.isWebGL2)(gl));

    switch (array.length) {
      case 1:
        gl.vertexAttribI1iv(location, array);
        break;

      case 2:
        gl.vertexAttribI2iv(location, array);
        break;

      case 3:
        gl.vertexAttribI3iv(location, array);
        break;

      case 4:
        gl.vertexAttribI4iv(location, array);
        break;

      default:
        (0, _assert.assert)(false);
    }
  }

  static _setConstantUintArray(gl, location, array) {
    (0, _assert.assert)((0, _gltools.isWebGL2)(gl));

    switch (array.length) {
      case 1:
        gl.vertexAttribI1uiv(location, array);
        break;

      case 2:
        gl.vertexAttribI2uiv(location, array);
        break;

      case 3:
        gl.vertexAttribI3uiv(location, array);
        break;

      case 4:
        gl.vertexAttribI4uiv(location, array);
        break;

      default:
        (0, _assert.assert)(false);
    }
  }

  _createHandle() {
    const gl2 = this.gl;
    return gl2.createVertexArray();
  }

  _deleteHandle(handle) {
    this.gl2.deleteVertexArray(handle);
    return [this.elements];
  }

  _bindHandle(handle) {
    this.gl2.bindVertexArray(handle);
  }

  _getParameter(pname, {
    location
  }) {
    (0, _assert.assert)(Number.isFinite(location));
    return this.bind(() => {
      switch (pname) {
        case 34373:
          return this.gl.getVertexAttribOffset(location, pname);

        default:
          return this.gl.getVertexAttrib(location, pname);
      }
    });
  }

}

exports.default = VertexArrayObject;
},{"./resource":"node_modules/@luma.gl/webgl/dist/esm/classes/resource.js","./buffer":"node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js","@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","../utils/array-utils-flat":"node_modules/@luma.gl/webgl/dist/esm/utils/array-utils-flat.js","../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js","probe.gl":"node_modules/probe.gl/dist/esm/index.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/vertex-array.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _gltools = require("@luma.gl/gltools");

var _accessor = _interopRequireDefault(require("./accessor"));

var _buffer = _interopRequireDefault(require("./buffer"));

var _vertexArrayObject = _interopRequireDefault(require("./vertex-array-object"));

var _assert = require("../utils/assert");

var _stubMethods = require("../utils/stub-methods");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const ERR_ATTRIBUTE_TYPE = 'VertexArray: attributes must be Buffers or constants (i.e. typed array)';
const MULTI_LOCATION_ATTRIBUTE_REGEXP = /^(.+)__LOCATION_([0-9]+)$/;
const DEPRECATIONS_V6 = ['setBuffers', 'setGeneric', 'clearBindings', 'setLocations', 'setGenericValues', 'setDivisor', 'enable', 'disable'];

class VertexArray {
  constructor(gl, opts = {}) {
    const id = opts.id || opts.program && opts.program.id;
    this.id = id;
    this.gl = gl;
    this.configuration = null;
    this.elements = null;
    this.elementsAccessor = null;
    this.values = null;
    this.accessors = null;
    this.unused = null;
    this.drawParams = null;
    this.buffer = null;
    this.attributes = {};
    this.vertexArrayObject = new _vertexArrayObject.default(gl);
    (0, _stubMethods.stubRemovedMethods)(this, 'VertexArray', 'v6.0', DEPRECATIONS_V6);
    this.initialize(opts);
    Object.seal(this);
  }

  delete() {
    if (this.buffer) {
      this.buffer.delete();
    }

    this.vertexArrayObject.delete();
  }

  initialize(props = {}) {
    this.reset();
    this.configuration = null;
    this.bindOnUse = false;
    return this.setProps(props);
  }

  reset() {
    this.elements = null;
    this.elementsAccessor = null;
    const {
      MAX_ATTRIBUTES
    } = this.vertexArrayObject;
    this.values = new Array(MAX_ATTRIBUTES).fill(null);
    this.accessors = new Array(MAX_ATTRIBUTES).fill(null);
    this.unused = {};
    this.drawParams = null;
    return this;
  }

  setProps(props) {
    if ('program' in props) {
      this.configuration = props.program && props.program.configuration;
    }

    if ('configuration' in props) {
      this.configuration = props.configuration;
    }

    if ('attributes' in props) {
      this.setAttributes(props.attributes);
    }

    if ('elements' in props) {
      this.setElementBuffer(props.elements);
    }

    if ('bindOnUse' in props) {
      props = props.bindOnUse;
    }

    return this;
  }

  clearDrawParams() {
    this.drawParams = null;
  }

  getDrawParams() {
    this.drawParams = this.drawParams || this._updateDrawParams();
    return this.drawParams;
  }

  setAttributes(attributes) {
    Object.assign(this.attributes, attributes);
    this.vertexArrayObject.bind(() => {
      for (const locationOrName in attributes) {
        const value = attributes[locationOrName];

        this._setAttribute(locationOrName, value);
      }

      this.gl.bindBuffer(34962, null);
    });
    return this;
  }

  setElementBuffer(elementBuffer = null, accessor = {}) {
    this.elements = elementBuffer;
    this.elementsAccessor = accessor;
    this.clearDrawParams();
    this.vertexArrayObject.setElementBuffer(elementBuffer, accessor);
    return this;
  }

  setBuffer(locationOrName, buffer, appAccessor = {}) {
    if (buffer.target === 34963) {
      return this.setElementBuffer(buffer, appAccessor);
    }

    const {
      location,
      accessor
    } = this._resolveLocationAndAccessor(locationOrName, buffer, buffer.accessor, appAccessor);

    if (location >= 0) {
      this.values[location] = buffer;
      this.accessors[location] = accessor;
      this.clearDrawParams();
      this.vertexArrayObject.setBuffer(location, buffer, accessor);
    }

    return this;
  }

  setConstant(locationOrName, arrayValue, appAccessor = {}) {
    const {
      location,
      accessor
    } = this._resolveLocationAndAccessor(locationOrName, arrayValue, Object.assign({
      size: arrayValue.length
    }, appAccessor));

    if (location >= 0) {
      arrayValue = this.vertexArrayObject._normalizeConstantArrayValue(arrayValue);
      this.values[location] = arrayValue;
      this.accessors[location] = accessor;
      this.clearDrawParams();
      this.vertexArrayObject.enable(location, false);
    }

    return this;
  }

  unbindBuffers() {
    this.vertexArrayObject.bind(() => {
      if (this.elements) {
        this.vertexArrayObject.setElementBuffer(null);
      }

      this.buffer = this.buffer || new _buffer.default(this.gl, {
        accessor: {
          size: 4
        }
      });

      for (let location = 0; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++) {
        if (this.values[location] instanceof _buffer.default) {
          this.gl.disableVertexAttribArray(location);
          this.gl.bindBuffer(34962, this.buffer.handle);
          this.gl.vertexAttribPointer(location, 1, 5126, false, 0, 0);
        }
      }
    });
    return this;
  }

  bindBuffers() {
    this.vertexArrayObject.bind(() => {
      if (this.elements) {
        this.setElementBuffer(this.elements);
      }

      for (let location = 0; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++) {
        const buffer = this.values[location];

        if (buffer instanceof _buffer.default) {
          this.setBuffer(location, buffer);
        }
      }
    });
    return this;
  }

  bindForDraw(vertexCount, instanceCount, func) {
    let value;
    this.vertexArrayObject.bind(() => {
      this._setConstantAttributes(vertexCount, instanceCount);

      value = func();
    });
    return value;
  }

  _resolveLocationAndAccessor(locationOrName, value, valueAccessor, appAccessor) {
    const INVALID_RESULT = {
      location: -1,
      accessor: null
    };

    const {
      location,
      name
    } = this._getAttributeIndex(locationOrName);

    if (!Number.isFinite(location) || location < 0) {
      this.unused[locationOrName] = value;

      _gltools.log.once(3, () => `unused value ${locationOrName} in ${this.id}`)();

      return INVALID_RESULT;
    }

    const accessInfo = this._getAttributeInfo(name || location);

    if (!accessInfo) {
      return INVALID_RESULT;
    }

    const currentAccessor = this.accessors[location] || {};

    const accessor = _accessor.default.resolve(accessInfo.accessor, currentAccessor, valueAccessor, appAccessor);

    const {
      size,
      type
    } = accessor;
    (0, _assert.assert)(Number.isFinite(size) && Number.isFinite(type));
    return {
      location,
      accessor
    };
  }

  _getAttributeInfo(attributeName) {
    return this.configuration && this.configuration.getAttributeInfo(attributeName);
  }

  _getAttributeIndex(locationOrName) {
    const location = Number(locationOrName);

    if (Number.isFinite(location)) {
      return {
        location
      };
    }

    const multiLocation = MULTI_LOCATION_ATTRIBUTE_REGEXP.exec(locationOrName);
    const name = multiLocation ? multiLocation[1] : locationOrName;
    const locationOffset = multiLocation ? Number(multiLocation[2]) : 0;

    if (this.configuration) {
      return {
        location: this.configuration.getAttributeLocation(name) + locationOffset,
        name
      };
    }

    return {
      location: -1
    };
  }

  _setAttribute(locationOrName, value) {
    if (value instanceof _buffer.default) {
      this.setBuffer(locationOrName, value);
    } else if (Array.isArray(value) && value.length && value[0] instanceof _buffer.default) {
      const buffer = value[0];
      const accessor = value[1];
      this.setBuffer(locationOrName, buffer, accessor);
    } else if (ArrayBuffer.isView(value) || Array.isArray(value)) {
      const constant = value;
      this.setConstant(locationOrName, constant);
    } else if (value.buffer instanceof _buffer.default) {
      const accessor = value;
      this.setBuffer(locationOrName, accessor.buffer, accessor);
    } else {
      throw new Error(ERR_ATTRIBUTE_TYPE);
    }
  }

  _setConstantAttributes(vertexCount, instanceCount) {
    const elementCount = Math.max(vertexCount | 0, instanceCount | 0);
    let constant = this.values[0];

    if (ArrayBuffer.isView(constant)) {
      this._setConstantAttributeZero(constant, elementCount);
    }

    for (let location = 1; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++) {
      constant = this.values[location];

      if (ArrayBuffer.isView(constant)) {
        this._setConstantAttribute(location, constant);
      }
    }
  }

  _setConstantAttributeZero(constant, elementCount) {
    if (_vertexArrayObject.default.isSupported(this.gl, {
      constantAttributeZero: true
    })) {
      this._setConstantAttribute(0, constant);

      return;
    }

    const buffer = this.vertexArrayObject.getConstantBuffer(elementCount, constant);
    this.vertexArrayObject.setBuffer(0, buffer, this.accessors[0]);
  }

  _setConstantAttribute(location, constant) {
    _vertexArrayObject.default.setConstant(this.gl, location, constant);
  }

  _updateDrawParams() {
    const drawParams = {
      isIndexed: false,
      isInstanced: false,
      indexCount: Infinity,
      vertexCount: Infinity,
      instanceCount: Infinity
    };

    for (let location = 0; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++) {
      this._updateDrawParamsForLocation(drawParams, location);
    }

    if (this.elements) {
      drawParams.elementCount = this.elements.getElementCount(this.elements.accessor);
      drawParams.isIndexed = true;
      drawParams.indexType = this.elementsAccessor.type || this.elements.accessor.type;
      drawParams.indexOffset = this.elementsAccessor.offset || 0;
    }

    if (drawParams.indexCount === Infinity) {
      drawParams.indexCount = 0;
    }

    if (drawParams.vertexCount === Infinity) {
      drawParams.vertexCount = 0;
    }

    if (drawParams.instanceCount === Infinity) {
      drawParams.instanceCount = 0;
    }

    return drawParams;
  }

  _updateDrawParamsForLocation(drawParams, location) {
    const value = this.values[location];
    const accessor = this.accessors[location];

    if (!value) {
      return;
    }

    const {
      divisor
    } = accessor;
    const isInstanced = divisor > 0;
    drawParams.isInstanced = drawParams.isInstanced || isInstanced;

    if (value instanceof _buffer.default) {
      const buffer = value;

      if (isInstanced) {
        const instanceCount = buffer.getVertexCount(accessor);
        drawParams.instanceCount = Math.min(drawParams.instanceCount, instanceCount);
      } else {
        const vertexCount = buffer.getVertexCount(accessor);
        drawParams.vertexCount = Math.min(drawParams.vertexCount, vertexCount);
      }
    }
  }

  setElements(elementBuffer = null, accessor = {}) {
    _gltools.log.deprecated('setElements', 'setElementBuffer')();

    return this.setElementBuffer(elementBuffer, accessor);
  }

}

exports.default = VertexArray;
},{"@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","./accessor":"node_modules/@luma.gl/webgl/dist/esm/classes/accessor.js","./buffer":"node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js","./vertex-array-object":"node_modules/@luma.gl/webgl/dist/esm/classes/vertex-array-object.js","../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js","../utils/stub-methods":"node_modules/@luma.gl/webgl/dist/esm/utils/stub-methods.js"}],"node_modules/@luma.gl/webgl/dist/esm/classes/uniform-buffer-layout.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _attributeUtils = require("../webgl-utils/attribute-utils");

var _assert = require("../utils/assert");

const ERR_ARGUMENT = 'UniformBufferLayout illegal argument';
const GL_FLOAT = 0x1406;
const GL_INT = 0x1404;
const GL_UNSIGNED_INT = 0x1405;

class UniformBufferLayout {
  constructor(layout) {
    this.layout = {};
    this.size = 0;

    for (const key in layout) {
      this._addUniform(key, layout[key]);
    }

    this.size += (4 - this.size % 4) % 4;
    const data = new Float32Array(this.size);
    this.typedArray = {
      [GL_FLOAT]: data,
      [GL_INT]: new Int32Array(data.buffer),
      [GL_UNSIGNED_INT]: new Uint32Array(data.buffer)
    };
  }

  getBytes() {
    return this.size * 4;
  }

  getData() {
    return this.typedArray[GL_FLOAT];
  }

  getSubData(index) {
    let data;
    let offset;

    if (index === undefined) {
      data = this.data;
      offset = 0;
    } else {
      const begin = this.offsets[index];
      const end = begin + this.sizes[index];
      data = this.data.subarray(begin, end);
      offset = begin * 4;
    }

    return {
      data,
      offset
    };
  }

  setUniforms(values) {
    for (const key in values) {
      this._setValue(key, values[key]);
    }

    return this;
  }

  _setValue(key, value) {
    const layout = this.layout[key];
    (0, _assert.assert)(layout, 'UniformLayoutStd140 illegal argument');
    const typedArray = this.typedArray[layout.type];

    if (layout.size === 1) {
      typedArray[layout.offset] = value;
    } else {
      typedArray.set(value, layout.offset);
    }
  }

  _addUniform(key, uniformType) {
    const typeAndComponents = (0, _attributeUtils.decomposeCompositeGLType)(uniformType);
    (0, _assert.assert)(typeAndComponents, ERR_ARGUMENT);
    const {
      type,
      components: count
    } = typeAndComponents;
    this.size = this._alignTo(this.size, count);
    const offset = this.size;
    this.size += count;
    this.layout[key] = {
      type,
      size: count,
      offset
    };
  }

  _alignTo(size, count) {
    switch (count) {
      case 1:
        return size;

      case 2:
        return size + size % 2;

      default:
        return size + (4 - size % 4) % 4;
    }
  }

}

exports.default = UniformBufferLayout;
},{"../webgl-utils/attribute-utils":"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/attribute-utils.js","../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js"}],"node_modules/@luma.gl/webgl/dist/esm/utils/format-value.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.formatValue = formatValue;

function formatArrayValue(v, opts) {
  const {
    maxElts = 16,
    size = 1
  } = opts;
  let string = '[';

  for (let i = 0; i < v.length && i < maxElts; ++i) {
    if (i > 0) {
      string += `,${i % size === 0 ? ' ' : ''}`;
    }

    string += formatValue(v[i], opts);
  }

  const terminator = v.length > maxElts ? '...' : ']';
  return `${string}${terminator}`;
}

function formatValue(v, opts = {}) {
  const EPSILON = 1e-16;
  const {
    isInteger = false
  } = opts;

  if (Array.isArray(v) || ArrayBuffer.isView(v)) {
    return formatArrayValue(v, opts);
  }

  if (!Number.isFinite(v)) {
    return String(v);
  }

  if (Math.abs(v) < EPSILON) {
    return isInteger ? '0' : '0.';
  }

  if (isInteger) {
    return v.toFixed(0);
  }

  if (Math.abs(v) > 100 && Math.abs(v) < 10000) {
    return v.toFixed(0);
  }

  const string = v.toPrecision(2);
  const decimal = string.indexOf('.0');
  return decimal === string.length - 2 ? string.slice(0, -1) : string;
}
},{}],"node_modules/@luma.gl/webgl/dist/esm/debug/debug-uniforms.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDebugTableForUniforms = getDebugTableForUniforms;

var _assert = require("../utils/assert");

var _formatValue = require("../utils/format-value");

function getDebugTableForUniforms({
  header = 'Uniforms',
  program,
  uniforms,
  undefinedOnly = false
}) {
  (0, _assert.assert)(program);
  const SHADER_MODULE_UNIFORM_REGEXP = '.*_.*';
  const PROJECT_MODULE_UNIFORM_REGEXP = '.*Matrix';
  const uniformLocations = program._uniformSetters;
  const table = {};
  const uniformNames = Object.keys(uniformLocations).sort();
  let count = 0;

  for (const uniformName of uniformNames) {
    if (!uniformName.match(SHADER_MODULE_UNIFORM_REGEXP) && !uniformName.match(PROJECT_MODULE_UNIFORM_REGEXP)) {
      if (addUniformToTable({
        table,
        header,
        uniforms,
        uniformName,
        undefinedOnly
      })) {
        count++;
      }
    }
  }

  for (const uniformName of uniformNames) {
    if (uniformName.match(PROJECT_MODULE_UNIFORM_REGEXP)) {
      if (addUniformToTable({
        table,
        header,
        uniforms,
        uniformName,
        undefinedOnly
      })) {
        count++;
      }
    }
  }

  for (const uniformName of uniformNames) {
    if (!table[uniformName]) {
      if (addUniformToTable({
        table,
        header,
        uniforms,
        uniformName,
        undefinedOnly
      })) {
        count++;
      }
    }
  }

  let unusedCount = 0;
  const unusedTable = {};

  if (!undefinedOnly) {
    for (const uniformName in uniforms) {
      const uniform = uniforms[uniformName];

      if (!table[uniformName]) {
        unusedCount++;
        unusedTable[uniformName] = {
          Type: `NOT USED: ${uniform}`,
          [header]: (0, _formatValue.formatValue)(uniform)
        };
      }
    }
  }

  return {
    table,
    count,
    unusedTable,
    unusedCount
  };
}

function addUniformToTable({
  table,
  header,
  uniforms,
  uniformName,
  undefinedOnly
}) {
  const value = uniforms[uniformName];
  const isDefined = isUniformDefined(value);

  if (!undefinedOnly || !isDefined) {
    table[uniformName] = {
      [header]: isDefined ? (0, _formatValue.formatValue)(value) : 'N/A',
      'Uniform Type': isDefined ? value : 'NOT PROVIDED'
    };
    return true;
  }

  return false;
}

function isUniformDefined(value) {
  return value !== undefined && value !== null;
}
},{"../utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js","../utils/format-value":"node_modules/@luma.gl/webgl/dist/esm/utils/format-value.js"}],"node_modules/@luma.gl/webgl/dist/esm/debug/debug-vertex-array.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDebugTableForVertexArray = getDebugTableForVertexArray;

var _buffer = _interopRequireDefault(require("../classes/buffer"));

var _constantsToKeys = require("../webgl-utils/constants-to-keys");

var _attributeUtils = require("../webgl-utils/attribute-utils");

var _formatValue = require("../utils/format-value");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getDebugTableForVertexArray({
  vertexArray,
  header = 'Attributes'
}) {
  if (!vertexArray.configuration) {
    return {};
  }

  const table = {};

  if (vertexArray.elements) {
    table.ELEMENT_ARRAY_BUFFER = getDebugTableRow(vertexArray, vertexArray.elements, null, header);
  }

  const attributes = vertexArray.values;

  for (const attributeLocation in attributes) {
    const info = vertexArray._getAttributeInfo(attributeLocation);

    if (info) {
      let rowHeader = `${attributeLocation}: ${info.name}`;
      const accessor = vertexArray.accessors[info.location];

      if (accessor) {
        rowHeader = `${attributeLocation}: ${getGLSLDeclaration(info.name, accessor)}`;
      }

      table[rowHeader] = getDebugTableRow(vertexArray, attributes[attributeLocation], accessor, header);
    }
  }

  return table;
}

function getDebugTableRow(vertexArray, attribute, accessor, header) {
  const {
    gl
  } = vertexArray;

  if (!attribute) {
    return {
      [header]: 'null',
      'Format ': 'N/A'
    };
  }

  let type = 'NOT PROVIDED';
  let size = 1;
  let verts = 0;
  let bytes = 0;
  let isInteger;
  let marker;
  let value;

  if (accessor) {
    type = accessor.type;
    size = accessor.size;
    type = String(type).replace('Array', '');
    isInteger = type.indexOf('nt') !== -1;
  }

  if (attribute instanceof _buffer.default) {
    const buffer = attribute;
    const {
      data,
      changed
    } = buffer.getDebugData();
    marker = changed ? '*' : '';
    value = data;
    bytes = buffer.byteLength;
    verts = bytes / data.BYTES_PER_ELEMENT / size;
    let format;

    if (accessor) {
      const instanced = accessor.divisor > 0;
      format = `${instanced ? 'I ' : 'P '} ${verts} (x${size}=${bytes} bytes ${(0, _constantsToKeys.getKey)(gl, type)})`;
    } else {
      isInteger = true;
      format = `${bytes} bytes`;
    }

    return {
      [header]: `${marker}${(0, _formatValue.formatValue)(value, {
        size,
        isInteger
      })}`,
      'Format ': format
    };
  }

  value = attribute;
  size = attribute.length;
  type = String(attribute.constructor.name).replace('Array', '');
  isInteger = type.indexOf('nt') !== -1;
  return {
    [header]: `${(0, _formatValue.formatValue)(value, {
      size,
      isInteger
    })} (constant)`,
    'Format ': `${size}x${type} (constant)`
  };
}

function getGLSLDeclaration(name, accessor) {
  const {
    type,
    size
  } = accessor;
  const typeAndName = (0, _attributeUtils.getCompositeGLType)(type, size);
  return typeAndName ? `${name} (${typeAndName.name})` : name;
}
},{"../classes/buffer":"node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js","../webgl-utils/constants-to-keys":"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/constants-to-keys.js","../webgl-utils/attribute-utils":"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/attribute-utils.js","../utils/format-value":"node_modules/@luma.gl/webgl/dist/esm/utils/format-value.js"}],"node_modules/@luma.gl/webgl/dist/esm/debug/debug-program-configuration.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDebugTableForProgramConfiguration = getDebugTableForProgramConfiguration;

var _attributeUtils = require("../webgl-utils/attribute-utils");

function getDebugTableForProgramConfiguration(config) {
  const table = {};
  const header = `Accessors for ${config.id}`;

  for (const attributeInfo of config.attributeInfos) {
    if (attributeInfo) {
      const glslDeclaration = getGLSLDeclaration(attributeInfo);
      table[`in ${glslDeclaration}`] = {
        [header]: JSON.stringify(attributeInfo.accessor)
      };
    }
  }

  for (const varyingInfo of config.varyingInfos) {
    if (varyingInfo) {
      const glslDeclaration = getGLSLDeclaration(varyingInfo);
      table[`out ${glslDeclaration}`] = {
        [header]: JSON.stringify(varyingInfo.accessor)
      };
    }
  }

  return table;
}

function getGLSLDeclaration(attributeInfo) {
  const {
    type,
    size
  } = attributeInfo.accessor;
  const typeAndName = (0, _attributeUtils.getCompositeGLType)(type, size);

  if (typeAndName) {
    return `${typeAndName.name} ${attributeInfo.name}`;
  }

  return attributeInfo.name;
}
},{"../webgl-utils/attribute-utils":"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/attribute-utils.js"}],"node_modules/@luma.gl/webgl/dist/esm/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Accessor", {
  enumerable: true,
  get: function () {
    return _accessor.default;
  }
});
Object.defineProperty(exports, "Buffer", {
  enumerable: true,
  get: function () {
    return _buffer.default;
  }
});
Object.defineProperty(exports, "FEATURES", {
  enumerable: true,
  get: function () {
    return _webglFeaturesTable.FEATURES;
  }
});
Object.defineProperty(exports, "FragmentShader", {
  enumerable: true,
  get: function () {
    return _shader.FragmentShader;
  }
});
Object.defineProperty(exports, "Framebuffer", {
  enumerable: true,
  get: function () {
    return _framebuffer.default;
  }
});
Object.defineProperty(exports, "Program", {
  enumerable: true,
  get: function () {
    return _program.default;
  }
});
Object.defineProperty(exports, "Query", {
  enumerable: true,
  get: function () {
    return _query.default;
  }
});
Object.defineProperty(exports, "Renderbuffer", {
  enumerable: true,
  get: function () {
    return _renderbuffer.default;
  }
});
Object.defineProperty(exports, "Shader", {
  enumerable: true,
  get: function () {
    return _shader.Shader;
  }
});
Object.defineProperty(exports, "Texture2D", {
  enumerable: true,
  get: function () {
    return _texture2d.default;
  }
});
Object.defineProperty(exports, "Texture3D", {
  enumerable: true,
  get: function () {
    return _texture3d.default;
  }
});
Object.defineProperty(exports, "TextureCube", {
  enumerable: true,
  get: function () {
    return _textureCube.default;
  }
});
Object.defineProperty(exports, "TransformFeedback", {
  enumerable: true,
  get: function () {
    return _transformFeedback.default;
  }
});
Object.defineProperty(exports, "UniformBufferLayout", {
  enumerable: true,
  get: function () {
    return _uniformBufferLayout.default;
  }
});
Object.defineProperty(exports, "VertexArray", {
  enumerable: true,
  get: function () {
    return _vertexArray.default;
  }
});
Object.defineProperty(exports, "VertexArrayObject", {
  enumerable: true,
  get: function () {
    return _vertexArrayObject.default;
  }
});
Object.defineProperty(exports, "VertexShader", {
  enumerable: true,
  get: function () {
    return _shader.VertexShader;
  }
});
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function () {
    return _assert.assert;
  }
});
Object.defineProperty(exports, "blit", {
  enumerable: true,
  get: function () {
    return _copyAndBlit.blit;
  }
});
Object.defineProperty(exports, "canCompileGLGSExtension", {
  enumerable: true,
  get: function () {
    return _checkGlslExtension.default;
  }
});
Object.defineProperty(exports, "cancelAnimationFrame", {
  enumerable: true,
  get: function () {
    return _requestAnimationFrame.cancelAnimationFrame;
  }
});
Object.defineProperty(exports, "clear", {
  enumerable: true,
  get: function () {
    return _clear.clear;
  }
});
Object.defineProperty(exports, "clearBuffer", {
  enumerable: true,
  get: function () {
    return _clear.clearBuffer;
  }
});
Object.defineProperty(exports, "cloneTextureFrom", {
  enumerable: true,
  get: function () {
    return _textureUtils.cloneTextureFrom;
  }
});
Object.defineProperty(exports, "copyToDataUrl", {
  enumerable: true,
  get: function () {
    return _copyAndBlit.copyToDataUrl;
  }
});
Object.defineProperty(exports, "copyToImage", {
  enumerable: true,
  get: function () {
    return _copyAndBlit.copyToImage;
  }
});
Object.defineProperty(exports, "copyToTexture", {
  enumerable: true,
  get: function () {
    return _copyAndBlit.copyToTexture;
  }
});
Object.defineProperty(exports, "getContextInfo", {
  enumerable: true,
  get: function () {
    return _limits.getContextInfo;
  }
});
Object.defineProperty(exports, "getContextLimits", {
  enumerable: true,
  get: function () {
    return _limits.getContextLimits;
  }
});
Object.defineProperty(exports, "getDebugTableForProgramConfiguration", {
  enumerable: true,
  get: function () {
    return _debugProgramConfiguration.getDebugTableForProgramConfiguration;
  }
});
Object.defineProperty(exports, "getDebugTableForUniforms", {
  enumerable: true,
  get: function () {
    return _debugUniforms.getDebugTableForUniforms;
  }
});
Object.defineProperty(exports, "getDebugTableForVertexArray", {
  enumerable: true,
  get: function () {
    return _debugVertexArray.getDebugTableForVertexArray;
  }
});
Object.defineProperty(exports, "getFeatures", {
  enumerable: true,
  get: function () {
    return _features.getFeatures;
  }
});
Object.defineProperty(exports, "getGLContextInfo", {
  enumerable: true,
  get: function () {
    return _limits.getGLContextInfo;
  }
});
Object.defineProperty(exports, "getKey", {
  enumerable: true,
  get: function () {
    return _constantsToKeys.getKey;
  }
});
Object.defineProperty(exports, "getKeyValue", {
  enumerable: true,
  get: function () {
    return _constantsToKeys.getKeyValue;
  }
});
Object.defineProperty(exports, "getShaderName", {
  enumerable: true,
  get: function () {
    return _getShaderName.default;
  }
});
Object.defineProperty(exports, "getShaderVersion", {
  enumerable: true,
  get: function () {
    return _getShaderVersion.default;
  }
});
Object.defineProperty(exports, "getUniformSetter", {
  enumerable: true,
  get: function () {
    return _uniforms.getUniformSetter;
  }
});
Object.defineProperty(exports, "hasFeature", {
  enumerable: true,
  get: function () {
    return _features.hasFeature;
  }
});
Object.defineProperty(exports, "hasFeatures", {
  enumerable: true,
  get: function () {
    return _features.hasFeatures;
  }
});
Object.defineProperty(exports, "isObjectEmpty", {
  enumerable: true,
  get: function () {
    return _utils.isObjectEmpty;
  }
});
Object.defineProperty(exports, "loadFile", {
  enumerable: true,
  get: function () {
    return _loadFile.loadFile;
  }
});
Object.defineProperty(exports, "loadImage", {
  enumerable: true,
  get: function () {
    return _loadFile.loadImage;
  }
});
Object.defineProperty(exports, "log", {
  enumerable: true,
  get: function () {
    return _gltools.log;
  }
});
Object.defineProperty(exports, "lumaStats", {
  enumerable: true,
  get: function () {
    return _init.lumaStats;
  }
});
Object.defineProperty(exports, "parseUniformName", {
  enumerable: true,
  get: function () {
    return _uniforms.parseUniformName;
  }
});
Object.defineProperty(exports, "readPixelsToArray", {
  enumerable: true,
  get: function () {
    return _copyAndBlit.readPixelsToArray;
  }
});
Object.defineProperty(exports, "readPixelsToBuffer", {
  enumerable: true,
  get: function () {
    return _copyAndBlit.readPixelsToBuffer;
  }
});
Object.defineProperty(exports, "requestAnimationFrame", {
  enumerable: true,
  get: function () {
    return _requestAnimationFrame.requestAnimationFrame;
  }
});
Object.defineProperty(exports, "setPathPrefix", {
  enumerable: true,
  get: function () {
    return _loadFile.setPathPrefix;
  }
});
Object.defineProperty(exports, "uid", {
  enumerable: true,
  get: function () {
    return _utils.uid;
  }
});

var _init = require("./init");

var _requestAnimationFrame = require("./webgl-utils/request-animation-frame");

var _textureUtils = require("./webgl-utils/texture-utils");

var _constantsToKeys = require("./webgl-utils/constants-to-keys");

var _limits = require("./features/limits");

var _webglFeaturesTable = require("./features/webgl-features-table");

var _features = require("./features/features");

var _checkGlslExtension = _interopRequireDefault(require("./features/check-glsl-extension"));

var _accessor = _interopRequireDefault(require("./classes/accessor"));

var _buffer = _interopRequireDefault(require("./classes/buffer"));

var _shader = require("./classes/shader");

var _program = _interopRequireDefault(require("./classes/program"));

var _framebuffer = _interopRequireDefault(require("./classes/framebuffer"));

var _renderbuffer = _interopRequireDefault(require("./classes/renderbuffer"));

var _texture2d = _interopRequireDefault(require("./classes/texture-2d"));

var _textureCube = _interopRequireDefault(require("./classes/texture-cube"));

var _clear = require("./classes/clear");

var _copyAndBlit = require("./classes/copy-and-blit");

var _query = _interopRequireDefault(require("./classes/query"));

var _texture3d = _interopRequireDefault(require("./classes/texture-3d"));

var _transformFeedback = _interopRequireDefault(require("./classes/transform-feedback"));

var _vertexArrayObject = _interopRequireDefault(require("./classes/vertex-array-object"));

var _vertexArray = _interopRequireDefault(require("./classes/vertex-array"));

var _uniformBufferLayout = _interopRequireDefault(require("./classes/uniform-buffer-layout"));

var _loadFile = require("./utils/load-file");

var _getShaderName = _interopRequireDefault(require("./glsl-utils/get-shader-name"));

var _getShaderVersion = _interopRequireDefault(require("./glsl-utils/get-shader-version"));

var _gltools = require("@luma.gl/gltools");

var _assert = require("./utils/assert");

var _utils = require("./utils/utils");

var _uniforms = require("./classes/uniforms");

var _debugUniforms = require("./debug/debug-uniforms");

var _debugVertexArray = require("./debug/debug-vertex-array");

var _debugProgramConfiguration = require("./debug/debug-program-configuration");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./init":"node_modules/@luma.gl/webgl/dist/esm/init.js","./webgl-utils/request-animation-frame":"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/request-animation-frame.js","./webgl-utils/texture-utils":"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/texture-utils.js","./webgl-utils/constants-to-keys":"node_modules/@luma.gl/webgl/dist/esm/webgl-utils/constants-to-keys.js","./features/limits":"node_modules/@luma.gl/webgl/dist/esm/features/limits.js","./features/webgl-features-table":"node_modules/@luma.gl/webgl/dist/esm/features/webgl-features-table.js","./features/features":"node_modules/@luma.gl/webgl/dist/esm/features/features.js","./features/check-glsl-extension":"node_modules/@luma.gl/webgl/dist/esm/features/check-glsl-extension.js","./classes/accessor":"node_modules/@luma.gl/webgl/dist/esm/classes/accessor.js","./classes/buffer":"node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js","./classes/shader":"node_modules/@luma.gl/webgl/dist/esm/classes/shader.js","./classes/program":"node_modules/@luma.gl/webgl/dist/esm/classes/program.js","./classes/framebuffer":"node_modules/@luma.gl/webgl/dist/esm/classes/framebuffer.js","./classes/renderbuffer":"node_modules/@luma.gl/webgl/dist/esm/classes/renderbuffer.js","./classes/texture-2d":"node_modules/@luma.gl/webgl/dist/esm/classes/texture-2d.js","./classes/texture-cube":"node_modules/@luma.gl/webgl/dist/esm/classes/texture-cube.js","./classes/clear":"node_modules/@luma.gl/webgl/dist/esm/classes/clear.js","./classes/copy-and-blit":"node_modules/@luma.gl/webgl/dist/esm/classes/copy-and-blit.js","./classes/query":"node_modules/@luma.gl/webgl/dist/esm/classes/query.js","./classes/texture-3d":"node_modules/@luma.gl/webgl/dist/esm/classes/texture-3d.js","./classes/transform-feedback":"node_modules/@luma.gl/webgl/dist/esm/classes/transform-feedback.js","./classes/vertex-array-object":"node_modules/@luma.gl/webgl/dist/esm/classes/vertex-array-object.js","./classes/vertex-array":"node_modules/@luma.gl/webgl/dist/esm/classes/vertex-array.js","./classes/uniform-buffer-layout":"node_modules/@luma.gl/webgl/dist/esm/classes/uniform-buffer-layout.js","./utils/load-file":"node_modules/@luma.gl/webgl/dist/esm/utils/load-file.js","./glsl-utils/get-shader-name":"node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-name.js","./glsl-utils/get-shader-version":"node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-version.js","@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","./utils/assert":"node_modules/@luma.gl/webgl/dist/esm/utils/assert.js","./utils/utils":"node_modules/@luma.gl/webgl/dist/esm/utils/utils.js","./classes/uniforms":"node_modules/@luma.gl/webgl/dist/esm/classes/uniforms.js","./debug/debug-uniforms":"node_modules/@luma.gl/webgl/dist/esm/debug/debug-uniforms.js","./debug/debug-vertex-array":"node_modules/@luma.gl/webgl/dist/esm/debug/debug-vertex-array.js","./debug/debug-program-configuration":"node_modules/@luma.gl/webgl/dist/esm/debug/debug-program-configuration.js"}],"node_modules/@luma.gl/engine/dist/esm/lib/animation-loop.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _gltools = require("@luma.gl/gltools");

var _webgl = require("@luma.gl/webgl");

var _env = require("@probe.gl/env");

const isPage = (0, _env.isBrowser)() && typeof document !== 'undefined';
let statIdCounter = 0;

class AnimationLoop {
  constructor(props = {}) {
    const {
      onCreateContext = opts => (0, _gltools.createGLContext)(opts),
      onAddHTML = null,
      onInitialize = () => {},
      onRender = () => {},
      onFinalize = () => {},
      onError,
      gl = null,
      glOptions = {},
      debug = false,
      createFramebuffer = false,
      autoResizeViewport = true,
      autoResizeDrawingBuffer = true,
      stats = _webgl.lumaStats.get(`animation-loop-${statIdCounter++}`)
    } = props;
    let {
      useDevicePixels = true
    } = props;

    if ('useDevicePixelRatio' in props) {
      _webgl.log.deprecated('useDevicePixelRatio', 'useDevicePixels')();

      useDevicePixels = props.useDevicePixelRatio;
    }

    this.props = {
      onCreateContext,
      onAddHTML,
      onInitialize,
      onRender,
      onFinalize,
      onError,
      gl,
      glOptions,
      debug,
      createFramebuffer
    };
    this.gl = gl;
    this.needsRedraw = null;
    this.timeline = null;
    this.stats = stats;
    this.cpuTime = this.stats.get('CPU Time');
    this.gpuTime = this.stats.get('GPU Time');
    this.frameRate = this.stats.get('Frame Rate');
    this._initialized = false;
    this._running = false;
    this._animationFrameId = null;
    this._nextFramePromise = null;
    this._resolveNextFrame = null;
    this._cpuStartTime = 0;
    this.setProps({
      autoResizeViewport,
      autoResizeDrawingBuffer,
      useDevicePixels
    });
    this.start = this.start.bind(this);
    this.stop = this.stop.bind(this);
    this._pageLoadPromise = null;
    this._onMousemove = this._onMousemove.bind(this);
    this._onMouseleave = this._onMouseleave.bind(this);
  }

  delete() {
    this.stop();

    this._setDisplay(null);
  }

  setNeedsRedraw(reason) {
    (0, _webgl.assert)(typeof reason === 'string');
    this.needsRedraw = this.needsRedraw || reason;
    return this;
  }

  setProps(props) {
    if ('autoResizeViewport' in props) {
      this.autoResizeViewport = props.autoResizeViewport;
    }

    if ('autoResizeDrawingBuffer' in props) {
      this.autoResizeDrawingBuffer = props.autoResizeDrawingBuffer;
    }

    if ('useDevicePixels' in props) {
      this.useDevicePixels = props.useDevicePixels;
    }

    return this;
  }

  start(opts = {}) {
    if (this._running) {
      return this;
    }

    this._running = true;

    const startPromise = this._getPageLoadPromise().then(() => {
      if (!this._running || this._initialized) {
        return null;
      }

      this._createWebGLContext(opts);

      this._createFramebuffer();

      this._startEventHandling();

      this._initializeCallbackData();

      this._updateCallbackData();

      this._resizeCanvasDrawingBuffer();

      this._resizeViewport();

      this._gpuTimeQuery = _webgl.Query.isSupported(this.gl, ['timers']) ? new _webgl.Query(this.gl) : null;
      this._initialized = true;
      return this.onInitialize(this.animationProps);
    }).then(appContext => {
      if (this._running) {
        this._addCallbackData(appContext || {});

        if (appContext !== false) {
          this._startLoop();
        }
      }
    });

    if (this.props.onError) {
      startPromise.catch(this.props.onError);
    }

    return this;
  }

  redraw() {
    if (this.isContextLost()) {
      return this;
    }

    this._beginTimers();

    this._setupFrame();

    this._updateCallbackData();

    this._renderFrame(this.animationProps);

    this._clearNeedsRedraw();

    if (this.offScreen && this.gl.commit) {
      this.gl.commit();
    }

    if (this._resolveNextFrame) {
      this._resolveNextFrame(this);

      this._nextFramePromise = null;
      this._resolveNextFrame = null;
    }

    this._endTimers();

    return this;
  }

  stop() {
    if (this._running) {
      this._finalizeCallbackData();

      this._cancelAnimationFrame(this._animationFrameId);

      this._nextFramePromise = null;
      this._resolveNextFrame = null;
      this._animationFrameId = null;
      this._running = false;
    }

    return this;
  }

  attachTimeline(timeline) {
    this.timeline = timeline;
    return this.timeline;
  }

  detachTimeline() {
    this.timeline = null;
  }

  waitForRender() {
    this.setNeedsRedraw('waitForRender');

    if (!this._nextFramePromise) {
      this._nextFramePromise = new Promise(resolve => {
        this._resolveNextFrame = resolve;
      });
    }

    return this._nextFramePromise;
  }

  async toDataURL() {
    this.setNeedsRedraw('toDataURL');
    await this.waitForRender();
    return this.gl.canvas.toDataURL();
  }

  isContextLost() {
    return this.gl.isContextLost();
  }

  onCreateContext(...args) {
    return this.props.onCreateContext(...args);
  }

  onInitialize(...args) {
    return this.props.onInitialize(...args);
  }

  onRender(...args) {
    return this.props.onRender(...args);
  }

  onFinalize(...args) {
    return this.props.onFinalize(...args);
  }

  getHTMLControlValue(id, defaultValue = 1) {
    const element = document.getElementById(id);
    return element ? Number(element.value) : defaultValue;
  }

  setViewParameters() {
    _webgl.log.removed('AnimationLoop.setViewParameters', 'AnimationLoop.setProps')();

    return this;
  }

  _startLoop() {
    const renderFrame = () => {
      if (!this._running) {
        return;
      }

      this.redraw();
      this._animationFrameId = this._requestAnimationFrame(renderFrame);
    };

    this._cancelAnimationFrame(this._animationFrameId);

    this._animationFrameId = this._requestAnimationFrame(renderFrame);
  }

  _getPageLoadPromise() {
    if (!this._pageLoadPromise) {
      this._pageLoadPromise = isPage ? new Promise((resolve, reject) => {
        if (isPage && document.readyState === 'complete') {
          resolve(document);
          return;
        }

        window.addEventListener('load', () => {
          resolve(document);
        });
      }) : Promise.resolve({});
    }

    return this._pageLoadPromise;
  }

  _setDisplay(display) {
    if (this.display) {
      this.display.delete();
      this.display.animationLoop = null;
    }

    if (display) {
      display.animationLoop = this;
    }

    this.display = display;
  }

  _cancelAnimationFrame(animationFrameId) {
    if (this.display && this.display.cancelAnimationFrame) {
      return this.display.cancelAnimationFrame(animationFrameId);
    }

    return (0, _webgl.cancelAnimationFrame)(animationFrameId);
  }

  _requestAnimationFrame(renderFrameCallback) {
    if (this._running) {
      if (this.display && this.display.requestAnimationFrame) {
        return this.display.requestAnimationFrame(renderFrameCallback);
      }

      return (0, _webgl.requestAnimationFrame)(renderFrameCallback);
    }

    return undefined;
  }

  _renderFrame(...args) {
    if (this.display) {
      this.display._renderFrame(...args);

      return;
    }

    this.onRender(...args);
  }

  _clearNeedsRedraw() {
    this.needsRedraw = null;
  }

  _setupFrame() {
    this._resizeCanvasDrawingBuffer();

    this._resizeViewport();

    this._resizeFramebuffer();
  }

  _initializeCallbackData() {
    this.animationProps = {
      gl: this.gl,
      stop: this.stop,
      canvas: this.gl.canvas,
      framebuffer: this.framebuffer,
      useDevicePixels: this.useDevicePixels,
      needsRedraw: null,
      startTime: Date.now(),
      engineTime: 0,
      tick: 0,
      tock: 0,
      time: 0,
      _timeline: this.timeline,
      _loop: this,
      _animationLoop: this,
      _mousePosition: null
    };
  }

  _updateCallbackData() {
    const {
      width,
      height,
      aspect
    } = this._getSizeAndAspect();

    if (width !== this.animationProps.width || height !== this.animationProps.height) {
      this.setNeedsRedraw('drawing buffer resized');
    }

    if (aspect !== this.animationProps.aspect) {
      this.setNeedsRedraw('drawing buffer aspect changed');
    }

    this.animationProps.width = width;
    this.animationProps.height = height;
    this.animationProps.aspect = aspect;
    this.animationProps.needsRedraw = this.needsRedraw;
    this.animationProps.engineTime = Date.now() - this.animationProps.startTime;

    if (this.timeline) {
      this.timeline.update(this.animationProps.engineTime);
    }

    this.animationProps.tick = Math.floor(this.animationProps.time / 1000 * 60);
    this.animationProps.tock++;
    this.animationProps.time = this.timeline ? this.timeline.getTime() : this.animationProps.engineTime;
    this.animationProps._offScreen = this.offScreen;
  }

  _finalizeCallbackData() {
    this.onFinalize(this.animationProps);
  }

  _addCallbackData(appContext) {
    if (typeof appContext === 'object' && appContext !== null) {
      this.animationProps = Object.assign({}, this.animationProps, appContext);
    }
  }

  _createWebGLContext(opts) {
    this.offScreen = opts.canvas && typeof OffscreenCanvas !== 'undefined' && opts.canvas instanceof OffscreenCanvas;
    opts = Object.assign({}, opts, this.props.glOptions);
    this.gl = this.props.gl ? (0, _gltools.instrumentGLContext)(this.props.gl, opts) : this.onCreateContext(opts);

    if (!(0, _gltools.isWebGL)(this.gl)) {
      throw new Error('AnimationLoop.onCreateContext - illegal context returned');
    }

    (0, _gltools.resetParameters)(this.gl);

    this._createInfoDiv();
  }

  _createInfoDiv() {
    if (this.gl.canvas && this.props.onAddHTML) {
      const wrapperDiv = document.createElement('div');
      document.body.appendChild(wrapperDiv);
      wrapperDiv.style.position = 'relative';
      const div = document.createElement('div');
      div.style.position = 'absolute';
      div.style.left = '10px';
      div.style.bottom = '10px';
      div.style.width = '300px';
      div.style.background = 'white';
      wrapperDiv.appendChild(this.gl.canvas);
      wrapperDiv.appendChild(div);
      const html = this.props.onAddHTML(div);

      if (html) {
        div.innerHTML = html;
      }
    }
  }

  _getSizeAndAspect() {
    const width = this.gl.drawingBufferWidth;
    const height = this.gl.drawingBufferHeight;
    let aspect = 1;
    const {
      canvas
    } = this.gl;

    if (canvas && canvas.clientHeight) {
      aspect = canvas.clientWidth / canvas.clientHeight;
    } else if (width > 0 && height > 0) {
      aspect = width / height;
    }

    return {
      width,
      height,
      aspect
    };
  }

  _resizeViewport() {
    if (this.autoResizeViewport) {
      this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight);
    }
  }

  _resizeCanvasDrawingBuffer() {
    if (this.autoResizeDrawingBuffer) {
      (0, _gltools.resizeGLContext)(this.gl, {
        useDevicePixels: this.useDevicePixels
      });
    }
  }

  _createFramebuffer() {
    if (this.props.createFramebuffer) {
      this.framebuffer = new _webgl.Framebuffer(this.gl);
    }
  }

  _resizeFramebuffer() {
    if (this.framebuffer) {
      this.framebuffer.resize({
        width: this.gl.drawingBufferWidth,
        height: this.gl.drawingBufferHeight
      });
    }
  }

  _beginTimers() {
    this.frameRate.timeEnd();
    this.frameRate.timeStart();

    if (this._gpuTimeQuery && this._gpuTimeQuery.isResultAvailable() && !this._gpuTimeQuery.isTimerDisjoint()) {
      this.stats.get('GPU Time').addTime(this._gpuTimeQuery.getTimerMilliseconds());
    }

    if (this._gpuTimeQuery) {
      this._gpuTimeQuery.beginTimeElapsedQuery();
    }

    this.cpuTime.timeStart();
  }

  _endTimers() {
    this.cpuTime.timeEnd();

    if (this._gpuTimeQuery) {
      this._gpuTimeQuery.end();
    }
  }

  _startEventHandling() {
    const {
      canvas
    } = this.gl;

    if (canvas) {
      canvas.addEventListener('mousemove', this._onMousemove);
      canvas.addEventListener('mouseleave', this._onMouseleave);
    }
  }

  _onMousemove(e) {
    this.animationProps._mousePosition = [e.offsetX, e.offsetY];
  }

  _onMouseleave(e) {
    this.animationProps._mousePosition = null;
  }

}

exports.default = AnimationLoop;
},{"@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","@luma.gl/webgl":"node_modules/@luma.gl/webgl/dist/esm/index.js","@probe.gl/env":"node_modules/@probe.gl/env/dist/esm/index.js"}],"node_modules/@luma.gl/shadertools/dist/esm/lib/constants.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VERTEX_SHADER = exports.FRAGMENT_SHADER = void 0;
const VERTEX_SHADER = 'vs';
exports.VERTEX_SHADER = VERTEX_SHADER;
const FRAGMENT_SHADER = 'fs';
exports.FRAGMENT_SHADER = FRAGMENT_SHADER;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/utils/assert.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = assert;

function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'shadertools: assertion failed.');
  }
}
},{}],"node_modules/@luma.gl/shadertools/dist/esm/utils/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function () {
    return _assert.default;
  }
});

var _assert = _interopRequireDefault(require("./assert"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./assert":"node_modules/@luma.gl/shadertools/dist/esm/utils/assert.js"}],"node_modules/@luma.gl/shadertools/dist/esm/lib/filters/prop-types.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parsePropTypes = parsePropTypes;
const TYPE_DEFINITIONS = {
  number: {
    validate(value, propType) {
      return Number.isFinite(value) && (!('max' in propType) || value <= propType.max) && (!('min' in propType) || value >= propType.min);
    }

  },
  array: {
    validate(value, propType) {
      return Array.isArray(value) || ArrayBuffer.isView(value);
    }

  }
};

function parsePropTypes(propDefs) {
  const propTypes = {};

  for (const propName in propDefs) {
    const propDef = propDefs[propName];
    const propType = parsePropType(propDef);
    propTypes[propName] = propType;
  }

  return propTypes;
}

function parsePropType(propDef) {
  let type = getTypeOf(propDef);

  if (type === 'object') {
    if (!propDef) {
      return {
        type: 'object',
        value: null
      };
    }

    if ('type' in propDef) {
      return Object.assign({}, propDef, TYPE_DEFINITIONS[propDef.type]);
    }

    if (!('value' in propDef)) {
      return {
        type: 'object',
        value: propDef
      };
    }

    type = getTypeOf(propDef.value);
    return Object.assign({
      type
    }, propDef, TYPE_DEFINITIONS[type]);
  }

  return Object.assign({
    type,
    value: propDef
  }, TYPE_DEFINITIONS[type]);
}

function getTypeOf(value) {
  if (Array.isArray(value) || ArrayBuffer.isView(value)) {
    return 'array';
  }

  return typeof value;
}
},{}],"node_modules/@luma.gl/shadertools/dist/esm/lib/shader-module.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
exports.normalizeShaderModule = normalizeShaderModule;

var _utils = require("../utils");

var _propTypes = require("./filters/prop-types");

const VERTEX_SHADER = 'vs';
const FRAGMENT_SHADER = 'fs';

class ShaderModule {
  constructor({
    name,
    vs,
    fs,
    dependencies = [],
    uniforms,
    getUniforms,
    deprecations = [],
    defines = {},
    inject = {},
    vertexShader,
    fragmentShader
  }) {
    (0, _utils.assert)(typeof name === 'string');
    this.name = name;
    this.vs = vs || vertexShader;
    this.fs = fs || fragmentShader;
    this.getModuleUniforms = getUniforms;
    this.dependencies = dependencies;
    this.deprecations = this._parseDeprecationDefinitions(deprecations);
    this.defines = defines;
    this.injections = normalizeInjections(inject);

    if (uniforms) {
      this.uniforms = (0, _propTypes.parsePropTypes)(uniforms);
    }
  }

  getModuleSource(type) {
    let moduleSource;

    switch (type) {
      case VERTEX_SHADER:
        moduleSource = this.vs || '';
        break;

      case FRAGMENT_SHADER:
        moduleSource = this.fs || '';
        break;

      default:
        (0, _utils.assert)(false);
    }

    return `\
#define MODULE_${this.name.toUpperCase().replace(/[^0-9a-z]/gi, '_')}
${moduleSource}\
// END MODULE_${this.name}

`;
  }

  getUniforms(opts, uniforms) {
    if (this.getModuleUniforms) {
      return this.getModuleUniforms(opts, uniforms);
    }

    if (this.uniforms) {
      return this._defaultGetUniforms(opts);
    }

    return {};
  }

  getDefines() {
    return this.defines;
  }

  checkDeprecations(shaderSource, log) {
    this.deprecations.forEach(def => {
      if (def.regex.test(shaderSource)) {
        if (def.deprecated) {
          log.deprecated(def.old, def.new)();
        } else {
          log.removed(def.old, def.new)();
        }
      }
    });
  }

  _parseDeprecationDefinitions(deprecations) {
    deprecations.forEach(def => {
      switch (def.type) {
        case 'function':
          def.regex = new RegExp(`\\b${def.old}\\(`);
          break;

        default:
          def.regex = new RegExp(`${def.type} ${def.old};`);
      }
    });
    return deprecations;
  }

  _defaultGetUniforms(opts = {}) {
    const uniforms = {};
    const propTypes = this.uniforms;

    for (const key in propTypes) {
      const propDef = propTypes[key];

      if (key in opts && !propDef.private) {
        if (propDef.validate) {
          (0, _utils.assert)(propDef.validate(opts[key], propDef), `${this.name}: invalid ${key}`);
        }

        uniforms[key] = opts[key];
      } else {
        uniforms[key] = propDef.value;
      }
    }

    return uniforms;
  }

}

exports.default = ShaderModule;

function normalizeShaderModule(module) {
  if (!module.normalized) {
    module.normalized = true;

    if (module.uniforms && !module.getUniforms) {
      const shaderModule = new ShaderModule(module);
      module.getUniforms = shaderModule.getUniforms.bind(shaderModule);
    }
  }

  return module;
}

function normalizeInjections(injections) {
  const result = {
    vs: {},
    fs: {}
  };

  for (const hook in injections) {
    let injection = injections[hook];
    const stage = hook.slice(0, 2);

    if (typeof injection === 'string') {
      injection = {
        order: 0,
        injection
      };
    }

    result[stage][hook] = injection;
  }

  return result;
}
},{"../utils":"node_modules/@luma.gl/shadertools/dist/esm/utils/index.js","./filters/prop-types":"node_modules/@luma.gl/shadertools/dist/esm/lib/filters/prop-types.js"}],"node_modules/@luma.gl/shadertools/dist/esm/lib/resolve-modules.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TEST_EXPORTS = void 0;
exports.resolveModules = resolveModules;

var _shaderModule = _interopRequireDefault(require("./shader-module"));

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function resolveModules(modules) {
  return getShaderDependencies(instantiateModules(modules));
}

function getShaderDependencies(modules) {
  const moduleMap = {};
  const moduleDepth = {};
  getDependencyGraph({
    modules,
    level: 0,
    moduleMap,
    moduleDepth
  });
  return Object.keys(moduleDepth).sort((a, b) => moduleDepth[b] - moduleDepth[a]).map(name => moduleMap[name]);
}

function getDependencyGraph({
  modules,
  level,
  moduleMap,
  moduleDepth
}) {
  if (level >= 5) {
    throw new Error('Possible loop in shader dependency graph');
  }

  for (const module of modules) {
    moduleMap[module.name] = module;

    if (moduleDepth[module.name] === undefined || moduleDepth[module.name] < level) {
      moduleDepth[module.name] = level;
    }
  }

  for (const module of modules) {
    if (module.dependencies) {
      getDependencyGraph({
        modules: module.dependencies,
        level: level + 1,
        moduleMap,
        moduleDepth
      });
    }
  }
}

function instantiateModules(modules, seen) {
  return modules.map(module => {
    if (module instanceof _shaderModule.default) {
      return module;
    }

    (0, _utils.assert)(typeof module !== 'string', `Shader module use by name is deprecated. Import shader module '${module}' and use it directly.`);
    (0, _utils.assert)(module.name, 'shader module has no name');
    module = new _shaderModule.default(module);
    module.dependencies = instantiateModules(module.dependencies);
    return module;
  });
}

const TEST_EXPORTS = {
  getShaderDependencies,
  getDependencyGraph
};
exports.TEST_EXPORTS = TEST_EXPORTS;
},{"./shader-module":"node_modules/@luma.gl/shadertools/dist/esm/lib/shader-module.js","../utils":"node_modules/@luma.gl/shadertools/dist/esm/utils/index.js"}],"node_modules/@luma.gl/shadertools/dist/esm/utils/is-old-ie.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isOldIE;

function isOldIE(opts = {}) {
  const navigator = typeof window !== 'undefined' ? window.navigator || {} : {};
  const userAgent = opts.userAgent || navigator.userAgent || '';
  const isMSIE = userAgent.indexOf('MSIE ') !== -1;
  const isTrident = userAgent.indexOf('Trident/') !== -1;
  return isMSIE || isTrident;
}
},{}],"node_modules/@luma.gl/shadertools/dist/esm/utils/webgl-info.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FEATURES = void 0;
exports.canCompileGLGSExtension = canCompileGLGSExtension;
exports.getContextInfo = getContextInfo;
exports.hasFeatures = hasFeatures;

var _isOldIe = _interopRequireDefault(require("./is-old-ie"));

var _assert = _interopRequireDefault(require("./assert"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const GL_VENDOR = 0x1f00;
const GL_RENDERER = 0x1f01;
const GL_VERSION = 0x1f02;
const GL_SHADING_LANGUAGE_VERSION = 0x8b8c;
const WEBGL_FEATURES = {
  GLSL_FRAG_DATA: ['WEBGL_draw_buffers', true],
  GLSL_FRAG_DEPTH: ['EXT_frag_depth', true],
  GLSL_DERIVATIVES: ['OES_standard_derivatives', true],
  GLSL_TEXTURE_LOD: ['EXT_shader_texture_lod', true]
};
const FEATURES = {};
exports.FEATURES = FEATURES;
Object.keys(WEBGL_FEATURES).forEach(key => {
  FEATURES[key] = key;
});

function isWebGL2(gl) {
  if (typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext) {
    return true;
  }

  return Boolean(gl && gl._version === 2);
}

function getContextInfo(gl) {
  const info = gl.getExtension('WEBGL_debug_renderer_info');
  const vendor = gl.getParameter(info && info.UNMASKED_VENDOR_WEBGL || GL_VENDOR);
  const renderer = gl.getParameter(info && info.UNMASKED_RENDERER_WEBGL || GL_RENDERER);
  const gpuVendor = identifyGPUVendor(vendor, renderer);
  const gpuInfo = {
    gpuVendor,
    vendor,
    renderer,
    version: gl.getParameter(GL_VERSION),
    shadingLanguageVersion: gl.getParameter(GL_SHADING_LANGUAGE_VERSION)
  };
  return gpuInfo;
}

function identifyGPUVendor(vendor, renderer) {
  if (vendor.match(/NVIDIA/i) || renderer.match(/NVIDIA/i)) {
    return 'NVIDIA';
  }

  if (vendor.match(/INTEL/i) || renderer.match(/INTEL/i)) {
    return 'INTEL';
  }

  if (vendor.match(/AMD/i) || renderer.match(/AMD/i) || vendor.match(/ATI/i) || renderer.match(/ATI/i)) {
    return 'AMD';
  }

  return 'UNKNOWN GPU';
}

const compiledGlslExtensions = {};

function canCompileGLGSExtension(gl, cap, opts = {}) {
  const feature = WEBGL_FEATURES[cap];
  (0, _assert.default)(feature, cap);

  if (!(0, _isOldIe.default)(opts)) {
    return true;
  }

  if (cap in compiledGlslExtensions) {
    return compiledGlslExtensions[cap];
  }

  const extensionName = feature[0];
  const behavior = opts.behavior || 'enable';
  const source = `#extension GL_${extensionName} : ${behavior}\nvoid main(void) {}`;
  const shader = gl.createShader(35633);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  const canCompile = gl.getShaderParameter(shader, 35713);
  gl.deleteShader(shader);
  compiledGlslExtensions[cap] = canCompile;
  return canCompile;
}

function getFeature(gl, cap) {
  const feature = WEBGL_FEATURES[cap];
  (0, _assert.default)(feature, cap);
  const extensionName = isWebGL2(gl) ? feature[1] || feature[0] : feature[0];
  const value = typeof extensionName === 'string' ? Boolean(gl.getExtension(extensionName)) : extensionName;
  (0, _assert.default)(value === false || value === true);
  return value;
}

function hasFeatures(gl, features) {
  features = Array.isArray(features) ? features : [features];
  return features.every(feature => getFeature(gl, feature));
}
},{"./is-old-ie":"node_modules/@luma.gl/shadertools/dist/esm/utils/is-old-ie.js","./assert":"node_modules/@luma.gl/shadertools/dist/esm/utils/assert.js"}],"node_modules/@luma.gl/shadertools/dist/esm/lib/platform-defines.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPlatformShaderDefines = getPlatformShaderDefines;
exports.getVersionDefines = getVersionDefines;

var _webglInfo = require("../utils/webgl-info");

function getPlatformShaderDefines(gl) {
  const debugInfo = (0, _webglInfo.getContextInfo)(gl);

  switch (debugInfo.gpuVendor.toLowerCase()) {
    case 'nvidia':
      return `\
#define NVIDIA_GPU
// Nvidia optimizes away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
`;

    case 'intel':
      return `\
#define INTEL_GPU
// Intel optimizes away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
// Intel's built-in 'tan' function doesn't have acceptable precision
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`;

    case 'amd':
      return `\
#define AMD_GPU
`;

    default:
      return `\
#define DEFAULT_GPU
// Prevent driver from optimizing away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
// Intel's built-in 'tan' function doesn't have acceptable precision
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`;
  }
}

function getVersionDefines(gl, glslVersion, isFragment) {
  let versionDefines = `\
#if (__VERSION__ > 120)

# define FEATURE_GLSL_DERIVATIVES
# define FEATURE_GLSL_DRAW_BUFFERS
# define FEATURE_GLSL_FRAG_DEPTH
# define FEATURE_GLSL_TEXTURE_LOD

// DEPRECATED FLAGS, remove in v9
# define FRAG_DEPTH
# define DERIVATIVES
# define DRAW_BUFFERS
# define TEXTURE_LOD

#endif // __VERSION
`;

  if ((0, _webglInfo.hasFeatures)(gl, _webglInfo.FEATURES.GLSL_FRAG_DEPTH)) {
    versionDefines += `\

// FRAG_DEPTH => gl_FragDepth is available
#ifdef GL_EXT_frag_depth
#extension GL_EXT_frag_depth : enable
# define FEATURE_GLSL_FRAG_DEPTH
# define FRAG_DEPTH
# define gl_FragDepth gl_FragDepthEXT
#endif
`;
  }

  if ((0, _webglInfo.hasFeatures)(gl, _webglInfo.FEATURES.GLSL_DERIVATIVES) && (0, _webglInfo.canCompileGLGSExtension)(gl, _webglInfo.FEATURES.GLSL_DERIVATIVES)) {
    versionDefines += `\

// DERIVATIVES => dxdF, dxdY and fwidth are available
#ifdef GL_OES_standard_derivatives
#extension GL_OES_standard_derivatives : enable
# define FEATURE_GLSL_DERIVATIVES
# define DERIVATIVES
#endif
`;
  }

  if ((0, _webglInfo.hasFeatures)(gl, _webglInfo.FEATURES.GLSL_FRAG_DATA) && (0, _webglInfo.canCompileGLGSExtension)(gl, _webglInfo.FEATURES.GLSL_FRAG_DATA, {
    behavior: 'require'
  })) {
    versionDefines += `\

// DRAW_BUFFERS => gl_FragData[] is available
#ifdef GL_EXT_draw_buffers
#extension GL_EXT_draw_buffers : require
#define FEATURE_GLSL_DRAW_BUFFERS
#define DRAW_BUFFERS
#endif
`;
  }

  if ((0, _webglInfo.hasFeatures)(gl, _webglInfo.FEATURES.GLSL_TEXTURE_LOD)) {
    versionDefines += `\
// TEXTURE_LOD => texture2DLod etc are available
#ifdef GL_EXT_shader_texture_lod
#extension GL_EXT_shader_texture_lod : enable

# define FEATURE_GLSL_TEXTURE_LOD
# define TEXTURE_LOD

#endif
`;
  }

  return versionDefines;
}
},{"../utils/webgl-info":"node_modules/@luma.gl/shadertools/dist/esm/utils/webgl-info.js"}],"node_modules/@luma.gl/shadertools/dist/esm/modules/module-injectors.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MODULE_INJECTORS_VS = exports.MODULE_INJECTORS_FS = void 0;
const MODULE_INJECTORS_VS = `\
#ifdef MODULE_LOGDEPTH
  logdepth_adjustPosition(gl_Position);
#endif
`;
exports.MODULE_INJECTORS_VS = MODULE_INJECTORS_VS;
const MODULE_INJECTORS_FS = `\
#ifdef MODULE_MATERIAL
  gl_FragColor = material_filterColor(gl_FragColor);
#endif

#ifdef MODULE_LIGHTING
  gl_FragColor = lighting_filterColor(gl_FragColor);
#endif

#ifdef MODULE_FOG
  gl_FragColor = fog_filterColor(gl_FragColor);
#endif

#ifdef MODULE_PICKING
  gl_FragColor = picking_filterHighlightColor(gl_FragColor);
  gl_FragColor = picking_filterPickingColor(gl_FragColor);
#endif

#ifdef MODULE_LOGDEPTH
  logdepth_setFragDepth();
#endif
`;
exports.MODULE_INJECTORS_FS = MODULE_INJECTORS_FS;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/lib/inject-shader.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DECLARATION_INJECT_MARKER = void 0;
exports.combineInjects = combineInjects;
exports.default = injectShader;

var _moduleInjectors = require("../modules/module-injectors");

var _constants = require("./constants");

var _utils = require("../utils");

const MODULE_INJECTORS = {
  [_constants.VERTEX_SHADER]: _moduleInjectors.MODULE_INJECTORS_VS,
  [_constants.FRAGMENT_SHADER]: _moduleInjectors.MODULE_INJECTORS_FS
};
const DECLARATION_INJECT_MARKER = '__LUMA_INJECT_DECLARATIONS__';
exports.DECLARATION_INJECT_MARKER = DECLARATION_INJECT_MARKER;
const REGEX_START_OF_MAIN = /void\s+main\s*\([^)]*\)\s*\{\n?/;
const REGEX_END_OF_MAIN = /}\n?[^{}]*$/;
const fragments = [];

function injectShader(source, type, inject, injectStandardStubs = false) {
  const isVertex = type === _constants.VERTEX_SHADER;

  for (const key in inject) {
    const fragmentData = inject[key];
    fragmentData.sort((a, b) => a.order - b.order);
    fragments.length = fragmentData.length;

    for (let i = 0, len = fragmentData.length; i < len; ++i) {
      fragments[i] = fragmentData[i].injection;
    }

    const fragmentString = `${fragments.join('\n')}\n`;

    switch (key) {
      case 'vs:#decl':
        if (isVertex) {
          source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);
        }

        break;

      case 'vs:#main-start':
        if (isVertex) {
          source = source.replace(REGEX_START_OF_MAIN, match => match + fragmentString);
        }

        break;

      case 'vs:#main-end':
        if (isVertex) {
          source = source.replace(REGEX_END_OF_MAIN, match => fragmentString + match);
        }

        break;

      case 'fs:#decl':
        if (!isVertex) {
          source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);
        }

        break;

      case 'fs:#main-start':
        if (!isVertex) {
          source = source.replace(REGEX_START_OF_MAIN, match => match + fragmentString);
        }

        break;

      case 'fs:#main-end':
        if (!isVertex) {
          source = source.replace(REGEX_END_OF_MAIN, match => fragmentString + match);
        }

        break;

      default:
        source = source.replace(key, match => match + fragmentString);
    }
  }

  source = source.replace(DECLARATION_INJECT_MARKER, '');

  if (injectStandardStubs) {
    source = source.replace(/\}\s*$/, match => match + MODULE_INJECTORS[type]);
  }

  return source;
}

function combineInjects(injects) {
  const result = {};
  (0, _utils.assert)(Array.isArray(injects) && injects.length > 1);
  injects.forEach(inject => {
    for (const key in inject) {
      result[key] = result[key] ? `${result[key]}\n${inject[key]}` : inject[key];
    }
  });
  return result;
}
},{"../modules/module-injectors":"node_modules/@luma.gl/shadertools/dist/esm/modules/module-injectors.js","./constants":"node_modules/@luma.gl/shadertools/dist/esm/lib/constants.js","../utils":"node_modules/@luma.gl/shadertools/dist/esm/utils/index.js"}],"node_modules/@luma.gl/shadertools/dist/esm/lib/transpile-shader.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = transpileShader;

function testVariable(qualifier) {
  return new RegExp(`\\b${qualifier}[ \\t]+(\\w+[ \\t]+\\w+(\\[\\w+\\])?;)`, 'g');
}

const ES300_REPLACEMENTS = [[/^(#version[ \t]+(100|300[ \t]+es))?[ \t]*\n/, '#version 300 es\n'], [/\btexture(2D|2DProj|Cube)Lod(EXT)?\(/g, 'textureLod('], [/\btexture(2D|2DProj|Cube)(EXT)?\(/g, 'texture(']];
const ES300_VERTEX_REPLACEMENTS = [...ES300_REPLACEMENTS, [testVariable('attribute'), 'in $1'], [testVariable('varying'), 'out $1']];
const ES300_FRAGMENT_REPLACEMENTS = [...ES300_REPLACEMENTS, [testVariable('varying'), 'in $1']];
const ES100_REPLACEMENTS = [[/^#version[ \t]+300[ \t]+es/, '#version 100'], [/\btexture(2D|2DProj|Cube)Lod\(/g, 'texture$1LodEXT('], [/\btexture\(/g, 'texture2D('], [/\btextureLod\(/g, 'texture2DLodEXT(']];
const ES100_VERTEX_REPLACEMENTS = [...ES100_REPLACEMENTS, [testVariable('in'), 'attribute $1'], [testVariable('out'), 'varying $1']];
const ES100_FRAGMENT_REPLACEMENTS = [...ES100_REPLACEMENTS, [testVariable('in'), 'varying $1']];
const ES100_FRAGMENT_OUTPUT_NAME = 'gl_FragColor';
const ES300_FRAGMENT_OUTPUT_REGEX = /\bout[ \t]+vec4[ \t]+(\w+)[ \t]*;\n?/;
const REGEX_START_OF_MAIN = /void\s+main\s*\([^)]*\)\s*\{\n?/;

function transpileShader(source, targetGLSLVersion, isVertex) {
  switch (targetGLSLVersion) {
    case 300:
      return isVertex ? convertShader(source, ES300_VERTEX_REPLACEMENTS) : convertFragmentShaderTo300(source);

    case 100:
      return isVertex ? convertShader(source, ES100_VERTEX_REPLACEMENTS) : convertFragmentShaderTo100(source);

    default:
      throw new Error(`unknown GLSL version ${targetGLSLVersion}`);
  }
}

function convertShader(source, replacements) {
  for (const [pattern, replacement] of replacements) {
    source = source.replace(pattern, replacement);
  }

  return source;
}

function convertFragmentShaderTo300(source) {
  source = convertShader(source, ES300_FRAGMENT_REPLACEMENTS);
  const outputMatch = source.match(ES300_FRAGMENT_OUTPUT_REGEX);

  if (outputMatch) {
    const outputName = outputMatch[1];
    source = source.replace(new RegExp(`\\b${ES100_FRAGMENT_OUTPUT_NAME}\\b`, 'g'), outputName);
  } else {
    const outputName = 'fragmentColor';
    source = source.replace(REGEX_START_OF_MAIN, match => `out vec4 ${outputName};\n${match}`).replace(new RegExp(`\\b${ES100_FRAGMENT_OUTPUT_NAME}\\b`, 'g'), outputName);
  }

  return source;
}

function convertFragmentShaderTo100(source) {
  source = convertShader(source, ES100_FRAGMENT_REPLACEMENTS);
  const outputMatch = source.match(ES300_FRAGMENT_OUTPUT_REGEX);

  if (outputMatch) {
    const outputName = outputMatch[1];
    source = source.replace(ES300_FRAGMENT_OUTPUT_REGEX, '').replace(new RegExp(`\\b${outputName}\\b`, 'g'), ES100_FRAGMENT_OUTPUT_NAME);
  }

  return source;
}
},{}],"node_modules/@luma.gl/shadertools/dist/esm/lib/assemble-shaders.js":[function(require,module,exports) {
var define;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assembleShaders = assembleShaders;

var _constants = require("./constants");

var _resolveModules = require("./resolve-modules");

var _platformDefines = require("./platform-defines");

var _injectShader = _interopRequireWildcard(require("./inject-shader"));

var _transpileShader = _interopRequireDefault(require("./transpile-shader"));

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const INJECT_SHADER_DECLARATIONS = `\n\n${_injectShader.DECLARATION_INJECT_MARKER}\n\n`;
const SHADER_TYPE = {
  [_constants.VERTEX_SHADER]: 'vertex',
  [_constants.FRAGMENT_SHADER]: 'fragment'
};
const FRAGMENT_SHADER_PROLOGUE = `\
precision highp float;

`;

function assembleShaders(gl, opts) {
  const {
    vs,
    fs
  } = opts;
  const modules = (0, _resolveModules.resolveModules)(opts.modules || []);
  return {
    gl,
    vs: assembleShader(gl, Object.assign({}, opts, {
      source: vs,
      type: _constants.VERTEX_SHADER,
      modules
    })),
    fs: assembleShader(gl, Object.assign({}, opts, {
      source: fs,
      type: _constants.FRAGMENT_SHADER,
      modules
    })),
    getUniforms: assembleGetUniforms(modules)
  };
}

function assembleShader(gl, {
  id,
  source,
  type,
  modules,
  defines = {},
  hookFunctions = [],
  inject = {},
  transpileToGLSL100 = false,
  prologue = true,
  log
}) {
  (0, _utils.assert)(typeof source === 'string', 'shader source must be a string');
  const isVertex = type === _constants.VERTEX_SHADER;
  const sourceLines = source.split('\n');
  let glslVersion = 100;
  let versionLine = '';
  let coreSource = source;

  if (sourceLines[0].indexOf('#version ') === 0) {
    glslVersion = 300;
    versionLine = sourceLines[0];
    coreSource = sourceLines.slice(1).join('\n');
  } else {
    versionLine = `#version ${glslVersion}`;
  }

  const allDefines = {};
  modules.forEach(module => {
    Object.assign(allDefines, module.getDefines());
  });
  Object.assign(allDefines, defines);
  let assembledSource = prologue ? `\
${versionLine}
${getShaderName({
    id,
    source,
    type
  })}
${getShaderType({
    type
  })}
${(0, _platformDefines.getPlatformShaderDefines)(gl)}
${(0, _platformDefines.getVersionDefines)(gl, glslVersion, !isVertex)}
${getApplicationDefines(allDefines)}
${isVertex ? '' : FRAGMENT_SHADER_PROLOGUE}
` : `${versionLine}
`;
  const hookFunctionMap = normalizeHookFunctions(hookFunctions);
  const hookInjections = {};
  const declInjections = {};
  const mainInjections = {};

  for (const key in inject) {
    const injection = typeof inject[key] === 'string' ? {
      injection: inject[key],
      order: 0
    } : inject[key];
    const match = key.match(/^(v|f)s:(#)?([\w-]+)$/);

    if (match) {
      const hash = match[2];
      const name = match[3];

      if (hash) {
        if (name === 'decl') {
          declInjections[key] = [injection];
        } else {
          mainInjections[key] = [injection];
        }
      } else {
        hookInjections[key] = [injection];
      }
    } else {
      mainInjections[key] = [injection];
    }
  }

  for (const module of modules) {
    if (log) {
      module.checkDeprecations(coreSource, log);
    }

    const moduleSource = module.getModuleSource(type, glslVersion);
    assembledSource += moduleSource;
    const injections = module.injections[type];

    for (const key in injections) {
      const match = key.match(/^(v|f)s:#([\w-]+)$/);

      if (match) {
        const name = match[2];
        const injectionType = name === 'decl' ? declInjections : mainInjections;
        injectionType[key] = injectionType[key] || [];
        injectionType[key].push(injections[key]);
      } else {
        hookInjections[key] = hookInjections[key] || [];
        hookInjections[key].push(injections[key]);
      }
    }
  }

  assembledSource += INJECT_SHADER_DECLARATIONS;
  assembledSource = (0, _injectShader.default)(assembledSource, type, declInjections);
  assembledSource += getHookFunctions(hookFunctionMap[type], hookInjections);
  assembledSource += coreSource;
  assembledSource = (0, _injectShader.default)(assembledSource, type, mainInjections);
  assembledSource = (0, _transpileShader.default)(assembledSource, transpileToGLSL100 ? 100 : glslVersion, isVertex);
  return assembledSource;
}

function assembleGetUniforms(modules) {
  return function getUniforms(opts) {
    const uniforms = {};

    for (const module of modules) {
      const moduleUniforms = module.getUniforms(opts, uniforms);
      Object.assign(uniforms, moduleUniforms);
    }

    return uniforms;
  };
}

function getShaderType({
  type
}) {
  return `
#define SHADER_TYPE_${SHADER_TYPE[type].toUpperCase()}
`;
}

function getShaderName({
  id,
  source,
  type
}) {
  const injectShaderName = id && typeof id === 'string' && source.indexOf('SHADER_NAME') === -1;
  return injectShaderName ? `
#define SHADER_NAME ${id}_${SHADER_TYPE[type]}

` : '';
}

function getApplicationDefines(defines = {}) {
  let count = 0;
  let sourceText = '';

  for (const define in defines) {
    if (count === 0) {
      sourceText += '\n// APPLICATION DEFINES\n';
    }

    count++;
    const value = defines[define];

    if (value || Number.isFinite(value)) {
      sourceText += `#define ${define.toUpperCase()} ${defines[define]}\n`;
    }
  }

  if (count === 0) {
    sourceText += '\n';
  }

  return sourceText;
}

function getHookFunctions(hookFunctions, hookInjections) {
  let result = '';

  for (const hookName in hookFunctions) {
    const hookFunction = hookFunctions[hookName];
    result += `void ${hookFunction.signature} {\n`;

    if (hookFunction.header) {
      result += `  ${hookFunction.header}`;
    }

    if (hookInjections[hookName]) {
      const injections = hookInjections[hookName];
      injections.sort((a, b) => a.order - b.order);

      for (const injection of injections) {
        result += `  ${injection.injection}\n`;
      }
    }

    if (hookFunction.footer) {
      result += `  ${hookFunction.footer}`;
    }

    result += '}\n';
  }

  return result;
}

function normalizeHookFunctions(hookFunctions) {
  const result = {
    vs: {},
    fs: {}
  };
  hookFunctions.forEach(hook => {
    let opts;

    if (typeof hook !== 'string') {
      opts = hook;
      hook = opts.hook;
    } else {
      opts = {};
    }

    hook = hook.trim();
    const [stage, signature] = hook.split(':');
    const name = hook.replace(/\(.+/, '');
    result[stage][name] = Object.assign(opts, {
      signature
    });
  });
  return result;
}
},{"./constants":"node_modules/@luma.gl/shadertools/dist/esm/lib/constants.js","./resolve-modules":"node_modules/@luma.gl/shadertools/dist/esm/lib/resolve-modules.js","./platform-defines":"node_modules/@luma.gl/shadertools/dist/esm/lib/platform-defines.js","./inject-shader":"node_modules/@luma.gl/shadertools/dist/esm/lib/inject-shader.js","./transpile-shader":"node_modules/@luma.gl/shadertools/dist/esm/lib/transpile-shader.js","../utils":"node_modules/@luma.gl/shadertools/dist/esm/utils/index.js"}],"node_modules/@luma.gl/shadertools/dist/esm/utils/shader-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.convertToVec4 = convertToVec4;
exports.getPassthroughFS = getPassthroughFS;
exports.getQualifierDetails = getQualifierDetails;
exports.typeToChannelCount = typeToChannelCount;
exports.typeToChannelSuffix = typeToChannelSuffix;

var _utils = require("../utils");

const FS100 = `void main() {gl_FragColor = vec4(0);}`;
const FS_GLES = `\
out vec4 transform_output;
void main() {
  transform_output = vec4(0);
}`;
const FS300 = `#version 300 es\n${FS_GLES}`;

function getQualifierDetails(line, qualifiers) {
  qualifiers = Array.isArray(qualifiers) ? qualifiers : [qualifiers];
  const words = line.replace(/^\s+/, '').split(/\s+/);
  const [qualifier, type, definition] = words;

  if (!qualifiers.includes(qualifier) || !type || !definition) {
    return null;
  }

  const name = definition.split(';')[0];
  return {
    qualifier,
    type,
    name
  };
}

function getPassthroughFS(options = {}) {
  const {
    version = 100,
    input,
    inputType,
    output
  } = options;

  if (!input) {
    if (version === 300) {
      return FS300;
    } else if (version > 300) {
      return `#version ${version}\n${FS_GLES}`;
    }

    return FS100;
  }

  const outputValue = convertToVec4(input, inputType);

  if (version >= 300) {
    return `\
#version ${version} ${version === 300 ? 'es' : ''}
in ${inputType} ${input};
out vec4 ${output};
void main() {
  ${output} = ${outputValue};
}`;
  }

  return `\
varying ${inputType} ${input};
void main() {
  gl_FragColor = ${outputValue};
}`;
}

function typeToChannelSuffix(type) {
  switch (type) {
    case 'float':
      return 'x';

    case 'vec2':
      return 'xy';

    case 'vec3':
      return 'xyz';

    case 'vec4':
      return 'xyzw';

    default:
      (0, _utils.assert)(false);
      return null;
  }
}

function typeToChannelCount(type) {
  switch (type) {
    case 'float':
      return 1;

    case 'vec2':
      return 2;

    case 'vec3':
      return 3;

    case 'vec4':
      return 4;

    default:
      (0, _utils.assert)(false);
      return null;
  }
}

function convertToVec4(variable, type) {
  switch (type) {
    case 'float':
      return `vec4(${variable}, 0.0, 0.0, 1.0)`;

    case 'vec2':
      return `vec4(${variable}, 0.0, 1.0)`;

    case 'vec3':
      return `vec4(${variable}, 1.0)`;

    case 'vec4':
      return variable;

    default:
      (0, _utils.assert)(false);
      return null;
  }
}
},{"../utils":"node_modules/@luma.gl/shadertools/dist/esm/utils/index.js"}],"node_modules/@luma.gl/shadertools/dist/esm/modules/utils/random.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.random = void 0;
const fs = `\
float random(vec3 scale, float seed) {
  return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);
}
`;
const random = {
  name: 'random',
  fs
};
exports.random = random;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/fp32/fp32.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fp32 = void 0;
const fp32shader = `\
#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND
const float TWO_PI = 6.2831854820251465;
const float PI_2 = 1.5707963705062866;
const float PI_16 = 0.1963495463132858;

const float SIN_TABLE_0 = 0.19509032368659973;
const float SIN_TABLE_1 = 0.3826834261417389;
const float SIN_TABLE_2 = 0.5555702447891235;
const float SIN_TABLE_3 = 0.7071067690849304;

const float COS_TABLE_0 = 0.9807852506637573;
const float COS_TABLE_1 = 0.9238795042037964;
const float COS_TABLE_2 = 0.8314695954322815;
const float COS_TABLE_3 = 0.7071067690849304;

const float INVERSE_FACTORIAL_3 = 1.666666716337204e-01;
const float INVERSE_FACTORIAL_5 = 8.333333767950535e-03;
const float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04;
const float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06;

float sin_taylor_fp32(float a) {
  float r, s, t, x;

  if (a == 0.0) {
    return 0.0;
  }

  x = -a * a;
  s = a;
  r = a;

  r = r * x;
  t = r * INVERSE_FACTORIAL_3;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_5;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_7;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_9;
  s = s + t;

  return s;
}

void sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {
  if (a == 0.0) {
    sin_t = 0.0;
    cos_t = 1.0;
  }
  sin_t = sin_taylor_fp32(a);
  cos_t = sqrt(1.0 - sin_t * sin_t);
}

float tan_taylor_fp32(float a) {
    float sin_a;
    float cos_a;

    if (a == 0.0) {
        return 0.0;
    }
    float z = floor(a / TWO_PI);
    float r = a - TWO_PI * z;

    float t;
    float q = floor(r / PI_2 + 0.5);
    int j = int(q);

    if (j < -2 || j > 2) {
        return 1.0 / 0.0;
    }

    t = r - PI_2 * q;

    q = floor(t / PI_16 + 0.5);
    int k = int(q);
    int abs_k = int(abs(float(k)));

    if (abs_k > 4) {
        return 1.0 / 0.0;
    } else {
        t = t - PI_16 * q;
    }

    float u = 0.0;
    float v = 0.0;

    float sin_t, cos_t;
    float s, c;
    sincos_taylor_fp32(t, sin_t, cos_t);

    if (k == 0) {
        s = sin_t;
        c = cos_t;
    } else {
        if (abs(float(abs_k) - 1.0) < 0.5) {
            u = COS_TABLE_0;
            v = SIN_TABLE_0;
        } else if (abs(float(abs_k) - 2.0) < 0.5) {
            u = COS_TABLE_1;
            v = SIN_TABLE_1;
        } else if (abs(float(abs_k) - 3.0) < 0.5) {
            u = COS_TABLE_2;
            v = SIN_TABLE_2;
        } else if (abs(float(abs_k) - 4.0) < 0.5) {
            u = COS_TABLE_3;
            v = SIN_TABLE_3;
        }
        if (k > 0) {
            s = u * sin_t + v * cos_t;
            c = u * cos_t - v * sin_t;
        } else {
            s = u * sin_t - v * cos_t;
            c = u * cos_t + v * sin_t;
        }
    }

    if (j == 0) {
        sin_a = s;
        cos_a = c;
    } else if (j == 1) {
        sin_a = c;
        cos_a = -s;
    } else if (j == -1) {
        sin_a = -c;
        cos_a = s;
    } else {
        sin_a = -s;
        cos_a = -c;
    }
    return sin_a / cos_a;
}
#endif

float tan_fp32(float a) {
#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND
  return tan_taylor_fp32(a);
#else
  return tan(a);
#endif
}
`;
const fp32 = {
  name: 'fp32',
  vs: fp32shader,
  fs: null
};
exports.fp32 = fp32;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fp64LowPart = fp64LowPart;
exports.fp64ify = fp64ify;
exports.fp64ifyMatrix4 = fp64ifyMatrix4;

function fp64ify(a, out = [], startIndex = 0) {
  const hiPart = Math.fround(a);
  const loPart = a - hiPart;
  out[startIndex] = hiPart;
  out[startIndex + 1] = loPart;
  return out;
}

function fp64LowPart(a) {
  return a - Math.fround(a);
}

function fp64ifyMatrix4(matrix) {
  const matrixFP64 = new Float32Array(32);

  for (let i = 0; i < 4; ++i) {
    for (let j = 0; j < 4; ++j) {
      const index = i * 4 + j;
      fp64ify(matrix[j * 4 + i], matrixFP64, index * 2);
    }
  }

  return matrixFP64;
}
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64-arithmetic.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = `\
uniform float ONE;
vec2 split(float a) {
  const float SPLIT = 4097.0;
  float t = a * SPLIT;
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float a_hi = t * ONE - (t - a);
  float a_lo = a * ONE - a_hi;
#else
  float a_hi = t - (t - a);
  float a_lo = a - a_hi;
#endif
  return vec2(a_hi, a_lo);
}
vec2 split2(vec2 a) {
  vec2 b = split(a.x);
  b.y += a.y;
  return b;
}
vec2 quickTwoSum(float a, float b) {
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float sum = (a + b) * ONE;
  float err = b - (sum - a) * ONE;
#else
  float sum = a + b;
  float err = b - (sum - a);
#endif
  return vec2(sum, err);
}
vec2 twoSum(float a, float b) {
  float s = (a + b);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float v = (s * ONE - a) * ONE;
  float err = (a - (s - v) * ONE) * ONE * ONE * ONE + (b - v);
#else
  float v = s - a;
  float err = (a - (s - v)) + (b - v);
#endif
  return vec2(s, err);
}

vec2 twoSub(float a, float b) {
  float s = (a - b);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float v = (s * ONE - a) * ONE;
  float err = (a - (s - v) * ONE) * ONE * ONE * ONE - (b + v);
#else
  float v = s - a;
  float err = (a - (s - v)) - (b + v);
#endif
  return vec2(s, err);
}

vec2 twoSqr(float a) {
  float prod = a * a;
  vec2 a_fp64 = split(a);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float err = ((a_fp64.x * a_fp64.x - prod) * ONE + 2.0 * a_fp64.x *
    a_fp64.y * ONE * ONE) + a_fp64.y * a_fp64.y * ONE * ONE * ONE;
#else
  float err = ((a_fp64.x * a_fp64.x - prod) + 2.0 * a_fp64.x * a_fp64.y) + a_fp64.y * a_fp64.y;
#endif
  return vec2(prod, err);
}

vec2 twoProd(float a, float b) {
  float prod = a * b;
  vec2 a_fp64 = split(a);
  vec2 b_fp64 = split(b);
  float err = ((a_fp64.x * b_fp64.x - prod) + a_fp64.x * b_fp64.y +
    a_fp64.y * b_fp64.x) + a_fp64.y * b_fp64.y;
  return vec2(prod, err);
}

vec2 sum_fp64(vec2 a, vec2 b) {
  vec2 s, t;
  s = twoSum(a.x, b.x);
  t = twoSum(a.y, b.y);
  s.y += t.x;
  s = quickTwoSum(s.x, s.y);
  s.y += t.y;
  s = quickTwoSum(s.x, s.y);
  return s;
}

vec2 sub_fp64(vec2 a, vec2 b) {
  vec2 s, t;
  s = twoSub(a.x, b.x);
  t = twoSub(a.y, b.y);
  s.y += t.x;
  s = quickTwoSum(s.x, s.y);
  s.y += t.y;
  s = quickTwoSum(s.x, s.y);
  return s;
}

vec2 mul_fp64(vec2 a, vec2 b) {
  vec2 prod = twoProd(a.x, b.x);
  prod.y += a.x * b.y;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  prod = split2(prod);
#endif
  prod = quickTwoSum(prod.x, prod.y);
  prod.y += a.y * b.x;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  prod = split2(prod);
#endif
  prod = quickTwoSum(prod.x, prod.y);
  return prod;
}

vec2 div_fp64(vec2 a, vec2 b) {
  float xn = 1.0 / b.x;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  vec2 yn = mul_fp64(a, vec2(xn, 0));
#else
  vec2 yn = a * xn;
#endif
  float diff = (sub_fp64(a, mul_fp64(b, yn))).x;
  vec2 prod = twoProd(xn, diff);
  return sum_fp64(yn, prod);
}

vec2 sqrt_fp64(vec2 a) {
  if (a.x == 0.0 && a.y == 0.0) return vec2(0.0, 0.0);
  if (a.x < 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);

  float x = 1.0 / sqrt(a.x);
  float yn = a.x * x;
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  vec2 yn_sqr = twoSqr(yn) * ONE;
#else
  vec2 yn_sqr = twoSqr(yn);
#endif
  float diff = sub_fp64(a, yn_sqr).x;
  vec2 prod = twoProd(x * 0.5, diff);
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  return sum_fp64(split(yn), prod);
#else
  return sum_fp64(vec2(yn, 0.0), prod);
#endif
}
`;
exports.default = _default;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64-functions.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = `\
const vec2 E_FP64 = vec2(2.7182817459106445e+00, 8.254840366817007e-08);
const vec2 LOG2_FP64 = vec2(0.6931471824645996e+00, -1.9046542121259336e-09);
const vec2 PI_FP64 = vec2(3.1415927410125732, -8.742278012618954e-8);
const vec2 TWO_PI_FP64 = vec2(6.2831854820251465, -1.7484556025237907e-7);
const vec2 PI_2_FP64 = vec2(1.5707963705062866, -4.371139006309477e-8);
const vec2 PI_4_FP64 = vec2(0.7853981852531433, -2.1855695031547384e-8);
const vec2 PI_16_FP64 = vec2(0.19634954631328583, -5.463923757886846e-9);
const vec2 PI_16_2_FP64 = vec2(0.39269909262657166, -1.0927847515773692e-8);
const vec2 PI_16_3_FP64 = vec2(0.5890486240386963, -1.4906100798128818e-9);
const vec2 PI_180_FP64 = vec2(0.01745329238474369, 1.3519960498364902e-10);

const vec2 SIN_TABLE_0_FP64 = vec2(0.19509032368659973, -1.6704714833615242e-9);
const vec2 SIN_TABLE_1_FP64 = vec2(0.3826834261417389, 6.22335089017767e-9);
const vec2 SIN_TABLE_2_FP64 = vec2(0.5555702447891235, -1.1769521357507529e-8);
const vec2 SIN_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617041793133e-8);

const vec2 COS_TABLE_0_FP64 = vec2(0.9807852506637573, 2.9739473106360492e-8);
const vec2 COS_TABLE_1_FP64 = vec2(0.9238795042037964, 2.8307490351764386e-8);
const vec2 COS_TABLE_2_FP64 = vec2(0.8314695954322815, 1.6870263741530778e-8);
const vec2 COS_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617152815436e-8);

const vec2 INVERSE_FACTORIAL_3_FP64 = vec2(1.666666716337204e-01, -4.967053879312289e-09);
const vec2 INVERSE_FACTORIAL_4_FP64 = vec2(4.16666679084301e-02, -1.2417634698280722e-09);
const vec2 INVERSE_FACTORIAL_5_FP64 = vec2(8.333333767950535e-03, -4.34617203337595e-10);
const vec2 INVERSE_FACTORIAL_6_FP64 = vec2(1.3888889225199819e-03, -3.3631094437103215e-11);
const vec2 INVERSE_FACTORIAL_7_FP64 = vec2(1.9841270113829523e-04,  -2.725596874933456e-12);
const vec2 INVERSE_FACTORIAL_8_FP64 = vec2(2.4801587642286904e-05, -3.406996025904184e-13);
const vec2 INVERSE_FACTORIAL_9_FP64 = vec2(2.75573188446287533e-06, 3.7935713937038186e-14);
const vec2 INVERSE_FACTORIAL_10_FP64 = vec2(2.755731998149713e-07, -7.575112367869873e-15);

float nint(float d) {
    if (d == floor(d)) return d;
    return floor(d + 0.5);
}

vec2 nint_fp64(vec2 a) {
    float hi = nint(a.x);
    float lo;
    vec2 tmp;
    if (hi == a.x) {
        lo = nint(a.y);
        tmp = quickTwoSum(hi, lo);
    } else {
        lo = 0.0;
        if (abs(hi - a.x) == 0.5 && a.y < 0.0) {
            hi -= 1.0;
        }
        tmp = vec2(hi, lo);
    }
    return tmp;
}

vec2 exp_fp64(vec2 a) {

  const int k_power = 4;
  const float k = 16.0;

  const float inv_k = 1.0 / k;

  if (a.x <= -88.0) return vec2(0.0, 0.0);
  if (a.x >= 88.0) return vec2(1.0 / 0.0, 1.0 / 0.0);
  if (a.x == 0.0 && a.y == 0.0) return vec2(1.0, 0.0);
  if (a.x == 1.0 && a.y == 0.0) return E_FP64;

  float m = floor(a.x / LOG2_FP64.x + 0.5);
  vec2 r = sub_fp64(a, mul_fp64(LOG2_FP64, vec2(m, 0.0))) * inv_k;
  vec2 s, t, p;

  p = mul_fp64(r, r);
  s = sum_fp64(r, p * 0.5);
  p = mul_fp64(p, r);
  t = mul_fp64(p, INVERSE_FACTORIAL_3_FP64);

  s = sum_fp64(s, t);
  p = mul_fp64(p, r);
  t = mul_fp64(p, INVERSE_FACTORIAL_4_FP64);

  s = sum_fp64(s, t);
  p = mul_fp64(p, r);
  t = mul_fp64(p, INVERSE_FACTORIAL_5_FP64);






  s = sum_fp64(s, t);
  for (int i = 0; i < k_power; i++) {
    s = sum_fp64(s * 2.0, mul_fp64(s, s));
  }

#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
  s = sum_fp64(s, vec2(ONE, 0.0));
#else
  s = sum_fp64(s, vec2(1.0, 0.0));
#endif

  return s * pow(2.0, m);
}

vec2 log_fp64(vec2 a)
{
  if (a.x == 1.0 && a.y == 0.0) return vec2(0.0, 0.0);
  if (a.x <= 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);
  vec2 x = vec2(log(a.x), 0.0);
  vec2 s;
#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
  s = vec2(ONE, 0.0);
#else
  s = vec2(1.0, 0.0);
#endif

  x = sub_fp64(sum_fp64(x, mul_fp64(a, exp_fp64(-x))), s);
  return x;
}

vec2 sin_taylor_fp64(vec2 a) {
  vec2 r, s, t, x;

  if (a.x == 0.0 && a.y == 0.0) {
    return vec2(0.0, 0.0);
  }

  x = -mul_fp64(a, a);
  s = a;
  r = a;

  r = mul_fp64(r, x);
  t = mul_fp64(r, INVERSE_FACTORIAL_3_FP64);
  s = sum_fp64(s, t);

  r = mul_fp64(r, x);
  t = mul_fp64(r, INVERSE_FACTORIAL_5_FP64);
  s = sum_fp64(s, t);






  return s;
}

vec2 cos_taylor_fp64(vec2 a) {
  vec2 r, s, t, x;

  if (a.x == 0.0 && a.y == 0.0) {
    return vec2(1.0, 0.0);
  }

  x = -mul_fp64(a, a);
  r = x;
  s = sum_fp64(vec2(1.0, 0.0), r * 0.5);

  r = mul_fp64(r, x);
  t = mul_fp64(r, INVERSE_FACTORIAL_4_FP64);
  s = sum_fp64(s, t);

  r = mul_fp64(r, x);
  t = mul_fp64(r, INVERSE_FACTORIAL_6_FP64);
  s = sum_fp64(s, t);






  return s;
}

void sincos_taylor_fp64(vec2 a, out vec2 sin_t, out vec2 cos_t) {
  if (a.x == 0.0 && a.y == 0.0) {
    sin_t = vec2(0.0, 0.0);
    cos_t = vec2(1.0, 0.0);
  }

  sin_t = sin_taylor_fp64(a);
  cos_t = sqrt_fp64(sub_fp64(vec2(1.0, 0.0), mul_fp64(sin_t, sin_t)));
}

vec2 sin_fp64(vec2 a) {
    if (a.x == 0.0 && a.y == 0.0) {
        return vec2(0.0, 0.0);
    }
    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));
    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));

    vec2 t;
    float q = floor(r.x / PI_2_FP64.x + 0.5);
    int j = int(q);

    if (j < -2 || j > 2) {
        return vec2(0.0 / 0.0, 0.0 / 0.0);
    }

    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));

    q = floor(t.x / PI_16_FP64.x + 0.5);
    int k = int(q);

    if (k == 0) {
        if (j == 0) {
            return sin_taylor_fp64(t);
        } else if (j == 1) {
            return cos_taylor_fp64(t);
        } else if (j == -1) {
            return -cos_taylor_fp64(t);
        } else {
            return -sin_taylor_fp64(t);
        }
    }

    int abs_k = int(abs(float(k)));

    if (abs_k > 4) {
        return vec2(0.0 / 0.0, 0.0 / 0.0);
    } else {
        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));
    }

    vec2 u = vec2(0.0, 0.0);
    vec2 v = vec2(0.0, 0.0);

#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
    if (abs(float(abs_k) - 1.0) < 0.5) {
        u = COS_TABLE_0_FP64;
        v = SIN_TABLE_0_FP64;
    } else if (abs(float(abs_k) - 2.0) < 0.5) {
        u = COS_TABLE_1_FP64;
        v = SIN_TABLE_1_FP64;
    } else if (abs(float(abs_k) - 3.0) < 0.5) {
        u = COS_TABLE_2_FP64;
        v = SIN_TABLE_2_FP64;
    } else if (abs(float(abs_k) - 4.0) < 0.5) {
        u = COS_TABLE_3_FP64;
        v = SIN_TABLE_3_FP64;
    }
#else
    if (abs_k == 1) {
        u = COS_TABLE_0_FP64;
        v = SIN_TABLE_0_FP64;
    } else if (abs_k == 2) {
        u = COS_TABLE_1_FP64;
        v = SIN_TABLE_1_FP64;
    } else if (abs_k == 3) {
        u = COS_TABLE_2_FP64;
        v = SIN_TABLE_2_FP64;
    } else if (abs_k == 4) {
        u = COS_TABLE_3_FP64;
        v = SIN_TABLE_3_FP64;
    }
#endif

    vec2 sin_t, cos_t;
    sincos_taylor_fp64(t, sin_t, cos_t);



    vec2 result = vec2(0.0, 0.0);
    if (j == 0) {
        if (k > 0) {
            result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
        } else {
            result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
        }
    } else if (j == 1) {
        if (k > 0) {
            result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
        } else {
            result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
        }
    } else if (j == -1) {
        if (k > 0) {
            result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));
        } else {
            result = -sum_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));
        }
    } else {
        if (k > 0) {
            result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
        } else {
            result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));
        }
    }

    return result;
}

vec2 cos_fp64(vec2 a) {
    if (a.x == 0.0 && a.y == 0.0) {
        return vec2(1.0, 0.0);
    }
    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));
    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));

    vec2 t;
    float q = floor(r.x / PI_2_FP64.x + 0.5);
    int j = int(q);

    if (j < -2 || j > 2) {
        return vec2(0.0 / 0.0, 0.0 / 0.0);
    }

    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));

    q = floor(t.x / PI_16_FP64.x + 0.5);
    int k = int(q);

    if (k == 0) {
        if (j == 0) {
            return cos_taylor_fp64(t);
        } else if (j == 1) {
            return -sin_taylor_fp64(t);
        } else if (j == -1) {
            return sin_taylor_fp64(t);
        } else {
            return -cos_taylor_fp64(t);
        }
    }

    int abs_k = int(abs(float(k)));

    if (abs_k > 4) {
        return vec2(0.0 / 0.0, 0.0 / 0.0);
    } else {
        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));
    }

    vec2 u = vec2(0.0, 0.0);
    vec2 v = vec2(0.0, 0.0);

#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
    if (abs(float(abs_k) - 1.0) < 0.5) {
        u = COS_TABLE_0_FP64;
        v = SIN_TABLE_0_FP64;
    } else if (abs(float(abs_k) - 2.0) < 0.5) {
        u = COS_TABLE_1_FP64;
        v = SIN_TABLE_1_FP64;
    } else if (abs(float(abs_k) - 3.0) < 0.5) {
        u = COS_TABLE_2_FP64;
        v = SIN_TABLE_2_FP64;
    } else if (abs(float(abs_k) - 4.0) < 0.5) {
        u = COS_TABLE_3_FP64;
        v = SIN_TABLE_3_FP64;
    }
#else
    if (abs_k == 1) {
        u = COS_TABLE_0_FP64;
        v = SIN_TABLE_0_FP64;
    } else if (abs_k == 2) {
        u = COS_TABLE_1_FP64;
        v = SIN_TABLE_1_FP64;
    } else if (abs_k == 3) {
        u = COS_TABLE_2_FP64;
        v = SIN_TABLE_2_FP64;
    } else if (abs_k == 4) {
        u = COS_TABLE_3_FP64;
        v = SIN_TABLE_3_FP64;
    }
#endif

    vec2 sin_t, cos_t;
    sincos_taylor_fp64(t, sin_t, cos_t);

    vec2 result = vec2(0.0, 0.0);
    if (j == 0) {
        if (k > 0) {
            result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
        } else {
            result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
        }
    } else if (j == 1) {
        if (k > 0) {
            result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
        } else {
            result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));
        }
    } else if (j == -1) {
        if (k > 0) {
            result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
        } else {
            result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
        }
    } else {
        if (k > 0) {
            result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));
        } else {
            result = -sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
        }
    }

    return result;
}

vec2 tan_fp64(vec2 a) {
    vec2 sin_a;
    vec2 cos_a;

    if (a.x == 0.0 && a.y == 0.0) {
        return vec2(0.0, 0.0);
    }
    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));
    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));

    vec2 t;
    float q = floor(r.x / PI_2_FP64.x + 0.5);
    int j = int(q);


    if (j < -2 || j > 2) {
        return vec2(0.0 / 0.0, 0.0 / 0.0);
    }

    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));

    q = floor(t.x / PI_16_FP64.x + 0.5);
    int k = int(q);
    int abs_k = int(abs(float(k)));

    if (abs_k > 4) {
        return vec2(0.0 / 0.0, 0.0 / 0.0);
    } else {
        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));
    }


    vec2 u = vec2(0.0, 0.0);
    vec2 v = vec2(0.0, 0.0);

    vec2 sin_t, cos_t;
    vec2 s, c;
    sincos_taylor_fp64(t, sin_t, cos_t);

    if (k == 0) {
        s = sin_t;
        c = cos_t;
    } else {
#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
        if (abs(float(abs_k) - 1.0) < 0.5) {
            u = COS_TABLE_0_FP64;
            v = SIN_TABLE_0_FP64;
        } else if (abs(float(abs_k) - 2.0) < 0.5) {
            u = COS_TABLE_1_FP64;
            v = SIN_TABLE_1_FP64;
        } else if (abs(float(abs_k) - 3.0) < 0.5) {
            u = COS_TABLE_2_FP64;
            v = SIN_TABLE_2_FP64;
        } else if (abs(float(abs_k) - 4.0) < 0.5) {
            u = COS_TABLE_3_FP64;
            v = SIN_TABLE_3_FP64;
        }
#else
        if (abs_k == 1) {
            u = COS_TABLE_0_FP64;
            v = SIN_TABLE_0_FP64;
        } else if (abs_k == 2) {
            u = COS_TABLE_1_FP64;
            v = SIN_TABLE_1_FP64;
        } else if (abs_k == 3) {
            u = COS_TABLE_2_FP64;
            v = SIN_TABLE_2_FP64;
        } else if (abs_k == 4) {
            u = COS_TABLE_3_FP64;
            v = SIN_TABLE_3_FP64;
        }
#endif
        if (k > 0) {
            s = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
            c = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
        } else {
            s = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
            c = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
        }
    }

    if (j == 0) {
        sin_a = s;
        cos_a = c;
    } else if (j == 1) {
        sin_a = c;
        cos_a = -s;
    } else if (j == -1) {
        sin_a = -c;
        cos_a = s;
    } else {
        sin_a = -s;
        cos_a = -c;
    }
    return div_fp64(sin_a, cos_a);
}

vec2 radians_fp64(vec2 degree) {
  return mul_fp64(degree, PI_180_FP64);
}

vec2 mix_fp64(vec2 a, vec2 b, float x) {
  vec2 range = sub_fp64(b, a);
  return sum_fp64(a, mul_fp64(range, vec2(x, 0.0)));
}

void vec2_sum_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {
    out_val[0] = sum_fp64(a[0], b[0]);
    out_val[1] = sum_fp64(a[1], b[1]);
}

void vec2_sub_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {
    out_val[0] = sub_fp64(a[0], b[0]);
    out_val[1] = sub_fp64(a[1], b[1]);
}

void vec2_mul_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {
    out_val[0] = mul_fp64(a[0], b[0]);
    out_val[1] = mul_fp64(a[1], b[1]);
}

void vec2_div_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {
    out_val[0] = div_fp64(a[0], b[0]);
    out_val[1] = div_fp64(a[1], b[1]);
}

void vec2_mix_fp64(vec2 x[2], vec2 y[2], float a, out vec2 out_val[2]) {
  vec2 range[2];
  vec2_sub_fp64(y, x, range);
  vec2 portion[2];
  portion[0] = range[0] * a;
  portion[1] = range[1] * a;
  vec2_sum_fp64(x, portion, out_val);
}

vec2 vec2_length_fp64(vec2 x[2]) {
  return sqrt_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])));
}

void vec2_normalize_fp64(vec2 x[2], out vec2 out_val[2]) {
  vec2 length = vec2_length_fp64(x);
  vec2 length_vec2[2];
  length_vec2[0] = length;
  length_vec2[1] = length;

  vec2_div_fp64(x, length_vec2, out_val);
}

vec2 vec2_distance_fp64(vec2 x[2], vec2 y[2]) {
  vec2 diff[2];
  vec2_sub_fp64(x, y, diff);
  return vec2_length_fp64(diff);
}

vec2 vec2_dot_fp64(vec2 a[2], vec2 b[2]) {
  vec2 v[2];

  v[0] = mul_fp64(a[0], b[0]);
  v[1] = mul_fp64(a[1], b[1]);

  return sum_fp64(v[0], v[1]);
}
void vec3_sub_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {
  for (int i = 0; i < 3; i++) {
    out_val[i] = sum_fp64(a[i], b[i]);
  }
}

void vec3_sum_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {
  for (int i = 0; i < 3; i++) {
    out_val[i] = sum_fp64(a[i], b[i]);
  }
}

vec2 vec3_length_fp64(vec2 x[3]) {
  return sqrt_fp64(sum_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])),
    mul_fp64(x[2], x[2])));
}

vec2 vec3_distance_fp64(vec2 x[3], vec2 y[3]) {
  vec2 diff[3];
  vec3_sub_fp64(x, y, diff);
  return vec3_length_fp64(diff);
}
void vec4_fp64(vec4 a, out vec2 out_val[4]) {
  out_val[0].x = a[0];
  out_val[0].y = 0.0;

  out_val[1].x = a[1];
  out_val[1].y = 0.0;

  out_val[2].x = a[2];
  out_val[2].y = 0.0;

  out_val[3].x = a[3];
  out_val[3].y = 0.0;
}

void vec4_scalar_mul_fp64(vec2 a[4], vec2 b, out vec2 out_val[4]) {
  out_val[0] = mul_fp64(a[0], b);
  out_val[1] = mul_fp64(a[1], b);
  out_val[2] = mul_fp64(a[2], b);
  out_val[3] = mul_fp64(a[3], b);
}

void vec4_sum_fp64(vec2 a[4], vec2 b[4], out vec2 out_val[4]) {
  for (int i = 0; i < 4; i++) {
    out_val[i] = sum_fp64(a[i], b[i]);
  }
}

void vec4_dot_fp64(vec2 a[4], vec2 b[4], out vec2 out_val) {
  vec2 v[4];

  v[0] = mul_fp64(a[0], b[0]);
  v[1] = mul_fp64(a[1], b[1]);
  v[2] = mul_fp64(a[2], b[2]);
  v[3] = mul_fp64(a[3], b[3]);

  out_val = sum_fp64(sum_fp64(v[0], v[1]), sum_fp64(v[2], v[3]));
}

void mat4_vec4_mul_fp64(vec2 b[16], vec2 a[4], out vec2 out_val[4]) {
  vec2 tmp[4];

  for (int i = 0; i < 4; i++)
  {
    for (int j = 0; j < 4; j++)
    {
      tmp[j] = b[j + i * 4];
    }
    vec4_dot_fp64(a, tmp, out_val[i]);
  }
}
`;
exports.default = _default;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fp64 = void 0;
Object.defineProperty(exports, "fp64LowPart", {
  enumerable: true,
  get: function () {
    return _fp64Utils.fp64LowPart;
  }
});
exports.fp64arithmetic = void 0;
Object.defineProperty(exports, "fp64ify", {
  enumerable: true,
  get: function () {
    return _fp64Utils.fp64ify;
  }
});
Object.defineProperty(exports, "fp64ifyMatrix4", {
  enumerable: true,
  get: function () {
    return _fp64Utils.fp64ifyMatrix4;
  }
});

var _fp64Utils = require("./fp64-utils");

var _fp64Arithmetic = _interopRequireDefault(require("./fp64-arithmetic.glsl"));

var _fp64Functions = _interopRequireDefault(require("./fp64-functions.glsl"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const CONST_UNIFORMS = {
  ONE: 1.0
};

function getUniforms() {
  return CONST_UNIFORMS;
}

const fp64arithmetic = {
  name: 'fp64-arithmetic',
  vs: _fp64Arithmetic.default,
  fs: null,
  getUniforms,
  fp64ify: _fp64Utils.fp64ify,
  fp64LowPart: _fp64Utils.fp64LowPart,
  fp64ifyMatrix4: _fp64Utils.fp64ifyMatrix4
};
exports.fp64arithmetic = fp64arithmetic;
const fp64 = {
  name: 'fp64',
  vs: _fp64Functions.default,
  fs: null,
  dependencies: [fp64arithmetic],
  fp64ify: _fp64Utils.fp64ify,
  fp64LowPart: _fp64Utils.fp64LowPart,
  fp64ifyMatrix4: _fp64Utils.fp64ifyMatrix4
};
exports.fp64 = fp64;
},{"./fp64-utils":"node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64-utils.js","./fp64-arithmetic.glsl":"node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64-arithmetic.glsl.js","./fp64-functions.glsl":"node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64-functions.glsl.js"}],"node_modules/@math.gl/core/dist/esm/lib/assert.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = assert;

function assert(condition, message) {
  if (!condition) {
    throw new Error("math.gl assertion ".concat(message));
  }
}
},{}],"node_modules/@math.gl/core/dist/esm/lib/common.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.acos = acos;
exports.asin = asin;
exports.atan = atan;
exports.clamp = clamp;
exports.clone = clone;
exports.config = void 0;
exports.configure = configure;
exports.cos = cos;
exports.degrees = degrees;
exports.equals = equals;
exports.exactEquals = exactEquals;
exports.formatValue = formatValue;
exports.isArray = isArray;
exports.lerp = lerp;
exports.radians = radians;
exports.sin = sin;
exports.tan = tan;
exports.toDegrees = toDegrees;
exports.toRadians = toRadians;
exports.withEpsilon = withEpsilon;

var _assert = _interopRequireDefault(require("./assert"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const RADIANS_TO_DEGREES = 1 / Math.PI * 180;
const DEGREES_TO_RADIANS = 1 / 180 * Math.PI;
const config = {};
exports.config = config;
config.EPSILON = 1e-12;
config.debug = false;
config.precision = 4;
config.printTypes = false;
config.printDegrees = false;
config.printRowMajor = true;

function configure(options = {}) {
  for (const key in options) {
    (0, _assert.default)(key in config);
    config[key] = options[key];
  }

  return config;
}

function round(value) {
  return Math.round(value / config.EPSILON) * config.EPSILON;
}

function formatValue(value, {
  precision = config.precision || 4
} = {}) {
  value = round(value);
  return "".concat(parseFloat(value.toPrecision(precision)));
}

function isArray(value) {
  return Array.isArray(value) || ArrayBuffer.isView(value) && !(value instanceof DataView);
}

function duplicateArray(array) {
  return array.clone ? array.clone() : new Array(array.length);
}

function clone(array) {
  return array.clone ? array.clone() : new Array(...array);
}

function map(value, func, result) {
  if (isArray(value)) {
    result = result || duplicateArray(value);

    for (let i = 0; i < result.length && i < value.length; ++i) {
      result[i] = func(value[i], i, result);
    }

    return result;
  }

  return func(value);
}

function toRadians(degrees) {
  return radians(degrees);
}

function toDegrees(radians) {
  return degrees(radians);
}

function radians(degrees, result) {
  return map(degrees, degrees => degrees * DEGREES_TO_RADIANS, result);
}

function degrees(radians, result) {
  return map(radians, radians => radians * RADIANS_TO_DEGREES, result);
}

function sin(radians) {
  return map(radians, angle => Math.sin(angle));
}

function cos(radians) {
  return map(radians, angle => Math.cos(angle));
}

function tan(radians) {
  return map(radians, angle => Math.tan(angle));
}

function asin(radians) {
  return map(radians, angle => Math.asin(angle));
}

function acos(radians) {
  return map(radians, angle => Math.acos(angle));
}

function atan(radians) {
  return map(radians, angle => Math.atan(angle));
}

function clamp(value, min, max) {
  return map(value, value => Math.max(min, Math.min(max, value)));
}

function lerp(a, b, t) {
  if (isArray(a)) {
    return a.map((ai, i) => lerp(ai, b[i], t));
  }

  return t * b + (1 - t) * a;
}

function equals(a, b, epsilon) {
  const oldEpsilon = config.EPSILON;

  if (epsilon) {
    config.EPSILON = epsilon;
  }

  try {
    if (a === b) {
      return true;
    }

    if (isArray(a) && isArray(b)) {
      if (a.length !== b.length) {
        return false;
      }

      for (let i = 0; i < a.length; ++i) {
        if (!equals(a[i], b[i])) {
          return false;
        }
      }

      return true;
    }

    if (a && a.equals) {
      return a.equals(b);
    }

    if (b && b.equals) {
      return b.equals(a);
    }

    if (Number.isFinite(a) && Number.isFinite(b)) {
      return Math.abs(a - b) <= config.EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
    }

    return false;
  } finally {
    config.EPSILON = oldEpsilon;
  }
}

function exactEquals(a, b) {
  if (a === b) {
    return true;
  }

  if (a && typeof a === 'object' && b && typeof b === 'object') {
    if (a.constructor !== b.constructor) {
      return false;
    }

    if (a.exactEquals) {
      return a.exactEquals(b);
    }
  }

  if (isArray(a) && isArray(b)) {
    if (a.length !== b.length) {
      return false;
    }

    for (let i = 0; i < a.length; ++i) {
      if (!exactEquals(a[i], b[i])) {
        return false;
      }
    }

    return true;
  }

  return false;
}

function withEpsilon(EPSILON, func) {
  const oldPrecision = config.EPSILON;
  config.EPSILON = EPSILON;
  let value;

  try {
    value = func();
  } finally {
    config.EPSILON = oldPrecision;
  }

  return value;
}
},{"./assert":"node_modules/@math.gl/core/dist/esm/lib/assert.js"}],"node_modules/@math.gl/core/dist/esm/classes/base/math-array.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _common = require("../../lib/common");

var _assert = _interopRequireDefault(require("../../lib/assert"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extendableBuiltin(cls) {
  function ExtendableBuiltin() {
    var instance = Reflect.construct(cls, Array.from(arguments));
    Object.setPrototypeOf(instance, Object.getPrototypeOf(this));
    return instance;
  }

  ExtendableBuiltin.prototype = Object.create(cls.prototype, {
    constructor: {
      value: cls,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });

  if (Object.setPrototypeOf) {
    Object.setPrototypeOf(ExtendableBuiltin, cls);
  } else {
    ExtendableBuiltin.__proto__ = cls;
  }

  return ExtendableBuiltin;
}

class MathArray extends _extendableBuiltin(Array) {
  get ELEMENTS() {
    (0, _assert.default)(false);
    return 0;
  }

  clone() {
    return new this.constructor().copy(this);
  }

  from(arrayOrObject) {
    return Array.isArray(arrayOrObject) ? this.copy(arrayOrObject) : this.fromObject(arrayOrObject);
  }

  fromArray(array, offset = 0) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] = array[i + offset];
    }

    return this.check();
  }

  to(arrayOrObject) {
    if (arrayOrObject === this) {
      return this;
    }

    return (0, _common.isArray)(arrayOrObject) ? this.toArray(arrayOrObject) : this.toObject(arrayOrObject);
  }

  toTarget(target) {
    return target ? this.to(target) : this;
  }

  toArray(array = [], offset = 0) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      array[offset + i] = this[i];
    }

    return array;
  }

  toFloat32Array() {
    return new Float32Array(this);
  }

  toString() {
    return this.formatString(_common.config);
  }

  formatString(opts) {
    let string = '';

    for (let i = 0; i < this.ELEMENTS; ++i) {
      string += (i > 0 ? ', ' : '') + (0, _common.formatValue)(this[i], opts);
    }

    return "".concat(opts.printTypes ? this.constructor.name : '', "[").concat(string, "]");
  }

  equals(array) {
    if (!array || this.length !== array.length) {
      return false;
    }

    for (let i = 0; i < this.ELEMENTS; ++i) {
      if (!(0, _common.equals)(this[i], array[i])) {
        return false;
      }
    }

    return true;
  }

  exactEquals(array) {
    if (!array || this.length !== array.length) {
      return false;
    }

    for (let i = 0; i < this.ELEMENTS; ++i) {
      if (this[i] !== array[i]) {
        return false;
      }
    }

    return true;
  }

  negate() {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] = -this[i];
    }

    return this.check();
  }

  lerp(a, b, t) {
    if (t === undefined) {
      t = b;
      b = a;
      a = this;
    }

    for (let i = 0; i < this.ELEMENTS; ++i) {
      const ai = a[i];
      this[i] = ai + t * (b[i] - ai);
    }

    return this.check();
  }

  min(vector) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] = Math.min(vector[i], this[i]);
    }

    return this.check();
  }

  max(vector) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] = Math.max(vector[i], this[i]);
    }

    return this.check();
  }

  clamp(minVector, maxVector) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] = Math.min(Math.max(this[i], minVector[i]), maxVector[i]);
    }

    return this.check();
  }

  add(...vectors) {
    for (const vector of vectors) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] += vector[i];
      }
    }

    return this.check();
  }

  subtract(...vectors) {
    for (const vector of vectors) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] -= vector[i];
      }
    }

    return this.check();
  }

  scale(scale) {
    if (Array.isArray(scale)) {
      return this.multiply(scale);
    }

    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] *= scale;
    }

    return this.check();
  }

  sub(a) {
    return this.subtract(a);
  }

  setScalar(a) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] = a;
    }

    return this.check();
  }

  addScalar(a) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] += a;
    }

    return this.check();
  }

  subScalar(a) {
    return this.addScalar(-a);
  }

  multiplyScalar(scalar) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] *= scalar;
    }

    return this.check();
  }

  divideScalar(a) {
    return this.scale(1 / a);
  }

  clampScalar(min, max) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] = Math.min(Math.max(this[i], min), max);
    }

    return this.check();
  }

  multiplyByScalar(scalar) {
    return this.scale(scalar);
  }

  get elements() {
    return this;
  }

  check() {
    if (_common.config.debug && !this.validate()) {
      throw new Error("math.gl: ".concat(this.constructor.name, " some fields set to invalid numbers'"));
    }

    return this;
  }

  validate() {
    let valid = this.length === this.ELEMENTS;

    for (let i = 0; i < this.ELEMENTS; ++i) {
      valid = valid && Number.isFinite(this[i]);
    }

    return valid;
  }

}

exports.default = MathArray;
},{"../../lib/common":"node_modules/@math.gl/core/dist/esm/lib/common.js","../../lib/assert":"node_modules/@math.gl/core/dist/esm/lib/assert.js"}],"node_modules/@math.gl/core/dist/esm/lib/validators.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.checkNumber = checkNumber;
exports.checkVector = checkVector;
exports.deprecated = deprecated;
exports.validateVector = validateVector;

var _common = require("./common");

function validateVector(v, length) {
  if (v.length !== length) {
    return false;
  }

  for (let i = 0; i < v.length; ++i) {
    if (!Number.isFinite(v[i])) {
      return false;
    }
  }

  return true;
}

function checkNumber(value) {
  if (!Number.isFinite(value)) {
    throw new Error("Invalid number ".concat(value));
  }

  return value;
}

function checkVector(v, length, callerName = '') {
  if (_common.config.debug && !validateVector(v, length)) {
    throw new Error("math.gl: ".concat(callerName, " some fields set to invalid numbers'"));
  }

  return v;
}

const map = {};

function deprecated(method, version) {
  if (!map[method]) {
    map[method] = true;
    console.warn("".concat(method, " has been removed in version ").concat(version, ", see upgrade guide for more information"));
  }
}
},{"./common":"node_modules/@math.gl/core/dist/esm/lib/common.js"}],"node_modules/@math.gl/core/dist/esm/classes/base/vector.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _mathArray = _interopRequireDefault(require("./math-array"));

var _validators = require("../../lib/validators");

var _assert = _interopRequireDefault(require("../../lib/assert"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class Vector extends _mathArray.default {
  get ELEMENTS() {
    (0, _assert.default)(false);
    return 0;
  }

  copy(vector) {
    (0, _assert.default)(false);
    return this;
  }

  get x() {
    return this[0];
  }

  set x(value) {
    this[0] = (0, _validators.checkNumber)(value);
  }

  get y() {
    return this[1];
  }

  set y(value) {
    this[1] = (0, _validators.checkNumber)(value);
  }

  len() {
    return Math.sqrt(this.lengthSquared());
  }

  magnitude() {
    return this.len();
  }

  lengthSquared() {
    let length = 0;

    for (let i = 0; i < this.ELEMENTS; ++i) {
      length += this[i] * this[i];
    }

    return length;
  }

  magnitudeSquared() {
    return this.lengthSquared();
  }

  distance(mathArray) {
    return Math.sqrt(this.distanceSquared(mathArray));
  }

  distanceSquared(mathArray) {
    let length = 0;

    for (let i = 0; i < this.ELEMENTS; ++i) {
      const dist = this[i] - mathArray[i];
      length += dist * dist;
    }

    return (0, _validators.checkNumber)(length);
  }

  dot(mathArray) {
    let product = 0;

    for (let i = 0; i < this.ELEMENTS; ++i) {
      product += this[i] * mathArray[i];
    }

    return (0, _validators.checkNumber)(product);
  }

  normalize() {
    const length = this.magnitude();

    if (length !== 0) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] /= length;
      }
    }

    return this.check();
  }

  multiply(...vectors) {
    for (const vector of vectors) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] *= vector[i];
      }
    }

    return this.check();
  }

  divide(...vectors) {
    for (const vector of vectors) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] /= vector[i];
      }
    }

    return this.check();
  }

  lengthSq() {
    return this.lengthSquared();
  }

  distanceTo(vector) {
    return this.distance(vector);
  }

  distanceToSquared(vector) {
    return this.distanceSquared(vector);
  }

  getComponent(i) {
    (0, _assert.default)(i >= 0 && i < this.ELEMENTS, 'index is out of range');
    return (0, _validators.checkNumber)(this[i]);
  }

  setComponent(i, value) {
    (0, _assert.default)(i >= 0 && i < this.ELEMENTS, 'index is out of range');
    this[i] = value;
    return this.check();
  }

  addVectors(a, b) {
    return this.copy(a).add(b);
  }

  subVectors(a, b) {
    return this.copy(a).subtract(b);
  }

  multiplyVectors(a, b) {
    return this.copy(a).multiply(b);
  }

  addScaledVector(a, b) {
    return this.add(new this.constructor(a).multiplyScalar(b));
  }

}

exports.default = Vector;
},{"./math-array":"node_modules/@math.gl/core/dist/esm/classes/base/math-array.js","../../lib/validators":"node_modules/@math.gl/core/dist/esm/lib/validators.js","../../lib/assert":"node_modules/@math.gl/core/dist/esm/lib/assert.js"}],"node_modules/@math.gl/core/node_modules/gl-matrix/esm/common.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RANDOM = exports.EPSILON = exports.ARRAY_TYPE = void 0;
exports.equals = equals;
exports.setMatrixArrayType = setMatrixArrayType;
exports.toRadian = toRadian;

/**
 * Common utilities
 * @module glMatrix
 */
// Configuration Constants
var EPSILON = 0.000001;
exports.EPSILON = EPSILON;
var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
exports.ARRAY_TYPE = ARRAY_TYPE;
var RANDOM = Math.random;
/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array
 */

exports.RANDOM = RANDOM;

function setMatrixArrayType(type) {
  exports.ARRAY_TYPE = ARRAY_TYPE = type;
}

var degree = Math.PI / 180;
/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */

function toRadian(a) {
  return a * degree;
}
/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */


function equals(a, b) {
  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
}

if (!Math.hypot) Math.hypot = function () {
  var y = 0,
      i = arguments.length;

  while (i--) {
    y += arguments[i] * arguments[i];
  }

  return Math.sqrt(y);
};
},{}],"node_modules/@math.gl/core/node_modules/gl-matrix/esm/vec2.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add = add;
exports.angle = angle;
exports.ceil = ceil;
exports.clone = clone;
exports.copy = copy;
exports.create = create;
exports.cross = cross;
exports.dist = void 0;
exports.distance = distance;
exports.div = void 0;
exports.divide = divide;
exports.dot = dot;
exports.equals = equals;
exports.exactEquals = exactEquals;
exports.floor = floor;
exports.forEach = void 0;
exports.fromValues = fromValues;
exports.inverse = inverse;
exports.len = void 0;
exports.length = length;
exports.lerp = lerp;
exports.max = max;
exports.min = min;
exports.mul = void 0;
exports.multiply = multiply;
exports.negate = negate;
exports.normalize = normalize;
exports.random = random;
exports.rotate = rotate;
exports.round = round;
exports.scale = scale;
exports.scaleAndAdd = scaleAndAdd;
exports.set = set;
exports.sqrLen = exports.sqrDist = void 0;
exports.squaredDistance = squaredDistance;
exports.squaredLength = squaredLength;
exports.str = str;
exports.sub = void 0;
exports.subtract = subtract;
exports.transformMat2 = transformMat2;
exports.transformMat2d = transformMat2d;
exports.transformMat3 = transformMat3;
exports.transformMat4 = transformMat4;
exports.zero = zero;

var glMatrix = _interopRequireWildcard(require("./common.js"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * 2 Dimensional Vector
 * @module vec2
 */

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(2);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }

  return out;
}
/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {ReadonlyVec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */


function fromValues(x, y) {
  var out = new glMatrix.ARRAY_TYPE(2);
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the source vector
 * @returns {vec2} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */


function set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}
/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */


function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}
/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */


function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}
/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to ceil
 * @returns {vec2} out
 */


function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}
/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to floor
 * @returns {vec2} out
 */


function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}
/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */


function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}
/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */


function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}
/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to round
 * @returns {vec2} out
 */


function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
}
/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */


function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}
/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */


function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} distance between a and b
 */


function distance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return Math.hypot(x, y);
}
/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} squared distance between a and b
 */


function squaredDistance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return x * x + y * y;
}
/**
 * Calculates the length of a vec2
 *
 * @param {ReadonlyVec2} a vector to calculate length of
 * @returns {Number} length of a
 */


function length(a) {
  var x = a[0],
      y = a[1];
  return Math.hypot(x, y);
}
/**
 * Calculates the squared length of a vec2
 *
 * @param {ReadonlyVec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */


function squaredLength(a) {
  var x = a[0],
      y = a[1];
  return x * x + y * y;
}
/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to negate
 * @returns {vec2} out
 */


function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}
/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to invert
 * @returns {vec2} out
 */


function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
}
/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to normalize
 * @returns {vec2} out
 */


function normalize(out, a) {
  var x = a[0],
      y = a[1];
  var len = x * x + y * y;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  return out;
}
/**
 * Calculates the dot product of two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} dot product of a and b
 */


function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}
/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec3} out
 */


function cross(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}
/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec2} out
 */


function lerp(out, a, b, t) {
  var ax = a[0],
      ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */


function random(out, scale) {
  scale = scale || 1.0;
  var r = glMatrix.RANDOM() * 2.0 * Math.PI;
  out[0] = Math.cos(r) * scale;
  out[1] = Math.sin(r) * scale;
  return out;
}
/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat2} m matrix to transform with
 * @returns {vec2} out
 */


function transformMat2(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}
/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat2d} m matrix to transform with
 * @returns {vec2} out
 */


function transformMat2d(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}
/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat3} m matrix to transform with
 * @returns {vec2} out
 */


function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec2} out
 */


function transformMat4(out, a, m) {
  var x = a[0];
  var y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}
/**
 * Rotate a 2D vector
 * @param {vec2} out The receiving vec2
 * @param {ReadonlyVec2} a The vec2 point to rotate
 * @param {ReadonlyVec2} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec2} out
 */


function rotate(out, a, b, rad) {
  //Translate point to the origin
  var p0 = a[0] - b[0],
      p1 = a[1] - b[1],
      sinC = Math.sin(rad),
      cosC = Math.cos(rad); //perform rotation and translate to correct position

  out[0] = p0 * cosC - p1 * sinC + b[0];
  out[1] = p0 * sinC + p1 * cosC + b[1];
  return out;
}
/**
 * Get the angle between two 2D vectors
 * @param {ReadonlyVec2} a The first operand
 * @param {ReadonlyVec2} b The second operand
 * @returns {Number} The angle in radians
 */


function angle(a, b) {
  var x1 = a[0],
      y1 = a[1],
      x2 = b[0],
      y2 = b[1],
      // mag is the product of the magnitudes of a and b
  mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2),
      // mag &&.. short circuits if mag == 0
  cosine = mag && (x1 * x2 + y1 * y2) / mag; // Math.min(Math.max(cosine, -1), 1) clamps the cosine between -1 and 1

  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
/**
 * Set the components of a vec2 to zero
 *
 * @param {vec2} out the receiving vector
 * @returns {vec2} out
 */


function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec2} a vector to represent as a string
 * @returns {String} string representation of the vector
 */


function str(a) {
  return "vec2(" + a[0] + ", " + a[1] + ")";
}
/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec2} a The first vector.
 * @param {ReadonlyVec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec2} a The first vector.
 * @param {ReadonlyVec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1];
  var b0 = b[0],
      b1 = b[1];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));
}
/**
 * Alias for {@link vec2.length}
 * @function
 */


var len = length;
/**
 * Alias for {@link vec2.subtract}
 * @function
 */

exports.len = len;
var sub = subtract;
/**
 * Alias for {@link vec2.multiply}
 * @function
 */

exports.sub = sub;
var mul = multiply;
/**
 * Alias for {@link vec2.divide}
 * @function
 */

exports.mul = mul;
var div = divide;
/**
 * Alias for {@link vec2.distance}
 * @function
 */

exports.div = div;
var dist = distance;
/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */

exports.dist = dist;
var sqrDist = squaredDistance;
/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */

exports.sqrDist = sqrDist;
var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

exports.sqrLen = sqrLen;

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 2;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }

    return a;
  };
}();

exports.forEach = forEach;
},{"./common.js":"node_modules/@math.gl/core/node_modules/gl-matrix/esm/common.js"}],"node_modules/@math.gl/core/dist/esm/lib/gl-matrix-extras.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.vec2_transformMat4AsVector = vec2_transformMat4AsVector;
exports.vec3_transformMat2 = vec3_transformMat2;
exports.vec3_transformMat4AsVector = vec3_transformMat4AsVector;
exports.vec4_transformMat2 = vec4_transformMat2;
exports.vec4_transformMat3 = vec4_transformMat3;

function vec2_transformMat4AsVector(out, a, m) {
  const x = a[0];
  const y = a[1];
  const w = m[3] * x + m[7] * y || 1.0;
  out[0] = (m[0] * x + m[4] * y) / w;
  out[1] = (m[1] * x + m[5] * y) / w;
  return out;
}

function vec3_transformMat4AsVector(out, a, m) {
  const x = a[0];
  const y = a[1];
  const z = a[2];
  const w = m[3] * x + m[7] * y + m[11] * z || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z) / w;
  return out;
}

function vec3_transformMat2(out, a, m) {
  const x = a[0];
  const y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  out[2] = a[2];
  return out;
}

function vec4_transformMat2(out, a, m) {
  const x = a[0];
  const y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

function vec4_transformMat3(out, a, m) {
  const x = a[0];
  const y = a[1];
  const z = a[2];
  out[0] = m[0] * x + m[3] * y + m[6] * z;
  out[1] = m[1] * x + m[4] * y + m[7] * z;
  out[2] = m[2] * x + m[5] * y + m[8] * z;
  out[3] = a[3];
  return out;
}
},{}],"node_modules/@math.gl/core/dist/esm/classes/vector2.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _vector = _interopRequireDefault(require("./base/vector"));

var _common = require("../lib/common");

var _validators = require("../lib/validators");

var vec2 = _interopRequireWildcard(require("gl-matrix/vec2"));

var _glMatrixExtras = require("../lib/gl-matrix-extras");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class Vector2 extends _vector.default {
  constructor(x = 0, y = 0) {
    super(2);

    if ((0, _common.isArray)(x) && arguments.length === 1) {
      this.copy(x);
    } else {
      if (_common.config.debug) {
        (0, _validators.checkNumber)(x);
        (0, _validators.checkNumber)(y);
      }

      this[0] = x;
      this[1] = y;
    }
  }

  set(x, y) {
    this[0] = x;
    this[1] = y;
    return this.check();
  }

  copy(array) {
    this[0] = array[0];
    this[1] = array[1];
    return this.check();
  }

  fromObject(object) {
    if (_common.config.debug) {
      (0, _validators.checkNumber)(object.x);
      (0, _validators.checkNumber)(object.y);
    }

    this[0] = object.x;
    this[1] = object.y;
    return this.check();
  }

  toObject(object) {
    object.x = this[0];
    object.y = this[1];
    return object;
  }

  get ELEMENTS() {
    return 2;
  }

  horizontalAngle() {
    return Math.atan2(this.y, this.x);
  }

  verticalAngle() {
    return Math.atan2(this.x, this.y);
  }

  transform(matrix4) {
    return this.transformAsPoint(matrix4);
  }

  transformAsPoint(matrix4) {
    vec2.transformMat4(this, this, matrix4);
    return this.check();
  }

  transformAsVector(matrix4) {
    (0, _glMatrixExtras.vec2_transformMat4AsVector)(this, this, matrix4);
    return this.check();
  }

  transformByMatrix3(matrix3) {
    vec2.transformMat3(this, this, matrix3);
    return this.check();
  }

  transformByMatrix2x3(matrix2x3) {
    vec2.transformMat2d(this, this, matrix2x3);
    return this.check();
  }

  transformByMatrix2(matrix2) {
    vec2.transformMat2(this, this, matrix2);
    return this.check();
  }

}

exports.default = Vector2;
},{"./base/vector":"node_modules/@math.gl/core/dist/esm/classes/base/vector.js","../lib/common":"node_modules/@math.gl/core/dist/esm/lib/common.js","../lib/validators":"node_modules/@math.gl/core/dist/esm/lib/validators.js","gl-matrix/vec2":"node_modules/@math.gl/core/node_modules/gl-matrix/esm/vec2.js","../lib/gl-matrix-extras":"node_modules/@math.gl/core/dist/esm/lib/gl-matrix-extras.js"}],"node_modules/@math.gl/core/node_modules/gl-matrix/esm/vec3.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add = add;
exports.angle = angle;
exports.bezier = bezier;
exports.ceil = ceil;
exports.clone = clone;
exports.copy = copy;
exports.create = create;
exports.cross = cross;
exports.dist = void 0;
exports.distance = distance;
exports.div = void 0;
exports.divide = divide;
exports.dot = dot;
exports.equals = equals;
exports.exactEquals = exactEquals;
exports.floor = floor;
exports.forEach = void 0;
exports.fromValues = fromValues;
exports.hermite = hermite;
exports.inverse = inverse;
exports.len = void 0;
exports.length = length;
exports.lerp = lerp;
exports.max = max;
exports.min = min;
exports.mul = void 0;
exports.multiply = multiply;
exports.negate = negate;
exports.normalize = normalize;
exports.random = random;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.round = round;
exports.scale = scale;
exports.scaleAndAdd = scaleAndAdd;
exports.set = set;
exports.sqrLen = exports.sqrDist = void 0;
exports.squaredDistance = squaredDistance;
exports.squaredLength = squaredLength;
exports.str = str;
exports.sub = void 0;
exports.subtract = subtract;
exports.transformMat3 = transformMat3;
exports.transformMat4 = transformMat4;
exports.transformQuat = transformQuat;
exports.zero = zero;

var glMatrix = _interopRequireWildcard(require("./common.js"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(3);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  return out;
}
/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {ReadonlyVec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Calculates the length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate length of
 * @returns {Number} length of a
 */


function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}
/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */


function fromValues(x, y, z) {
  var out = new glMatrix.ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the source vector
 * @returns {vec3} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */


function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */


function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */


function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}
/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to ceil
 * @returns {vec3} out
 */


function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}
/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to floor
 * @returns {vec3} out
 */


function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}
/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */


function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}
/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */


function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}
/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to round
 * @returns {vec3} out
 */


function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}
/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */


function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */


function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} distance between a and b
 */


function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.hypot(x, y, z);
}
/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} squared distance between a and b
 */


function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}
/**
 * Calculates the squared length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */


function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}
/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to negate
 * @returns {vec3} out
 */


function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to invert
 * @returns {vec3} out
 */


function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}
/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to normalize
 * @returns {vec3} out
 */


function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len = x * x + y * y + z * z;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  out[2] = a[2] * len;
  return out;
}
/**
 * Calculates the dot product of two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} dot product of a and b
 */


function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */


function cross(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2];
  var bx = b[0],
      by = b[1],
      bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */


function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {ReadonlyVec3} c the third operand
 * @param {ReadonlyVec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */


function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {ReadonlyVec3} c the third operand
 * @param {ReadonlyVec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */


function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */


function random(out, scale) {
  scale = scale || 1.0;
  var r = glMatrix.RANDOM() * 2.0 * Math.PI;
  var z = glMatrix.RANDOM() * 2.0 - 1.0;
  var zScale = Math.sqrt(1.0 - z * z) * scale;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}
/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec3} out
 */


function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat3} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */


function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
/**
 * Transforms the vec3 with a quat
 * Can also be used for dual quaternions. (Multiply it with the real part)
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyQuat} q quaternion to transform with
 * @returns {vec3} out
 */


function transformQuat(out, a, q) {
  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3];
  var x = a[0],
      y = a[1],
      z = a[2]; // var qvec = [qx, qy, qz];
  // var uv = vec3.cross([], qvec, a);

  var uvx = qy * z - qz * y,
      uvy = qz * x - qx * z,
      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);

  var uuvx = qy * uvz - qz * uvy,
      uuvy = qz * uvx - qx * uvz,
      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);

  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2; // vec3.scale(uuv, uuv, 2);

  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));

  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */


function rotateX(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0];
  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */


function rotateY(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */


function rotateZ(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
  r[2] = p[2]; //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Get the angle between two 3D vectors
 * @param {ReadonlyVec3} a The first operand
 * @param {ReadonlyVec3} b The second operand
 * @returns {Number} The angle in radians
 */


function angle(a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      bx = b[0],
      by = b[1],
      bz = b[2],
      mag1 = Math.sqrt(ax * ax + ay * ay + az * az),
      mag2 = Math.sqrt(bx * bx + by * by + bz * bz),
      mag = mag1 * mag2,
      cosine = mag && dot(a, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
/**
 * Set the components of a vec3 to zero
 *
 * @param {vec3} out the receiving vector
 * @returns {vec3} out
 */


function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */


function str(a) {
  return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec3} a The first vector.
 * @param {ReadonlyVec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec3} a The first vector.
 * @param {ReadonlyVec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));
}
/**
 * Alias for {@link vec3.subtract}
 * @function
 */


var sub = subtract;
/**
 * Alias for {@link vec3.multiply}
 * @function
 */

exports.sub = sub;
var mul = multiply;
/**
 * Alias for {@link vec3.divide}
 * @function
 */

exports.mul = mul;
var div = divide;
/**
 * Alias for {@link vec3.distance}
 * @function
 */

exports.div = div;
var dist = distance;
/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */

exports.dist = dist;
var sqrDist = squaredDistance;
/**
 * Alias for {@link vec3.length}
 * @function
 */

exports.sqrDist = sqrDist;
var len = length;
/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */

exports.len = len;
var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

exports.sqrLen = sqrLen;

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 3;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }

    return a;
  };
}();

exports.forEach = forEach;
},{"./common.js":"node_modules/@math.gl/core/node_modules/gl-matrix/esm/common.js"}],"node_modules/@math.gl/core/dist/esm/classes/vector3.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _vector = _interopRequireDefault(require("./base/vector"));

var _common = require("../lib/common");

var _validators = require("../lib/validators");

var vec3 = _interopRequireWildcard(require("gl-matrix/vec3"));

var _glMatrixExtras = require("../lib/gl-matrix-extras");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const ORIGIN = [0, 0, 0];
const constants = {};

class Vector3 extends _vector.default {
  static get ZERO() {
    return constants.ZERO = constants.ZERO || Object.freeze(new Vector3(0, 0, 0, 0));
  }

  constructor(x = 0, y = 0, z = 0) {
    super(-0, -0, -0);

    if (arguments.length === 1 && (0, _common.isArray)(x)) {
      this.copy(x);
    } else {
      if (_common.config.debug) {
        (0, _validators.checkNumber)(x);
        (0, _validators.checkNumber)(y);
        (0, _validators.checkNumber)(z);
      }

      this[0] = x;
      this[1] = y;
      this[2] = z;
    }
  }

  set(x, y, z) {
    this[0] = x;
    this[1] = y;
    this[2] = z;
    return this.check();
  }

  copy(array) {
    this[0] = array[0];
    this[1] = array[1];
    this[2] = array[2];
    return this.check();
  }

  fromObject(object) {
    if (_common.config.debug) {
      (0, _validators.checkNumber)(object.x);
      (0, _validators.checkNumber)(object.y);
      (0, _validators.checkNumber)(object.z);
    }

    this[0] = object.x;
    this[1] = object.y;
    this[2] = object.z;
    return this.check();
  }

  toObject(object) {
    object.x = this[0];
    object.y = this[1];
    object.z = this[2];
    return object;
  }

  get ELEMENTS() {
    return 3;
  }

  get z() {
    return this[2];
  }

  set z(value) {
    this[2] = (0, _validators.checkNumber)(value);
  }

  angle(vector) {
    return vec3.angle(this, vector);
  }

  cross(vector) {
    vec3.cross(this, this, vector);
    return this.check();
  }

  rotateX({
    radians,
    origin = ORIGIN
  }) {
    vec3.rotateX(this, this, origin, radians);
    return this.check();
  }

  rotateY({
    radians,
    origin = ORIGIN
  }) {
    vec3.rotateY(this, this, origin, radians);
    return this.check();
  }

  rotateZ({
    radians,
    origin = ORIGIN
  }) {
    vec3.rotateZ(this, this, origin, radians);
    return this.check();
  }

  transform(matrix4) {
    return this.transformAsPoint(matrix4);
  }

  transformAsPoint(matrix4) {
    vec3.transformMat4(this, this, matrix4);
    return this.check();
  }

  transformAsVector(matrix4) {
    (0, _glMatrixExtras.vec3_transformMat4AsVector)(this, this, matrix4);
    return this.check();
  }

  transformByMatrix3(matrix3) {
    vec3.transformMat3(this, this, matrix3);
    return this.check();
  }

  transformByMatrix2(matrix2) {
    (0, _glMatrixExtras.vec3_transformMat2)(this, this, matrix2);
    return this.check();
  }

  transformByQuaternion(quaternion) {
    vec3.transformQuat(this, this, quaternion);
    return this.check();
  }

}

exports.default = Vector3;
},{"./base/vector":"node_modules/@math.gl/core/dist/esm/classes/base/vector.js","../lib/common":"node_modules/@math.gl/core/dist/esm/lib/common.js","../lib/validators":"node_modules/@math.gl/core/dist/esm/lib/validators.js","gl-matrix/vec3":"node_modules/@math.gl/core/node_modules/gl-matrix/esm/vec3.js","../lib/gl-matrix-extras":"node_modules/@math.gl/core/dist/esm/lib/gl-matrix-extras.js"}],"node_modules/@math.gl/core/dist/esm/classes/vector4.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _vector = _interopRequireDefault(require("./base/vector"));

var _common = require("../lib/common");

var _validators = require("../lib/validators");

var vec4 = _interopRequireWildcard(require("gl-matrix/vec3"));

var _glMatrixExtras = require("../lib/gl-matrix-extras");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const constants = {};

class Vector4 extends _vector.default {
  static get ZERO() {
    return constants.ZERO = constants.ZERO || Object.freeze(new Vector4(0, 0, 0, 0));
  }

  constructor(x = 0, y = 0, z = 0, w = 0) {
    super(-0, -0, -0, -0);

    if ((0, _common.isArray)(x) && arguments.length === 1) {
      this.copy(x);
    } else {
      if (_common.config.debug) {
        (0, _validators.checkNumber)(x);
        (0, _validators.checkNumber)(y);
        (0, _validators.checkNumber)(z);
        (0, _validators.checkNumber)(w);
      }

      this[0] = x;
      this[1] = y;
      this[2] = z;
      this[3] = w;
    }
  }

  set(x, y, z, w) {
    this[0] = x;
    this[1] = y;
    this[2] = z;
    this[3] = w;
    return this.check();
  }

  copy(array) {
    this[0] = array[0];
    this[1] = array[1];
    this[2] = array[2];
    this[3] = array[3];
    return this.check();
  }

  fromObject(object) {
    if (_common.config.debug) {
      (0, _validators.checkNumber)(object.x);
      (0, _validators.checkNumber)(object.y);
      (0, _validators.checkNumber)(object.z);
      (0, _validators.checkNumber)(object.w);
    }

    this[0] = object.x;
    this[1] = object.y;
    this[2] = object.z;
    this[3] = object.w;
    return this;
  }

  toObject(object) {
    object.x = this[0];
    object.y = this[1];
    object.z = this[2];
    object.w = this[3];
    return object;
  }

  get ELEMENTS() {
    return 4;
  }

  get z() {
    return this[2];
  }

  set z(value) {
    this[2] = (0, _validators.checkNumber)(value);
  }

  get w() {
    return this[3];
  }

  set w(value) {
    this[3] = (0, _validators.checkNumber)(value);
  }

  transform(matrix4) {
    vec4.transformMat4(this, this, matrix4);
    return this.check();
  }

  transformByMatrix3(matrix3) {
    (0, _glMatrixExtras.vec4_transformMat3)(this, this, matrix3);
    return this.check();
  }

  transformByMatrix2(matrix2) {
    (0, _glMatrixExtras.vec4_transformMat2)(this, this, matrix2);
    return this.check();
  }

  transformByQuaternion(quaternion) {
    vec4.transformQuat(this, this, quaternion);
    return this.check();
  }

  applyMatrix4(m) {
    m.transform(this, this);
    return this;
  }

}

exports.default = Vector4;
},{"./base/vector":"node_modules/@math.gl/core/dist/esm/classes/base/vector.js","../lib/common":"node_modules/@math.gl/core/dist/esm/lib/common.js","../lib/validators":"node_modules/@math.gl/core/dist/esm/lib/validators.js","gl-matrix/vec3":"node_modules/@math.gl/core/node_modules/gl-matrix/esm/vec3.js","../lib/gl-matrix-extras":"node_modules/@math.gl/core/dist/esm/lib/gl-matrix-extras.js"}],"node_modules/@math.gl/core/dist/esm/classes/base/matrix.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _mathArray = _interopRequireDefault(require("./math-array"));

var _validators = require("../../lib/validators");

var _common = require("../../lib/common");

var _assert = _interopRequireDefault(require("../../lib/assert"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class Matrix extends _mathArray.default {
  get ELEMENTS() {
    (0, _assert.default)(false);
    return 0;
  }

  get RANK() {
    (0, _assert.default)(false);
    return 0;
  }

  toString() {
    let string = '[';

    if (_common.config.printRowMajor) {
      string += 'row-major:';

      for (let row = 0; row < this.RANK; ++row) {
        for (let col = 0; col < this.RANK; ++col) {
          string += " ".concat(this[col * this.RANK + row]);
        }
      }
    } else {
      string += 'column-major:';

      for (let i = 0; i < this.ELEMENTS; ++i) {
        string += " ".concat(this[i]);
      }
    }

    string += ']';
    return string;
  }

  getElementIndex(row, col) {
    return col * this.RANK + row;
  }

  getElement(row, col) {
    return this[col * this.RANK + row];
  }

  setElement(row, col, value) {
    this[col * this.RANK + row] = (0, _validators.checkNumber)(value);
    return this;
  }

  getColumn(columnIndex, result = new Array(this.RANK).fill(-0)) {
    const firstIndex = columnIndex * this.RANK;

    for (let i = 0; i < this.RANK; ++i) {
      result[i] = this[firstIndex + i];
    }

    return result;
  }

  setColumn(columnIndex, columnVector) {
    const firstIndex = columnIndex * this.RANK;

    for (let i = 0; i < this.RANK; ++i) {
      this[firstIndex + i] = columnVector[i];
    }

    return this;
  }

}

exports.default = Matrix;
},{"./math-array":"node_modules/@math.gl/core/dist/esm/classes/base/math-array.js","../../lib/validators":"node_modules/@math.gl/core/dist/esm/lib/validators.js","../../lib/common":"node_modules/@math.gl/core/dist/esm/lib/common.js","../../lib/assert":"node_modules/@math.gl/core/dist/esm/lib/assert.js"}],"node_modules/@math.gl/core/node_modules/gl-matrix/esm/mat3.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add = add;
exports.adjoint = adjoint;
exports.clone = clone;
exports.copy = copy;
exports.create = create;
exports.determinant = determinant;
exports.equals = equals;
exports.exactEquals = exactEquals;
exports.frob = frob;
exports.fromMat2d = fromMat2d;
exports.fromMat4 = fromMat4;
exports.fromQuat = fromQuat;
exports.fromRotation = fromRotation;
exports.fromScaling = fromScaling;
exports.fromTranslation = fromTranslation;
exports.fromValues = fromValues;
exports.identity = identity;
exports.invert = invert;
exports.mul = void 0;
exports.multiply = multiply;
exports.multiplyScalar = multiplyScalar;
exports.multiplyScalarAndAdd = multiplyScalarAndAdd;
exports.normalFromMat4 = normalFromMat4;
exports.projection = projection;
exports.rotate = rotate;
exports.scale = scale;
exports.set = set;
exports.str = str;
exports.sub = void 0;
exports.subtract = subtract;
exports.translate = translate;
exports.transpose = transpose;

var glMatrix = _interopRequireWildcard(require("./common.js"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * 3x3 Matrix
 * @module mat3
 */

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(9);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }

  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {ReadonlyMat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */


function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}
/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */


function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new glMatrix.ARRAY_TYPE(9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */


function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */


function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */


function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }

  return out;
}
/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */


function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20; // Calculate the determinant

  var det = a00 * b01 + a01 * b11 + a02 * b21;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */


function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}
/**
 * Calculates the determinant of a mat3
 *
 * @param {ReadonlyMat3} a the source matrix
 * @returns {Number} determinant of a
 */


function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */


function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b00 = b[0],
      b01 = b[1],
      b02 = b[2];
  var b10 = b[3],
      b11 = b[4],
      b12 = b[5];
  var b20 = b[6],
      b21 = b[7],
      b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to translate
 * @param {ReadonlyVec2} v vector to translate by
 * @returns {mat3} out
 */


function translate(out, a, v) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      x = v[0],
      y = v[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}
/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */


function rotate(out, a, rad) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;
  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}
/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to rotate
 * @param {ReadonlyVec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/


function scale(out, a, v) {
  var x = v[0],
      y = v[1];
  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];
  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyVec2} v Translation vector
 * @returns {mat3} out
 */


function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */


function fromRotation(out, rad) {
  var s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = -s;
  out[4] = c;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyVec2} v Scaling vector
 * @returns {mat3} out
 */


function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to copy
 * @returns {mat3} out
 **/


function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;
  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;
  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}
/**
 * Calculates a 3x3 matrix from the given quaternion
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyQuat} q Quaternion to create matrix from
 *
 * @returns {mat3} out
 */


function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;
  return out;
}
/**
 * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyMat4} a Mat4 to derive the normal matrix from
 *
 * @returns {mat3} out
 */


function normalFromMat4(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  return out;
}
/**
 * Generates a 2D projection matrix with the given bounds
 *
 * @param {mat3} out mat3 frustum matrix will be written into
 * @param {number} width Width of your gl context
 * @param {number} height Height of gl context
 * @returns {mat3} out
 */


function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}
/**
 * Returns a string representation of a mat3
 *
 * @param {ReadonlyMat3} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */


function str(a) {
  return "mat3(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ")";
}
/**
 * Returns Frobenius norm of a mat3
 *
 * @param {ReadonlyMat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */


function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
}
/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */


function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  return out;
}
/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */


function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat3} a The first matrix.
 * @param {ReadonlyMat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat3} a The first matrix.
 * @param {ReadonlyMat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7],
      a8 = a[8];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7],
      b8 = b[8];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8));
}
/**
 * Alias for {@link mat3.multiply}
 * @function
 */


var mul = multiply;
/**
 * Alias for {@link mat3.subtract}
 * @function
 */

exports.mul = mul;
var sub = subtract;
exports.sub = sub;
},{"./common.js":"node_modules/@math.gl/core/node_modules/gl-matrix/esm/common.js"}],"node_modules/@math.gl/core/dist/esm/classes/matrix3.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _matrix = _interopRequireDefault(require("./base/matrix"));

var _validators = require("../lib/validators");

var _glMatrixExtras = require("../lib/gl-matrix-extras");

var mat3 = _interopRequireWildcard(require("gl-matrix/mat3"));

var vec2 = _interopRequireWildcard(require("gl-matrix/vec2"));

var vec3 = _interopRequireWildcard(require("gl-matrix/vec3"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const IDENTITY = Object.freeze([1, 0, 0, 0, 1, 0, 0, 0, 1]);
const ZERO = Object.freeze([0, 0, 0, 0, 0, 0, 0, 0, 0]);
const INDICES = Object.freeze({
  COL0ROW0: 0,
  COL0ROW1: 1,
  COL0ROW2: 2,
  COL1ROW0: 3,
  COL1ROW1: 4,
  COL1ROW2: 5,
  COL2ROW0: 6,
  COL2ROW1: 7,
  COL2ROW2: 8
});
const constants = {};

class Matrix3 extends _matrix.default {
  static get IDENTITY() {
    constants.IDENTITY = constants.IDENTITY || Object.freeze(new Matrix3(IDENTITY));
    return constants.IDENTITY;
  }

  static get ZERO() {
    constants.ZERO = constants.ZERO || Object.freeze(new Matrix3(ZERO));
    return constants.ZERO;
  }

  get ELEMENTS() {
    return 9;
  }

  get RANK() {
    return 3;
  }

  get INDICES() {
    return INDICES;
  }

  constructor(array) {
    super(-0, -0, -0, -0, -0, -0, -0, -0, -0);

    if (arguments.length === 1 && Array.isArray(array)) {
      this.copy(array);
    } else {
      this.identity();
    }
  }

  copy(array) {
    this[0] = array[0];
    this[1] = array[1];
    this[2] = array[2];
    this[3] = array[3];
    this[4] = array[4];
    this[5] = array[5];
    this[6] = array[6];
    this[7] = array[7];
    this[8] = array[8];
    return this.check();
  }

  set(m00, m10, m20, m01, m11, m21, m02, m12, m22) {
    this[0] = m00;
    this[1] = m10;
    this[2] = m20;
    this[3] = m01;
    this[4] = m11;
    this[5] = m21;
    this[6] = m02;
    this[7] = m12;
    this[8] = m22;
    return this.check();
  }

  setRowMajor(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    this[0] = m00;
    this[1] = m10;
    this[2] = m20;
    this[3] = m01;
    this[4] = m11;
    this[5] = m21;
    this[6] = m02;
    this[7] = m12;
    this[8] = m22;
    return this.check();
  }

  determinant() {
    return mat3.determinant(this);
  }

  identity() {
    return this.copy(IDENTITY);
  }

  fromQuaternion(q) {
    mat3.fromQuat(this, q);
    return this.check();
  }

  transpose() {
    mat3.transpose(this, this);
    return this.check();
  }

  invert() {
    mat3.invert(this, this);
    return this.check();
  }

  multiplyLeft(a) {
    mat3.multiply(this, a, this);
    return this.check();
  }

  multiplyRight(a) {
    mat3.multiply(this, this, a);
    return this.check();
  }

  rotate(radians) {
    mat3.rotate(this, this, radians);
    return this.check();
  }

  scale(factor) {
    if (Array.isArray(factor)) {
      mat3.scale(this, this, factor);
    } else {
      mat3.scale(this, this, [factor, factor, factor]);
    }

    return this.check();
  }

  translate(vec) {
    mat3.translate(this, this, vec);
    return this.check();
  }

  transform(vector, result) {
    switch (vector.length) {
      case 2:
        result = vec2.transformMat3(result || [-0, -0], vector, this);
        break;

      case 3:
        result = vec3.transformMat3(result || [-0, -0, -0], vector, this);
        break;

      case 4:
        result = (0, _glMatrixExtras.vec4_transformMat3)(result || [-0, -0, -0, -0], vector, this);
        break;

      default:
        throw new Error('Illegal vector');
    }

    (0, _validators.checkVector)(result, vector.length);
    return result;
  }

  transformVector(vector, result) {
    (0, _validators.deprecated)('Matrix3.transformVector');
    return this.transform(vector, result);
  }

  transformVector2(vector, result) {
    (0, _validators.deprecated)('Matrix3.transformVector');
    return this.transform(vector, result);
  }

  transformVector3(vector, result) {
    (0, _validators.deprecated)('Matrix3.transformVector');
    return this.transform(vector, result);
  }

}

exports.default = Matrix3;
},{"./base/matrix":"node_modules/@math.gl/core/dist/esm/classes/base/matrix.js","../lib/validators":"node_modules/@math.gl/core/dist/esm/lib/validators.js","../lib/gl-matrix-extras":"node_modules/@math.gl/core/dist/esm/lib/gl-matrix-extras.js","gl-matrix/mat3":"node_modules/@math.gl/core/node_modules/gl-matrix/esm/mat3.js","gl-matrix/vec2":"node_modules/@math.gl/core/node_modules/gl-matrix/esm/vec2.js","gl-matrix/vec3":"node_modules/@math.gl/core/node_modules/gl-matrix/esm/vec3.js"}],"node_modules/@math.gl/core/node_modules/gl-matrix/esm/mat4.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add = add;
exports.adjoint = adjoint;
exports.clone = clone;
exports.copy = copy;
exports.create = create;
exports.determinant = determinant;
exports.equals = equals;
exports.exactEquals = exactEquals;
exports.frob = frob;
exports.fromQuat = fromQuat;
exports.fromQuat2 = fromQuat2;
exports.fromRotation = fromRotation;
exports.fromRotationTranslation = fromRotationTranslation;
exports.fromRotationTranslationScale = fromRotationTranslationScale;
exports.fromRotationTranslationScaleOrigin = fromRotationTranslationScaleOrigin;
exports.fromScaling = fromScaling;
exports.fromTranslation = fromTranslation;
exports.fromValues = fromValues;
exports.fromXRotation = fromXRotation;
exports.fromYRotation = fromYRotation;
exports.fromZRotation = fromZRotation;
exports.frustum = frustum;
exports.getRotation = getRotation;
exports.getScaling = getScaling;
exports.getTranslation = getTranslation;
exports.identity = identity;
exports.invert = invert;
exports.lookAt = lookAt;
exports.mul = void 0;
exports.multiply = multiply;
exports.multiplyScalar = multiplyScalar;
exports.multiplyScalarAndAdd = multiplyScalarAndAdd;
exports.ortho = ortho;
exports.perspective = perspective;
exports.perspectiveFromFieldOfView = perspectiveFromFieldOfView;
exports.rotate = rotate;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.scale = scale;
exports.set = set;
exports.str = str;
exports.sub = void 0;
exports.subtract = subtract;
exports.targetTo = targetTo;
exports.translate = translate;
exports.transpose = transpose;

var glMatrix = _interopRequireWildcard(require("./common.js"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
 * @module mat4
 */

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(16);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }

  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */


function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new glMatrix.ARRAY_TYPE(16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */


function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */


function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */


function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a12 = a[6],
        a13 = a[7];
    var a23 = a[11];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }

  return out;
}
/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */


function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */


function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
  return out;
}
/**
 * Calculates the determinant of a mat4
 *
 * @param {ReadonlyMat4} a the source matrix
 * @returns {Number} determinant of a
 */


function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
/**
 * Multiplies two mat4s
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */


function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15]; // Cache only the current line of the second matrix

  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to translate
 * @param {ReadonlyVec3} v vector to translate by
 * @returns {mat4} out
 */


function translate(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;

  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }

  return out;
}
/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to scale
 * @param {ReadonlyVec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/


function scale(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @returns {mat4} out
 */


function rotate(out, a, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;

  if (len < glMatrix.EPSILON) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  a00 = a[0];
  a01 = a[1];
  a02 = a[2];
  a03 = a[3];
  a10 = a[4];
  a11 = a[5];
  a12 = a[6];
  a13 = a[7];
  a20 = a[8];
  a21 = a[9];
  a22 = a[10];
  a23 = a[11]; // Construct the elements of the rotation matrix

  b00 = x * x * t + c;
  b01 = y * x * t + z * s;
  b02 = z * x * t - y * s;
  b10 = x * y * t - z * s;
  b11 = y * y * t + c;
  b12 = z * y * t + x * s;
  b20 = x * z * t + y * s;
  b21 = y * z * t - x * s;
  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication

  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  return out;
}
/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function rotateX(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function rotateY(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function rotateZ(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyVec3} v Translation vector
 * @returns {mat4} out
 */


function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyVec3} v Scaling vector
 * @returns {mat4} out
 */


function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @returns {mat4} out
 */


function fromRotation(out, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;

  if (len < glMatrix.EPSILON) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c; // Perform rotation-specific matrix multiplication

  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function fromXRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function fromYRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = 0;
  out[2] = -s;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function fromZRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @returns {mat4} out
 */


function fromRotationTranslation(out, q, v) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 from a dual quat.
 *
 * @param {mat4} out Matrix
 * @param {ReadonlyQuat2} a Dual Quaternion
 * @returns {mat4} mat4 receiving operation result
 */


function fromQuat2(out, a) {
  var translation = new glMatrix.ARRAY_TYPE(3);
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7];
  var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense

  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }

  fromRotationTranslation(out, a, translation);
  return out;
}
/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */


function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
/**
 * Returns the scaling factor component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslationScale
 *  with a normalized Quaternion paramter, the returned vector will be
 *  the same as the scaling vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive scaling factor component
 * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */


function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.hypot(m11, m12, m13);
  out[1] = Math.hypot(m21, m22, m23);
  out[2] = Math.hypot(m31, m32, m33);
  return out;
}
/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */


function getRotation(out, mat) {
  var scaling = new glMatrix.ARRAY_TYPE(3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S = 0;

  if (trace > 0) {
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (sm23 - sm32) / S;
    out[1] = (sm31 - sm13) / S;
    out[2] = (sm12 - sm21) / S;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S;
    out[0] = 0.25 * S;
    out[1] = (sm12 + sm21) / S;
    out[2] = (sm31 + sm13) / S;
  } else if (sm22 > sm33) {
    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S;
    out[0] = (sm12 + sm21) / S;
    out[1] = 0.25 * S;
    out[2] = (sm23 + sm32) / S;
  } else {
    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S;
    out[0] = (sm31 + sm13) / S;
    out[1] = (sm23 + sm32) / S;
    out[2] = 0.25 * S;
  }

  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @param {ReadonlyVec3} s Scaling vector
 * @returns {mat4} out
 */


function fromRotationTranslationScale(out, q, v, s) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @param {ReadonlyVec3} s Scaling vector
 * @param {ReadonlyVec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */


function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  var ox = o[0];
  var oy = o[1];
  var oz = o[2];
  var out0 = (1 - (yy + zz)) * sx;
  var out1 = (xy + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx) * sz;
  var out10 = (1 - (xx + yy)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}
/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyQuat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */


function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */


function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
/**
 * Generates a perspective projection matrix with the given bounds.
 * Passing null/undefined/no value for far will generate infinite projection matrix.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum, can be null or Infinity
 * @returns {mat4} out
 */


function perspective(out, fovy, aspect, near, far) {
  var f = 1.0 / Math.tan(fovy / 2),
      nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;

  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }

  return out;
}
/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */


function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);
  var xScale = 2.0 / (leftTan + rightTan);
  var yScale = 2.0 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  out[4] = 0.0;
  out[5] = yScale;
  out[6] = 0.0;
  out[7] = 0.0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1.0;
  out[12] = 0.0;
  out[13] = 0.0;
  out[14] = far * near / (near - far);
  out[15] = 0.0;
  return out;
}
/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */


function ortho(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis.
 * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {ReadonlyVec3} eye Position of the viewer
 * @param {ReadonlyVec3} center Point the viewer is looking at
 * @param {ReadonlyVec3} up vec3 pointing up
 * @returns {mat4} out
 */


function lookAt(out, eye, center, up) {
  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];

  if (Math.abs(eyex - centerx) < glMatrix.EPSILON && Math.abs(eyey - centery) < glMatrix.EPSILON && Math.abs(eyez - centerz) < glMatrix.EPSILON) {
    return identity(out);
  }

  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len = 1 / Math.hypot(z0, z1, z2);
  z0 *= len;
  z1 *= len;
  z2 *= len;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len = Math.hypot(x0, x1, x2);

  if (!len) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len = 1 / len;
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len = Math.hypot(y0, y1, y2);

  if (!len) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len = 1 / len;
    y0 *= len;
    y1 *= len;
    y2 *= len;
  }

  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
/**
 * Generates a matrix that makes something look at something else.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {ReadonlyVec3} eye Position of the viewer
 * @param {ReadonlyVec3} center Point the viewer is looking at
 * @param {ReadonlyVec3} up vec3 pointing up
 * @returns {mat4} out
 */


function targetTo(out, eye, target, up) {
  var eyex = eye[0],
      eyey = eye[1],
      eyez = eye[2],
      upx = up[0],
      upy = up[1],
      upz = up[2];
  var z0 = eyex - target[0],
      z1 = eyey - target[1],
      z2 = eyez - target[2];
  var len = z0 * z0 + z1 * z1 + z2 * z2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    z0 *= len;
    z1 *= len;
    z2 *= len;
  }

  var x0 = upy * z2 - upz * z1,
      x1 = upz * z0 - upx * z2,
      x2 = upx * z1 - upy * z0;
  len = x0 * x0 + x1 * x1 + x2 * x2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}
/**
 * Returns a string representation of a mat4
 *
 * @param {ReadonlyMat4} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */


function str(a) {
  return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
}
/**
 * Returns Frobenius norm of a mat4
 *
 * @param {ReadonlyMat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */


function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
}
/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */


function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}
/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */


function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  out[9] = a[9] + b[9] * scale;
  out[10] = a[10] + b[10] * scale;
  out[11] = a[11] + b[11] * scale;
  out[12] = a[12] + b[12] * scale;
  out[13] = a[13] + b[13] * scale;
  out[14] = a[14] + b[14] * scale;
  out[15] = a[15] + b[15] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat4} a The first matrix.
 * @param {ReadonlyMat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat4} a The first matrix.
 * @param {ReadonlyMat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7];
  var a8 = a[8],
      a9 = a[9],
      a10 = a[10],
      a11 = a[11];
  var a12 = a[12],
      a13 = a[13],
      a14 = a[14],
      a15 = a[15];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  var b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7];
  var b8 = b[8],
      b9 = b[9],
      b10 = b[10],
      b11 = b[11];
  var b12 = b[12],
      b13 = b[13],
      b14 = b[14],
      b15 = b[15];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));
}
/**
 * Alias for {@link mat4.multiply}
 * @function
 */


var mul = multiply;
/**
 * Alias for {@link mat4.subtract}
 * @function
 */

exports.mul = mul;
var sub = subtract;
exports.sub = sub;
},{"./common.js":"node_modules/@math.gl/core/node_modules/gl-matrix/esm/common.js"}],"node_modules/@math.gl/core/node_modules/gl-matrix/esm/vec4.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add = add;
exports.ceil = ceil;
exports.clone = clone;
exports.copy = copy;
exports.create = create;
exports.cross = cross;
exports.dist = void 0;
exports.distance = distance;
exports.div = void 0;
exports.divide = divide;
exports.dot = dot;
exports.equals = equals;
exports.exactEquals = exactEquals;
exports.floor = floor;
exports.forEach = void 0;
exports.fromValues = fromValues;
exports.inverse = inverse;
exports.len = void 0;
exports.length = length;
exports.lerp = lerp;
exports.max = max;
exports.min = min;
exports.mul = void 0;
exports.multiply = multiply;
exports.negate = negate;
exports.normalize = normalize;
exports.random = random;
exports.round = round;
exports.scale = scale;
exports.scaleAndAdd = scaleAndAdd;
exports.set = set;
exports.sqrLen = exports.sqrDist = void 0;
exports.squaredDistance = squaredDistance;
exports.squaredLength = squaredLength;
exports.str = str;
exports.sub = void 0;
exports.subtract = subtract;
exports.transformMat4 = transformMat4;
exports.transformQuat = transformQuat;
exports.zero = zero;

var glMatrix = _interopRequireWildcard(require("./common.js"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * 4 Dimensional Vector
 * @module vec4
 */

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(4);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }

  return out;
}
/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {ReadonlyVec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */


function fromValues(x, y, z, w) {
  var out = new glMatrix.ARRAY_TYPE(4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the source vector
 * @returns {vec4} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */


function set(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */


function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  out[3] = a[3] * b[3];
  return out;
}
/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */


function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  out[3] = a[3] / b[3];
  return out;
}
/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to ceil
 * @returns {vec4} out
 */


function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  out[3] = Math.ceil(a[3]);
  return out;
}
/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to floor
 * @returns {vec4} out
 */


function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  out[3] = Math.floor(a[3]);
  return out;
}
/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */


function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  out[3] = Math.min(a[3], b[3]);
  return out;
}
/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */


function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  out[3] = Math.max(a[3], b[3]);
  return out;
}
/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to round
 * @returns {vec4} out
 */


function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  out[3] = Math.round(a[3]);
  return out;
}
/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */


function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */


function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} distance between a and b
 */


function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return Math.hypot(x, y, z, w);
}
/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} squared distance between a and b
 */


function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Calculates the length of a vec4
 *
 * @param {ReadonlyVec4} a vector to calculate length of
 * @returns {Number} length of a
 */


function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return Math.hypot(x, y, z, w);
}
/**
 * Calculates the squared length of a vec4
 *
 * @param {ReadonlyVec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */


function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to negate
 * @returns {vec4} out
 */


function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = -a[3];
  return out;
}
/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to invert
 * @returns {vec4} out
 */


function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
}
/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to normalize
 * @returns {vec4} out
 */


function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len = x * x + y * y + z * z + w * w;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
  }

  out[0] = x * len;
  out[1] = y * len;
  out[2] = z * len;
  out[3] = w * len;
  return out;
}
/**
 * Calculates the dot product of two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} dot product of a and b
 */


function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}
/**
 * Returns the cross-product of three vectors in a 4-dimensional space
 *
 * @param {ReadonlyVec4} result the receiving vector
 * @param {ReadonlyVec4} U the first vector
 * @param {ReadonlyVec4} V the second vector
 * @param {ReadonlyVec4} W the third vector
 * @returns {vec4} result
 */


function cross(out, u, v, w) {
  var A = v[0] * w[1] - v[1] * w[0],
      B = v[0] * w[2] - v[2] * w[0],
      C = v[0] * w[3] - v[3] * w[0],
      D = v[1] * w[2] - v[2] * w[1],
      E = v[1] * w[3] - v[3] * w[1],
      F = v[2] * w[3] - v[3] * w[2];
  var G = u[0];
  var H = u[1];
  var I = u[2];
  var J = u[3];
  out[0] = H * F - I * E + J * D;
  out[1] = -(G * F) + I * C - J * B;
  out[2] = G * E - H * C + J * A;
  out[3] = -(G * D) + H * B - I * A;
  return out;
}
/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec4} out
 */


function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  var aw = a[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */


function random(out, scale) {
  scale = scale || 1.0; // Marsaglia, George. Choosing a Point from the Surface of a
  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.
  // http://projecteuclid.org/euclid.aoms/1177692644;

  var v1, v2, v3, v4;
  var s1, s2;

  do {
    v1 = glMatrix.RANDOM() * 2 - 1;
    v2 = glMatrix.RANDOM() * 2 - 1;
    s1 = v1 * v1 + v2 * v2;
  } while (s1 >= 1);

  do {
    v3 = glMatrix.RANDOM() * 2 - 1;
    v4 = glMatrix.RANDOM() * 2 - 1;
    s2 = v3 * v3 + v4 * v4;
  } while (s2 >= 1);

  var d = Math.sqrt((1 - s1) / s2);
  out[0] = scale * v1;
  out[1] = scale * v2;
  out[2] = scale * v3 * d;
  out[3] = scale * v4 * d;
  return out;
}
/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec4} out
 */


function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out;
}
/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to transform
 * @param {ReadonlyQuat} q quaternion to transform with
 * @returns {vec4} out
 */


function transformQuat(out, a, q) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3]; // calculate quat * vec

  var ix = qw * x + qy * z - qz * y;
  var iy = qw * y + qz * x - qx * z;
  var iz = qw * z + qx * y - qy * x;
  var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to zero
 *
 * @param {vec4} out the receiving vector
 * @returns {vec4} out
 */


function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec4} a vector to represent as a string
 * @returns {String} string representation of the vector
 */


function str(a) {
  return "vec4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec4} a The first vector.
 * @param {ReadonlyVec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec4} a The first vector.
 * @param {ReadonlyVec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}
/**
 * Alias for {@link vec4.subtract}
 * @function
 */


var sub = subtract;
/**
 * Alias for {@link vec4.multiply}
 * @function
 */

exports.sub = sub;
var mul = multiply;
/**
 * Alias for {@link vec4.divide}
 * @function
 */

exports.mul = mul;
var div = divide;
/**
 * Alias for {@link vec4.distance}
 * @function
 */

exports.div = div;
var dist = distance;
/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */

exports.dist = dist;
var sqrDist = squaredDistance;
/**
 * Alias for {@link vec4.length}
 * @function
 */

exports.sqrDist = sqrDist;
var len = length;
/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */

exports.len = len;
var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

exports.sqrLen = sqrLen;

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 4;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }

    return a;
  };
}();

exports.forEach = forEach;
},{"./common.js":"node_modules/@math.gl/core/node_modules/gl-matrix/esm/common.js"}],"node_modules/@math.gl/core/dist/esm/classes/matrix4.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _validators = require("../lib/validators");

var _matrix = _interopRequireDefault(require("./base/matrix"));

var _glMatrixExtras = require("../lib/gl-matrix-extras");

var mat4 = _interopRequireWildcard(require("gl-matrix/mat4"));

var vec2 = _interopRequireWildcard(require("gl-matrix/vec2"));

var vec3 = _interopRequireWildcard(require("gl-matrix/vec3"));

var vec4 = _interopRequireWildcard(require("gl-matrix/vec4"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const IDENTITY = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
const ZERO = Object.freeze([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
const INDICES = Object.freeze({
  COL0ROW0: 0,
  COL0ROW1: 1,
  COL0ROW2: 2,
  COL0ROW3: 3,
  COL1ROW0: 4,
  COL1ROW1: 5,
  COL1ROW2: 6,
  COL1ROW3: 7,
  COL2ROW0: 8,
  COL2ROW1: 9,
  COL2ROW2: 10,
  COL2ROW3: 11,
  COL3ROW0: 12,
  COL3ROW1: 13,
  COL3ROW2: 14,
  COL3ROW3: 15
});
const constants = {};

class Matrix4 extends _matrix.default {
  static get IDENTITY() {
    constants.IDENTITY = constants.IDENTITY || Object.freeze(new Matrix4(IDENTITY));
    return constants.IDENTITY;
  }

  static get ZERO() {
    constants.ZERO = constants.ZERO || Object.freeze(new Matrix4(ZERO));
    return constants.ZERO;
  }

  get INDICES() {
    return INDICES;
  }

  get ELEMENTS() {
    return 16;
  }

  get RANK() {
    return 4;
  }

  constructor(array) {
    super(-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0);

    if (arguments.length === 1 && Array.isArray(array)) {
      this.copy(array);
    } else {
      this.identity();
    }
  }

  copy(array) {
    this[0] = array[0];
    this[1] = array[1];
    this[2] = array[2];
    this[3] = array[3];
    this[4] = array[4];
    this[5] = array[5];
    this[6] = array[6];
    this[7] = array[7];
    this[8] = array[8];
    this[9] = array[9];
    this[10] = array[10];
    this[11] = array[11];
    this[12] = array[12];
    this[13] = array[13];
    this[14] = array[14];
    this[15] = array[15];
    return this.check();
  }

  set(m00, m10, m20, m30, m01, m11, m21, m31, m02, m12, m22, m32, m03, m13, m23, m33) {
    this[0] = m00;
    this[1] = m10;
    this[2] = m20;
    this[3] = m30;
    this[4] = m01;
    this[5] = m11;
    this[6] = m21;
    this[7] = m31;
    this[8] = m02;
    this[9] = m12;
    this[10] = m22;
    this[11] = m32;
    this[12] = m03;
    this[13] = m13;
    this[14] = m23;
    this[15] = m33;
    return this.check();
  }

  setRowMajor(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    this[0] = m00;
    this[1] = m10;
    this[2] = m20;
    this[3] = m30;
    this[4] = m01;
    this[5] = m11;
    this[6] = m21;
    this[7] = m31;
    this[8] = m02;
    this[9] = m12;
    this[10] = m22;
    this[11] = m32;
    this[12] = m03;
    this[13] = m13;
    this[14] = m23;
    this[15] = m33;
    return this.check();
  }

  toRowMajor(result) {
    result[0] = this[0];
    result[1] = this[4];
    result[2] = this[8];
    result[3] = this[12];
    result[4] = this[1];
    result[5] = this[5];
    result[6] = this[9];
    result[7] = this[13];
    result[8] = this[2];
    result[9] = this[6];
    result[10] = this[10];
    result[11] = this[14];
    result[12] = this[3];
    result[13] = this[7];
    result[14] = this[11];
    result[15] = this[15];
    return result;
  }

  identity() {
    return this.copy(IDENTITY);
  }

  fromQuaternion(q) {
    mat4.fromQuat(this, q);
    return this.check();
  }

  frustum({
    left,
    right,
    bottom,
    top,
    near,
    far
  }) {
    if (far === Infinity) {
      Matrix4._computeInfinitePerspectiveOffCenter(this, left, right, bottom, top, near);
    } else {
      mat4.frustum(this, left, right, bottom, top, near, far);
    }

    return this.check();
  }

  static _computeInfinitePerspectiveOffCenter(result, left, right, bottom, top, near) {
    const column0Row0 = 2.0 * near / (right - left);
    const column1Row1 = 2.0 * near / (top - bottom);
    const column2Row0 = (right + left) / (right - left);
    const column2Row1 = (top + bottom) / (top - bottom);
    const column2Row2 = -1.0;
    const column2Row3 = -1.0;
    const column3Row2 = -2.0 * near;
    result[0] = column0Row0;
    result[1] = 0.0;
    result[2] = 0.0;
    result[3] = 0.0;
    result[4] = 0.0;
    result[5] = column1Row1;
    result[6] = 0.0;
    result[7] = 0.0;
    result[8] = column2Row0;
    result[9] = column2Row1;
    result[10] = column2Row2;
    result[11] = column2Row3;
    result[12] = 0.0;
    result[13] = 0.0;
    result[14] = column3Row2;
    result[15] = 0.0;
    return result;
  }

  lookAt(eye, center, up) {
    if (arguments.length === 1) {
      ({
        eye,
        center,
        up
      } = eye);
    }

    center = center || [0, 0, 0];
    up = up || [0, 1, 0];
    mat4.lookAt(this, eye, center, up);
    return this.check();
  }

  ortho({
    left,
    right,
    bottom,
    top,
    near = 0.1,
    far = 500
  }) {
    mat4.ortho(this, left, right, bottom, top, near, far);
    return this.check();
  }

  orthographic({
    fovy = 45 * Math.PI / 180,
    aspect = 1,
    focalDistance = 1,
    near = 0.1,
    far = 500
  }) {
    if (fovy > Math.PI * 2) {
      throw Error('radians');
    }

    const halfY = fovy / 2;
    const top = focalDistance * Math.tan(halfY);
    const right = top * aspect;
    return new Matrix4().ortho({
      left: -right,
      right,
      bottom: -top,
      top,
      near,
      far
    });
  }

  perspective({
    fovy = undefined,
    fov = 45 * Math.PI / 180,
    aspect = 1,
    near = 0.1,
    far = 500
  } = {}) {
    fovy = fovy || fov;

    if (fovy > Math.PI * 2) {
      throw Error('radians');
    }

    mat4.perspective(this, fovy, aspect, near, far);
    return this.check();
  }

  determinant() {
    return mat4.determinant(this);
  }

  getScale(result = [-0, -0, -0]) {
    result[0] = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]);
    result[1] = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]);
    result[2] = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]);
    return result;
  }

  getTranslation(result = [-0, -0, -0]) {
    result[0] = this[12];
    result[1] = this[13];
    result[2] = this[14];
    return result;
  }

  getRotation(result = [-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0], scaleResult = null) {
    const scale = this.getScale(scaleResult || [-0, -0, -0]);
    const inverseScale0 = 1 / scale[0];
    const inverseScale1 = 1 / scale[1];
    const inverseScale2 = 1 / scale[2];
    result[0] = this[0] * inverseScale0;
    result[1] = this[1] * inverseScale1;
    result[2] = this[2] * inverseScale2;
    result[3] = 0;
    result[4] = this[4] * inverseScale0;
    result[5] = this[5] * inverseScale1;
    result[6] = this[6] * inverseScale2;
    result[7] = 0;
    result[8] = this[8] * inverseScale0;
    result[9] = this[9] * inverseScale1;
    result[10] = this[10] * inverseScale2;
    result[11] = 0;
    result[12] = 0;
    result[13] = 0;
    result[14] = 0;
    result[15] = 1;
    return result;
  }

  getRotationMatrix3(result = [-0, -0, -0, -0, -0, -0, -0, -0, -0], scaleResult = null) {
    const scale = this.getScale(scaleResult || [-0, -0, -0]);
    const inverseScale0 = 1 / scale[0];
    const inverseScale1 = 1 / scale[1];
    const inverseScale2 = 1 / scale[2];
    result[0] = this[0] * inverseScale0;
    result[1] = this[1] * inverseScale1;
    result[2] = this[2] * inverseScale2;
    result[3] = this[4] * inverseScale0;
    result[4] = this[5] * inverseScale1;
    result[5] = this[6] * inverseScale2;
    result[6] = this[8] * inverseScale0;
    result[7] = this[9] * inverseScale1;
    result[8] = this[10] * inverseScale2;
    return result;
  }

  transpose() {
    mat4.transpose(this, this);
    return this.check();
  }

  invert() {
    mat4.invert(this, this);
    return this.check();
  }

  multiplyLeft(a) {
    mat4.multiply(this, a, this);
    return this.check();
  }

  multiplyRight(a) {
    mat4.multiply(this, this, a);
    return this.check();
  }

  rotateX(radians) {
    mat4.rotateX(this, this, radians);
    return this.check();
  }

  rotateY(radians) {
    mat4.rotateY(this, this, radians);
    return this.check();
  }

  rotateZ(radians) {
    mat4.rotateZ(this, this, radians);
    return this.check();
  }

  rotateXYZ([rx, ry, rz]) {
    return this.rotateX(rx).rotateY(ry).rotateZ(rz);
  }

  rotateAxis(radians, axis) {
    mat4.rotate(this, this, radians, axis);
    return this.check();
  }

  scale(factor) {
    if (Array.isArray(factor)) {
      mat4.scale(this, this, factor);
    } else {
      mat4.scale(this, this, [factor, factor, factor]);
    }

    return this.check();
  }

  translate(vec) {
    mat4.translate(this, this, vec);
    return this.check();
  }

  transform(vector, result) {
    if (vector.length === 4) {
      result = vec4.transformMat4(result || [-0, -0, -0, -0], vector, this);
      (0, _validators.checkVector)(result, 4);
      return result;
    }

    return this.transformAsPoint(vector, result);
  }

  transformAsPoint(vector, result) {
    const {
      length
    } = vector;

    switch (length) {
      case 2:
        result = vec2.transformMat4(result || [-0, -0], vector, this);
        break;

      case 3:
        result = vec3.transformMat4(result || [-0, -0, -0], vector, this);
        break;

      default:
        throw new Error('Illegal vector');
    }

    (0, _validators.checkVector)(result, vector.length);
    return result;
  }

  transformAsVector(vector, result) {
    switch (vector.length) {
      case 2:
        result = (0, _glMatrixExtras.vec2_transformMat4AsVector)(result || [-0, -0], vector, this);
        break;

      case 3:
        result = (0, _glMatrixExtras.vec3_transformMat4AsVector)(result || [-0, -0, -0], vector, this);
        break;

      default:
        throw new Error('Illegal vector');
    }

    (0, _validators.checkVector)(result, vector.length);
    return result;
  }

  makeRotationX(radians) {
    return this.identity().rotateX(radians);
  }

  makeTranslation(x, y, z) {
    return this.identity().translate([x, y, z]);
  }

  transformPoint(vector, result) {
    (0, _validators.deprecated)('Matrix4.transformPoint', '3.0');
    return this.transformAsPoint(vector, result);
  }

  transformVector(vector, result) {
    (0, _validators.deprecated)('Matrix4.transformVector', '3.0');
    return this.transformAsPoint(vector, result);
  }

  transformDirection(vector, result) {
    (0, _validators.deprecated)('Matrix4.transformDirection', '3.0');
    return this.transformAsVector(vector, result);
  }

}

exports.default = Matrix4;
},{"../lib/validators":"node_modules/@math.gl/core/dist/esm/lib/validators.js","./base/matrix":"node_modules/@math.gl/core/dist/esm/classes/base/matrix.js","../lib/gl-matrix-extras":"node_modules/@math.gl/core/dist/esm/lib/gl-matrix-extras.js","gl-matrix/mat4":"node_modules/@math.gl/core/node_modules/gl-matrix/esm/mat4.js","gl-matrix/vec2":"node_modules/@math.gl/core/node_modules/gl-matrix/esm/vec2.js","gl-matrix/vec3":"node_modules/@math.gl/core/node_modules/gl-matrix/esm/vec3.js","gl-matrix/vec4":"node_modules/@math.gl/core/node_modules/gl-matrix/esm/vec4.js"}],"node_modules/@math.gl/core/node_modules/gl-matrix/esm/quat.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add = void 0;
exports.calculateW = calculateW;
exports.clone = void 0;
exports.conjugate = conjugate;
exports.copy = void 0;
exports.create = create;
exports.exactEquals = exports.equals = exports.dot = void 0;
exports.exp = exp;
exports.fromEuler = fromEuler;
exports.fromMat3 = fromMat3;
exports.fromValues = void 0;
exports.getAngle = getAngle;
exports.getAxisAngle = getAxisAngle;
exports.identity = identity;
exports.invert = invert;
exports.lerp = exports.length = exports.len = void 0;
exports.ln = ln;
exports.mul = void 0;
exports.multiply = multiply;
exports.normalize = void 0;
exports.pow = pow;
exports.random = random;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.setAxes = exports.set = exports.scale = exports.rotationTo = void 0;
exports.setAxisAngle = setAxisAngle;
exports.slerp = slerp;
exports.squaredLength = exports.sqrLen = exports.sqlerp = void 0;
exports.str = str;

var glMatrix = _interopRequireWildcard(require("./common.js"));

var mat3 = _interopRequireWildcard(require("./mat3.js"));

var vec3 = _interopRequireWildcard(require("./vec3.js"));

var vec4 = _interopRequireWildcard(require("./vec4.js"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Quaternion
 * @module quat
 */

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(4);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  out[3] = 1;
  return out;
}
/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */


function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyVec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/


function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
/**
 * Gets the rotation axis and angle for a given
 *  quaternion. If a quaternion is created with
 *  setAxisAngle, this method will return the same
 *  values as providied in the original parameter list
 *  OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *  angle -90 is the same as the quaternion formed by
 *  [0, 0, 1] and 270. This method favors the latter.
 * @param  {vec3} out_axis  Vector receiving the axis of rotation
 * @param  {ReadonlyQuat} q     Quaternion to be decomposed
 * @return {Number}     Angle, in radians, of the rotation
 */


function getAxisAngle(out_axis, q) {
  var rad = Math.acos(q[3]) * 2.0;
  var s = Math.sin(rad / 2.0);

  if (s > glMatrix.EPSILON) {
    out_axis[0] = q[0] / s;
    out_axis[1] = q[1] / s;
    out_axis[2] = q[2] / s;
  } else {
    // If s is zero, return any axis (no rotation - axis does not matter)
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }

  return rad;
}
/**
 * Gets the angular distance between two unit quaternions
 *
 * @param  {ReadonlyQuat} a     Origin unit quaternion
 * @param  {ReadonlyQuat} b     Destination unit quaternion
 * @return {Number}     Angle, in radians, between the two quaternions
 */


function getAngle(a, b) {
  var dotproduct = dot(a, b);
  return Math.acos(2 * dotproduct * dotproduct - 1);
}
/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @returns {quat} out
 */


function multiply(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {ReadonlyQuat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */


function rotateX(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {ReadonlyQuat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */


function rotateY(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var by = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {ReadonlyQuat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */


function rotateZ(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bz = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}
/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate W component of
 * @returns {quat} out
 */


function calculateW(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
  return out;
}
/**
 * Calculate the exponential of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate the exponential of
 * @returns {quat} out
 */


function exp(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var et = Math.exp(w);
  var s = r > 0 ? et * Math.sin(r) / r : 0;
  out[0] = x * s;
  out[1] = y * s;
  out[2] = z * s;
  out[3] = et * Math.cos(r);
  return out;
}
/**
 * Calculate the natural logarithm of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate the exponential of
 * @returns {quat} out
 */


function ln(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var t = r > 0 ? Math.atan2(r, w) / r : 0;
  out[0] = x * t;
  out[1] = y * t;
  out[2] = z * t;
  out[3] = 0.5 * Math.log(x * x + y * y + z * z + w * w);
  return out;
}
/**
 * Calculate the scalar power of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate the exponential of
 * @param {Number} b amount to scale the quaternion by
 * @returns {quat} out
 */


function pow(out, a, b) {
  ln(out, a);
  scale(out, out, b);
  exp(out, out);
  return out;
}
/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */


function slerp(out, a, b, t) {
  // benchmarks:
  //    http://jsperf.com/quaternion-slerp-implementations
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];
  var omega, cosom, sinom, scale0, scale1; // calc cosine

  cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)

  if (cosom < 0.0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  } // calculate coefficients


  if (1.0 - cosom > glMatrix.EPSILON) {
    // standard case (slerp)
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1.0 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    // "from" and "to" quaternions are very close
    //  ... so we can do a linear interpolation
    scale0 = 1.0 - t;
    scale1 = t;
  } // calculate final values


  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
/**
 * Generates a random unit quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */


function random(out) {
  // Implementation of http://planning.cs.uiuc.edu/node198.html
  // TODO: Calling random 3 times is probably not the fastest solution
  var u1 = glMatrix.RANDOM();
  var u2 = glMatrix.RANDOM();
  var u3 = glMatrix.RANDOM();
  var sqrt1MinusU1 = Math.sqrt(1 - u1);
  var sqrtU1 = Math.sqrt(u1);
  out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);
  out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);
  out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);
  out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);
  return out;
}
/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate inverse of
 * @returns {quat} out
 */


function invert(out, a) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
  var invDot = dot ? 1.0 / dot : 0; // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a2 * invDot;
  out[3] = a3 * invDot;
  return out;
}
/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate conjugate of
 * @returns {quat} out
 */


function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyMat3} m rotation matrix
 * @returns {quat} out
 * @function
 */


function fromMat3(out, m) {
  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
  // article "Quaternion Calculus and Fast Animation".
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;

  if (fTrace > 0.0) {
    // |w| > 1/2, may as well choose w > 1/2
    fRoot = Math.sqrt(fTrace + 1.0); // 2w

    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot; // 1/(4w)

    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    // |w| <= 1/2
    var i = 0;
    if (m[4] > m[0]) i = 1;
    if (m[8] > m[i * 3 + i]) i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }

  return out;
}
/**
 * Creates a quaternion from the given euler angle x, y, z.
 *
 * @param {quat} out the receiving quaternion
 * @param {x} Angle to rotate around X axis in degrees.
 * @param {y} Angle to rotate around Y axis in degrees.
 * @param {z} Angle to rotate around Z axis in degrees.
 * @returns {quat} out
 * @function
 */


function fromEuler(out, x, y, z) {
  var halfToRad = 0.5 * Math.PI / 180.0;
  x *= halfToRad;
  y *= halfToRad;
  z *= halfToRad;
  var sx = Math.sin(x);
  var cx = Math.cos(x);
  var sy = Math.sin(y);
  var cy = Math.cos(y);
  var sz = Math.sin(z);
  var cz = Math.cos(z);
  out[0] = sx * cy * cz - cx * sy * sz;
  out[1] = cx * sy * cz + sx * cy * sz;
  out[2] = cx * cy * sz - sx * sy * cz;
  out[3] = cx * cy * cz + sx * sy * sz;
  return out;
}
/**
 * Returns a string representation of a quatenion
 *
 * @param {ReadonlyQuat} a vector to represent as a string
 * @returns {String} string representation of the vector
 */


function str(a) {
  return "quat(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {ReadonlyQuat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */


var clone = vec4.clone;
/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */

exports.clone = clone;
var fromValues = vec4.fromValues;
/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the source quaternion
 * @returns {quat} out
 * @function
 */

exports.fromValues = fromValues;
var copy = vec4.copy;
/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */

exports.copy = copy;
var set = vec4.set;
/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @returns {quat} out
 * @function
 */

exports.set = set;
var add = vec4.add;
/**
 * Alias for {@link quat.multiply}
 * @function
 */

exports.add = add;
var mul = multiply;
/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {ReadonlyQuat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */

exports.mul = mul;
var scale = vec4.scale;
/**
 * Calculates the dot product of two quat's
 *
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */

exports.scale = scale;
var dot = vec4.dot;
/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 * @function
 */

exports.dot = dot;
var lerp = vec4.lerp;
/**
 * Calculates the length of a quat
 *
 * @param {ReadonlyQuat} a vector to calculate length of
 * @returns {Number} length of a
 */

exports.lerp = lerp;
var length = vec4.length;
/**
 * Alias for {@link quat.length}
 * @function
 */

exports.length = length;
var len = length;
/**
 * Calculates the squared length of a quat
 *
 * @param {ReadonlyQuat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */

exports.len = len;
var squaredLength = vec4.squaredLength;
/**
 * Alias for {@link quat.squaredLength}
 * @function
 */

exports.squaredLength = squaredLength;
var sqrLen = squaredLength;
/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */

exports.sqrLen = sqrLen;
var normalize = vec4.normalize;
/**
 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyQuat} a The first quaternion.
 * @param {ReadonlyQuat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

exports.normalize = normalize;
var exactEquals = vec4.exactEquals;
/**
 * Returns whether or not the quaternions have approximately the same elements in the same position.
 *
 * @param {ReadonlyQuat} a The first vector.
 * @param {ReadonlyQuat} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

exports.exactEquals = exactEquals;
var equals = vec4.equals;
/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {ReadonlyVec3} a the initial vector
 * @param {ReadonlyVec3} b the destination vector
 * @returns {quat} out
 */

exports.equals = equals;

var rotationTo = function () {
  var tmpvec3 = vec3.create();
  var xUnitVec3 = vec3.fromValues(1, 0, 0);
  var yUnitVec3 = vec3.fromValues(0, 1, 0);
  return function (out, a, b) {
    var dot = vec3.dot(a, b);

    if (dot < -0.999999) {
      vec3.cross(tmpvec3, xUnitVec3, a);
      if (vec3.len(tmpvec3) < 0.000001) vec3.cross(tmpvec3, yUnitVec3, a);
      vec3.normalize(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      vec3.cross(tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot;
      return normalize(out, out);
    }
  };
}();
/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {ReadonlyQuat} c the third operand
 * @param {ReadonlyQuat} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */


exports.rotationTo = rotationTo;

var sqlerp = function () {
  var temp1 = create();
  var temp2 = create();
  return function (out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
}();
/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {ReadonlyVec3} view  the vector representing the viewing direction
 * @param {ReadonlyVec3} right the vector representing the local "right" direction
 * @param {ReadonlyVec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */


exports.sqlerp = sqlerp;

var setAxes = function () {
  var matr = mat3.create();
  return function (out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize(out, fromMat3(out, matr));
  };
}();

exports.setAxes = setAxes;
},{"./common.js":"node_modules/@math.gl/core/node_modules/gl-matrix/esm/common.js","./mat3.js":"node_modules/@math.gl/core/node_modules/gl-matrix/esm/mat3.js","./vec3.js":"node_modules/@math.gl/core/node_modules/gl-matrix/esm/vec3.js","./vec4.js":"node_modules/@math.gl/core/node_modules/gl-matrix/esm/vec4.js"}],"node_modules/@math.gl/core/dist/esm/classes/quaternion.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _mathArray = _interopRequireDefault(require("./base/math-array"));

var _validators = require("../lib/validators");

var _assert = _interopRequireDefault(require("../lib/assert"));

var quat = _interopRequireWildcard(require("gl-matrix/quat"));

var vec4 = _interopRequireWildcard(require("gl-matrix/vec4"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const IDENTITY_QUATERNION = [0, 0, 0, 1];

class Quaternion extends _mathArray.default {
  constructor(x = 0, y = 0, z = 0, w = 1) {
    super(-0, -0, -0, -0);

    if (Array.isArray(x) && arguments.length === 1) {
      this.copy(x);
    } else {
      this.set(x, y, z, w);
    }
  }

  copy(array) {
    this[0] = array[0];
    this[1] = array[1];
    this[2] = array[2];
    this[3] = array[3];
    return this.check();
  }

  set(x, y, z, w) {
    this[0] = x;
    this[1] = y;
    this[2] = z;
    this[3] = w;
    return this.check();
  }

  fromMatrix3(m) {
    quat.fromMat3(this, m);
    return this.check();
  }

  identity() {
    quat.identity(this);
    return this.check();
  }

  fromAxisRotation(axis, rad) {
    quat.setAxisAngle(this, axis, rad);
    return this.check();
  }

  setAxisAngle(axis, rad) {
    return this.fromAxisRotation(axis, rad);
  }

  get ELEMENTS() {
    return 4;
  }

  get x() {
    return this[0];
  }

  set x(value) {
    this[0] = (0, _validators.checkNumber)(value);
  }

  get y() {
    return this[1];
  }

  set y(value) {
    this[1] = (0, _validators.checkNumber)(value);
  }

  get z() {
    return this[2];
  }

  set z(value) {
    this[2] = (0, _validators.checkNumber)(value);
  }

  get w() {
    return this[3];
  }

  set w(value) {
    this[3] = (0, _validators.checkNumber)(value);
  }

  len() {
    return quat.length(this);
  }

  lengthSquared() {
    return quat.squaredLength(this);
  }

  dot(a, b) {
    if (b !== undefined) {
      throw new Error('Quaternion.dot only takes one argument');
    }

    return quat.dot(this, a);
  }

  rotationTo(vectorA, vectorB) {
    quat.rotationTo(this, vectorA, vectorB);
    return this.check();
  }

  add(a, b) {
    if (b !== undefined) {
      throw new Error('Quaternion.add only takes one argument');
    }

    quat.add(this, this, a);
    return this.check();
  }

  calculateW() {
    quat.calculateW(this, this);
    return this.check();
  }

  conjugate() {
    quat.conjugate(this, this);
    return this.check();
  }

  invert() {
    quat.invert(this, this);
    return this.check();
  }

  lerp(a, b, t) {
    quat.lerp(this, a, b, t);
    return this.check();
  }

  multiplyRight(a, b) {
    (0, _assert.default)(!b);
    quat.multiply(this, this, a);
    return this.check();
  }

  multiplyLeft(a, b) {
    (0, _assert.default)(!b);
    quat.multiply(this, a, this);
    return this.check();
  }

  normalize() {
    const length = this.len();
    const l = length > 0 ? 1 / length : 0;
    this[0] = this[0] * l;
    this[1] = this[1] * l;
    this[2] = this[2] * l;
    this[3] = this[3] * l;

    if (length === 0) {
      this[3] = 1;
    }

    return this.check();
  }

  rotateX(rad) {
    quat.rotateX(this, this, rad);
    return this.check();
  }

  rotateY(rad) {
    quat.rotateY(this, this, rad);
    return this.check();
  }

  rotateZ(rad) {
    quat.rotateZ(this, this, rad);
    return this.check();
  }

  scale(b) {
    quat.scale(this, this, b);
    return this.check();
  }

  slerp(start, target, ratio) {
    switch (arguments.length) {
      case 1:
        ({
          start = IDENTITY_QUATERNION,
          target,
          ratio
        } = arguments[0]);
        break;

      case 2:
        [target, ratio] = arguments;
        start = this;
        break;

      default:
    }

    quat.slerp(this, start, target, ratio);
    return this.check();
  }

  transformVector4(vector, result = vector) {
    vec4.transformQuat(result, vector, this);
    return (0, _validators.checkVector)(result, 4);
  }

  lengthSq() {
    return this.lengthSquared();
  }

  setFromAxisAngle(axis, rad) {
    return this.setAxisAngle(axis, rad);
  }

  premultiply(a, b) {
    return this.multiplyLeft(a, b);
  }

  multiply(a, b) {
    return this.multiplyRight(a, b);
  }

}

exports.default = Quaternion;
},{"./base/math-array":"node_modules/@math.gl/core/dist/esm/classes/base/math-array.js","../lib/validators":"node_modules/@math.gl/core/dist/esm/lib/validators.js","../lib/assert":"node_modules/@math.gl/core/dist/esm/lib/assert.js","gl-matrix/quat":"node_modules/@math.gl/core/node_modules/gl-matrix/esm/quat.js","gl-matrix/vec4":"node_modules/@math.gl/core/node_modules/gl-matrix/esm/vec4.js"}],"node_modules/@math.gl/core/dist/esm/lib/math-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = {
  EPSILON1: 1e-1,
  EPSILON2: 1e-2,
  EPSILON3: 1e-3,
  EPSILON4: 1e-4,
  EPSILON5: 1e-5,
  EPSILON6: 1e-6,
  EPSILON7: 1e-7,
  EPSILON8: 1e-8,
  EPSILON9: 1e-9,
  EPSILON10: 1e-10,
  EPSILON11: 1e-11,
  EPSILON12: 1e-12,
  EPSILON13: 1e-13,
  EPSILON14: 1e-14,
  EPSILON15: 1e-15,
  EPSILON16: 1e-16,
  EPSILON17: 1e-17,
  EPSILON18: 1e-18,
  EPSILON19: 1e-19,
  EPSILON20: 1e-20,
  PI_OVER_TWO: Math.PI / 2,
  PI_OVER_FOUR: Math.PI / 4,
  PI_OVER_SIX: Math.PI / 6,
  TWO_PI: Math.PI * 2
};
exports.default = _default;
},{}],"node_modules/@math.gl/core/dist/esm/classes/spherical-coordinates.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _common = require("../lib/common");

var _vector = _interopRequireDefault(require("./vector3"));

var vec3 = _interopRequireWildcard(require("gl-matrix/vec3"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const EPSILON = 0.000001;
const EARTH_RADIUS_METERS = 6.371e6;

class SphericalCoordinates {
  constructor({
    phi = 0,
    theta = 0,
    radius = 1,
    bearing = undefined,
    pitch = undefined,
    altitude = undefined,
    radiusScale = EARTH_RADIUS_METERS
  } = {}) {
    this.phi = phi;
    this.theta = theta;
    this.radius = radius || altitude || 1;
    this.radiusScale = radiusScale || 1;

    if (bearing !== undefined) {
      this.bearing = bearing;
    }

    if (pitch !== undefined) {
      this.pitch = pitch;
    }

    this.check();
  }

  toString() {
    return this.formatString(_common.config);
  }

  formatString({
    printTypes = false
  }) {
    const f = _common.formatValue;
    return "".concat(printTypes ? 'Spherical' : '', "[rho:").concat(f(this.radius), ",theta:").concat(f(this.theta), ",phi:").concat(f(this.phi), "]");
  }

  equals(other) {
    return (0, _common.equals)(this.radius, other.radius) && (0, _common.equals)(this.theta, other.theta) && (0, _common.equals)(this.phi, other.phi);
  }

  exactEquals(other) {
    return this.radius === other.radius && this.theta === other.theta && this.phi === other.phi;
  }

  get bearing() {
    return 180 - (0, _common.degrees)(this.phi);
  }

  set bearing(v) {
    this.phi = Math.PI - (0, _common.radians)(v);
  }

  get pitch() {
    return (0, _common.degrees)(this.theta);
  }

  set pitch(v) {
    this.theta = (0, _common.radians)(v);
  }

  get longitude() {
    return (0, _common.degrees)(this.phi);
  }

  get latitude() {
    return (0, _common.degrees)(this.theta);
  }

  get lng() {
    return (0, _common.degrees)(this.phi);
  }

  get lat() {
    return (0, _common.degrees)(this.theta);
  }

  get z() {
    return (this.radius - 1) * this.radiusScale;
  }

  set(radius, phi, theta) {
    this.radius = radius;
    this.phi = phi;
    this.theta = theta;
    return this.check();
  }

  clone() {
    return new SphericalCoordinates().copy(this);
  }

  copy(other) {
    this.radius = other.radius;
    this.phi = other.phi;
    this.theta = other.theta;
    return this.check();
  }

  fromLngLatZ([lng, lat, z]) {
    this.radius = 1 + z / this.radiusScale;
    this.phi = (0, _common.radians)(lat);
    this.theta = (0, _common.radians)(lng);
  }

  fromVector3(v) {
    this.radius = vec3.length(v);

    if (this.radius > 0) {
      this.theta = Math.atan2(v[0], v[1]);
      this.phi = Math.acos((0, _common.clamp)(v[2] / this.radius, -1, 1));
    }

    return this.check();
  }

  toVector3() {
    return new _vector.default(0, 0, this.radius).rotateX({
      radians: this.theta
    }).rotateZ({
      radians: this.phi
    });
  }

  makeSafe() {
    this.phi = Math.max(EPSILON, Math.min(Math.PI - EPSILON, this.phi));
    return this;
  }

  check() {
    if (!Number.isFinite(this.phi) || !Number.isFinite(this.theta) || !(this.radius > 0)) {
      throw new Error('SphericalCoordinates: some fields set to invalid numbers');
    }

    return this;
  }

}

exports.default = SphericalCoordinates;
},{"../lib/common":"node_modules/@math.gl/core/dist/esm/lib/common.js","./vector3":"node_modules/@math.gl/core/dist/esm/classes/vector3.js","gl-matrix/vec3":"node_modules/@math.gl/core/node_modules/gl-matrix/esm/vec3.js"}],"node_modules/@math.gl/core/dist/esm/classes/euler.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _mathArray = _interopRequireDefault(require("./base/math-array"));

var _common = require("../lib/common");

var _validators = require("../lib/validators");

var _quaternion = _interopRequireDefault(require("./quaternion"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const ERR_UNKNOWN_ORDER = 'Unknown Euler angle order';
const ALMOST_ONE = 0.99999;

function validateOrder(value) {
  return value >= 0 && value < 6;
}

function checkOrder(value) {
  if (value < 0 && value >= 6) {
    throw new Error(ERR_UNKNOWN_ORDER);
  }

  return value;
}

class Euler extends _mathArray.default {
  static get ZYX() {
    return 0;
  }

  static get YXZ() {
    return 1;
  }

  static get XZY() {
    return 2;
  }

  static get ZXY() {
    return 3;
  }

  static get YZX() {
    return 4;
  }

  static get XYZ() {
    return 5;
  }

  static get RollPitchYaw() {
    return 0;
  }

  static get DefaultOrder() {
    return Euler.ZYX;
  }

  static get RotationOrders() {
    return ['ZYX', 'YXZ', 'XZY', 'ZXY', 'YZX', 'XYZ'];
  }

  static rotationOrder(order) {
    return Euler.RotationOrders[order];
  }

  get ELEMENTS() {
    return 4;
  }

  constructor(x = 0, y = 0, z = 0, order = Euler.DefaultOrder) {
    super(-0, -0, -0, -0);

    if (arguments.length > 0 && Array.isArray(arguments[0])) {
      this.fromVector3(...arguments);
    } else {
      this.set(x, y, z, order);
    }
  }

  fromQuaternion(quaternion) {
    const [x, y, z, w] = quaternion;
    const ysqr = y * y;
    const t0 = -2.0 * (ysqr + z * z) + 1.0;
    const t1 = +2.0 * (x * y + w * z);
    let t2 = -2.0 * (x * z - w * y);
    const t3 = +2.0 * (y * z + w * x);
    const t4 = -2.0 * (x * x + ysqr) + 1.0;
    t2 = t2 > 1.0 ? 1.0 : t2;
    t2 = t2 < -1.0 ? -1.0 : t2;
    const roll = Math.atan2(t3, t4);
    const pitch = Math.asin(t2);
    const yaw = Math.atan2(t1, t0);
    return new Euler(roll, pitch, yaw, Euler.RollPitchYaw);
  }

  copy(array) {
    this[0] = array[0];
    this[1] = array[1];
    this[2] = array[2];
    this[3] = Number.isFinite(array[3]) || this.order;
    return this.check();
  }

  set(x = 0, y = 0, z = 0, order) {
    this[0] = x;
    this[1] = y;
    this[2] = z;
    this[3] = Number.isFinite(order) ? order : this[3];
    return this.check();
  }

  validate() {
    return validateOrder(this[3]) && Number.isFinite(this[0]) && Number.isFinite(this[1]) && Number.isFinite(this[2]);
  }

  toArray(array = [], offset = 0) {
    array[offset] = this[0];
    array[offset + 1] = this[1];
    array[offset + 2] = this[2];
    return array;
  }

  toArray4(array = [], offset = 0) {
    array[offset] = this[0];
    array[offset + 1] = this[1];
    array[offset + 2] = this[2];
    array[offset + 3] = this[3];
    return array;
  }

  toVector3(result = [-0, -0, -0]) {
    result[0] = this[0];
    result[1] = this[1];
    result[2] = this[2];
    return result;
  }

  get x() {
    return this[0];
  }

  set x(value) {
    this[0] = (0, _validators.checkNumber)(value);
  }

  get y() {
    return this[1];
  }

  set y(value) {
    this[1] = (0, _validators.checkNumber)(value);
  }

  get z() {
    return this[2];
  }

  set z(value) {
    this[2] = (0, _validators.checkNumber)(value);
  }

  get alpha() {
    return this[0];
  }

  set alpha(value) {
    this[0] = (0, _validators.checkNumber)(value);
  }

  get beta() {
    return this[1];
  }

  set beta(value) {
    this[1] = (0, _validators.checkNumber)(value);
  }

  get gamma() {
    return this[2];
  }

  set gamma(value) {
    this[2] = (0, _validators.checkNumber)(value);
  }

  get phi() {
    return this[0];
  }

  set phi(value) {
    this[0] = (0, _validators.checkNumber)(value);
  }

  get theta() {
    return this[1];
  }

  set theta(value) {
    this[1] = (0, _validators.checkNumber)(value);
  }

  get psi() {
    return this[2];
  }

  set psi(value) {
    this[2] = (0, _validators.checkNumber)(value);
  }

  get roll() {
    return this[0];
  }

  set roll(value) {
    this[0] = (0, _validators.checkNumber)(value);
  }

  get pitch() {
    return this[1];
  }

  set pitch(value) {
    this[1] = (0, _validators.checkNumber)(value);
  }

  get yaw() {
    return this[2];
  }

  set yaw(value) {
    this[2] = (0, _validators.checkNumber)(value);
  }

  get order() {
    return this[3];
  }

  set order(value) {
    this[3] = checkOrder(value);
  }

  fromVector3(v, order) {
    return this.set(v[0], v[1], v[2], Number.isFinite(order) ? order : this[3]);
  }

  fromArray(array, offset = 0) {
    this[0] = array[0 + offset];
    this[1] = array[1 + offset];
    this[2] = array[2 + offset];

    if (array[3] !== undefined) {
      this[3] = array[3];
    }

    return this.check();
  }

  fromRollPitchYaw(roll, pitch, yaw) {
    return this.set(roll, pitch, yaw, Euler.ZYX);
  }

  fromRotationMatrix(m, order = Euler.DefaultOrder) {
    this._fromRotationMatrix(m, order);

    return this.check();
  }

  getRotationMatrix(m) {
    return this._getRotationMatrix(m);
  }

  getQuaternion() {
    const q = new _quaternion.default();

    switch (this[3]) {
      case Euler.XYZ:
        return q.rotateX(this[0]).rotateY(this[1]).rotateZ(this[2]);

      case Euler.YXZ:
        return q.rotateY(this[0]).rotateX(this[1]).rotateZ(this[2]);

      case Euler.ZXY:
        return q.rotateZ(this[0]).rotateX(this[1]).rotateY(this[2]);

      case Euler.ZYX:
        return q.rotateZ(this[0]).rotateY(this[1]).rotateX(this[2]);

      case Euler.YZX:
        return q.rotateY(this[0]).rotateZ(this[1]).rotateX(this[2]);

      case Euler.XZY:
        return q.rotateX(this[0]).rotateZ(this[1]).rotateY(this[2]);

      default:
        throw new Error(ERR_UNKNOWN_ORDER);
    }
  }

  _fromRotationMatrix(m, order = Euler.DefaultOrder) {
    const te = m.elements;
    const m11 = te[0],
          m12 = te[4],
          m13 = te[8];
    const m21 = te[1],
          m22 = te[5],
          m23 = te[9];
    const m31 = te[2],
          m32 = te[6],
          m33 = te[10];
    order = order || this[3];

    switch (order) {
      case Euler.XYZ:
        this[1] = Math.asin((0, _common.clamp)(m13, -1, 1));

        if (Math.abs(m13) < ALMOST_ONE) {
          this[0] = Math.atan2(-m23, m33);
          this[2] = Math.atan2(-m12, m11);
        } else {
          this[0] = Math.atan2(m32, m22);
          this[2] = 0;
        }

        break;

      case Euler.YXZ:
        this[0] = Math.asin(-(0, _common.clamp)(m23, -1, 1));

        if (Math.abs(m23) < ALMOST_ONE) {
          this[1] = Math.atan2(m13, m33);
          this[2] = Math.atan2(m21, m22);
        } else {
          this[1] = Math.atan2(-m31, m11);
          this[2] = 0;
        }

        break;

      case Euler.ZXY:
        this[0] = Math.asin((0, _common.clamp)(m32, -1, 1));

        if (Math.abs(m32) < ALMOST_ONE) {
          this[1] = Math.atan2(-m31, m33);
          this[2] = Math.atan2(-m12, m22);
        } else {
          this[1] = 0;
          this[2] = Math.atan2(m21, m11);
        }

        break;

      case Euler.ZYX:
        this[1] = Math.asin(-(0, _common.clamp)(m31, -1, 1));

        if (Math.abs(m31) < ALMOST_ONE) {
          this[0] = Math.atan2(m32, m33);
          this[2] = Math.atan2(m21, m11);
        } else {
          this[0] = 0;
          this[2] = Math.atan2(-m12, m22);
        }

        break;

      case Euler.YZX:
        this[2] = Math.asin((0, _common.clamp)(m21, -1, 1));

        if (Math.abs(m21) < ALMOST_ONE) {
          this[0] = Math.atan2(-m23, m22);
          this[1] = Math.atan2(-m31, m11);
        } else {
          this[0] = 0;
          this[1] = Math.atan2(m13, m33);
        }

        break;

      case Euler.XZY:
        this[2] = Math.asin(-(0, _common.clamp)(m12, -1, 1));

        if (Math.abs(m12) < ALMOST_ONE) {
          this[0] = Math.atan2(m32, m22);
          this[1] = Math.atan2(m13, m11);
        } else {
          this[0] = Math.atan2(-m23, m33);
          this[1] = 0;
        }

        break;

      default:
        throw new Error(ERR_UNKNOWN_ORDER);
    }

    this[3] = order;
    return this;
  }

  _getRotationMatrix(result) {
    const te = result || [-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0];
    const x = this.x,
          y = this.y,
          z = this.z;
    const a = Math.cos(x);
    const c = Math.cos(y);
    const e = Math.cos(z);
    const b = Math.sin(x);
    const d = Math.sin(y);
    const f = Math.sin(z);

    switch (this[3]) {
      case Euler.XYZ:
        {
          const ae = a * e,
                af = a * f,
                be = b * e,
                bf = b * f;
          te[0] = c * e;
          te[4] = -c * f;
          te[8] = d;
          te[1] = af + be * d;
          te[5] = ae - bf * d;
          te[9] = -b * c;
          te[2] = bf - ae * d;
          te[6] = be + af * d;
          te[10] = a * c;
          break;
        }

      case Euler.YXZ:
        {
          const ce = c * e,
                cf = c * f,
                de = d * e,
                df = d * f;
          te[0] = ce + df * b;
          te[4] = de * b - cf;
          te[8] = a * d;
          te[1] = a * f;
          te[5] = a * e;
          te[9] = -b;
          te[2] = cf * b - de;
          te[6] = df + ce * b;
          te[10] = a * c;
          break;
        }

      case Euler.ZXY:
        {
          const ce = c * e,
                cf = c * f,
                de = d * e,
                df = d * f;
          te[0] = ce - df * b;
          te[4] = -a * f;
          te[8] = de + cf * b;
          te[1] = cf + de * b;
          te[5] = a * e;
          te[9] = df - ce * b;
          te[2] = -a * d;
          te[6] = b;
          te[10] = a * c;
          break;
        }

      case Euler.ZYX:
        {
          const ae = a * e,
                af = a * f,
                be = b * e,
                bf = b * f;
          te[0] = c * e;
          te[4] = be * d - af;
          te[8] = ae * d + bf;
          te[1] = c * f;
          te[5] = bf * d + ae;
          te[9] = af * d - be;
          te[2] = -d;
          te[6] = b * c;
          te[10] = a * c;
          break;
        }

      case Euler.YZX:
        {
          const ac = a * c,
                ad = a * d,
                bc = b * c,
                bd = b * d;
          te[0] = c * e;
          te[4] = bd - ac * f;
          te[8] = bc * f + ad;
          te[1] = f;
          te[5] = a * e;
          te[9] = -b * e;
          te[2] = -d * e;
          te[6] = ad * f + bc;
          te[10] = ac - bd * f;
          break;
        }

      case Euler.XZY:
        {
          const ac = a * c,
                ad = a * d,
                bc = b * c,
                bd = b * d;
          te[0] = c * e;
          te[4] = -f;
          te[8] = d * e;
          te[1] = ac * f + bd;
          te[5] = a * e;
          te[9] = ad * f - bc;
          te[2] = bc * f - ad;
          te[6] = b * e;
          te[10] = bd * f + ac;
          break;
        }

      default:
        throw new Error(ERR_UNKNOWN_ORDER);
    }

    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return te;
  }

  toQuaternion() {
    const cy = Math.cos(this.yaw * 0.5);
    const sy = Math.sin(this.yaw * 0.5);
    const cr = Math.cos(this.roll * 0.5);
    const sr = Math.sin(this.roll * 0.5);
    const cp = Math.cos(this.pitch * 0.5);
    const sp = Math.sin(this.pitch * 0.5);
    const w = cy * cr * cp + sy * sr * sp;
    const x = cy * sr * cp - sy * cr * sp;
    const y = cy * cr * sp + sy * sr * cp;
    const z = sy * cr * cp - cy * sr * sp;
    return new _quaternion.default(x, y, z, w);
  }

}

exports.default = Euler;
},{"./base/math-array":"node_modules/@math.gl/core/dist/esm/classes/base/math-array.js","../lib/common":"node_modules/@math.gl/core/dist/esm/lib/common.js","../lib/validators":"node_modules/@math.gl/core/dist/esm/lib/validators.js","./quaternion":"node_modules/@math.gl/core/dist/esm/classes/quaternion.js"}],"node_modules/@math.gl/core/dist/esm/classes/pose.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _matrix = _interopRequireDefault(require("./matrix4"));

var _vector = _interopRequireDefault(require("./vector3"));

var _euler = _interopRequireDefault(require("./euler"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class Pose {
  constructor({
    x = 0,
    y = 0,
    z = 0,
    roll = 0,
    pitch = 0,
    yaw = 0,
    position = undefined,
    orientation = undefined
  } = {}) {
    if (Array.isArray(position) && position.length === 3) {
      this.position = new _vector.default(position);
    } else {
      this.position = new _vector.default(x, y, z);
    }

    if (Array.isArray(orientation) && orientation.length === 4) {
      this.orientation = new _euler.default(orientation, orientation[3]);
    } else {
      this.orientation = new _euler.default(roll, pitch, yaw, _euler.default.RollPitchYaw);
    }
  }

  get x() {
    return this.position.x;
  }

  set x(value) {
    this.position.x = value;
  }

  get y() {
    return this.position.y;
  }

  set y(value) {
    this.position.y = value;
  }

  get z() {
    return this.position.z;
  }

  set z(value) {
    this.position.z = value;
  }

  get roll() {
    return this.orientation.roll;
  }

  set roll(value) {
    this.orientation.roll = value;
  }

  get pitch() {
    return this.orientation.pitch;
  }

  set pitch(value) {
    this.orientation.pitch = value;
  }

  get yaw() {
    return this.orientation.yaw;
  }

  set yaw(value) {
    this.orientation.yaw = value;
  }

  getPosition() {
    return this.position;
  }

  getOrientation() {
    return this.orientation;
  }

  equals(pose) {
    if (!pose) {
      return false;
    }

    return this.position.equals(pose.position) && this.orientation.equals(pose.orientation);
  }

  exactEquals(pose) {
    if (!pose) {
      return false;
    }

    return this.position.exactEquals(pose.position) && this.orientation.exactEquals(pose.orientation);
  }

  getTransformationMatrix() {
    const sr = Math.sin(this.roll);
    const sp = Math.sin(this.pitch);
    const sw = Math.sin(this.yaw);
    const cr = Math.cos(this.roll);
    const cp = Math.cos(this.pitch);
    const cw = Math.cos(this.yaw);
    const matrix = new _matrix.default().setRowMajor(cw * cp, -sw * cr + cw * sp * sr, sw * sr + cw * sp * cr, this.x, sw * cp, cw * cr + sw * sp * sr, -cw * sr + sw * sp * cr, this.y, -sp, cp * sr, cp * cr, this.z, 0, 0, 0, 1);
    return matrix;
  }

  getTransformationMatrixFromPose(pose) {
    return new _matrix.default().multiplyRight(this.getTransformationMatrix()).multiplyRight(pose.getTransformationMatrix().invert());
  }

  getTransformationMatrixToPose(pose) {
    return new _matrix.default().multiplyRight(pose.getTransformationMatrix()).multiplyRight(this.getTransformationMatrix().invert());
  }

}

exports.default = Pose;
},{"./matrix4":"node_modules/@math.gl/core/dist/esm/classes/matrix4.js","./vector3":"node_modules/@math.gl/core/dist/esm/classes/vector3.js","./euler":"node_modules/@math.gl/core/dist/esm/classes/euler.js"}],"node_modules/@math.gl/core/dist/esm/index.js":[function(require,module,exports) {
var global = arguments[3];
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Euler", {
  enumerable: true,
  get: function () {
    return _euler.default;
  }
});
Object.defineProperty(exports, "Matrix3", {
  enumerable: true,
  get: function () {
    return _matrix.default;
  }
});
Object.defineProperty(exports, "Matrix4", {
  enumerable: true,
  get: function () {
    return _matrix2.default;
  }
});
Object.defineProperty(exports, "Pose", {
  enumerable: true,
  get: function () {
    return _pose.default;
  }
});
Object.defineProperty(exports, "Quaternion", {
  enumerable: true,
  get: function () {
    return _quaternion.default;
  }
});
Object.defineProperty(exports, "SphericalCoordinates", {
  enumerable: true,
  get: function () {
    return _sphericalCoordinates.default;
  }
});
Object.defineProperty(exports, "Vector2", {
  enumerable: true,
  get: function () {
    return _vector.default;
  }
});
Object.defineProperty(exports, "Vector3", {
  enumerable: true,
  get: function () {
    return _vector2.default;
  }
});
Object.defineProperty(exports, "Vector4", {
  enumerable: true,
  get: function () {
    return _vector3.default;
  }
});
Object.defineProperty(exports, "_Euler", {
  enumerable: true,
  get: function () {
    return _euler.default;
  }
});
Object.defineProperty(exports, "_MathUtils", {
  enumerable: true,
  get: function () {
    return _mathUtils.default;
  }
});
Object.defineProperty(exports, "_Pose", {
  enumerable: true,
  get: function () {
    return _pose.default;
  }
});
Object.defineProperty(exports, "_SphericalCoordinates", {
  enumerable: true,
  get: function () {
    return _sphericalCoordinates.default;
  }
});
Object.defineProperty(exports, "acos", {
  enumerable: true,
  get: function () {
    return _common.acos;
  }
});
Object.defineProperty(exports, "asin", {
  enumerable: true,
  get: function () {
    return _common.asin;
  }
});
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function () {
    return _assert.default;
  }
});
Object.defineProperty(exports, "atan", {
  enumerable: true,
  get: function () {
    return _common.atan;
  }
});
Object.defineProperty(exports, "checkNumber", {
  enumerable: true,
  get: function () {
    return _validators.checkNumber;
  }
});
Object.defineProperty(exports, "clamp", {
  enumerable: true,
  get: function () {
    return _common.clamp;
  }
});
Object.defineProperty(exports, "clone", {
  enumerable: true,
  get: function () {
    return _common.clone;
  }
});
Object.defineProperty(exports, "config", {
  enumerable: true,
  get: function () {
    return _common.config;
  }
});
Object.defineProperty(exports, "configure", {
  enumerable: true,
  get: function () {
    return _common.configure;
  }
});
Object.defineProperty(exports, "cos", {
  enumerable: true,
  get: function () {
    return _common.cos;
  }
});
Object.defineProperty(exports, "degrees", {
  enumerable: true,
  get: function () {
    return _common.degrees;
  }
});
Object.defineProperty(exports, "equals", {
  enumerable: true,
  get: function () {
    return _common.equals;
  }
});
Object.defineProperty(exports, "exactEquals", {
  enumerable: true,
  get: function () {
    return _common.exactEquals;
  }
});
Object.defineProperty(exports, "formatValue", {
  enumerable: true,
  get: function () {
    return _common.formatValue;
  }
});
Object.defineProperty(exports, "isArray", {
  enumerable: true,
  get: function () {
    return _common.isArray;
  }
});
Object.defineProperty(exports, "lerp", {
  enumerable: true,
  get: function () {
    return _common.lerp;
  }
});
Object.defineProperty(exports, "radians", {
  enumerable: true,
  get: function () {
    return _common.radians;
  }
});
Object.defineProperty(exports, "sin", {
  enumerable: true,
  get: function () {
    return _common.sin;
  }
});
Object.defineProperty(exports, "tan", {
  enumerable: true,
  get: function () {
    return _common.tan;
  }
});
Object.defineProperty(exports, "toDegrees", {
  enumerable: true,
  get: function () {
    return _common.toDegrees;
  }
});
Object.defineProperty(exports, "toRadians", {
  enumerable: true,
  get: function () {
    return _common.toRadians;
  }
});
Object.defineProperty(exports, "withEpsilon", {
  enumerable: true,
  get: function () {
    return _common.withEpsilon;
  }
});

var _common = require("./lib/common");

var _vector = _interopRequireDefault(require("./classes/vector2"));

var _vector2 = _interopRequireDefault(require("./classes/vector3"));

var _vector3 = _interopRequireDefault(require("./classes/vector4"));

var _matrix = _interopRequireDefault(require("./classes/matrix3"));

var _matrix2 = _interopRequireDefault(require("./classes/matrix4"));

var _quaternion = _interopRequireDefault(require("./classes/quaternion"));

var _validators = require("./lib/validators");

var _mathUtils = _interopRequireDefault(require("./lib/math-utils"));

var _sphericalCoordinates = _interopRequireDefault(require("./classes/spherical-coordinates"));

var _pose = _interopRequireDefault(require("./classes/pose"));

var _euler = _interopRequireDefault(require("./classes/euler"));

var _assert = _interopRequireDefault(require("./lib/assert"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const globals = {
  self: typeof self !== 'undefined' && self,
  window: typeof window !== 'undefined' && window,
  global: typeof global !== 'undefined' && global
};
const global_ = globals.global || globals.self || globals.window;
global_.mathgl = {
  config: _common.config
};
},{"./lib/common":"node_modules/@math.gl/core/dist/esm/lib/common.js","./classes/vector2":"node_modules/@math.gl/core/dist/esm/classes/vector2.js","./classes/vector3":"node_modules/@math.gl/core/dist/esm/classes/vector3.js","./classes/vector4":"node_modules/@math.gl/core/dist/esm/classes/vector4.js","./classes/matrix3":"node_modules/@math.gl/core/dist/esm/classes/matrix3.js","./classes/matrix4":"node_modules/@math.gl/core/dist/esm/classes/matrix4.js","./classes/quaternion":"node_modules/@math.gl/core/dist/esm/classes/quaternion.js","./lib/validators":"node_modules/@math.gl/core/dist/esm/lib/validators.js","./lib/math-utils":"node_modules/@math.gl/core/dist/esm/lib/math-utils.js","./classes/spherical-coordinates":"node_modules/@math.gl/core/dist/esm/classes/spherical-coordinates.js","./classes/pose":"node_modules/@math.gl/core/dist/esm/classes/pose.js","./classes/euler":"node_modules/@math.gl/core/dist/esm/classes/euler.js","./lib/assert":"node_modules/@math.gl/core/dist/esm/lib/assert.js"}],"node_modules/@luma.gl/shadertools/dist/esm/modules/project/project.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.project = void 0;

var _core = require("@math.gl/core");

const IDENTITY_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
const DEFAULT_MODULE_OPTIONS = {
  modelMatrix: IDENTITY_MATRIX,
  viewMatrix: IDENTITY_MATRIX,
  projectionMatrix: IDENTITY_MATRIX,
  cameraPositionWorld: [0, 0, 0]
};

function getUniforms(opts = DEFAULT_MODULE_OPTIONS, prevUniforms = {}) {
  const uniforms = {};

  if (opts.modelMatrix !== undefined) {
    uniforms.modelMatrix = opts.modelMatrix;
  }

  if (opts.viewMatrix !== undefined) {
    uniforms.viewMatrix = opts.viewMatrix;
  }

  if (opts.projectionMatrix !== undefined) {
    uniforms.projectionMatrix = opts.projectionMatrix;
  }

  if (opts.cameraPositionWorld !== undefined) {
    uniforms.cameraPositionWorld = opts.cameraPositionWorld;
  }

  if (opts.projectionMatrix !== undefined || opts.viewMatrix !== undefined) {
    uniforms.viewProjectionMatrix = new _core.Matrix4(opts.projectionMatrix).multiplyRight(opts.viewMatrix);
  }

  return uniforms;
}

const common = `\
varying vec4 project_vPositionWorld;
varying vec3 project_vNormalWorld;

vec4 project_getPosition_World() {
  return project_vPositionWorld;
}

vec3 project_getNormal_World() {
  return project_vNormalWorld;
}
`;
const vs = `\
${common}
uniform mat4 modelMatrix;
uniform mat4 viewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewProjectionMatrix;
uniform vec3 cameraPositionWorld;

struct World {
  vec3 position;
  vec3 normal;
};

World world;

void project_setPosition(vec4 position) {
  project_vPositionWorld = position;
}

void project_setNormal(vec3 normal) {
  project_vNormalWorld = normal;
}

void project_setPositionAndNormal_World(vec3 position, vec3 normal) {
  world.position = position;
  world.normal = normal;
}

void project_setPositionAndNormal_Model(vec3 position, vec3 normal) {
  world.position = (modelMatrix * vec4(position, 1.)).xyz;
  world.normal = mat3(modelMatrix) * normal;
}

vec4 project_model_to_clipspace(vec4 position) {
  return viewProjectionMatrix * modelMatrix * position;
}

vec4 project_model_to_clipspace(vec3 position) {
  return viewProjectionMatrix * modelMatrix * vec4(position, 1.);
}

vec4 project_world_to_clipspace(vec3 position) {
  return viewProjectionMatrix * vec4(position, 1.);
}

vec4 project_view_to_clipspace(vec3 position) {
  return projectionMatrix * vec4(position, 1.);
}

vec4 project_to_clipspace(vec3 position) {
  return viewProjectionMatrix * vec4(position, 1.);
}
`;
const fs = `
${common}\
`;
const project = {
  name: 'project',
  getUniforms,
  vs,
  fs
};
exports.project = project;
},{"@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js"}],"node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = `\
#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))

struct AmbientLight {
 vec3 color;
};

struct PointLight {
 vec3 color;
 vec3 position;
 vec3 attenuation;
};

struct DirectionalLight {
  vec3 color;
  vec3 direction;
};

uniform AmbientLight lighting_uAmbientLight;
uniform PointLight lighting_uPointLight[MAX_LIGHTS];
uniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];
uniform int lighting_uPointLightCount;
uniform int lighting_uDirectionalLightCount;

uniform bool lighting_uEnabled;

float getPointLightAttenuation(PointLight pointLight, float distance) {
  return pointLight.attenuation.x
       + pointLight.attenuation.y * distance
       + pointLight.attenuation.z * distance * distance;
}

#endif
`;
exports.default = _default;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.lights = void 0;

var _lights = _interopRequireDefault(require("./lights.glsl"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const INITIAL_MODULE_OPTIONS = {
  lightSources: {}
};

function convertColor({
  color = [0, 0, 0],
  intensity = 1.0
} = {}) {
  return color.map(component => component * intensity / 255.0);
}

function getLightSourceUniforms({
  ambientLight,
  pointLights = [],
  directionalLights = []
}) {
  const lightSourceUniforms = {};

  if (ambientLight) {
    lightSourceUniforms['lighting_uAmbientLight.color'] = convertColor(ambientLight);
  } else {
    lightSourceUniforms['lighting_uAmbientLight.color'] = [0, 0, 0];
  }

  pointLights.forEach((pointLight, index) => {
    lightSourceUniforms[`lighting_uPointLight[${index}].color`] = convertColor(pointLight);
    lightSourceUniforms[`lighting_uPointLight[${index}].position`] = pointLight.position;
    lightSourceUniforms[`lighting_uPointLight[${index}].attenuation`] = pointLight.attenuation || [1, 0, 0];
  });
  lightSourceUniforms.lighting_uPointLightCount = pointLights.length;
  directionalLights.forEach((directionalLight, index) => {
    lightSourceUniforms[`lighting_uDirectionalLight[${index}].color`] = convertColor(directionalLight);
    lightSourceUniforms[`lighting_uDirectionalLight[${index}].direction`] = directionalLight.direction;
  });
  lightSourceUniforms.lighting_uDirectionalLightCount = directionalLights.length;
  return lightSourceUniforms;
}

function getUniforms(opts = INITIAL_MODULE_OPTIONS) {
  if ('lightSources' in opts) {
    const {
      ambientLight,
      pointLights,
      directionalLights
    } = opts.lightSources || {};
    const hasLights = ambientLight || pointLights && pointLights.length > 0 || directionalLights && directionalLights.length > 0;

    if (!hasLights) {
      return {
        lighting_uEnabled: false
      };
    }

    return Object.assign({}, getLightSourceUniforms({
      ambientLight,
      pointLights,
      directionalLights
    }), {
      lighting_uEnabled: true
    });
  }

  if ('lights' in opts) {
    const lightSources = {
      pointLights: [],
      directionalLights: []
    };

    for (const light of opts.lights || []) {
      switch (light.type) {
        case 'ambient':
          lightSources.ambientLight = light;
          break;

        case 'directional':
          lightSources.directionalLights.push(light);
          break;

        case 'point':
          lightSources.pointLights.push(light);
          break;

        default:
      }
    }

    return getUniforms({
      lightSources
    });
  }

  return {};
}

const lights = {
  name: 'lights',
  vs: _lights.default,
  fs: _lights.default,
  getUniforms,
  defines: {
    MAX_LIGHTS: 3
  }
};
exports.lights = lights;
},{"./lights.glsl":"node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.glsl.js"}],"node_modules/@luma.gl/shadertools/dist/esm/modules/dirlight/dirlight.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dirlight = void 0;

var _project = require("../project/project");

const DEFAULT_LIGHT_DIRECTION = new Float32Array([1, 1, 2]);
const DEFAULT_MODULE_OPTIONS = {
  lightDirection: DEFAULT_LIGHT_DIRECTION
};

function getUniforms(opts = DEFAULT_MODULE_OPTIONS) {
  const uniforms = {};

  if (opts.lightDirection) {
    uniforms.dirlight_uLightDirection = opts.lightDirection;
  }

  return uniforms;
}

const vs = null;
const fs = `\
uniform vec3 dirlight_uLightDirection;
vec4 dirlight_filterColor(vec4 color) {
  vec3 normal = project_getNormal_World();
  float d = abs(dot(normalize(normal), normalize(dirlight_uLightDirection)));
  return vec4(color.rgb * d, color.a);
}
`;
const dirlight = {
  name: 'dirlight',
  vs,
  fs,
  getUniforms,
  dependencies: [_project.project]
};
exports.dirlight = dirlight;
},{"../project/project":"node_modules/@luma.gl/shadertools/dist/esm/modules/project/project.js"}],"node_modules/@luma.gl/shadertools/dist/esm/modules/picking/picking.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.picking = void 0;
const DEFAULT_HIGHLIGHT_COLOR = new Uint8Array([0, 255, 255, 255]);
const DEFAULT_MODULE_OPTIONS = {
  pickingSelectedColor: null,
  pickingHighlightColor: DEFAULT_HIGHLIGHT_COLOR,
  pickingActive: false,
  pickingAttribute: false
};

function getUniforms(opts = DEFAULT_MODULE_OPTIONS) {
  const uniforms = {};

  if (opts.pickingSelectedColor !== undefined) {
    if (!opts.pickingSelectedColor) {
      uniforms.picking_uSelectedColorValid = 0;
    } else {
      const selectedColor = opts.pickingSelectedColor.slice(0, 3);
      uniforms.picking_uSelectedColorValid = 1;
      uniforms.picking_uSelectedColor = selectedColor;
    }
  }

  if (opts.pickingHighlightColor) {
    const color = Array.from(opts.pickingHighlightColor, x => x / 255);

    if (!Number.isFinite(color[3])) {
      color[3] = 1;
    }

    uniforms.picking_uHighlightColor = color;
  }

  if (opts.pickingActive !== undefined) {
    uniforms.picking_uActive = Boolean(opts.pickingActive);
    uniforms.picking_uAttribute = Boolean(opts.pickingAttribute);
  }

  return uniforms;
}

const vs = `\
uniform bool picking_uActive;
uniform bool picking_uAttribute;
uniform vec3 picking_uSelectedColor;
uniform bool picking_uSelectedColorValid;

out vec4 picking_vRGBcolor_Avalid;

const float COLOR_SCALE = 1. / 255.;

bool picking_isColorValid(vec3 color) {
  return dot(color, vec3(1.0)) > 0.001;
}

bool isVertexPicked(vec3 vertexColor) {
  return
    picking_uSelectedColorValid &&
    !picking_isColorValid(abs(vertexColor - picking_uSelectedColor));
}

void picking_setPickingColor(vec3 pickingColor) {
  if (picking_uActive) {
    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));

    if (!picking_uAttribute) {
      picking_vRGBcolor_Avalid.rgb = pickingColor * COLOR_SCALE;
    }
  } else {
    picking_vRGBcolor_Avalid.a = float(isVertexPicked(pickingColor));
  }
}

void picking_setPickingAttribute(float value) {
  if (picking_uAttribute) {
    picking_vRGBcolor_Avalid.r = value;
  }
}
void picking_setPickingAttribute(vec2 value) {
  if (picking_uAttribute) {
    picking_vRGBcolor_Avalid.rg = value;
  }
}
void picking_setPickingAttribute(vec3 value) {
  if (picking_uAttribute) {
    picking_vRGBcolor_Avalid.rgb = value;
  }
}
`;
const fs = `\
uniform bool picking_uActive;
uniform vec3 picking_uSelectedColor;
uniform vec4 picking_uHighlightColor;

in vec4 picking_vRGBcolor_Avalid;
vec4 picking_filterHighlightColor(vec4 color) {
  if (picking_uActive) {
    return color;
  }
  bool selected = bool(picking_vRGBcolor_Avalid.a);

  if (selected) {
    float highLightAlpha = picking_uHighlightColor.a;
    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);
    float highLightRatio = highLightAlpha / blendedAlpha;

    vec3 blendedRGB = mix(color.rgb, picking_uHighlightColor.rgb, highLightRatio);
    return vec4(blendedRGB, blendedAlpha);
  } else {
    return color;
  }
}
vec4 picking_filterPickingColor(vec4 color) {
  if (picking_uActive) {
    if (picking_vRGBcolor_Avalid.a == 0.0) {
      discard;
    }
    return picking_vRGBcolor_Avalid;
  }
  return color;
}
vec4 picking_filterColor(vec4 color) {
  vec4 highightColor = picking_filterHighlightColor(color);
  return picking_filterPickingColor(highightColor);
}

`;
const picking = {
  name: 'picking',
  vs,
  fs,
  getUniforms
};
exports.picking = picking;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = `\

uniform float lighting_uAmbient;
uniform float lighting_uDiffuse;
uniform float lighting_uShininess;
uniform vec3  lighting_uSpecularColor;

vec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {
    vec3 halfway_direction = normalize(light_direction + view_direction);
    float lambertian = dot(light_direction, normal_worldspace);
    float specular = 0.0;
    if (lambertian > 0.0) {
      float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);
      specular = pow(specular_angle, lighting_uShininess);
    }
    lambertian = max(lambertian, 0.0);
    return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;
}

vec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {
  vec3 lightColor = surfaceColor;

  if (lighting_uEnabled) {
    vec3 view_direction = normalize(cameraPosition - position_worldspace);
    lightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;

    for (int i = 0; i < MAX_LIGHTS; i++) {
      if (i >= lighting_uPointLightCount) {
        break;
      }
      PointLight pointLight = lighting_uPointLight[i];
      vec3 light_position_worldspace = pointLight.position;
      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
    }

    for (int i = 0; i < MAX_LIGHTS; i++) {
      if (i >= lighting_uDirectionalLightCount) {
        break;
      }
      DirectionalLight directionalLight = lighting_uDirectionalLight[i];
      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
    }
  }
  return lightColor;
}

vec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {
  vec3 lightColor = vec3(0, 0, 0);
  vec3 surfaceColor = vec3(0, 0, 0);

  if (lighting_uEnabled) {
    vec3 view_direction = normalize(cameraPosition - position_worldspace);

    for (int i = 0; i < MAX_LIGHTS; i++) {
      if (i >= lighting_uPointLightCount) {
        break;
      }
      PointLight pointLight = lighting_uPointLight[i];
      vec3 light_position_worldspace = pointLight.position;
      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
    }

    for (int i = 0; i < MAX_LIGHTS; i++) {
      if (i >= lighting_uDirectionalLightCount) {
        break;
      }
      DirectionalLight directionalLight = lighting_uDirectionalLight[i];
      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
    }
  }
  return lightColor;
}
`;
exports.default = _default;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.phongLighting = exports.gouraudLighting = void 0;

var _lights = require("../lights/lights");

var _phongLighting = _interopRequireDefault(require("./phong-lighting.glsl"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const INITIAL_MODULE_OPTIONS = {};

function getMaterialUniforms(material) {
  const {
    ambient = 0.35,
    diffuse = 0.6,
    shininess = 32,
    specularColor = [30, 30, 30]
  } = material;
  return {
    lighting_uAmbient: ambient,
    lighting_uDiffuse: diffuse,
    lighting_uShininess: shininess,
    lighting_uSpecularColor: specularColor.map(x => x / 255)
  };
}

function getUniforms(opts = INITIAL_MODULE_OPTIONS) {
  if (!('material' in opts)) {
    return {};
  }

  const {
    material
  } = opts;

  if (!material) {
    return {
      lighting_uEnabled: false
    };
  }

  return getMaterialUniforms(material);
}

const gouraudLighting = {
  name: 'gouraud-lighting',
  dependencies: [_lights.lights],
  vs: _phongLighting.default,
  defines: {
    LIGHTING_VERTEX: 1
  },
  getUniforms
};
exports.gouraudLighting = gouraudLighting;
const phongLighting = {
  name: 'phong-lighting',
  dependencies: [_lights.lights],
  fs: _phongLighting.default,
  defines: {
    LIGHTING_FRAGMENT: 1
  },
  getUniforms
};
exports.phongLighting = phongLighting;
},{"../lights/lights":"node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.js","./phong-lighting.glsl":"node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.glsl.js"}],"node_modules/@luma.gl/shadertools/dist/esm/modules/pbr/pbr-vertex.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = `\
uniform mat4 u_MVPMatrix;
uniform mat4 u_ModelMatrix;
uniform mat4 u_NormalMatrix;

varying vec3 pbr_vPosition;
varying vec2 pbr_vUV;

#ifdef HAS_NORMALS
# ifdef HAS_TANGENTS
varying mat3 pbr_vTBN;
# else
varying vec3 pbr_vNormal;
# endif
#endif

void pbr_setPositionNormalTangentUV(vec4 position, vec4 normal, vec4 tangent, vec2 uv)
{
  vec4 pos = u_ModelMatrix * position;
  pbr_vPosition = vec3(pos.xyz) / pos.w;

#ifdef HAS_NORMALS
#ifdef HAS_TANGENTS
  vec3 normalW = normalize(vec3(u_NormalMatrix * vec4(normal.xyz, 0.0)));
  vec3 tangentW = normalize(vec3(u_ModelMatrix * vec4(tangent.xyz, 0.0)));
  vec3 bitangentW = cross(normalW, tangentW) * tangent.w;
  pbr_vTBN = mat3(tangentW, bitangentW, normalW);
#else
  pbr_vNormal = normalize(vec3(u_ModelMatrix * vec4(normal.xyz, 0.0)));
#endif
#endif

#ifdef HAS_UV
  pbr_vUV = uv;
#else
  pbr_vUV = vec2(0.,0.);
#endif
}
`;
exports.default = _default;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/pbr/pbr-fragment.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = `\
#if defined(USE_TEX_LOD) && !defined(FEATURE_GLSL_TEXTURE_LOD)
# error PBR fragment shader: Texture LOD is not available
#endif

#if !defined(HAS_TANGENTS) && !defined(FEATURE_GLSL_DERIVATIVES)
# error PBR fragment shader: Derivatives are not available
#endif


#if (__VERSION__ < 300)
  #define SMART_FOR(INIT, WEBGL1COND, WEBGL2COND, INCR) for (INIT; WEBGL1COND; INCR)
#else
  #define SMART_FOR(INIT, WEBGL1COND, WEBGL2COND, INCR) for (INIT; WEBGL2COND; INCR)
#endif

precision highp float;

uniform bool pbr_uUnlit;

#ifdef USE_IBL
uniform samplerCube u_DiffuseEnvSampler;
uniform samplerCube u_SpecularEnvSampler;
uniform sampler2D u_brdfLUT;
uniform vec2 u_ScaleIBLAmbient;
#endif

#ifdef HAS_BASECOLORMAP
uniform sampler2D u_BaseColorSampler;
#endif
#ifdef HAS_NORMALMAP
uniform sampler2D u_NormalSampler;
uniform float u_NormalScale;
#endif
#ifdef HAS_EMISSIVEMAP
uniform sampler2D u_EmissiveSampler;
uniform vec3 u_EmissiveFactor;
#endif
#ifdef HAS_METALROUGHNESSMAP
uniform sampler2D u_MetallicRoughnessSampler;
#endif
#ifdef HAS_OCCLUSIONMAP
uniform sampler2D u_OcclusionSampler;
uniform float u_OcclusionStrength;
#endif

#ifdef ALPHA_CUTOFF
uniform float u_AlphaCutoff;
#endif

uniform vec2 u_MetallicRoughnessValues;
uniform vec4 u_BaseColorFactor;

uniform vec3 u_Camera;
#ifdef PBR_DEBUG
uniform vec4 u_ScaleDiffBaseMR;
uniform vec4 u_ScaleFGDSpec;
#endif

varying vec3 pbr_vPosition;

varying vec2 pbr_vUV;

#ifdef HAS_NORMALS
#ifdef HAS_TANGENTS
varying mat3 pbr_vTBN;
#else
varying vec3 pbr_vNormal;
#endif
#endif


struct PBRInfo
{
  float NdotL;
  float NdotV;
  float NdotH;
  float LdotH;
  float VdotH;
  float perceptualRoughness;
  float metalness;
  vec3 reflectance0;
  vec3 reflectance90;
  float alphaRoughness;
  vec3 diffuseColor;
  vec3 specularColor;
  vec3 n;
  vec3 v;
};

const float M_PI = 3.141592653589793;
const float c_MinRoughness = 0.04;

vec4 SRGBtoLINEAR(vec4 srgbIn)
{
#ifdef MANUAL_SRGB
#ifdef SRGB_FAST_APPROXIMATION
  vec3 linOut = pow(srgbIn.xyz,vec3(2.2));
#else
  vec3 bLess = step(vec3(0.04045),srgbIn.xyz);
  vec3 linOut = mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess );
#endif
  return vec4(linOut,srgbIn.w);;
#else
  return srgbIn;
#endif
}

vec3 getNormal()
{
#ifndef HAS_TANGENTS
  vec3 pos_dx = dFdx(pbr_vPosition);
  vec3 pos_dy = dFdy(pbr_vPosition);
  vec3 tex_dx = dFdx(vec3(pbr_vUV, 0.0));
  vec3 tex_dy = dFdy(vec3(pbr_vUV, 0.0));
  vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);

#ifdef HAS_NORMALS
  vec3 ng = normalize(pbr_vNormal);
#else
  vec3 ng = cross(pos_dx, pos_dy);
#endif

  t = normalize(t - ng * dot(ng, t));
  vec3 b = normalize(cross(ng, t));
  mat3 tbn = mat3(t, b, ng);
#else
  mat3 tbn = pbr_vTBN;
#endif

#ifdef HAS_NORMALMAP
  vec3 n = texture2D(u_NormalSampler, pbr_vUV).rgb;
  n = normalize(tbn * ((2.0 * n - 1.0) * vec3(u_NormalScale, u_NormalScale, 1.0)));
#else
  vec3 n = normalize(tbn[2].xyz);
#endif

  return n;
}


#ifdef USE_IBL
vec3 getIBLContribution(PBRInfo pbrInputs, vec3 n, vec3 reflection)
{
  float mipCount = 9.0;
  float lod = (pbrInputs.perceptualRoughness * mipCount);
  vec3 brdf = SRGBtoLINEAR(texture2D(u_brdfLUT,
    vec2(pbrInputs.NdotV, 1.0 - pbrInputs.perceptualRoughness))).rgb;
  vec3 diffuseLight = SRGBtoLINEAR(textureCube(u_DiffuseEnvSampler, n)).rgb;

#ifdef USE_TEX_LOD
  vec3 specularLight = SRGBtoLINEAR(textureCubeLod(u_SpecularEnvSampler, reflection, lod)).rgb;
#else
  vec3 specularLight = SRGBtoLINEAR(textureCube(u_SpecularEnvSampler, reflection)).rgb;
#endif

  vec3 diffuse = diffuseLight * pbrInputs.diffuseColor;
  vec3 specular = specularLight * (pbrInputs.specularColor * brdf.x + brdf.y);
  diffuse *= u_ScaleIBLAmbient.x;
  specular *= u_ScaleIBLAmbient.y;

  return diffuse + specular;
}
#endif


vec3 diffuse(PBRInfo pbrInputs)
{
  return pbrInputs.diffuseColor / M_PI;
}

vec3 specularReflection(PBRInfo pbrInputs)
{
  return pbrInputs.reflectance0 +
    (pbrInputs.reflectance90 - pbrInputs.reflectance0) *
    pow(clamp(1.0 - pbrInputs.VdotH, 0.0, 1.0), 5.0);
}



float geometricOcclusion(PBRInfo pbrInputs)
{
  float NdotL = pbrInputs.NdotL;
  float NdotV = pbrInputs.NdotV;
  float r = pbrInputs.alphaRoughness;

  float attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));
  float attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));
  return attenuationL * attenuationV;
}





float microfacetDistribution(PBRInfo pbrInputs)
{
  float roughnessSq = pbrInputs.alphaRoughness * pbrInputs.alphaRoughness;
  float f = (pbrInputs.NdotH * roughnessSq - pbrInputs.NdotH) * pbrInputs.NdotH + 1.0;
  return roughnessSq / (M_PI * f * f);
}

void PBRInfo_setAmbientLight(inout PBRInfo pbrInputs) {
  pbrInputs.NdotL = 1.0;
  pbrInputs.NdotH = 0.0;
  pbrInputs.LdotH = 0.0;
  pbrInputs.VdotH = 1.0;
}

void PBRInfo_setDirectionalLight(inout PBRInfo pbrInputs, vec3 lightDirection) {
  vec3 n = pbrInputs.n;
  vec3 v = pbrInputs.v;
  vec3 l = normalize(lightDirection);
  vec3 h = normalize(l+v);

  pbrInputs.NdotL = clamp(dot(n, l), 0.001, 1.0);
  pbrInputs.NdotH = clamp(dot(n, h), 0.0, 1.0);
  pbrInputs.LdotH = clamp(dot(l, h), 0.0, 1.0);
  pbrInputs.VdotH = clamp(dot(v, h), 0.0, 1.0);
}

void PBRInfo_setPointLight(inout PBRInfo pbrInputs, PointLight pointLight) {
  vec3 light_direction = normalize(pointLight.position - pbr_vPosition);
  PBRInfo_setDirectionalLight(pbrInputs, light_direction);
}

vec3 calculateFinalColor(PBRInfo pbrInputs, vec3 lightColor) {
  vec3 F = specularReflection(pbrInputs);
  float G = geometricOcclusion(pbrInputs);
  float D = microfacetDistribution(pbrInputs);
  vec3 diffuseContrib = (1.0 - F) * diffuse(pbrInputs);
  vec3 specContrib = F * G * D / (4.0 * pbrInputs.NdotL * pbrInputs.NdotV);
  return pbrInputs.NdotL * lightColor * (diffuseContrib + specContrib);
}

vec4 pbr_filterColor(vec4 colorUnused)
{
#ifdef HAS_BASECOLORMAP
  vec4 baseColor = SRGBtoLINEAR(texture2D(u_BaseColorSampler, pbr_vUV)) * u_BaseColorFactor;
#else
  vec4 baseColor = u_BaseColorFactor;
#endif

#ifdef ALPHA_CUTOFF
  if (baseColor.a < u_AlphaCutoff) {
    discard;
  }
#endif

  vec3 color = vec3(0, 0, 0);

  if(pbr_uUnlit){
    color.rgb = baseColor.rgb;
  }
  else{


    float perceptualRoughness = u_MetallicRoughnessValues.y;
    float metallic = u_MetallicRoughnessValues.x;
#ifdef HAS_METALROUGHNESSMAP

    vec4 mrSample = texture2D(u_MetallicRoughnessSampler, pbr_vUV);
    perceptualRoughness = mrSample.g * perceptualRoughness;
    metallic = mrSample.b * metallic;
#endif
    perceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);
    metallic = clamp(metallic, 0.0, 1.0);

    float alphaRoughness = perceptualRoughness * perceptualRoughness;

    vec3 f0 = vec3(0.04);
    vec3 diffuseColor = baseColor.rgb * (vec3(1.0) - f0);
    diffuseColor *= 1.0 - metallic;
    vec3 specularColor = mix(f0, baseColor.rgb, metallic);
    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);



    float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);
    vec3 specularEnvironmentR0 = specularColor.rgb;
    vec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;

    vec3 n = getNormal();
    vec3 v = normalize(u_Camera - pbr_vPosition);

    float NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);
    vec3 reflection = -normalize(reflect(v, n));

    PBRInfo pbrInputs = PBRInfo(
      0.0,
      NdotV,
      0.0,
      0.0,
      0.0,
      perceptualRoughness,
      metallic,
      specularEnvironmentR0,
      specularEnvironmentR90,
      alphaRoughness,
      diffuseColor,
      specularColor,
      n,
      v
    );

#ifdef USE_LIGHTS
    PBRInfo_setAmbientLight(pbrInputs);
    color += calculateFinalColor(pbrInputs, lighting_uAmbientLight.color);
    SMART_FOR(int i = 0, i < MAX_LIGHTS, i < lighting_uDirectionalLightCount, i++) {
      if (i < lighting_uDirectionalLightCount) {
        PBRInfo_setDirectionalLight(pbrInputs, lighting_uDirectionalLight[i].direction);
        color += calculateFinalColor(pbrInputs, lighting_uDirectionalLight[i].color);
      }
    }
    SMART_FOR(int i = 0, i < MAX_LIGHTS, i < lighting_uPointLightCount, i++) {
      if (i < lighting_uPointLightCount) {
        PBRInfo_setPointLight(pbrInputs, lighting_uPointLight[i]);
        float attenuation = getPointLightAttenuation(lighting_uPointLight[i], distance(lighting_uPointLight[i].position, pbr_vPosition));
        color += calculateFinalColor(pbrInputs, lighting_uPointLight[i].color / attenuation);
      }
    }
#endif
#ifdef USE_IBL
    color += getIBLContribution(pbrInputs, n, reflection);
#endif
#ifdef HAS_OCCLUSIONMAP
    float ao = texture2D(u_OcclusionSampler, pbr_vUV).r;
    color = mix(color, color * ao, u_OcclusionStrength);
#endif

#ifdef HAS_EMISSIVEMAP
    vec3 emissive = SRGBtoLINEAR(texture2D(u_EmissiveSampler, pbr_vUV)).rgb * u_EmissiveFactor;
    color += emissive;
#endif

#ifdef PBR_DEBUG





    color = mix(color, baseColor.rgb, u_ScaleDiffBaseMR.y);
    color = mix(color, vec3(metallic), u_ScaleDiffBaseMR.z);
    color = mix(color, vec3(perceptualRoughness), u_ScaleDiffBaseMR.w);
#endif

  }

  return vec4(pow(color,vec3(1.0/2.2)), baseColor.a);
}
`;
exports.default = _default;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/pbr/pbr.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pbr = void 0;

var _lights = require("../lights/lights");

var _pbrVertex = _interopRequireDefault(require("./pbr-vertex.glsl"));

var _pbrFragment = _interopRequireDefault(require("./pbr-fragment.glsl"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const pbr = {
  name: 'pbr',
  vs: _pbrVertex.default,
  fs: _pbrFragment.default,
  defines: {
    LIGHTING_FRAGMENT: 1
  },
  dependencies: [_lights.lights]
};
exports.pbr = pbr;
},{"../lights/lights":"node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.js","./pbr-vertex.glsl":"node_modules/@luma.gl/shadertools/dist/esm/modules/pbr/pbr-vertex.glsl.js","./pbr-fragment.glsl":"node_modules/@luma.gl/shadertools/dist/esm/modules/pbr/pbr-fragment.glsl.js"}],"node_modules/@luma.gl/shadertools/dist/esm/modules/image-blur-filters/tiltshift.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tiltShift = void 0;

var _random = require("../utils/random");

const fs = `\
uniform float blurRadius;
uniform float gradientRadius;
uniform vec2 start;
uniform vec2 end;
uniform bool invert;

vec2 tiltShift_getDelta(vec2 texSize) {
  vec2 vector = normalize((end - start) * texSize);
  return invert ? vec2(-vector.y, vector.x) : vector;
}

vec4 tiltShift_sampleColor(sampler2D texture, vec2 texSize, vec2 texCoord) {
  vec4 color = vec4(0.0);
  float total = 0.0;
  float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);

  vec2 normal = normalize(vec2((start.y - end.y) * texSize.y, (end.x - start.x) * texSize.x));
  float radius = smoothstep(0.0, 1.0,
    abs(dot(texCoord * texSize - start * texSize, normal)) / gradientRadius) * blurRadius;

  for (float t = -30.0; t <= 30.0; t++) {
    float percent = (t + offset - 0.5) / 30.0;
    float weight = 1.0 - abs(percent);
    vec4 sample = texture2D(texture, texCoord + tiltShift_getDelta(texSize) / texSize * percent * radius);
    sample.rgb *= sample.a;

    color += sample * weight;
    total += weight;
  }

  color = color / total;
  color.rgb /= color.a + 0.00001;

  return color;
}
`;
const uniforms = {
  blurRadius: {
    value: 15,
    min: 0,
    max: 50
  },
  gradientRadius: {
    value: 200,
    min: 0,
    max: 400
  },
  start: [0, 0],
  end: [1, 1],
  invert: {
    value: false,
    private: true
  }
};
const tiltShift = {
  name: 'tiltShift',
  uniforms,
  fs,
  dependencies: [_random.random],
  passes: [{
    sampler: true,
    uniforms: {
      invert: false
    }
  }, {
    sampler: true,
    uniforms: {
      invert: true
    }
  }]
};
exports.tiltShift = tiltShift;
},{"../utils/random":"node_modules/@luma.gl/shadertools/dist/esm/modules/utils/random.js"}],"node_modules/@luma.gl/shadertools/dist/esm/modules/image-blur-filters/triangleblur.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.triangleBlur = void 0;

var _random = require("../utils/random");

const fs = `\
uniform float radius;
uniform vec2 delta;

vec4 triangleBlur_sampleColor(sampler2D texture, vec2 texSize, vec2 texCoord) {
  vec2 adjustedDelta = delta * radius / texSize;

  vec4 color = vec4(0.0);
  float total = 0.0;
  float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);

  for (float t = -30.0; t <= 30.0; t++) {
    float percent = (t + offset - 0.5) / 30.0;
    float weight = 1.0 - abs(percent);
    vec4 sample = texture2D(texture, texCoord + adjustedDelta * percent);
    sample.rgb *= sample.a;

    color += sample * weight;
    total += weight;
  }

  color = color / total;
  color.rgb /= color.a + 0.00001;

  return color;
}
`;
const uniforms = {
  radius: {
    value: 20,
    min: 0,
    softMax: 100
  },
  delta: {
    value: [1, 0],
    private: true
  }
};
const triangleBlur = {
  name: 'triangleBlur',
  uniforms,
  fs,
  dependencies: [_random.random],
  passes: [{
    sampler: true,
    uniforms: {
      delta: [1, 0]
    }
  }, {
    sampler: true,
    uniforms: {
      delta: [0, 1]
    }
  }]
};
exports.triangleBlur = triangleBlur;
},{"../utils/random":"node_modules/@luma.gl/shadertools/dist/esm/modules/utils/random.js"}],"node_modules/@luma.gl/shadertools/dist/esm/modules/image-blur-filters/zoomblur.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.zoomBlur = void 0;

var _random = require("../utils/random");

const fs = `
uniform vec2 center;
uniform float strength;

vec4 zoomBlur_sampleColor(sampler2D texture, vec2 texSize, vec2 texCoord) {
  vec4 color = vec4(0.0);
  float total = 0.0;
  vec2 toCenter = center * texSize - texCoord * texSize;
  float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);

  for (float t = 0.0; t <= 40.0; t++) {
    float percent = (t + offset) / 40.0;
    float weight = 4.0 * (percent - percent * percent);
    vec4 sample = texture2D(texture, texCoord + toCenter * percent * strength / texSize);
    sample.rgb *= sample.a;

    color += sample * weight;
    total += weight;
  }

  color = color / total;
  color.rgb /= color.a + 0.00001;

  return color;
}
`;
const uniforms = {
  center: [0.5, 0.5],
  strength: {
    value: 0.3,
    min: 0,
    softMax: 1
  }
};
const zoomBlur = {
  name: 'zoomBlur',
  uniforms,
  fs,
  dependencies: [_random.random],
  passes: [{
    sampler: true
  }]
};
exports.zoomBlur = zoomBlur;
},{"../utils/random":"node_modules/@luma.gl/shadertools/dist/esm/modules/utils/random.js"}],"node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/brightnesscontrast.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.brightnessContrast = void 0;
const fs = `\
uniform float brightness;
uniform float contrast;

vec4 brightnessContrast_filterColor(vec4 color) {
  color.rgb += brightness;
  if (contrast > 0.0) {
    color.rgb = (color.rgb - 0.5) / (1.0 - contrast) + 0.5;
  } else {
    color.rgb = (color.rgb - 0.5) * (1.0 + contrast) + 0.5;
  }
  return color;
}

vec4 brightnessContrast_filterColor(vec4 color, vec2 texSize, vec2 texCoords) {
  return brightnessContrast_filterColor(color);
}
`;
const uniforms = {
  brightness: {
    value: 0,
    min: -1,
    max: 1
  },
  contrast: {
    value: 0,
    min: -1,
    max: 1
  }
};
const brightnessContrast = {
  name: 'brightnessContrast',
  uniforms,
  fs,
  passes: [{
    filter: true
  }]
};
exports.brightnessContrast = brightnessContrast;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/denoise.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.denoise = void 0;
const fs = `\
uniform float strength;

vec4 denoise_sampleColor(sampler2D texture, vec2 texSize, vec2 texCoord) {
  float adjustedExponent = 3. + 200. * pow(1. - strength, 4.);

  vec4 center = texture2D(texture, texCoord);
  vec4 color = vec4(0.0);
  float total = 0.0;
  for (float x = -4.0; x <= 4.0; x += 1.0) {
    for (float y = -4.0; y <= 4.0; y += 1.0) {
      vec4 sample = texture2D(texture, texCoord + vec2(x, y) / texSize);
      float weight = 1.0 - abs(dot(sample.rgb - center.rgb, vec3(0.25)));
      weight = pow(weight, adjustedExponent);
      color += sample * weight;
      total += weight;
    }
  }

  return color / total;
}
`;
const uniforms = {
  strength: {
    value: 0.5,
    min: 0,
    max: 0.1,
    adjust: strength => 0.53 + 200 * Math.pow(1 - strength, 4)
  }
};
const denoise = {
  name: 'denoise',
  uniforms,
  fs,
  passes: [{
    sampler: true
  }, {
    sampler: true
  }]
};
exports.denoise = denoise;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/huesaturation.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hueSaturation = void 0;
const fs = `\
uniform float hue;
uniform float saturation;

vec4 hueSaturation_filterColor(vec4 color) {
  float angle = hue * 3.14159265;
  float s = sin(angle), c = cos(angle);
  vec3 weights = (vec3(2.0 * c, -sqrt(3.0) * s - c, sqrt(3.0) * s - c) + 1.0) / 3.0;
  float len = length(color.rgb);
  color.rgb = vec3(
    dot(color.rgb, weights.xyz),
    dot(color.rgb, weights.zxy),
    dot(color.rgb, weights.yzx)
  );
  float average = (color.r + color.g + color.b) / 3.0;
  if (saturation > 0.0) {
    color.rgb += (average - color.rgb) * (1.0 - 1.0 / (1.001 - saturation));
  } else {
    color.rgb += (average - color.rgb) * (-saturation);
  }

  return color;
}

vec4 hueSaturation_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {
  return hueSaturation_filterColor(color);
}
`;
const uniforms = {
  hue: {
    value: 0,
    min: -1,
    max: 1
  },
  saturation: {
    value: 0,
    min: -1,
    max: 1
  }
};
const hueSaturation = {
  name: 'hueSaturation',
  uniforms,
  fs,
  passes: [{
    filter: true
  }]
};
exports.hueSaturation = hueSaturation;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/noise.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.noise = void 0;
const fs = `\
uniform float amount;

float rand(vec2 co) {
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec4 noise_filterColor(vec4 color, vec2 texCoord) {
  float diff = (rand(texCoord) - 0.5) * amount;
  color.r += diff;
  color.g += diff;
  color.b += diff;
  return color;
}

vec4 noise_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {
  return noise_filterColor(color, texCoord);
}
`;
const uniforms = {
  amount: {
    value: 0.5,
    min: 0,
    max: 1
  }
};
const noise = {
  name: 'noise',
  uniforms,
  fs,
  passes: [{
    filter: true
  }]
};
exports.noise = noise;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/sepia.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sepia = void 0;
const fs = `\
uniform float amount;

vec4 sepia_filterColor(vec4 color) {
  float r = color.r;
  float g = color.g;
  float b = color.b;

  color.r =
    min(1.0, (r * (1.0 - (0.607 * amount))) + (g * (0.769 * amount)) + (b * (0.189 * amount)));
  color.g = min(1.0, (r * 0.349 * amount) + (g * (1.0 - (0.314 * amount))) + (b * 0.168 * amount));
  color.b = min(1.0, (r * 0.272 * amount) + (g * 0.534 * amount) + (b * (1.0 - (0.869 * amount))));

  return color;
}

vec4 sepia_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {
  return sepia_filterColor(color);
}
`;
const uniforms = {
  amount: {
    value: 0.5,
    min: 0,
    max: 1
  }
};
const sepia = {
  name: 'sepia',
  uniforms,
  fs,
  passes: [{
    filter: true
  }]
};
exports.sepia = sepia;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/vibrance.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.vibrance = void 0;
const fs = `\
uniform float amount;

vec4 vibrance_filterColor(vec4 color) {
  float average = (color.r + color.g + color.b) / 3.0;
  float mx = max(color.r, max(color.g, color.b));
  float amt = (mx - average) * (-amount * 3.0);
  color.rgb = mix(color.rgb, vec3(mx), amt);
  return color;
}

vec4 vibrance_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {
  return vibrance_filterColor(color);
}
`;
const uniforms = {
  amount: {
    value: 0,
    min: -1,
    max: 1
  }
};
const vibrance = {
  name: 'vibrance',
  uniforms,
  fs,
  passes: [{
    filter: true
  }]
};
exports.vibrance = vibrance;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/vignette.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.vignette = void 0;
const fs = `\
uniform float radius;
uniform float amount;

vec4 vignette_filterColor(vec4 color, vec2 texCoord) {
  float dist = distance(texCoord, vec2(0.5, 0.5));
  float ratio = smoothstep(0.8, radius * 0.799, dist * (amount + radius));
  return color.rgba * ratio + (1.0 - ratio)*vec4(0.0, 0.0, 0.0, 1.0);
}

vec4 vignette_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {
  return vignette_filterColor(color, texCoord);
}
`;
const uniforms = {
  radius: {
    value: 0.5,
    min: 0,
    max: 1
  },
  amount: {
    value: 0.5,
    min: 0,
    max: 1
  }
};
const vignette = {
  name: 'vignette',
  fs,
  uniforms,
  passes: [{
    filter: true
  }]
};
exports.vignette = vignette;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/colorhalftone.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.colorHalftone = void 0;
const fs = `\
uniform vec2 center;
uniform float angle;
uniform float size;

float scale = 3.1514 / size;

float pattern(float angle, vec2 texSize, vec2 texCoord) {
  float s = sin(angle), c = cos(angle);
  vec2 tex = texCoord * texSize - center * texSize;
  vec2 point = vec2(
	c * tex.x - s * tex.y,
	s * tex.x + c * tex.y
  ) * scale;
  return (sin(point.x) * sin(point.y)) * 4.0;
}

vec4 colorHalftone_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {
  vec3 cmy = 1.0 - color.rgb;
  float k = min(cmy.x, min(cmy.y, cmy.z));
  cmy = (cmy - k) / (1.0 - k);
  cmy = clamp(
	cmy * 10.0 - 3.0 + vec3(
    pattern(angle + 0.26179, texSize, texCoord),
	  pattern(angle + 1.30899, texSize, texCoord),
    pattern(angle, texSize, texCoord)
  ),
	0.0,
	1.0
  );
  k = clamp(k * 10.0 - 5.0 + pattern(angle + 0.78539, texSize, texCoord), 0.0, 1.0);
  return vec4(1.0 - cmy - k, color.a);
}
`;
const uniforms = {
  center: [0.5, 0.5],
  angle: {
    value: 1.1,
    softMin: 0,
    softMax: Math.PI / 2
  },
  size: {
    value: 4,
    min: 1,
    softMin: 3,
    softMax: 20
  }
};
const colorHalftone = {
  name: 'colorHalftone',
  uniforms,
  fs,
  passes: [{
    filter: true
  }]
};
exports.colorHalftone = colorHalftone;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/dotscreen.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dotScreen = void 0;
const fs = `\
uniform vec2 center;
uniform float angle;
uniform float size;

float pattern(vec2 texSize, vec2 texCoord) {
  float scale = 3.1415 / size;

  float s = sin(angle), c = cos(angle);
  vec2 tex = texCoord * texSize - center * texSize;
  vec2 point = vec2(
    c * tex.x - s * tex.y,
    s * tex.x + c * tex.y
  ) * scale;
  return (sin(point.x) * sin(point.y)) * 4.0;
}

vec4 dotScreen_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {
  float average = (color.r + color.g + color.b) / 3.0;
  return vec4(vec3(average * 10.0 - 5.0 + pattern(texSize, texCoord)), color.a);
}
`;
const uniforms = {
  center: [0.5, 0.5],
  angle: {
    value: 1.1,
    softMin: 0,
    softMax: Math.PI / 2
  },
  size: {
    value: 3,
    min: 1,
    softMin: 3,
    softMax: 20
  }
};
const dotScreen = {
  name: 'dotScreen',
  uniforms,
  fs,
  passes: [{
    filter: true
  }]
};
exports.dotScreen = dotScreen;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/edgework.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.edgeWork = void 0;

var _random = require("../utils/random");

const fs = `\
uniform float radius;
uniform vec2 delta;

vec4 edgeWork_sampleColor1(sampler2D source, vec2 texSize, vec2 texCoord) {
  vec2 relativeDelta = radius * delta / texSize;

  vec2 color = vec2(0.0);
  vec2 total = vec2(0.0);
  float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);

  for (float t = -30.0; t <= 30.0; t++) {
    float percent = (t + offset - 0.5) / 30.0;
    float weight = 1.0 - abs(percent);
    vec3 sampleColor = texture2D(source, texCoord + relativeDelta * percent).rgb;
    float average = (sampleColor.r + sampleColor.g + sampleColor.b) / 3.0;
    color.x += average * weight;
    total.x += weight;
    if (abs(t) < 15.0) {
      weight = weight * 2.0 - 1.0;
      color.y += average * weight;
      total.y += weight;
    }
  }
  return vec4(color / total, 0.0, 1.0);
}

vec4 edgeWork_sampleColor2(sampler2D source, vec2 texSize, vec2 texCoord) {
  vec2 relativeDelta = radius * delta / texSize;

  vec2 color = vec2(0.0);
  vec2 total = vec2(0.0);
  float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);

  for (float t = -30.0; t <= 30.0; t++) {
    float percent = (t + offset - 0.5) / 30.0;
    float weight = 1.0 - abs(percent);
    vec2 sampleColor = texture2D(source, texCoord + relativeDelta * percent).xy;
    color.x += sampleColor.x * weight;
    total.x += weight;
    if (abs(t) < 15.0) {
      weight = weight * 2.0 - 1.0;
      color.y += sampleColor.y * weight;
      total.y += weight;
    }
  }
  float c = clamp(10000.0 * (color.y / total.y - color.x / total.x) + 0.5, 0.0, 1.0);
  return vec4(c, c, c, 1.0);
}
`;
const uniforms = {
  radius: {
    value: 2,
    min: 1,
    softMax: 50
  },
  delta: {
    value: [1, 0],
    private: true
  }
};
const edgeWork = {
  name: 'edgeWork',
  uniforms,
  fs,
  dependencies: [_random.random],
  passes: [{
    sampler: 'edgeWork_sampleColor1',
    uniforms: {
      delta: [1, 0]
    }
  }, {
    sampler: 'edgeWork_sampleColor2',
    uniforms: {
      delta: [0, 1]
    }
  }]
};
exports.edgeWork = edgeWork;
},{"../utils/random":"node_modules/@luma.gl/shadertools/dist/esm/modules/utils/random.js"}],"node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/hexagonalpixelate.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hexagonalPixelate = void 0;
const fs = `\
uniform vec2 center;
uniform float scale;

vec4 hexagonalPixelate_sampleColor(sampler2D texture, vec2 texSize, vec2 texCoord) {
  vec2 tex = (texCoord * texSize - center * texSize) / scale;
  tex.y /= 0.866025404;
  tex.x -= tex.y * 0.5;

  vec2 a;
  if (tex.x + tex.y - floor(tex.x) - floor(tex.y) < 1.0) {
    a = vec2(floor(tex.x), floor(tex.y));
  }
  else a = vec2(ceil(tex.x), ceil(tex.y));
  vec2 b = vec2(ceil(tex.x), floor(tex.y));
  vec2 c = vec2(floor(tex.x), ceil(tex.y));

  vec3 TEX = vec3(tex.x, tex.y, 1.0 - tex.x - tex.y);
  vec3 A = vec3(a.x, a.y, 1.0 - a.x - a.y);
  vec3 B = vec3(b.x, b.y, 1.0 - b.x - b.y);
  vec3 C = vec3(c.x, c.y, 1.0 - c.x - c.y);

  float alen = length(TEX - A);
  float blen = length(TEX - B);
  float clen = length(TEX - C);

  vec2 choice;
  if (alen < blen) {
    if (alen < clen) choice = a;
    else choice = c;
  } else {
    if (blen < clen) choice = b;
    else choice = c;
  }

  choice.x += choice.y * 0.5;
  choice.y *= 0.866025404;
  choice *= scale / texSize;

  return texture2D(texture, choice + center);
}
`;
const uniforms = {
  center: {
    value: [0.5, 0.5],
    hint: 'screenspace'
  },
  scale: {
    value: 10,
    min: 1,
    softMin: 5,
    softMax: 50
  }
};
const hexagonalPixelate = {
  name: 'hexagonalPixelate',
  uniforms,
  fs,
  passes: [{
    sampler: true
  }]
};
exports.hexagonalPixelate = hexagonalPixelate;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/ink.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ink = void 0;
const fs = `\
uniform float strength;

vec4 ink_sampleColor(sampler2D texture, vec2 texSize, vec2 texCoord) {
  vec2 dx = vec2(1.0 / texSize.x, 0.0);
  vec2 dy = vec2(0.0, 1.0 / texSize.y);
  vec4 color = texture2D(texture, texCoord);
  float bigTotal = 0.0;
  float smallTotal = 0.0;
  vec3 bigAverage = vec3(0.0);
  vec3 smallAverage = vec3(0.0);
  for (float x = -2.0; x <= 2.0; x += 1.0) {
    for (float y = -2.0; y <= 2.0; y += 1.0) {
      vec3 sample = texture2D(texture, texCoord + dx * x + dy * y).rgb;
      bigAverage += sample;
      bigTotal += 1.0;
      if (abs(x) + abs(y) < 2.0) {
        smallAverage += sample;
        smallTotal += 1.0;
      }
    }
  }
  vec3 edge = max(vec3(0.0), bigAverage / bigTotal - smallAverage / smallTotal);
  float power = strength * strength * strength * strength * strength;
  return vec4(color.rgb - dot(edge, edge) * power * 100000.0, color.a);
}
`;
const uniforms = {
  strength: {
    value: 0.25,
    min: 0,
    softMax: 1
  }
};
const ink = {
  name: 'ink',
  uniforms,
  fs,
  passes: [{
    sampler: true
  }]
};
exports.ink = ink;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/magnify.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.magnify = void 0;
const fs = `\
uniform vec2 screenXY;
uniform float radiusPixels;
uniform float zoom;
uniform float borderWidthPixels;
uniform vec4 borderColor;

vec4 magnify_sampleColor(sampler2D texture, vec2 texSize, vec2 texCoord) {
  vec2 pos = vec2(screenXY.x, 1.0 - screenXY.y);
  float dist = distance(texCoord * texSize, pos * texSize);
  if (dist < radiusPixels) {
    return texture2D(texture, (texCoord - pos) / zoom + pos);
  }

  if (dist <= radiusPixels + borderWidthPixels) {
    return borderColor;
  }
  return texture2D(texture, texCoord);
}
`;
const uniforms = {
  screenXY: [0, 0],
  radiusPixels: 200,
  zoom: 2.0,
  borderWidthPixels: 0.0,
  borderColor: [255, 255, 255, 255]
};
const magnify = {
  name: 'magnify',
  uniforms,
  fs,
  passes: [{
    sampler: true
  }]
};
exports.magnify = magnify;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/image-warp-filters/warp.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.warp = void 0;
const fs = `\
vec4 warp_sampleColor(sampler2D texture, vec2 texSize, vec2 coord) {
  vec4 color = texture2D(texture, coord / texSize);
  vec2 clampedCoord = clamp(coord, vec2(0.0), texSize);
  if (coord != clampedCoord) {
    color.a *= max(0.0, 1.0 - length(coord - clampedCoord));
  }

  return color;
}
`;
const warp = {
  name: 'warp',
  fs
};
exports.warp = warp;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/image-warp-filters/bulgepinch.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.bulgePinch = void 0;

var _warp = require("./warp");

const fs = `\
uniform float radius;
uniform float strength;
uniform vec2 center;

vec2 bulgePinch_warp(vec2 coord, vec2 texCenter) {
  coord -= texCenter;
  float distance = length(coord);
  if (distance < radius) {
    float percent = distance / radius;
    if (strength > 0.0) {
      coord *= mix(1.0, smoothstep(0.0, radius / distance, percent), strength * 0.75);
    } else {
      coord *= mix(1.0, pow(percent, 1.0 + strength * 0.75) * radius / distance, 1.0 - percent);
    }
  }
  coord += texCenter;
  return coord;
}

vec4 bulgePinch_sampleColor(sampler2D texture, vec2 texSize, vec2 texCoord) {
  vec2 coord = texCoord * texSize;
  coord = bulgePinch_warp(coord, center * texSize);

  return warp_sampleColor(texture, texSize, coord);
}
`;
const uniforms = {
  center: [0.5, 0.5],
  radius: {
    value: 200,
    min: 1,
    softMax: 600
  },
  strength: {
    value: 0.5,
    min: -1,
    max: 1
  }
};
const bulgePinch = {
  name: 'bulgePinch',
  fs,
  uniforms,
  dependencies: [_warp.warp],
  passes: [{
    sampler: true
  }]
};
exports.bulgePinch = bulgePinch;
},{"./warp":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-warp-filters/warp.js"}],"node_modules/@luma.gl/shadertools/dist/esm/modules/image-warp-filters/swirl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.swirl = void 0;

var _warp = require("./warp");

const fs = `\
uniform float radius;
uniform float angle;
uniform vec2 center;

vec2 swirl_warp(vec2 coord, vec2 texCenter) {
  coord -= texCenter;
  float distance = length(coord);
  if (distance < radius) {
    float percent = (radius - distance) / radius;
    float theta = percent * percent * angle;
    float s = sin(theta);
    float c = cos(theta);
    coord = vec2(
      coord.x * c - coord.y * s,
      coord.x * s + coord.y * c
    );
  }
  coord += texCenter;
  return coord;
}

vec4 swirl_sampleColor(sampler2D texture, vec2 texSize, vec2 texCoord) {
  vec2 coord = texCoord * texSize;
  coord = swirl_warp(coord, center * texSize);

  return warp_sampleColor(texture, texSize, coord);
}
`;
const uniforms = {
  center: [0.5, 0.5],
  radius: {
    value: 200,
    min: 1,
    softMax: 600
  },
  angle: {
    value: 3,
    softMin: -25,
    softMax: 25
  }
};
const swirl = {
  name: 'swirl',
  fs,
  uniforms,
  dependencies: [_warp.warp],
  passes: [{
    sampler: true
  }]
};
exports.swirl = swirl;
},{"./warp":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-warp-filters/warp.js"}],"node_modules/@luma.gl/shadertools/dist/esm/modules/fxaa/fxaa.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fxaa = void 0;

/**
 * ORIGINAL LICENCE
 * @license
 * Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *  * Neither the name of NVIDIA CORPORATION nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ''AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
const fs = `
#define FXAA_QUALITY_PRESET 29

#if (FXAA_QUALITY_PRESET == 10)
    #define FXAA_QUALITY_PS 3
    #define FXAA_QUALITY_P0 1.5
    #define FXAA_QUALITY_P1 3.0
    #define FXAA_QUALITY_P2 12.0
#endif
#if (FXAA_QUALITY_PRESET == 11)
    #define FXAA_QUALITY_PS 4
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.5
    #define FXAA_QUALITY_P2 3.0
    #define FXAA_QUALITY_P3 12.0
#endif
#if (FXAA_QUALITY_PRESET == 12)
    #define FXAA_QUALITY_PS 5
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.5
    #define FXAA_QUALITY_P2 2.0
    #define FXAA_QUALITY_P3 4.0
    #define FXAA_QUALITY_P4 12.0
#endif
#if (FXAA_QUALITY_PRESET == 13)
    #define FXAA_QUALITY_PS 6
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.5
    #define FXAA_QUALITY_P2 2.0
    #define FXAA_QUALITY_P3 2.0
    #define FXAA_QUALITY_P4 4.0
    #define FXAA_QUALITY_P5 12.0
#endif
#if (FXAA_QUALITY_PRESET == 14)
    #define FXAA_QUALITY_PS 7
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.5
    #define FXAA_QUALITY_P2 2.0
    #define FXAA_QUALITY_P3 2.0
    #define FXAA_QUALITY_P4 2.0
    #define FXAA_QUALITY_P5 4.0
    #define FXAA_QUALITY_P6 12.0
#endif
#if (FXAA_QUALITY_PRESET == 15)
    #define FXAA_QUALITY_PS 8
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.5
    #define FXAA_QUALITY_P2 2.0
    #define FXAA_QUALITY_P3 2.0
    #define FXAA_QUALITY_P4 2.0
    #define FXAA_QUALITY_P5 2.0
    #define FXAA_QUALITY_P6 4.0
    #define FXAA_QUALITY_P7 12.0
#endif
#if (FXAA_QUALITY_PRESET == 20)
    #define FXAA_QUALITY_PS 3
    #define FXAA_QUALITY_P0 1.5
    #define FXAA_QUALITY_P1 2.0
    #define FXAA_QUALITY_P2 8.0
#endif
#if (FXAA_QUALITY_PRESET == 21)
    #define FXAA_QUALITY_PS 4
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.5
    #define FXAA_QUALITY_P2 2.0
    #define FXAA_QUALITY_P3 8.0
#endif
#if (FXAA_QUALITY_PRESET == 22)
    #define FXAA_QUALITY_PS 5
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.5
    #define FXAA_QUALITY_P2 2.0
    #define FXAA_QUALITY_P3 2.0
    #define FXAA_QUALITY_P4 8.0
#endif
#if (FXAA_QUALITY_PRESET == 23)
    #define FXAA_QUALITY_PS 6
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.5
    #define FXAA_QUALITY_P2 2.0
    #define FXAA_QUALITY_P3 2.0
    #define FXAA_QUALITY_P4 2.0
    #define FXAA_QUALITY_P5 8.0
#endif
#if (FXAA_QUALITY_PRESET == 24)
    #define FXAA_QUALITY_PS 7
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.5
    #define FXAA_QUALITY_P2 2.0
    #define FXAA_QUALITY_P3 2.0
    #define FXAA_QUALITY_P4 2.0
    #define FXAA_QUALITY_P5 3.0
    #define FXAA_QUALITY_P6 8.0
#endif
#if (FXAA_QUALITY_PRESET == 25)
    #define FXAA_QUALITY_PS 8
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.5
    #define FXAA_QUALITY_P2 2.0
    #define FXAA_QUALITY_P3 2.0
    #define FXAA_QUALITY_P4 2.0
    #define FXAA_QUALITY_P5 2.0
    #define FXAA_QUALITY_P6 4.0
    #define FXAA_QUALITY_P7 8.0
#endif
#if (FXAA_QUALITY_PRESET == 26)
    #define FXAA_QUALITY_PS 9
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.5
    #define FXAA_QUALITY_P2 2.0
    #define FXAA_QUALITY_P3 2.0
    #define FXAA_QUALITY_P4 2.0
    #define FXAA_QUALITY_P5 2.0
    #define FXAA_QUALITY_P6 2.0
    #define FXAA_QUALITY_P7 4.0
    #define FXAA_QUALITY_P8 8.0
#endif
#if (FXAA_QUALITY_PRESET == 27)
    #define FXAA_QUALITY_PS 10
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.5
    #define FXAA_QUALITY_P2 2.0
    #define FXAA_QUALITY_P3 2.0
    #define FXAA_QUALITY_P4 2.0
    #define FXAA_QUALITY_P5 2.0
    #define FXAA_QUALITY_P6 2.0
    #define FXAA_QUALITY_P7 2.0
    #define FXAA_QUALITY_P8 4.0
    #define FXAA_QUALITY_P9 8.0
#endif
#if (FXAA_QUALITY_PRESET == 28)
    #define FXAA_QUALITY_PS 11
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.5
    #define FXAA_QUALITY_P2 2.0
    #define FXAA_QUALITY_P3 2.0
    #define FXAA_QUALITY_P4 2.0
    #define FXAA_QUALITY_P5 2.0
    #define FXAA_QUALITY_P6 2.0
    #define FXAA_QUALITY_P7 2.0
    #define FXAA_QUALITY_P8 2.0
    #define FXAA_QUALITY_P9 4.0
    #define FXAA_QUALITY_P10 8.0
#endif
#if (FXAA_QUALITY_PRESET == 29)
    #define FXAA_QUALITY_PS 12
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.5
    #define FXAA_QUALITY_P2 2.0
    #define FXAA_QUALITY_P3 2.0
    #define FXAA_QUALITY_P4 2.0
    #define FXAA_QUALITY_P5 2.0
    #define FXAA_QUALITY_P6 2.0
    #define FXAA_QUALITY_P7 2.0
    #define FXAA_QUALITY_P8 2.0
    #define FXAA_QUALITY_P9 2.0
    #define FXAA_QUALITY_P10 4.0
    #define FXAA_QUALITY_P11 8.0
#endif
#if (FXAA_QUALITY_PRESET == 39)
    #define FXAA_QUALITY_PS 12
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.0
    #define FXAA_QUALITY_P2 1.0
    #define FXAA_QUALITY_P3 1.0
    #define FXAA_QUALITY_P4 1.0
    #define FXAA_QUALITY_P5 1.5
    #define FXAA_QUALITY_P6 2.0
    #define FXAA_QUALITY_P7 2.0
    #define FXAA_QUALITY_P8 2.0
    #define FXAA_QUALITY_P9 2.0
    #define FXAA_QUALITY_P10 4.0
    #define FXAA_QUALITY_P11 8.0
#endif

#define FxaaBool bool
#define FxaaFloat float
#define FxaaFloat2 vec2
#define FxaaFloat3 vec3
#define FxaaFloat4 vec4
#define FxaaHalf float
#define FxaaHalf2 vec2
#define FxaaHalf3 vec3
#define FxaaHalf4 vec4
#define FxaaInt2 vec2
#define FxaaTex sampler2D

#define FxaaSat(x) clamp(x, 0.0, 1.0)
#define FxaaTexTop(t, p) texture2D(t, p)
#define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r))

FxaaFloat FxaaLuma_(FxaaFloat4 rgba) { return dot(rgba.rgb, vec3(0.2126, 0.7152, 0.0722)); }

FxaaFloat4 FxaaPixelShader_(


    FxaaFloat2 pos,




    FxaaTex tex,




    FxaaFloat2 fxaaQualityRcpFrame,










    FxaaFloat fxaaQualitySubpix,









    FxaaFloat fxaaQualityEdgeThreshold,













    FxaaFloat fxaaQualityEdgeThresholdMin
) {
    FxaaFloat2 posM;
    posM.x = pos.x;
    posM.y = pos.y;
    FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);
    #define lumaM rgbyM.y
    FxaaFloat lumaS = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));
    FxaaFloat lumaE = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));
    FxaaFloat lumaN = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));
    FxaaFloat lumaW = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));
    FxaaFloat maxSM = max(lumaS, lumaM);
    FxaaFloat minSM = min(lumaS, lumaM);
    FxaaFloat maxESM = max(lumaE, maxSM);
    FxaaFloat minESM = min(lumaE, minSM);
    FxaaFloat maxWN = max(lumaN, lumaW);
    FxaaFloat minWN = min(lumaN, lumaW);
    FxaaFloat rangeMax = max(maxWN, maxESM);
    FxaaFloat rangeMin = min(minWN, minESM);
    FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;
    FxaaFloat range = rangeMax - rangeMin;
    FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);
    FxaaBool earlyExit = range < rangeMaxClamped;
    if(earlyExit)
        return rgbyM;
    FxaaFloat lumaNW = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));
    FxaaFloat lumaSE = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));
    FxaaFloat lumaNE = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));
    FxaaFloat lumaSW = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));
    FxaaFloat lumaNS = lumaN + lumaS;
    FxaaFloat lumaWE = lumaW + lumaE;
    FxaaFloat subpixRcpRange = 1.0/range;
    FxaaFloat subpixNSWE = lumaNS + lumaWE;
    FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;
    FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;
    FxaaFloat lumaNESE = lumaNE + lumaSE;
    FxaaFloat lumaNWNE = lumaNW + lumaNE;
    FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;
    FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;
    FxaaFloat lumaNWSW = lumaNW + lumaSW;
    FxaaFloat lumaSWSE = lumaSW + lumaSE;
    FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);
    FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);
    FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;
    FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;
    FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;
    FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;
    FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;
    FxaaFloat lengthSign = fxaaQualityRcpFrame.x;
    FxaaBool horzSpan = edgeHorz >= edgeVert;
    FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;
    if(!horzSpan) lumaN = lumaW;
    if(!horzSpan) lumaS = lumaE;
    if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;
    FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;
    FxaaFloat gradientN = lumaN - lumaM;
    FxaaFloat gradientS = lumaS - lumaM;
    FxaaFloat lumaNN = lumaN + lumaM;
    FxaaFloat lumaSS = lumaS + lumaM;
    FxaaBool pairN = abs(gradientN) >= abs(gradientS);
    FxaaFloat gradient = max(abs(gradientN), abs(gradientS));
    if(pairN) lengthSign = -lengthSign;
    FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);
    FxaaFloat2 posB;
    posB.x = posM.x;
    posB.y = posM.y;
    FxaaFloat2 offNP;
    offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;
    offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;
    if(!horzSpan) posB.x += lengthSign * 0.5;
    if( horzSpan) posB.y += lengthSign * 0.5;
    FxaaFloat2 posN;
    posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;
    posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;
    FxaaFloat2 posP;
    posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;
    posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;
    FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;
    FxaaFloat lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN));
    FxaaFloat subpixE = subpixC * subpixC;
    FxaaFloat lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP));
    if(!pairN) lumaNN = lumaSS;
    FxaaFloat gradientScaled = gradient * 1.0/4.0;
    FxaaFloat lumaMM = lumaM - lumaNN * 0.5;
    FxaaFloat subpixF = subpixD * subpixE;
    FxaaBool lumaMLTZero = lumaMM < 0.0;
    lumaEndN -= lumaNN * 0.5;
    lumaEndP -= lumaNN * 0.5;
    FxaaBool doneN = abs(lumaEndN) >= gradientScaled;
    FxaaBool doneP = abs(lumaEndP) >= gradientScaled;
    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;
    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;
    FxaaBool doneNP = (!doneN) || (!doneP);
    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;
    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;
    if(doneNP) {
        if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));
        if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));
        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
        doneN = abs(lumaEndN) >= gradientScaled;
        doneP = abs(lumaEndP) >= gradientScaled;
        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;
        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;
        doneNP = (!doneN) || (!doneP);
        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;
        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;
        #if (FXAA_QUALITY_PS > 3)
        if(doneNP) {
            if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));
            if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));
            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
            doneN = abs(lumaEndN) >= gradientScaled;
            doneP = abs(lumaEndP) >= gradientScaled;
            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;
            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;
            doneNP = (!doneN) || (!doneP);
            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;
            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;
            #if (FXAA_QUALITY_PS > 4)
            if(doneNP) {
                if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));
                if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));
                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                doneN = abs(lumaEndN) >= gradientScaled;
                doneP = abs(lumaEndP) >= gradientScaled;
                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;
                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;
                doneNP = (!doneN) || (!doneP);
                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;
                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;
                #if (FXAA_QUALITY_PS > 5)
                if(doneNP) {
                    if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));
                    if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));
                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                    doneN = abs(lumaEndN) >= gradientScaled;
                    doneP = abs(lumaEndP) >= gradientScaled;
                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;
                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;
                    doneNP = (!doneN) || (!doneP);
                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;
                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;
                    #if (FXAA_QUALITY_PS > 6)
                    if(doneNP) {
                        if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));
                        if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));
                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                        doneN = abs(lumaEndN) >= gradientScaled;
                        doneP = abs(lumaEndP) >= gradientScaled;
                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;
                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;
                        doneNP = (!doneN) || (!doneP);
                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;
                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;
                        #if (FXAA_QUALITY_PS > 7)
                        if(doneNP) {
                            if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));
                            if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));
                            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                            doneN = abs(lumaEndN) >= gradientScaled;
                            doneP = abs(lumaEndP) >= gradientScaled;
                            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;
                            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;
                            doneNP = (!doneN) || (!doneP);
                            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;
                            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;
    #if (FXAA_QUALITY_PS > 8)
    if(doneNP) {
        if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));
        if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));
        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
        doneN = abs(lumaEndN) >= gradientScaled;
        doneP = abs(lumaEndP) >= gradientScaled;
        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;
        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;
        doneNP = (!doneN) || (!doneP);
        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;
        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;
        #if (FXAA_QUALITY_PS > 9)
        if(doneNP) {
            if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));
            if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));
            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
            doneN = abs(lumaEndN) >= gradientScaled;
            doneP = abs(lumaEndP) >= gradientScaled;
            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;
            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;
            doneNP = (!doneN) || (!doneP);
            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;
            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;
            #if (FXAA_QUALITY_PS > 10)
            if(doneNP) {
                if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));
                if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));
                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                doneN = abs(lumaEndN) >= gradientScaled;
                doneP = abs(lumaEndP) >= gradientScaled;
                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;
                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;
                doneNP = (!doneN) || (!doneP);
                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;
                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;
                #if (FXAA_QUALITY_PS > 11)
                if(doneNP) {
                    if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));
                    if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));
                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                    doneN = abs(lumaEndN) >= gradientScaled;
                    doneP = abs(lumaEndP) >= gradientScaled;
                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;
                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;
                    doneNP = (!doneN) || (!doneP);
                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;
                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;
                    #if (FXAA_QUALITY_PS > 12)
                    if(doneNP) {
                        if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));
                        if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));
                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                        doneN = abs(lumaEndN) >= gradientScaled;
                        doneP = abs(lumaEndP) >= gradientScaled;
                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;
                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;
                        doneNP = (!doneN) || (!doneP);
                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;
                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;
                    }
                    #endif
                }
                #endif
            }
            #endif
        }
        #endif
    }
    #endif
                        }
                        #endif
                    }
                    #endif
                }
                #endif
            }
            #endif
        }
        #endif
    }
    FxaaFloat dstN = posM.x - posN.x;
    FxaaFloat dstP = posP.x - posM.x;
    if(!horzSpan) dstN = posM.y - posN.y;
    if(!horzSpan) dstP = posP.y - posM.y;
    FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;
    FxaaFloat spanLength = (dstP + dstN);
    FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;
    FxaaFloat spanLengthRcp = 1.0/spanLength;
    FxaaBool directionN = dstN < dstP;
    FxaaFloat dst = min(dstN, dstP);
    FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;
    FxaaFloat subpixG = subpixF * subpixF;
    FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;
    FxaaFloat subpixH = subpixG * fxaaQualitySubpix;
    FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;
    FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);
    if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;
    if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;
    return FxaaTexTop(tex, posM);
}

vec4 fxaa_sampleColor(sampler2D texture, vec2 texSize, vec2 texCoord) {
    const float fxaa_QualitySubpix = 0.5;
    const float fxaa_QualityEdgeThreshold = 0.125;
    const float fxaa_QualityEdgeThresholdMin = 0.0833;

    return FxaaPixelShader_(
        texCoord,
        texture,
        vec2(1.0) / texSize,
        fxaa_QualitySubpix,
        fxaa_QualityEdgeThreshold,
        fxaa_QualityEdgeThresholdMin
    );
}
`;
const fxaa = {
  name: 'fxaa',
  uniforms: {},
  fs,
  passes: [{
    sampler: true
  }]
};
exports.fxaa = fxaa;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/transform/transform.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transform = void 0;
const vs = `\
attribute float transform_elementID;
vec2 transform_getPixelSizeHalf(vec2 size) {
  return vec2(1.) / (2. * size);
}

vec2 transform_getPixelIndices(vec2 texSize, vec2 pixelSizeHalf) {
  float yIndex = floor((transform_elementID / texSize[0]) + pixelSizeHalf[1]);
  float xIndex = transform_elementID - (yIndex * texSize[0]);
  return vec2(xIndex, yIndex);
}
vec2 transform_getTexCoord(vec2 size) {
  vec2 pixelSizeHalf = transform_getPixelSizeHalf(size);
  vec2 indices = transform_getPixelIndices(size, pixelSizeHalf);
  vec2 coord = indices / size + pixelSizeHalf;
  return coord;
}
vec2 transform_getPos(vec2 size) {
  vec2 texCoord = transform_getTexCoord(size);
  vec2 pos = (texCoord * (2.0, 2.0)) - (1., 1.);
  return pos;
}
vec4 transform_getInput(sampler2D texSampler, vec2 size) {
  vec2 texCoord = transform_getTexCoord(size);
  vec4 textureColor = texture2D(texSampler, texCoord);
  return textureColor;
}
`;
const transform = {
  name: 'transform',
  vs,
  fs: null
};
exports.transform = transform;
},{}],"node_modules/@luma.gl/shadertools/dist/esm/modules/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "_transform", {
  enumerable: true,
  get: function () {
    return _transform.transform;
  }
});
Object.defineProperty(exports, "_warp", {
  enumerable: true,
  get: function () {
    return _warp.warp;
  }
});
Object.defineProperty(exports, "brightnessContrast", {
  enumerable: true,
  get: function () {
    return _brightnesscontrast.brightnessContrast;
  }
});
Object.defineProperty(exports, "bulgePinch", {
  enumerable: true,
  get: function () {
    return _bulgepinch.bulgePinch;
  }
});
Object.defineProperty(exports, "colorHalftone", {
  enumerable: true,
  get: function () {
    return _colorhalftone.colorHalftone;
  }
});
Object.defineProperty(exports, "denoise", {
  enumerable: true,
  get: function () {
    return _denoise.denoise;
  }
});
Object.defineProperty(exports, "dirlight", {
  enumerable: true,
  get: function () {
    return _dirlight.dirlight;
  }
});
Object.defineProperty(exports, "dotScreen", {
  enumerable: true,
  get: function () {
    return _dotscreen.dotScreen;
  }
});
Object.defineProperty(exports, "edgeWork", {
  enumerable: true,
  get: function () {
    return _edgework.edgeWork;
  }
});
Object.defineProperty(exports, "fp32", {
  enumerable: true,
  get: function () {
    return _fp.fp32;
  }
});
Object.defineProperty(exports, "fp64", {
  enumerable: true,
  get: function () {
    return _fp2.fp64;
  }
});
Object.defineProperty(exports, "fp64arithmetic", {
  enumerable: true,
  get: function () {
    return _fp2.fp64arithmetic;
  }
});
Object.defineProperty(exports, "fxaa", {
  enumerable: true,
  get: function () {
    return _fxaa.fxaa;
  }
});
Object.defineProperty(exports, "gouraudLighting", {
  enumerable: true,
  get: function () {
    return _phongLighting.gouraudLighting;
  }
});
Object.defineProperty(exports, "hexagonalPixelate", {
  enumerable: true,
  get: function () {
    return _hexagonalpixelate.hexagonalPixelate;
  }
});
Object.defineProperty(exports, "hueSaturation", {
  enumerable: true,
  get: function () {
    return _huesaturation.hueSaturation;
  }
});
Object.defineProperty(exports, "ink", {
  enumerable: true,
  get: function () {
    return _ink.ink;
  }
});
Object.defineProperty(exports, "lights", {
  enumerable: true,
  get: function () {
    return _lights.lights;
  }
});
Object.defineProperty(exports, "magnify", {
  enumerable: true,
  get: function () {
    return _magnify.magnify;
  }
});
Object.defineProperty(exports, "noise", {
  enumerable: true,
  get: function () {
    return _noise.noise;
  }
});
Object.defineProperty(exports, "pbr", {
  enumerable: true,
  get: function () {
    return _pbr.pbr;
  }
});
Object.defineProperty(exports, "phongLighting", {
  enumerable: true,
  get: function () {
    return _phongLighting.phongLighting;
  }
});
Object.defineProperty(exports, "picking", {
  enumerable: true,
  get: function () {
    return _picking.picking;
  }
});
Object.defineProperty(exports, "project", {
  enumerable: true,
  get: function () {
    return _project.project;
  }
});
Object.defineProperty(exports, "random", {
  enumerable: true,
  get: function () {
    return _random.random;
  }
});
Object.defineProperty(exports, "sepia", {
  enumerable: true,
  get: function () {
    return _sepia.sepia;
  }
});
Object.defineProperty(exports, "swirl", {
  enumerable: true,
  get: function () {
    return _swirl.swirl;
  }
});
Object.defineProperty(exports, "tiltShift", {
  enumerable: true,
  get: function () {
    return _tiltshift.tiltShift;
  }
});
Object.defineProperty(exports, "triangleBlur", {
  enumerable: true,
  get: function () {
    return _triangleblur.triangleBlur;
  }
});
Object.defineProperty(exports, "vibrance", {
  enumerable: true,
  get: function () {
    return _vibrance.vibrance;
  }
});
Object.defineProperty(exports, "vignette", {
  enumerable: true,
  get: function () {
    return _vignette.vignette;
  }
});
Object.defineProperty(exports, "zoomBlur", {
  enumerable: true,
  get: function () {
    return _zoomblur.zoomBlur;
  }
});

var _random = require("./utils/random");

var _fp = require("./fp32/fp32");

var _fp2 = require("./fp64/fp64");

var _project = require("./project/project");

var _lights = require("./lights/lights");

var _dirlight = require("./dirlight/dirlight");

var _picking = require("./picking/picking");

var _phongLighting = require("./phong-lighting/phong-lighting");

var _pbr = require("./pbr/pbr");

var _tiltshift = require("./image-blur-filters/tiltshift");

var _triangleblur = require("./image-blur-filters/triangleblur");

var _zoomblur = require("./image-blur-filters/zoomblur");

var _brightnesscontrast = require("./image-adjust-filters/brightnesscontrast");

var _denoise = require("./image-adjust-filters/denoise");

var _huesaturation = require("./image-adjust-filters/huesaturation");

var _noise = require("./image-adjust-filters/noise");

var _sepia = require("./image-adjust-filters/sepia");

var _vibrance = require("./image-adjust-filters/vibrance");

var _vignette = require("./image-adjust-filters/vignette");

var _colorhalftone = require("./image-fun-filters/colorhalftone");

var _dotscreen = require("./image-fun-filters/dotscreen");

var _edgework = require("./image-fun-filters/edgework");

var _hexagonalpixelate = require("./image-fun-filters/hexagonalpixelate");

var _ink = require("./image-fun-filters/ink");

var _magnify = require("./image-fun-filters/magnify");

var _bulgepinch = require("./image-warp-filters/bulgepinch");

var _swirl = require("./image-warp-filters/swirl");

var _warp = require("./image-warp-filters/warp");

var _fxaa = require("./fxaa/fxaa");

var _transform = require("./transform/transform");
},{"./utils/random":"node_modules/@luma.gl/shadertools/dist/esm/modules/utils/random.js","./fp32/fp32":"node_modules/@luma.gl/shadertools/dist/esm/modules/fp32/fp32.js","./fp64/fp64":"node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64.js","./project/project":"node_modules/@luma.gl/shadertools/dist/esm/modules/project/project.js","./lights/lights":"node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.js","./dirlight/dirlight":"node_modules/@luma.gl/shadertools/dist/esm/modules/dirlight/dirlight.js","./picking/picking":"node_modules/@luma.gl/shadertools/dist/esm/modules/picking/picking.js","./phong-lighting/phong-lighting":"node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.js","./pbr/pbr":"node_modules/@luma.gl/shadertools/dist/esm/modules/pbr/pbr.js","./image-blur-filters/tiltshift":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-blur-filters/tiltshift.js","./image-blur-filters/triangleblur":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-blur-filters/triangleblur.js","./image-blur-filters/zoomblur":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-blur-filters/zoomblur.js","./image-adjust-filters/brightnesscontrast":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/brightnesscontrast.js","./image-adjust-filters/denoise":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/denoise.js","./image-adjust-filters/huesaturation":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/huesaturation.js","./image-adjust-filters/noise":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/noise.js","./image-adjust-filters/sepia":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/sepia.js","./image-adjust-filters/vibrance":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/vibrance.js","./image-adjust-filters/vignette":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/vignette.js","./image-fun-filters/colorhalftone":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/colorhalftone.js","./image-fun-filters/dotscreen":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/dotscreen.js","./image-fun-filters/edgework":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/edgework.js","./image-fun-filters/hexagonalpixelate":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/hexagonalpixelate.js","./image-fun-filters/ink":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/ink.js","./image-fun-filters/magnify":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/magnify.js","./image-warp-filters/bulgepinch":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-warp-filters/bulgepinch.js","./image-warp-filters/swirl":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-warp-filters/swirl.js","./image-warp-filters/warp":"node_modules/@luma.gl/shadertools/dist/esm/modules/image-warp-filters/warp.js","./fxaa/fxaa":"node_modules/@luma.gl/shadertools/dist/esm/modules/fxaa/fxaa.js","./transform/transform":"node_modules/@luma.gl/shadertools/dist/esm/modules/transform/transform.js"}],"node_modules/@luma.gl/shadertools/dist/esm/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  assembleShaders: true,
  combineInjects: true,
  normalizeShaderModule: true,
  getQualifierDetails: true,
  getPassthroughFS: true,
  typeToChannelSuffix: true,
  typeToChannelCount: true,
  convertToVec4: true
};
Object.defineProperty(exports, "assembleShaders", {
  enumerable: true,
  get: function () {
    return _assembleShaders.assembleShaders;
  }
});
Object.defineProperty(exports, "combineInjects", {
  enumerable: true,
  get: function () {
    return _injectShader.combineInjects;
  }
});
Object.defineProperty(exports, "convertToVec4", {
  enumerable: true,
  get: function () {
    return _shaderUtils.convertToVec4;
  }
});
Object.defineProperty(exports, "getPassthroughFS", {
  enumerable: true,
  get: function () {
    return _shaderUtils.getPassthroughFS;
  }
});
Object.defineProperty(exports, "getQualifierDetails", {
  enumerable: true,
  get: function () {
    return _shaderUtils.getQualifierDetails;
  }
});
Object.defineProperty(exports, "normalizeShaderModule", {
  enumerable: true,
  get: function () {
    return _shaderModule.normalizeShaderModule;
  }
});
Object.defineProperty(exports, "typeToChannelCount", {
  enumerable: true,
  get: function () {
    return _shaderUtils.typeToChannelCount;
  }
});
Object.defineProperty(exports, "typeToChannelSuffix", {
  enumerable: true,
  get: function () {
    return _shaderUtils.typeToChannelSuffix;
  }
});

var _assembleShaders = require("./lib/assemble-shaders");

var _injectShader = require("./lib/inject-shader");

var _shaderModule = require("./lib/shader-module");

var _shaderUtils = require("./utils/shader-utils");

var _modules = require("./modules");

Object.keys(_modules).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _modules[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _modules[key];
    }
  });
});
},{"./lib/assemble-shaders":"node_modules/@luma.gl/shadertools/dist/esm/lib/assemble-shaders.js","./lib/inject-shader":"node_modules/@luma.gl/shadertools/dist/esm/lib/inject-shader.js","./lib/shader-module":"node_modules/@luma.gl/shadertools/dist/esm/lib/shader-module.js","./utils/shader-utils":"node_modules/@luma.gl/shadertools/dist/esm/utils/shader-utils.js","./modules":"node_modules/@luma.gl/shadertools/dist/esm/modules/index.js"}],"node_modules/@luma.gl/engine/dist/esm/lib/program-manager.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _shadertools = require("@luma.gl/shadertools");

var _webgl = require("@luma.gl/webgl");

class ProgramManager {
  static getDefaultProgramManager(gl) {
    gl.luma = gl.luma || {};
    gl.luma.defaultProgramManager = gl.luma.defaultProgramManager || new ProgramManager(gl);
    return gl.luma.defaultProgramManager;
  }

  constructor(gl) {
    this.gl = gl;
    this._programCache = {};
    this._getUniforms = {};
    this._registeredModules = {};
    this._hookFunctions = [];
    this._defaultModules = [];
    this._hashes = {};
    this._hashCounter = 0;
    this.stateHash = 0;
    this._useCounts = {};
  }

  addDefaultModule(module) {
    if (!this._defaultModules.find(m => m.name === module.name)) {
      this._defaultModules.push(module);
    }

    this.stateHash++;
  }

  removeDefaultModule(module) {
    const moduleName = typeof module === 'string' ? module : module.name;
    this._defaultModules = this._defaultModules.filter(m => m.name !== moduleName);
    this.stateHash++;
  }

  addShaderHook(hook, opts) {
    if (opts) {
      hook = Object.assign(opts, {
        hook
      });
    }

    this._hookFunctions.push(hook);

    this.stateHash++;
  }

  get(props = {}) {
    const {
      vs = '',
      fs = '',
      defines = {},
      inject = {},
      varyings = [],
      bufferMode = 0x8c8d,
      transpileToGLSL100 = false
    } = props;

    const modules = this._getModuleList(props.modules);

    const vsHash = this._getHash(vs);

    const fsHash = this._getHash(fs);

    const moduleHashes = modules.map(m => this._getHash(m.name)).sort();
    const varyingHashes = varyings.map(v => this._getHash(v));
    const defineKeys = Object.keys(defines).sort();
    const injectKeys = Object.keys(inject).sort();
    const defineHashes = [];
    const injectHashes = [];

    for (const key of defineKeys) {
      defineHashes.push(this._getHash(key));
      defineHashes.push(this._getHash(defines[key]));
    }

    for (const key of injectKeys) {
      injectHashes.push(this._getHash(key));
      injectHashes.push(this._getHash(inject[key]));
    }

    const hash = `${vsHash}/${fsHash}D${defineHashes.join('/')}M${moduleHashes.join('/')}I${injectHashes.join('/')}V${varyingHashes.join('/')}H${this.stateHash}B${bufferMode}${transpileToGLSL100 ? 'T' : ''}`;

    if (!this._programCache[hash]) {
      const assembled = (0, _shadertools.assembleShaders)(this.gl, {
        vs,
        fs,
        modules,
        inject,
        defines,
        hookFunctions: this._hookFunctions,
        transpileToGLSL100
      });
      this._programCache[hash] = new _webgl.Program(this.gl, {
        hash,
        vs: assembled.vs,
        fs: assembled.fs,
        varyings,
        bufferMode
      });

      this._getUniforms[hash] = assembled.getUniforms || (x => {});

      this._useCounts[hash] = 0;
    }

    this._useCounts[hash]++;
    return this._programCache[hash];
  }

  getUniforms(program) {
    return this._getUniforms[program.hash] || null;
  }

  release(program) {
    const hash = program.hash;
    this._useCounts[hash]--;

    if (this._useCounts[hash] === 0) {
      this._programCache[hash].delete();

      delete this._programCache[hash];
      delete this._getUniforms[hash];
      delete this._useCounts[hash];
    }
  }

  _getHash(key) {
    if (this._hashes[key] === undefined) {
      this._hashes[key] = this._hashCounter++;
    }

    return this._hashes[key];
  }

  _getModuleList(appModules = []) {
    const modules = new Array(this._defaultModules.length + appModules.length);
    const seen = {};
    let count = 0;

    for (let i = 0, len = this._defaultModules.length; i < len; ++i) {
      const module = this._defaultModules[i];
      const name = module.name;
      modules[count++] = module;
      seen[name] = true;
    }

    for (let i = 0, len = appModules.length; i < len; ++i) {
      const module = appModules[i];
      const name = module.name;

      if (!seen[name]) {
        modules[count++] = module;
        seen[name] = true;
      }
    }

    modules.length = count;
    return modules;
  }

}

exports.default = ProgramManager;
},{"@luma.gl/shadertools":"node_modules/@luma.gl/shadertools/dist/esm/index.js","@luma.gl/webgl":"node_modules/@luma.gl/webgl/dist/esm/index.js"}],"node_modules/@luma.gl/engine/dist/esm/lib/model-utils.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getBuffersFromGeometry = getBuffersFromGeometry;
exports.inferAttributeAccessor = inferAttributeAccessor;

var _webgl = require("@luma.gl/webgl");

const GLTF_TO_LUMA_ATTRIBUTE_MAP = {
  POSITION: 'positions',
  NORMAL: 'normals',
  COLOR_0: 'colors',
  TEXCOORD_0: 'texCoords',
  TEXCOORD_1: 'texCoords1',
  TEXCOORD_2: 'texCoords2'
};

function getBuffersFromGeometry(gl, geometry, options) {
  const buffers = {};
  let indices = geometry.indices;

  for (const name in geometry.attributes) {
    const attribute = geometry.attributes[name];
    const remappedName = mapAttributeName(name, options);

    if (name === 'indices') {
      indices = attribute;
    } else if (attribute.constant) {
      buffers[remappedName] = attribute.value;
    } else {
      const typedArray = attribute.value;
      const accessor = { ...attribute
      };
      delete accessor.value;
      buffers[remappedName] = [new _webgl.Buffer(gl, typedArray), accessor];
      inferAttributeAccessor(name, accessor);
    }
  }

  if (indices) {
    const data = indices.value || indices;
    (0, _webgl.assert)(data instanceof Uint16Array || data instanceof Uint32Array, 'attribute array for "indices" must be of integer type');
    const accessor = {
      size: 1,
      isIndexed: indices.isIndexed === undefined ? true : indices.isIndexed
    };
    buffers.indices = [new _webgl.Buffer(gl, {
      data,
      target: 34963
    }), accessor];
  }

  return buffers;
}

function mapAttributeName(name, options) {
  const {
    attributeMap = GLTF_TO_LUMA_ATTRIBUTE_MAP
  } = options || {};
  return attributeMap && attributeMap[name] || name;
}

function inferAttributeAccessor(attributeName, attribute) {
  let category;

  switch (attributeName) {
    case 'texCoords':
    case 'texCoord1':
    case 'texCoord2':
    case 'texCoord3':
      category = 'uvs';
      break;

    case 'vertices':
    case 'positions':
    case 'normals':
    case 'pickingColors':
      category = 'vectors';
      break;

    default:
  }

  switch (category) {
    case 'vectors':
      attribute.size = attribute.size || 3;
      break;

    case 'uvs':
      attribute.size = attribute.size || 2;
      break;

    default:
  }

  (0, _webgl.assert)(Number.isFinite(attribute.size), `attribute ${attributeName} needs size`);
}
},{"@luma.gl/webgl":"node_modules/@luma.gl/webgl/dist/esm/index.js"}],"node_modules/@luma.gl/engine/dist/esm/lib/model.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _gltools = require("@luma.gl/gltools");

var _programManager = _interopRequireDefault(require("./program-manager"));

var _webgl = require("@luma.gl/webgl");

var _modelUtils = require("./model-utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const LOG_DRAW_PRIORITY = 2;
const LOG_DRAW_TIMEOUT = 10000;
const ERR_MODEL_PARAMS = 'Model needs drawMode and vertexCount';

const NOOP = () => {};

const DRAW_PARAMS = {};

class Model {
  constructor(gl, props = {}) {
    const {
      id = (0, _webgl.uid)('model')
    } = props;
    (0, _webgl.assert)((0, _gltools.isWebGL)(gl));
    this.id = id;
    this.gl = gl;
    this.id = props.id || (0, _webgl.uid)('Model');
    this.lastLogTime = 0;
    this.animated = false;
    this.initialize(props);
  }

  initialize(props) {
    this.props = {};
    this.programManager = props.programManager || _programManager.default.getDefaultProgramManager(this.gl);
    this._programManagerState = -1;
    this._managedProgram = false;
    const {
      program = null,
      vs,
      fs,
      modules,
      defines,
      inject,
      varyings,
      bufferMode,
      transpileToGLSL100
    } = props;
    this.programProps = {
      program,
      vs,
      fs,
      modules,
      defines,
      inject,
      varyings,
      bufferMode,
      transpileToGLSL100
    };
    this.program = null;
    this.vertexArray = null;
    this._programDirty = true;
    this.userData = {};
    this.needsRedraw = true;
    this._attributes = {};
    this.attributes = {};
    this.uniforms = {};
    this.pickable = true;

    this._checkProgram();

    this.setUniforms(Object.assign({}, this.getModuleUniforms(props.moduleSettings)));
    this.drawMode = props.drawMode !== undefined ? props.drawMode : 4;
    this.vertexCount = props.vertexCount || 0;
    this.geometryBuffers = {};
    this.isInstanced = props.isInstanced || props.instanced || props.instanceCount > 0;

    this._setModelProps(props);

    this.geometry = {};
    (0, _webgl.assert)(this.drawMode !== undefined && Number.isFinite(this.vertexCount), ERR_MODEL_PARAMS);
  }

  setProps(props) {
    this._setModelProps(props);
  }

  delete() {
    for (const key in this._attributes) {
      if (this._attributes[key] !== this.attributes[key]) {
        this._attributes[key].delete();
      }
    }

    if (this._managedProgram) {
      this.programManager.release(this.program);
      this._managedProgram = false;
    }

    this.vertexArray.delete();

    this._deleteGeometryBuffers();
  }

  getDrawMode() {
    return this.drawMode;
  }

  getVertexCount() {
    return this.vertexCount;
  }

  getInstanceCount() {
    return this.instanceCount;
  }

  getAttributes() {
    return this.attributes;
  }

  getProgram() {
    return this.program;
  }

  setProgram(props) {
    const {
      program,
      vs,
      fs,
      modules,
      defines,
      inject,
      varyings,
      bufferMode,
      transpileToGLSL100
    } = props;
    this.programProps = {
      program,
      vs,
      fs,
      modules,
      defines,
      inject,
      varyings,
      bufferMode,
      transpileToGLSL100
    };
    this._programDirty = true;
  }

  getUniforms() {
    return this.uniforms;
  }

  setDrawMode(drawMode) {
    this.drawMode = drawMode;
    return this;
  }

  setVertexCount(vertexCount) {
    (0, _webgl.assert)(Number.isFinite(vertexCount));
    this.vertexCount = vertexCount;
    return this;
  }

  setInstanceCount(instanceCount) {
    (0, _webgl.assert)(Number.isFinite(instanceCount));
    this.instanceCount = instanceCount;
    return this;
  }

  setGeometry(geometry) {
    this.drawMode = geometry.drawMode;
    this.vertexCount = geometry.getVertexCount();

    this._deleteGeometryBuffers();

    this.geometryBuffers = (0, _modelUtils.getBuffersFromGeometry)(this.gl, geometry);
    this.vertexArray.setAttributes(this.geometryBuffers);
    return this;
  }

  setAttributes(attributes = {}) {
    if ((0, _webgl.isObjectEmpty)(attributes)) {
      return this;
    }

    const normalizedAttributes = {};

    for (const name in attributes) {
      const attribute = attributes[name];
      normalizedAttributes[name] = attribute.getValue ? attribute.getValue() : attribute;
    }

    this.vertexArray.setAttributes(normalizedAttributes);
    return this;
  }

  setUniforms(uniforms = {}) {
    Object.assign(this.uniforms, uniforms);
    return this;
  }

  getModuleUniforms(opts) {
    this._checkProgram();

    const getUniforms = this.programManager.getUniforms(this.program);

    if (getUniforms) {
      return getUniforms(opts);
    }

    return {};
  }

  updateModuleSettings(opts) {
    const uniforms = this.getModuleUniforms(opts || {});
    return this.setUniforms(uniforms);
  }

  clear(opts) {
    (0, _webgl.clear)(this.program.gl, opts);
    return this;
  }

  draw(opts = {}) {
    this._checkProgram();

    const {
      moduleSettings = null,
      framebuffer,
      uniforms = {},
      attributes = {},
      transformFeedback = this.transformFeedback,
      parameters = {},
      vertexArray = this.vertexArray
    } = opts;
    this.setAttributes(attributes);
    this.updateModuleSettings(moduleSettings);
    this.setUniforms(uniforms);
    let logPriority;

    if (_webgl.log.priority >= LOG_DRAW_PRIORITY) {
      logPriority = this._logDrawCallStart(LOG_DRAW_PRIORITY);
    }

    const drawParams = this.vertexArray.getDrawParams();
    const {
      isIndexed = drawParams.isIndexed,
      indexType = drawParams.indexType,
      indexOffset = drawParams.indexOffset,
      vertexArrayInstanced = drawParams.isInstanced
    } = this.props;

    if (vertexArrayInstanced && !this.isInstanced) {
      _webgl.log.warn('Found instanced attributes on non-instanced model', this.id)();
    }

    const {
      isInstanced,
      instanceCount
    } = this;
    const {
      onBeforeRender = NOOP,
      onAfterRender = NOOP
    } = this.props;
    onBeforeRender();
    this.program.setUniforms(this.uniforms);
    const didDraw = this.program.draw(Object.assign(DRAW_PARAMS, opts, {
      logPriority,
      uniforms: null,
      framebuffer,
      parameters,
      drawMode: this.getDrawMode(),
      vertexCount: this.getVertexCount(),
      vertexArray,
      transformFeedback,
      isIndexed,
      indexType,
      isInstanced,
      instanceCount,
      offset: isIndexed ? indexOffset : 0
    }));
    onAfterRender();

    if (_webgl.log.priority >= LOG_DRAW_PRIORITY) {
      this._logDrawCallEnd(logPriority, vertexArray, framebuffer);
    }

    return didDraw;
  }

  transform(opts = {}) {
    const {
      discard = true,
      feedbackBuffers,
      unbindModels = []
    } = opts;
    let {
      parameters
    } = opts;

    if (feedbackBuffers) {
      this._setFeedbackBuffers(feedbackBuffers);
    }

    if (discard) {
      parameters = Object.assign({}, parameters, {
        [35977]: discard
      });
    }

    unbindModels.forEach(model => model.vertexArray.unbindBuffers());

    try {
      this.draw(Object.assign({}, opts, {
        parameters
      }));
    } finally {
      unbindModels.forEach(model => model.vertexArray.bindBuffers());
    }

    return this;
  }

  render(uniforms = {}) {
    _webgl.log.warn('Model.render() is deprecated. Use Model.setUniforms() and Model.draw()')();

    return this.setUniforms(uniforms).draw();
  }

  _setModelProps(props) {
    Object.assign(this.props, props);

    if ('uniforms' in props) {
      this.setUniforms(props.uniforms);
    }

    if ('pickable' in props) {
      this.pickable = props.pickable;
    }

    if ('instanceCount' in props) {
      this.instanceCount = props.instanceCount;
    }

    if ('geometry' in props) {
      this.setGeometry(props.geometry);
    }

    if ('attributes' in props) {
      this.setAttributes(props.attributes);
    }

    if ('_feedbackBuffers' in props) {
      this._setFeedbackBuffers(props._feedbackBuffers);
    }
  }

  _checkProgram() {
    const needsUpdate = this._programDirty || this.programManager.stateHash !== this._programManagerState;

    if (!needsUpdate) {
      return;
    }

    let {
      program
    } = this.programProps;

    if (program) {
      this._managedProgram = false;
    } else {
      const {
        vs,
        fs,
        modules,
        inject,
        defines,
        varyings,
        bufferMode,
        transpileToGLSL100
      } = this.programProps;
      program = this.programManager.get({
        vs,
        fs,
        modules,
        inject,
        defines,
        varyings,
        bufferMode,
        transpileToGLSL100
      });

      if (this.program && this._managedProgram) {
        this.programManager.release(this.program);
      }

      this._programManagerState = this.programManager.stateHash;
      this._managedProgram = true;
    }

    (0, _webgl.assert)(program instanceof _webgl.Program, 'Model needs a program');
    this._programDirty = false;

    if (program === this.program) {
      return;
    }

    this.program = program;

    if (this.vertexArray) {
      this.vertexArray.setProps({
        program: this.program,
        attributes: this.vertexArray.attributes
      });
    } else {
      this.vertexArray = new _webgl.VertexArray(this.gl, {
        program: this.program
      });
    }

    this.setUniforms(Object.assign({}, this.getModuleUniforms()));
  }

  _deleteGeometryBuffers() {
    for (const name in this.geometryBuffers) {
      const buffer = this.geometryBuffers[name][0] || this.geometryBuffers[name];

      if (buffer instanceof _webgl.Buffer) {
        buffer.delete();
      }
    }
  }

  _setAnimationProps(animationProps) {
    if (this.animated) {
      (0, _webgl.assert)(animationProps, 'Model.draw(): animated uniforms but no animationProps');
    }
  }

  _setFeedbackBuffers(feedbackBuffers = {}) {
    if ((0, _webgl.isObjectEmpty)(feedbackBuffers)) {
      return this;
    }

    const {
      gl
    } = this.program;
    this.transformFeedback = this.transformFeedback || new _webgl.TransformFeedback(gl, {
      program: this.program
    });
    this.transformFeedback.setBuffers(feedbackBuffers);
    return this;
  }

  _logDrawCallStart(logLevel) {
    const logDrawTimeout = logLevel > 3 ? 0 : LOG_DRAW_TIMEOUT;

    if (Date.now() - this.lastLogTime < logDrawTimeout) {
      return undefined;
    }

    this.lastLogTime = Date.now();

    _webgl.log.group(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`, {
      collapsed: _webgl.log.level <= 2
    })();

    return logLevel;
  }

  _logDrawCallEnd(logLevel, vertexArray, uniforms, framebuffer) {
    if (logLevel === undefined) {
      return;
    }

    const attributeTable = (0, _webgl.getDebugTableForVertexArray)({
      vertexArray,
      header: `${this.id} attributes`,
      attributes: this._attributes
    });
    const {
      table: uniformTable,
      unusedTable,
      unusedCount
    } = (0, _webgl.getDebugTableForUniforms)({
      header: `${this.id} uniforms`,
      program: this.program,
      uniforms: Object.assign({}, this.program.uniforms, uniforms)
    });
    const {
      table: missingTable,
      count: missingCount
    } = (0, _webgl.getDebugTableForUniforms)({
      header: `${this.id} uniforms`,
      program: this.program,
      uniforms: Object.assign({}, this.program.uniforms, uniforms),
      undefinedOnly: true
    });

    if (missingCount > 0) {
      _webgl.log.log('MISSING UNIFORMS', Object.keys(missingTable))();
    }

    if (unusedCount > 0) {
      _webgl.log.log('UNUSED UNIFORMS', Object.keys(unusedTable))();
    }

    const configTable = (0, _webgl.getDebugTableForProgramConfiguration)(this.vertexArray.configuration);

    _webgl.log.table(logLevel, attributeTable)();

    _webgl.log.table(logLevel, uniformTable)();

    _webgl.log.table(logLevel + 1, configTable)();

    if (framebuffer) {
      framebuffer.log({
        logLevel: LOG_DRAW_PRIORITY,
        message: `Rendered to ${framebuffer.id}`
      });
    }

    _webgl.log.groupEnd(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`)();
  }

}

exports.default = Model;
},{"@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","./program-manager":"node_modules/@luma.gl/engine/dist/esm/lib/program-manager.js","@luma.gl/webgl":"node_modules/@luma.gl/webgl/dist/esm/index.js","./model-utils":"node_modules/@luma.gl/engine/dist/esm/lib/model-utils.js"}],"node_modules/@luma.gl/engine/dist/esm/transform/buffer-transform.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _gltools = require("@luma.gl/gltools");

var _webgl = require("@luma.gl/webgl");

class BufferTransform {
  constructor(gl, props = {}) {
    this.gl = gl;
    this.currentIndex = 0;
    this.feedbackMap = {};
    this.varyings = null;
    this.bindings = [];
    this.resources = {};

    this._initialize(props);

    Object.seal(this);
  }

  setupResources(opts) {
    for (const binding of this.bindings) {
      this._setupTransformFeedback(binding, opts);
    }
  }

  updateModelProps(props = {}) {
    const {
      varyings
    } = this;

    if (varyings.length > 0) {
      props = Object.assign({}, props, {
        varyings
      });
    }

    return props;
  }

  getDrawOptions(opts = {}) {
    const binding = this.bindings[this.currentIndex];
    const {
      sourceBuffers,
      transformFeedback
    } = binding;
    const attributes = Object.assign({}, sourceBuffers, opts.attributes);
    return {
      attributes,
      transformFeedback
    };
  }

  swap() {
    if (this.feedbackMap) {
      this.currentIndex = this._getNextIndex();
      return true;
    }

    return false;
  }

  update(opts = {}) {
    this._setupBuffers(opts);
  }

  getBuffer(varyingName) {
    const {
      feedbackBuffers
    } = this.bindings[this.currentIndex];
    const bufferOrParams = varyingName ? feedbackBuffers[varyingName] : null;

    if (!bufferOrParams) {
      return null;
    }

    return bufferOrParams instanceof _webgl.Buffer ? bufferOrParams : bufferOrParams.buffer;
  }

  getData(options = {}) {
    const {
      varyingName
    } = options;
    const buffer = this.getBuffer(varyingName);

    if (buffer) {
      return buffer.getData();
    }

    return null;
  }

  delete() {
    for (const name in this.resources) {
      this.resources[name].delete();
    }
  }

  _initialize(props = {}) {
    this._setupBuffers(props);

    this.varyings = props.varyings || Object.keys(this.bindings[this.currentIndex].feedbackBuffers);

    if (this.varyings.length > 0) {
      (0, _webgl.assert)((0, _gltools.isWebGL2)(this.gl));
    }
  }

  _getFeedbackBuffers(props) {
    const {
      sourceBuffers = {}
    } = props;
    const feedbackBuffers = {};

    if (this.bindings[this.currentIndex]) {
      Object.assign(feedbackBuffers, this.bindings[this.currentIndex].feedbackBuffers);
    }

    if (this.feedbackMap) {
      for (const sourceName in this.feedbackMap) {
        const feedbackName = this.feedbackMap[sourceName];

        if (sourceName in sourceBuffers) {
          feedbackBuffers[feedbackName] = sourceName;
        }
      }
    }

    Object.assign(feedbackBuffers, props.feedbackBuffers);

    for (const bufferName in feedbackBuffers) {
      const bufferOrRef = feedbackBuffers[bufferName];

      if (typeof bufferOrRef === 'string') {
        const sourceBuffer = sourceBuffers[bufferOrRef];
        const {
          byteLength,
          usage,
          accessor
        } = sourceBuffer;
        feedbackBuffers[bufferName] = this._createNewBuffer(bufferName, {
          byteLength,
          usage,
          accessor
        });
      }
    }

    return feedbackBuffers;
  }

  _setupBuffers(props = {}) {
    const {
      sourceBuffers = null
    } = props;
    Object.assign(this.feedbackMap, props.feedbackMap);

    const feedbackBuffers = this._getFeedbackBuffers(props);

    this._updateBindings({
      sourceBuffers,
      feedbackBuffers
    });
  }

  _setupTransformFeedback(binding, {
    model
  }) {
    const {
      program
    } = model;
    binding.transformFeedback = new _webgl.TransformFeedback(this.gl, {
      program,
      buffers: binding.feedbackBuffers
    });
  }

  _updateBindings(opts) {
    this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], opts);

    if (this.feedbackMap) {
      const {
        sourceBuffers,
        feedbackBuffers
      } = this._swapBuffers(this.bindings[this.currentIndex]);

      const nextIndex = this._getNextIndex();

      this.bindings[nextIndex] = this._updateBinding(this.bindings[nextIndex], {
        sourceBuffers,
        feedbackBuffers
      });
    }
  }

  _updateBinding(binding, opts) {
    if (!binding) {
      return {
        sourceBuffers: Object.assign({}, opts.sourceBuffers),
        feedbackBuffers: Object.assign({}, opts.feedbackBuffers)
      };
    }

    Object.assign(binding.sourceBuffers, opts.sourceBuffers);
    Object.assign(binding.feedbackBuffers, opts.feedbackBuffers);

    if (binding.transformFeedback) {
      binding.transformFeedback.setBuffers(binding.feedbackBuffers);
    }

    return binding;
  }

  _swapBuffers(opts) {
    if (!this.feedbackMap) {
      return null;
    }

    const sourceBuffers = Object.assign({}, opts.sourceBuffers);
    const feedbackBuffers = Object.assign({}, opts.feedbackBuffers);

    for (const srcName in this.feedbackMap) {
      const dstName = this.feedbackMap[srcName];
      sourceBuffers[srcName] = opts.feedbackBuffers[dstName];
      feedbackBuffers[dstName] = opts.sourceBuffers[srcName];
      (0, _webgl.assert)(feedbackBuffers[dstName] instanceof _webgl.Buffer);
    }

    return {
      sourceBuffers,
      feedbackBuffers
    };
  }

  _createNewBuffer(name, opts) {
    const buffer = new _webgl.Buffer(this.gl, opts);

    if (this.resources[name]) {
      this.resources[name].delete();
    }

    this.resources[name] = buffer;
    return buffer;
  }

  _getNextIndex() {
    return (this.currentIndex + 1) % 2;
  }

}

exports.default = BufferTransform;
},{"@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","@luma.gl/webgl":"node_modules/@luma.gl/webgl/dist/esm/index.js"}],"node_modules/@luma.gl/engine/dist/esm/transform/transform-shader-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSizeUniforms = getSizeUniforms;
exports.getVaryingType = getVaryingType;
exports.processAttributeDefinition = processAttributeDefinition;
exports.updateForTextures = updateForTextures;

var _webgl = require("@luma.gl/webgl");

var _shadertools = require("@luma.gl/shadertools");

const SAMPLER_UNIFORM_PREFIX = 'transform_uSampler_';
const SIZE_UNIFORM_PREFIX = 'transform_uSize_';
const VS_POS_VARIABLE = 'transform_position';

function updateForTextures({
  vs,
  sourceTextureMap,
  targetTextureVarying,
  targetTexture
}) {
  const texAttributeNames = Object.keys(sourceTextureMap);
  let sourceCount = texAttributeNames.length;
  let targetTextureType = null;
  const samplerTextureMap = {};
  let updatedVs = vs;
  let finalInject = {};

  if (sourceCount > 0 || targetTextureVarying) {
    const vsLines = updatedVs.split('\n');
    const updateVsLines = vsLines.slice();
    vsLines.forEach((line, index, lines) => {
      if (sourceCount > 0) {
        const updated = processAttributeDefinition(line, sourceTextureMap);

        if (updated) {
          const {
            updatedLine,
            inject
          } = updated;
          updateVsLines[index] = updatedLine;
          finalInject = (0, _shadertools.combineInjects)([finalInject, inject]);
          Object.assign(samplerTextureMap, updated.samplerTextureMap);
          sourceCount--;
        }
      }

      if (targetTextureVarying && !targetTextureType) {
        targetTextureType = getVaryingType(line, targetTextureVarying);
      }
    });

    if (targetTextureVarying) {
      (0, _webgl.assert)(targetTexture);
      const sizeName = `${SIZE_UNIFORM_PREFIX}${targetTextureVarying}`;
      const uniformDeclaration = `uniform vec2 ${sizeName};\n`;
      const posInstructions = `\
     vec2 ${VS_POS_VARIABLE} = transform_getPos(${sizeName});
     gl_Position = vec4(${VS_POS_VARIABLE}, 0, 1.);\n`;
      const inject = {
        'vs:#decl': uniformDeclaration,
        'vs:#main-start': posInstructions
      };
      finalInject = (0, _shadertools.combineInjects)([finalInject, inject]);
    }

    updatedVs = updateVsLines.join('\n');
  }

  return {
    vs: updatedVs,
    targetTextureType,
    inject: finalInject,
    samplerTextureMap
  };
}

function getSizeUniforms({
  sourceTextureMap,
  targetTextureVarying,
  targetTexture
}) {
  const uniforms = {};
  let width;
  let height;

  if (targetTextureVarying) {
    ({
      width,
      height
    } = targetTexture);
    uniforms[`${SIZE_UNIFORM_PREFIX}${targetTextureVarying}`] = [width, height];
  }

  for (const textureName in sourceTextureMap) {
    ({
      width,
      height
    } = sourceTextureMap[textureName]);
    uniforms[`${SIZE_UNIFORM_PREFIX}${textureName}`] = [width, height];
  }

  return uniforms;
}

function getAttributeDefinition(line) {
  return (0, _shadertools.getQualifierDetails)(line, ['attribute', 'in']);
}

function getSamplerDeclerations(textureName) {
  const samplerName = `${SAMPLER_UNIFORM_PREFIX}${textureName}`;
  const sizeName = `${SIZE_UNIFORM_PREFIX}${textureName}`;
  const uniformDeclerations = `\
  uniform sampler2D ${samplerName};
  uniform vec2 ${sizeName};`;
  return {
    samplerName,
    sizeName,
    uniformDeclerations
  };
}

function getVaryingType(line, varying) {
  const qualaiferDetails = (0, _shadertools.getQualifierDetails)(line, ['varying', 'out']);

  if (!qualaiferDetails) {
    return null;
  }

  return qualaiferDetails.name === varying ? qualaiferDetails.type : null;
}

function processAttributeDefinition(line, textureMap) {
  const samplerTextureMap = {};
  const attributeData = getAttributeDefinition(line);

  if (!attributeData) {
    return null;
  }

  const {
    type,
    name
  } = attributeData;

  if (name && textureMap[name]) {
    const updatedLine = `\// ${line} => Replaced by Transform with a sampler`;
    const {
      samplerName,
      sizeName,
      uniformDeclerations
    } = getSamplerDeclerations(name);
    const channels = (0, _shadertools.typeToChannelSuffix)(type);
    const sampleInstruction = `  ${type} ${name} = transform_getInput(${samplerName}, ${sizeName}).${channels};\n`;
    samplerTextureMap[samplerName] = name;
    const inject = {
      'vs:#decl': uniformDeclerations,
      'vs:#main-start': sampleInstruction
    };
    return {
      updatedLine,
      inject,
      samplerTextureMap
    };
  }

  return null;
}
},{"@luma.gl/webgl":"node_modules/@luma.gl/webgl/dist/esm/index.js","@luma.gl/shadertools":"node_modules/@luma.gl/shadertools/dist/esm/index.js"}],"node_modules/@luma.gl/engine/dist/esm/transform/texture-transform.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _webgl = require("@luma.gl/webgl");

var _shadertools = require("@luma.gl/shadertools");

var _transformShaderUtils = require("./transform-shader-utils");

const SRC_TEX_PARAMETER_OVERRIDES = {
  [10241]: 9728,
  [10240]: 9728,
  [10242]: 33071,
  [10243]: 33071
};
const FS_OUTPUT_VARIABLE = 'transform_output';

class TextureTransform {
  constructor(gl, props = {}) {
    this.gl = gl;
    this.id = this.currentIndex = 0;
    this._swapTexture = null;
    this.targetTextureVarying = null;
    this.targetTextureType = null;
    this.samplerTextureMap = null;
    this.bindings = [];
    this.resources = {};

    this._initialize(props);

    Object.seal(this);
  }

  updateModelProps(props = {}) {
    const updatedModelProps = this._processVertexShader(props);

    return Object.assign({}, props, updatedModelProps);
  }

  getDrawOptions(opts = {}) {
    const {
      sourceBuffers,
      sourceTextures,
      framebuffer,
      targetTexture
    } = this.bindings[this.currentIndex];
    const attributes = Object.assign({}, sourceBuffers, opts.attributes);
    const uniforms = Object.assign({}, opts.uniforms);
    const parameters = Object.assign({}, opts.parameters);
    let discard = opts.discard;

    if (this.hasSourceTextures || this.hasTargetTexture) {
      attributes.transform_elementID = this.elementIDBuffer;

      for (const sampler in this.samplerTextureMap) {
        const textureName = this.samplerTextureMap[sampler];
        uniforms[sampler] = sourceTextures[textureName];
      }

      this._setSourceTextureParameters();

      const sizeUniforms = (0, _transformShaderUtils.getSizeUniforms)({
        sourceTextureMap: sourceTextures,
        targetTextureVarying: this.targetTextureVarying,
        targetTexture
      });
      Object.assign(uniforms, sizeUniforms);
    }

    if (this.hasTargetTexture) {
      discard = false;
      parameters.viewport = [0, 0, framebuffer.width, framebuffer.height];
    }

    return {
      attributes,
      framebuffer,
      uniforms,
      discard,
      parameters
    };
  }

  swap() {
    if (this._swapTexture) {
      this.currentIndex = this._getNextIndex();
      return true;
    }

    return false;
  }

  update(opts = {}) {
    this._setupTextures(opts);
  }

  getTargetTexture() {
    const {
      targetTexture
    } = this.bindings[this.currentIndex];
    return targetTexture;
  }

  getData({
    packed = false
  } = {}) {
    const {
      framebuffer
    } = this.bindings[this.currentIndex];
    const pixels = (0, _webgl.readPixelsToArray)(framebuffer);

    if (!packed) {
      return pixels;
    }

    const ArrayType = pixels.constructor;
    const channelCount = (0, _shadertools.typeToChannelCount)(this.targetTextureType);
    const packedPixels = new ArrayType(pixels.length * channelCount / 4);
    let packCount = 0;

    for (let i = 0; i < pixels.length; i += 4) {
      for (let j = 0; j < channelCount; j++) {
        packedPixels[packCount++] = pixels[i + j];
      }
    }

    return packedPixels;
  }

  getFramebuffer() {
    const currentResources = this.bindings[this.currentIndex];
    return currentResources.framebuffer;
  }

  delete() {
    if (this.ownTexture) {
      this.ownTexture.delete();
    }

    if (this.elementIDBuffer) {
      this.elementIDBuffer.delete();
    }
  }

  _initialize(props = {}) {
    const {
      _targetTextureVarying,
      _swapTexture
    } = props;
    this._swapTexture = _swapTexture;
    this.targetTextureVarying = _targetTextureVarying;
    this.hasTargetTexture = _targetTextureVarying;

    this._setupTextures(props);
  }

  _createTargetTexture(props) {
    const {
      sourceTextures,
      textureOrReference
    } = props;

    if (textureOrReference instanceof _webgl.Texture2D) {
      return textureOrReference;
    }

    const refTexture = sourceTextures[textureOrReference];

    if (!refTexture) {
      return null;
    }

    this._targetRefTexName = textureOrReference;
    return this._createNewTexture(refTexture);
  }

  _setupTextures(props = {}) {
    const {
      sourceBuffers,
      _sourceTextures = {},
      _targetTexture
    } = props;

    const targetTexture = this._createTargetTexture({
      sourceTextures: _sourceTextures,
      textureOrReference: _targetTexture
    });

    this.hasSourceTextures = this.hasSourceTextures || _sourceTextures && Object.keys(_sourceTextures).length > 0;

    this._updateBindings({
      sourceBuffers,
      sourceTextures: _sourceTextures,
      targetTexture
    });

    if ('elementCount' in props) {
      this._updateElementIDBuffer(props.elementCount);
    }
  }

  _updateElementIDBuffer(elementCount) {
    if (typeof elementCount !== 'number' || this.elementCount >= elementCount) {
      return;
    }

    const elementIds = new Float32Array(elementCount);
    elementIds.forEach((_, index, array) => {
      array[index] = index;
    });

    if (!this.elementIDBuffer) {
      this.elementIDBuffer = new _webgl.Buffer(this.gl, {
        data: elementIds,
        accessor: {
          size: 1
        }
      });
    } else {
      this.elementIDBuffer.setData({
        data: elementIds
      });
    }

    this.elementCount = elementCount;
  }

  _updateBindings(opts) {
    this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], opts);

    if (this._swapTexture) {
      const {
        sourceTextures,
        targetTexture
      } = this._swapTextures(this.bindings[this.currentIndex]);

      const nextIndex = this._getNextIndex();

      this.bindings[nextIndex] = this._updateBinding(this.bindings[nextIndex], {
        sourceTextures,
        targetTexture
      });
    }
  }

  _updateBinding(binding, opts) {
    const {
      sourceBuffers,
      sourceTextures,
      targetTexture
    } = opts;

    if (!binding) {
      binding = {
        sourceBuffers: {},
        sourceTextures: {},
        targetTexture: null
      };
    }

    Object.assign(binding.sourceTextures, sourceTextures);
    Object.assign(binding.sourceBuffers, sourceBuffers);

    if (targetTexture) {
      binding.targetTexture = targetTexture;
      const {
        width,
        height
      } = targetTexture;
      const {
        framebuffer
      } = binding;

      if (framebuffer) {
        framebuffer.update({
          attachments: {
            [36064]: targetTexture
          },
          resizeAttachments: false
        });
        framebuffer.resize({
          width,
          height
        });
      } else {
        binding.framebuffer = new _webgl.Framebuffer(this.gl, {
          id: `transform-framebuffer`,
          width,
          height,
          attachments: {
            [36064]: targetTexture
          }
        });
      }
    }

    return binding;
  }

  _setSourceTextureParameters() {
    const index = this.currentIndex;
    const {
      sourceTextures
    } = this.bindings[index];

    for (const name in sourceTextures) {
      sourceTextures[name].setParameters(SRC_TEX_PARAMETER_OVERRIDES);
    }
  }

  _swapTextures(opts) {
    if (!this._swapTexture) {
      return null;
    }

    const sourceTextures = Object.assign({}, opts.sourceTextures);
    sourceTextures[this._swapTexture] = opts.targetTexture;
    const targetTexture = opts.sourceTextures[this._swapTexture];
    return {
      sourceTextures,
      targetTexture
    };
  }

  _createNewTexture(refTexture) {
    const texture = (0, _webgl.cloneTextureFrom)(refTexture, {
      parameters: {
        [10241]: 9728,
        [10240]: 9728,
        [10242]: 33071,
        [10243]: 33071
      },
      pixelStore: {
        [37440]: false
      }
    });

    if (this.ownTexture) {
      this.ownTexture.delete();
    }

    this.ownTexture = texture;
    return texture;
  }

  _getNextIndex() {
    return (this.currentIndex + 1) % 2;
  }

  _processVertexShader(props = {}) {
    const {
      sourceTextures,
      targetTexture
    } = this.bindings[this.currentIndex];
    const {
      vs,
      uniforms,
      targetTextureType,
      inject,
      samplerTextureMap
    } = (0, _transformShaderUtils.updateForTextures)({
      vs: props.vs,
      sourceTextureMap: sourceTextures,
      targetTextureVarying: this.targetTextureVarying,
      targetTexture
    });
    const combinedInject = (0, _shadertools.combineInjects)([props.inject || {}, inject]);
    this.targetTextureType = targetTextureType;
    this.samplerTextureMap = samplerTextureMap;
    const fs = props._fs || (0, _shadertools.getPassthroughFS)({
      version: (0, _webgl.getShaderVersion)(vs),
      input: this.targetTextureVarying,
      inputType: targetTextureType,
      output: FS_OUTPUT_VARIABLE
    });
    const modules = this.hasSourceTextures || this.targetTextureVarying ? [_shadertools._transform].concat(props.modules || []) : props.modules;
    return {
      vs,
      fs,
      modules,
      uniforms,
      inject: combinedInject
    };
  }

}

exports.default = TextureTransform;
},{"@luma.gl/webgl":"node_modules/@luma.gl/webgl/dist/esm/index.js","@luma.gl/shadertools":"node_modules/@luma.gl/shadertools/dist/esm/index.js","./transform-shader-utils":"node_modules/@luma.gl/engine/dist/esm/transform/transform-shader-utils.js"}],"node_modules/@luma.gl/engine/dist/esm/transform/transform.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _shadertools = require("@luma.gl/shadertools");

var _bufferTransform = _interopRequireDefault(require("./buffer-transform"));

var _textureTransform = _interopRequireDefault(require("./texture-transform"));

var _gltools = require("@luma.gl/gltools");

var _webgl = require("@luma.gl/webgl");

var _model = _interopRequireDefault(require("../lib/model"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class Transform {
  static isSupported(gl) {
    return (0, _gltools.isWebGL2)(gl);
  }

  constructor(gl, props = {}) {
    this.gl = gl;
    this.model = null;
    this.elementCount = 0;
    this.bufferTransform = null;
    this.textureTransform = null;
    this.elementIDBuffer = null;

    this._initialize(props);

    Object.seal(this);
  }

  delete() {
    const {
      model,
      bufferTransform,
      textureTransform
    } = this;

    if (model) {
      model.delete();
    }

    if (bufferTransform) {
      bufferTransform.delete();
    }

    if (textureTransform) {
      textureTransform.delete();
    }
  }

  run(opts = {}) {
    const {
      clearRenderTarget = true
    } = opts;

    const updatedOpts = this._updateDrawOptions(opts);

    if (clearRenderTarget && updatedOpts.framebuffer) {
      updatedOpts.framebuffer.clear({
        color: true
      });
    }

    this.model.transform(updatedOpts);
  }

  swap() {
    let swapped = false;
    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);

    for (const resourceTransform of resourceTransforms) {
      swapped = swapped || resourceTransform.swap();
    }

    (0, _webgl.assert)(swapped, 'Nothing to swap');
  }

  getBuffer(varyingName = null) {
    return this.bufferTransform && this.bufferTransform.getBuffer(varyingName);
  }

  getData(opts = {}) {
    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);

    for (const resourceTransform of resourceTransforms) {
      const data = resourceTransform.getData(opts);

      if (data) {
        return data;
      }
    }

    return null;
  }

  getFramebuffer() {
    return this.textureTransform && this.textureTransform.getFramebuffer();
  }

  update(opts = {}) {
    if ('elementCount' in opts) {
      this.model.setVertexCount(opts.elementCount);
    }

    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);

    for (const resourceTransform of resourceTransforms) {
      resourceTransform.update(opts);
    }
  }

  _initialize(props = {}) {
    const {
      gl
    } = this;

    this._buildResourceTransforms(gl, props);

    props = this._updateModelProps(props);
    this.model = new _model.default(gl, Object.assign({}, props, {
      fs: props.fs || (0, _shadertools.getPassthroughFS)({
        version: (0, _webgl.getShaderVersion)(props.vs)
      }),
      id: props.id || 'transform-model',
      drawMode: props.drawMode || 0,
      vertexCount: props.elementCount
    }));
    this.bufferTransform && this.bufferTransform.setupResources({
      model: this.model
    });
  }

  _updateModelProps(props) {
    let updatedProps = Object.assign({}, props);
    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);

    for (const resourceTransform of resourceTransforms) {
      updatedProps = resourceTransform.updateModelProps(updatedProps);
    }

    return updatedProps;
  }

  _buildResourceTransforms(gl, props) {
    if (canCreateBufferTransform(props)) {
      this.bufferTransform = new _bufferTransform.default(gl, props);
    }

    if (canCreateTextureTransform(props)) {
      this.textureTransform = new _textureTransform.default(gl, props);
    }

    (0, _webgl.assert)(this.bufferTransform || this.textureTransform, 'must provide source/feedback buffers or source/target textures');
  }

  _updateDrawOptions(opts) {
    let updatedOpts = Object.assign({}, opts);
    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);

    for (const resourceTransform of resourceTransforms) {
      updatedOpts = Object.assign(updatedOpts, resourceTransform.getDrawOptions(updatedOpts));
    }

    return updatedOpts;
  }

}

exports.default = Transform;

function canCreateBufferTransform(props) {
  if (!(0, _webgl.isObjectEmpty)(props.feedbackBuffers) || !(0, _webgl.isObjectEmpty)(props.feedbackMap) || props.varyings && props.varyings.length > 0) {
    return true;
  }

  return false;
}

function canCreateTextureTransform(props) {
  if (!(0, _webgl.isObjectEmpty)(props._sourceTextures) || props._targetTexture || props._targetTextureVarying) {
    return true;
  }

  return false;
}
},{"@luma.gl/shadertools":"node_modules/@luma.gl/shadertools/dist/esm/index.js","./buffer-transform":"node_modules/@luma.gl/engine/dist/esm/transform/buffer-transform.js","./texture-transform":"node_modules/@luma.gl/engine/dist/esm/transform/texture-transform.js","@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","@luma.gl/webgl":"node_modules/@luma.gl/webgl/dist/esm/index.js","../lib/model":"node_modules/@luma.gl/engine/dist/esm/lib/model.js"}],"node_modules/@luma.gl/engine/dist/esm/geometry/geometry.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.DRAW_MODE = void 0;

var _webgl = require("@luma.gl/webgl");

const DRAW_MODE = {
  POINTS: 0x0000,
  LINES: 0x0001,
  LINE_LOOP: 0x0002,
  LINE_STRIP: 0x0003,
  TRIANGLES: 0x0004,
  TRIANGLE_STRIP: 0x0005,
  TRIANGLE_FAN: 0x0006
};
exports.DRAW_MODE = DRAW_MODE;

class Geometry {
  static get DRAW_MODE() {
    return DRAW_MODE;
  }

  constructor(props = {}) {
    const {
      id = (0, _webgl.uid)('geometry'),
      drawMode = DRAW_MODE.TRIANGLES,
      attributes = {},
      indices = null,
      vertexCount = null
    } = props;
    this.id = id;
    this.drawMode = drawMode | 0;
    this.attributes = {};
    this.userData = {};

    this._setAttributes(attributes, indices);

    this.vertexCount = vertexCount || this._calculateVertexCount(this.attributes, this.indices);
  }

  get mode() {
    return this.drawMode;
  }

  getVertexCount() {
    return this.vertexCount;
  }

  getAttributes() {
    return this.indices ? {
      indices: this.indices,
      ...this.attributes
    } : this.attributes;
  }

  _print(attributeName) {
    return `Geometry ${this.id} attribute ${attributeName}`;
  }

  _setAttributes(attributes, indices) {
    if (indices) {
      this.indices = ArrayBuffer.isView(indices) ? {
        value: indices,
        size: 1
      } : indices;
    }

    for (const attributeName in attributes) {
      let attribute = attributes[attributeName];
      attribute = ArrayBuffer.isView(attribute) ? {
        value: attribute
      } : attribute;
      (0, _webgl.assert)(ArrayBuffer.isView(attribute.value), `${this._print(attributeName)}: must be typed array or object with value as typed array`);

      if ((attributeName === 'POSITION' || attributeName === 'positions') && !attribute.size) {
        attribute.size = 3;
      }

      if (attributeName === 'indices') {
        (0, _webgl.assert)(!this.indices);
        this.indices = attribute;
      } else {
        this.attributes[attributeName] = attribute;
      }
    }

    if (this.indices && this.indices.isIndexed !== undefined) {
      this.indices = Object.assign({}, this.indices);
      delete this.indices.isIndexed;
    }

    return this;
  }

  _calculateVertexCount(attributes, indices) {
    if (indices) {
      return indices.value.length;
    }

    let vertexCount = Infinity;

    for (const attributeName in attributes) {
      const attribute = attributes[attributeName];
      const {
        value,
        size,
        constant
      } = attribute;

      if (!constant && value && size >= 1) {
        vertexCount = Math.min(vertexCount, value.length / size);
      }
    }

    (0, _webgl.assert)(Number.isFinite(vertexCount));
    return vertexCount;
  }

}

exports.default = Geometry;
},{"@luma.gl/webgl":"node_modules/@luma.gl/webgl/dist/esm/index.js"}],"node_modules/@luma.gl/engine/dist/esm/geometries/truncated-cone-geometry.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _geometry = _interopRequireDefault(require("../geometry/geometry"));

var _webgl = require("@luma.gl/webgl");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const INDEX_OFFSETS = {
  x: [2, 0, 1],
  y: [0, 1, 2],
  z: [1, 2, 0]
};

class TruncatedConeGeometry extends _geometry.default {
  constructor(props = {}) {
    const {
      id = (0, _webgl.uid)('truncated-code-geometry')
    } = props;
    const {
      indices,
      attributes
    } = tesselateTruncatedCone(props);
    super({ ...props,
      id,
      indices,
      attributes: { ...attributes,
        ...props.attributes
      }
    });
  }

}

exports.default = TruncatedConeGeometry;

function tesselateTruncatedCone(props) {
  const {
    bottomRadius = 0,
    topRadius = 0,
    height = 1,
    nradial = 10,
    nvertical = 10,
    verticalAxis = 'y',
    topCap = false,
    bottomCap = false
  } = props;
  const extra = (topCap ? 2 : 0) + (bottomCap ? 2 : 0);
  const numVertices = (nradial + 1) * (nvertical + 1 + extra);
  const slant = Math.atan2(bottomRadius - topRadius, height);
  const msin = Math.sin;
  const mcos = Math.cos;
  const mpi = Math.PI;
  const cosSlant = mcos(slant);
  const sinSlant = msin(slant);
  const start = topCap ? -2 : 0;
  const end = nvertical + (bottomCap ? 2 : 0);
  const vertsAroundEdge = nradial + 1;
  const indices = new Uint16Array(nradial * (nvertical + extra) * 6);
  const indexOffset = INDEX_OFFSETS[verticalAxis];
  const positions = new Float32Array(numVertices * 3);
  const normals = new Float32Array(numVertices * 3);
  const texCoords = new Float32Array(numVertices * 2);
  let i3 = 0;
  let i2 = 0;

  for (let i = start; i <= end; i++) {
    let v = i / nvertical;
    let y = height * v;
    let ringRadius;

    if (i < 0) {
      y = 0;
      v = 1;
      ringRadius = bottomRadius;
    } else if (i > nvertical) {
      y = height;
      v = 1;
      ringRadius = topRadius;
    } else {
      ringRadius = bottomRadius + (topRadius - bottomRadius) * (i / nvertical);
    }

    if (i === -2 || i === nvertical + 2) {
      ringRadius = 0;
      v = 0;
    }

    y -= height / 2;

    for (let j = 0; j < vertsAroundEdge; j++) {
      const sin = msin(j * mpi * 2 / nradial);
      const cos = mcos(j * mpi * 2 / nradial);
      positions[i3 + indexOffset[0]] = sin * ringRadius;
      positions[i3 + indexOffset[1]] = y;
      positions[i3 + indexOffset[2]] = cos * ringRadius;
      normals[i3 + indexOffset[0]] = i < 0 || i > nvertical ? 0 : sin * cosSlant;
      normals[i3 + indexOffset[1]] = i < 0 ? -1 : i > nvertical ? 1 : sinSlant;
      normals[i3 + indexOffset[2]] = i < 0 || i > nvertical ? 0 : cos * cosSlant;
      texCoords[i2 + 0] = j / nradial;
      texCoords[i2 + 1] = v;
      i2 += 2;
      i3 += 3;
    }
  }

  for (let i = 0; i < nvertical + extra; i++) {
    for (let j = 0; j < nradial; j++) {
      const index = (i * nradial + j) * 6;
      indices[index + 0] = vertsAroundEdge * (i + 0) + 0 + j;
      indices[index + 1] = vertsAroundEdge * (i + 0) + 1 + j;
      indices[index + 2] = vertsAroundEdge * (i + 1) + 1 + j;
      indices[index + 3] = vertsAroundEdge * (i + 0) + 0 + j;
      indices[index + 4] = vertsAroundEdge * (i + 1) + 1 + j;
      indices[index + 5] = vertsAroundEdge * (i + 1) + 0 + j;
    }
  }

  return {
    indices,
    attributes: {
      POSITION: {
        size: 3,
        value: positions
      },
      NORMAL: {
        size: 3,
        value: normals
      },
      TEXCOORD_0: {
        size: 2,
        value: texCoords
      }
    }
  };
}
},{"../geometry/geometry":"node_modules/@luma.gl/engine/dist/esm/geometry/geometry.js","@luma.gl/webgl":"node_modules/@luma.gl/webgl/dist/esm/index.js"}],"node_modules/@luma.gl/engine/dist/esm/geometries/cone-geometry.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _truncatedConeGeometry = _interopRequireDefault(require("./truncated-cone-geometry"));

var _webgl = require("@luma.gl/webgl");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class ConeGeometry extends _truncatedConeGeometry.default {
  constructor(props = {}) {
    const {
      id = (0, _webgl.uid)('cone-geometry'),
      radius = 1,
      cap = true
    } = props;
    super({ ...props,
      id,
      topRadius: 0,
      topCap: Boolean(cap),
      bottomCap: Boolean(cap),
      bottomRadius: radius
    });
  }

}

exports.default = ConeGeometry;
},{"./truncated-cone-geometry":"node_modules/@luma.gl/engine/dist/esm/geometries/truncated-cone-geometry.js","@luma.gl/webgl":"node_modules/@luma.gl/webgl/dist/esm/index.js"}],"node_modules/@luma.gl/engine/dist/esm/geometries/cube-geometry.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _geometry = _interopRequireDefault(require("../geometry/geometry"));

var _webgl = require("@luma.gl/webgl");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const CUBE_INDICES = new Uint16Array([0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23]);
const CUBE_POSITIONS = new Float32Array([-1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1, -1, -1, 1, -1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, -1, -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1]);
const CUBE_NORMALS = new Float32Array([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0]);
const CUBE_TEX_COORDS = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1]);
const ATTRIBUTES = {
  POSITION: {
    size: 3,
    value: new Float32Array(CUBE_POSITIONS)
  },
  NORMAL: {
    size: 3,
    value: new Float32Array(CUBE_NORMALS)
  },
  TEXCOORD_0: {
    size: 2,
    value: new Float32Array(CUBE_TEX_COORDS)
  }
};

class CubeGeometry extends _geometry.default {
  constructor(props = {}) {
    const {
      id = (0, _webgl.uid)('cube-geometry')
    } = props;
    super({ ...props,
      id,
      indices: {
        size: 1,
        value: new Uint16Array(CUBE_INDICES)
      },
      attributes: { ...ATTRIBUTES,
        ...props.attributes
      }
    });
  }

}

exports.default = CubeGeometry;
},{"../geometry/geometry":"node_modules/@luma.gl/engine/dist/esm/geometry/geometry.js","@luma.gl/webgl":"node_modules/@luma.gl/webgl/dist/esm/index.js"}],"node_modules/@luma.gl/engine/dist/esm/geometries/cylinder-geometry.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _truncatedConeGeometry = _interopRequireDefault(require("./truncated-cone-geometry"));

var _webgl = require("@luma.gl/webgl");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class CylinderGeometry extends _truncatedConeGeometry.default {
  constructor(props = {}) {
    const {
      id = (0, _webgl.uid)('cylinder-geometry'),
      radius = 1
    } = props;
    super({ ...props,
      id,
      bottomRadius: radius,
      topRadius: radius
    });
  }

}

exports.default = CylinderGeometry;
},{"./truncated-cone-geometry":"node_modules/@luma.gl/engine/dist/esm/geometries/truncated-cone-geometry.js","@luma.gl/webgl":"node_modules/@luma.gl/webgl/dist/esm/index.js"}],"node_modules/@luma.gl/engine/dist/esm/geometries/ico-sphere-geometry.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _core = require("@math.gl/core");

var _geometry = _interopRequireDefault(require("../geometry/geometry"));

var _webgl = require("@luma.gl/webgl");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const ICO_POSITIONS = [-1, 0, 0, 0, 1, 0, 0, 0, -1, 0, 0, 1, 0, -1, 0, 1, 0, 0];
const ICO_INDICES = [3, 4, 5, 3, 5, 1, 3, 1, 0, 3, 0, 4, 4, 0, 2, 4, 2, 5, 2, 0, 1, 5, 2, 1];

class IcoSphereGeometry extends _geometry.default {
  constructor(props = {}) {
    const {
      id = (0, _webgl.uid)('ico-sphere-geometry')
    } = props;
    const {
      indices,
      attributes
    } = tesselateIcosaHedron(props);
    super({ ...props,
      id,
      indices,
      attributes: { ...attributes,
        ...props.attributes
      }
    });
  }

}

exports.default = IcoSphereGeometry;

function tesselateIcosaHedron(props) {
  const {
    iterations = 0
  } = props;
  const PI = Math.PI;
  const PI2 = PI * 2;
  const positions = [...ICO_POSITIONS];
  let indices = [...ICO_INDICES];
  positions.push();
  indices.push();

  const getMiddlePoint = (() => {
    const pointMemo = {};
    return (i1, i2) => {
      i1 *= 3;
      i2 *= 3;
      const mini = i1 < i2 ? i1 : i2;
      const maxi = i1 > i2 ? i1 : i2;
      const key = `${mini}|${maxi}`;

      if (key in pointMemo) {
        return pointMemo[key];
      }

      const x1 = positions[i1];
      const y1 = positions[i1 + 1];
      const z1 = positions[i1 + 2];
      const x2 = positions[i2];
      const y2 = positions[i2 + 1];
      const z2 = positions[i2 + 2];
      let xm = (x1 + x2) / 2;
      let ym = (y1 + y2) / 2;
      let zm = (z1 + z2) / 2;
      const len = Math.sqrt(xm * xm + ym * ym + zm * zm);
      xm /= len;
      ym /= len;
      zm /= len;
      positions.push(xm, ym, zm);
      return pointMemo[key] = positions.length / 3 - 1;
    };
  })();

  for (let i = 0; i < iterations; i++) {
    const indices2 = [];

    for (let j = 0; j < indices.length; j += 3) {
      const a = getMiddlePoint(indices[j + 0], indices[j + 1]);
      const b = getMiddlePoint(indices[j + 1], indices[j + 2]);
      const c = getMiddlePoint(indices[j + 2], indices[j + 0]);
      indices2.push(c, indices[j + 0], a, a, indices[j + 1], b, b, indices[j + 2], c, a, b, c);
    }

    indices = indices2;
  }

  const normals = new Array(positions.length);
  const texCoords = new Array(positions.length / 3 * 2);
  const l = indices.length;

  for (let i = l - 3; i >= 0; i -= 3) {
    const i1 = indices[i + 0];
    const i2 = indices[i + 1];
    const i3 = indices[i + 2];
    const in1 = i1 * 3;
    const in2 = i2 * 3;
    const in3 = i3 * 3;
    const iu1 = i1 * 2;
    const iu2 = i2 * 2;
    const iu3 = i3 * 2;
    const x1 = positions[in1 + 0];
    const y1 = positions[in1 + 1];
    const z1 = positions[in1 + 2];
    const theta1 = Math.acos(z1 / Math.sqrt(x1 * x1 + y1 * y1 + z1 * z1));
    const phi1 = Math.atan2(y1, x1) + PI;
    const v1 = theta1 / PI;
    const u1 = 1 - phi1 / PI2;
    const x2 = positions[in2 + 0];
    const y2 = positions[in2 + 1];
    const z2 = positions[in2 + 2];
    const theta2 = Math.acos(z2 / Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2));
    const phi2 = Math.atan2(y2, x2) + PI;
    const v2 = theta2 / PI;
    const u2 = 1 - phi2 / PI2;
    const x3 = positions[in3 + 0];
    const y3 = positions[in3 + 1];
    const z3 = positions[in3 + 2];
    const theta3 = Math.acos(z3 / Math.sqrt(x3 * x3 + y3 * y3 + z3 * z3));
    const phi3 = Math.atan2(y3, x3) + PI;
    const v3 = theta3 / PI;
    const u3 = 1 - phi3 / PI2;
    const vec1 = [x3 - x2, y3 - y2, z3 - z2];
    const vec2 = [x1 - x2, y1 - y2, z1 - z2];
    const normal = new _core.Vector3(vec1).cross(vec2).normalize();
    let newIndex;

    if ((u1 === 0 || u2 === 0 || u3 === 0) && (u1 === 0 || u1 > 0.5) && (u2 === 0 || u2 > 0.5) && (u3 === 0 || u3 > 0.5)) {
      positions.push(positions[in1 + 0], positions[in1 + 1], positions[in1 + 2]);
      newIndex = positions.length / 3 - 1;
      indices.push(newIndex);
      texCoords[newIndex * 2 + 0] = 1;
      texCoords[newIndex * 2 + 1] = v1;
      normals[newIndex * 3 + 0] = normal.x;
      normals[newIndex * 3 + 1] = normal.y;
      normals[newIndex * 3 + 2] = normal.z;
      positions.push(positions[in2 + 0], positions[in2 + 1], positions[in2 + 2]);
      newIndex = positions.length / 3 - 1;
      indices.push(newIndex);
      texCoords[newIndex * 2 + 0] = 1;
      texCoords[newIndex * 2 + 1] = v2;
      normals[newIndex * 3 + 0] = normal.x;
      normals[newIndex * 3 + 1] = normal.y;
      normals[newIndex * 3 + 2] = normal.z;
      positions.push(positions[in3 + 0], positions[in3 + 1], positions[in3 + 2]);
      newIndex = positions.length / 3 - 1;
      indices.push(newIndex);
      texCoords[newIndex * 2 + 0] = 1;
      texCoords[newIndex * 2 + 1] = v3;
      normals[newIndex * 3 + 0] = normal.x;
      normals[newIndex * 3 + 1] = normal.y;
      normals[newIndex * 3 + 2] = normal.z;
    }

    normals[in1 + 0] = normals[in2 + 0] = normals[in3 + 0] = normal.x;
    normals[in1 + 1] = normals[in2 + 1] = normals[in3 + 1] = normal.y;
    normals[in1 + 2] = normals[in2 + 2] = normals[in3 + 2] = normal.z;
    texCoords[iu1 + 0] = u1;
    texCoords[iu1 + 1] = v1;
    texCoords[iu2 + 0] = u2;
    texCoords[iu2 + 1] = v2;
    texCoords[iu3 + 0] = u3;
    texCoords[iu3 + 1] = v3;
  }

  return {
    indices: {
      size: 1,
      value: new Uint16Array(indices)
    },
    attributes: {
      POSITION: {
        size: 3,
        value: new Float32Array(positions)
      },
      NORMAL: {
        size: 3,
        value: new Float32Array(normals)
      },
      TEXCOORD_0: {
        size: 2,
        value: new Float32Array(texCoords)
      }
    }
  };
}
},{"@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js","../geometry/geometry":"node_modules/@luma.gl/engine/dist/esm/geometry/geometry.js","@luma.gl/webgl":"node_modules/@luma.gl/webgl/dist/esm/index.js"}],"node_modules/@luma.gl/engine/dist/esm/geometry/geometry-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.unpackIndexedGeometry = unpackIndexedGeometry;

function unpackIndexedGeometry(geometry) {
  const {
    indices,
    attributes
  } = geometry;

  if (!indices) {
    return geometry;
  }

  const vertexCount = indices.value.length;
  const unpackedAttributes = {};

  for (const attributeName in attributes) {
    const attribute = attributes[attributeName];
    const {
      constant,
      value,
      size
    } = attribute;

    if (constant || !size) {
      continue;
    }

    const unpackedValue = new value.constructor(vertexCount * size);

    for (let x = 0; x < vertexCount; ++x) {
      const index = indices.value[x];

      for (let i = 0; i < size; i++) {
        unpackedValue[x * size + i] = value[index * size + i];
      }
    }

    unpackedAttributes[attributeName] = {
      size,
      value: unpackedValue
    };
  }

  return {
    attributes: Object.assign({}, attributes, unpackedAttributes)
  };
}
},{}],"node_modules/@luma.gl/engine/dist/esm/geometries/plane-geometry.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _geometry = _interopRequireDefault(require("../geometry/geometry"));

var _geometryUtils = require("../geometry/geometry-utils");

var _webgl = require("@luma.gl/webgl");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class PlaneGeometry extends _geometry.default {
  constructor(props = {}) {
    const {
      id = (0, _webgl.uid)('plane-geometry')
    } = props;
    const {
      indices,
      attributes
    } = tesselatePlane(props);
    super({ ...props,
      id,
      indices,
      attributes: { ...attributes,
        ...props.attributes
      }
    });
  }

}

exports.default = PlaneGeometry;

function tesselatePlane(props) {
  const {
    type = 'x,y',
    offset = 0,
    flipCull = false,
    unpack = false
  } = props;
  const coords = type.split(',');
  let c1len = props[`${coords[0]}len`] || 1;
  const c2len = props[`${coords[1]}len`] || 1;
  const subdivisions1 = props[`n${coords[0]}`] || 1;
  const subdivisions2 = props[`n${coords[1]}`] || 1;
  const numVertices = (subdivisions1 + 1) * (subdivisions2 + 1);
  const positions = new Float32Array(numVertices * 3);
  const normals = new Float32Array(numVertices * 3);
  const texCoords = new Float32Array(numVertices * 2);

  if (flipCull) {
    c1len = -c1len;
  }

  let i2 = 0;
  let i3 = 0;

  for (let z = 0; z <= subdivisions2; z++) {
    for (let x = 0; x <= subdivisions1; x++) {
      const u = x / subdivisions1;
      const v = z / subdivisions2;
      texCoords[i2 + 0] = flipCull ? 1 - u : u;
      texCoords[i2 + 1] = v;

      switch (type) {
        case 'x,y':
          positions[i3 + 0] = c1len * u - c1len * 0.5;
          positions[i3 + 1] = c2len * v - c2len * 0.5;
          positions[i3 + 2] = offset;
          normals[i3 + 0] = 0;
          normals[i3 + 1] = 0;
          normals[i3 + 2] = flipCull ? 1 : -1;
          break;

        case 'x,z':
          positions[i3 + 0] = c1len * u - c1len * 0.5;
          positions[i3 + 1] = offset;
          positions[i3 + 2] = c2len * v - c2len * 0.5;
          normals[i3 + 0] = 0;
          normals[i3 + 1] = flipCull ? 1 : -1;
          normals[i3 + 2] = 0;
          break;

        case 'y,z':
          positions[i3 + 0] = offset;
          positions[i3 + 1] = c1len * u - c1len * 0.5;
          positions[i3 + 2] = c2len * v - c2len * 0.5;
          normals[i3 + 0] = flipCull ? 1 : -1;
          normals[i3 + 1] = 0;
          normals[i3 + 2] = 0;
          break;

        default:
          throw new Error('PlaneGeometry: unknown type');
      }

      i2 += 2;
      i3 += 3;
    }
  }

  const numVertsAcross = subdivisions1 + 1;
  const indices = new Uint16Array(subdivisions1 * subdivisions2 * 6);

  for (let z = 0; z < subdivisions2; z++) {
    for (let x = 0; x < subdivisions1; x++) {
      const index = (z * subdivisions1 + x) * 6;
      indices[index + 0] = (z + 0) * numVertsAcross + x;
      indices[index + 1] = (z + 1) * numVertsAcross + x;
      indices[index + 2] = (z + 0) * numVertsAcross + x + 1;
      indices[index + 3] = (z + 1) * numVertsAcross + x;
      indices[index + 4] = (z + 1) * numVertsAcross + x + 1;
      indices[index + 5] = (z + 0) * numVertsAcross + x + 1;
    }
  }

  const geometry = {
    indices: {
      size: 1,
      value: indices
    },
    attributes: {
      POSITION: {
        size: 3,
        value: positions
      },
      NORMAL: {
        size: 3,
        value: normals
      },
      TEXCOORD_0: {
        size: 2,
        value: texCoords
      }
    }
  };
  return unpack ? (0, _geometryUtils.unpackIndexedGeometry)(geometry) : geometry;
}
},{"../geometry/geometry":"node_modules/@luma.gl/engine/dist/esm/geometry/geometry.js","../geometry/geometry-utils":"node_modules/@luma.gl/engine/dist/esm/geometry/geometry-utils.js","@luma.gl/webgl":"node_modules/@luma.gl/webgl/dist/esm/index.js"}],"node_modules/@luma.gl/engine/dist/esm/geometries/sphere-geometry.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _geometry = _interopRequireDefault(require("../geometry/geometry"));

var _webgl = require("@luma.gl/webgl");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class SphereGeometry extends _geometry.default {
  constructor(props = {}) {
    const {
      id = (0, _webgl.uid)('sphere-geometry')
    } = props;
    const {
      indices,
      attributes
    } = tesselateSphere(props);
    super({ ...props,
      id,
      indices,
      attributes: { ...attributes,
        ...props.attributes
      }
    });
  }

}

exports.default = SphereGeometry;

function tesselateSphere(props) {
  const {
    nlat = 10,
    nlong = 10
  } = props;
  let {
    radius = 1
  } = props;
  const startLat = 0;
  const endLat = Math.PI;
  const latRange = endLat - startLat;
  const startLong = 0;
  const endLong = 2 * Math.PI;
  const longRange = endLong - startLong;
  const numVertices = (nlat + 1) * (nlong + 1);

  if (typeof radius === 'number') {
    const value = radius;

    radius = (n1, n2, n3, u, v) => value;
  }

  const positions = new Float32Array(numVertices * 3);
  const normals = new Float32Array(numVertices * 3);
  const texCoords = new Float32Array(numVertices * 2);
  const IndexType = numVertices > 0xffff ? Uint32Array : Uint16Array;
  const indices = new IndexType(nlat * nlong * 6);

  for (let y = 0; y <= nlat; y++) {
    for (let x = 0; x <= nlong; x++) {
      const u = x / nlong;
      const v = y / nlat;
      const index = x + y * (nlong + 1);
      const i2 = index * 2;
      const i3 = index * 3;
      const theta = longRange * u;
      const phi = latRange * v;
      const sinTheta = Math.sin(theta);
      const cosTheta = Math.cos(theta);
      const sinPhi = Math.sin(phi);
      const cosPhi = Math.cos(phi);
      const ux = cosTheta * sinPhi;
      const uy = cosPhi;
      const uz = sinTheta * sinPhi;
      const r = radius(ux, uy, uz, u, v);
      positions[i3 + 0] = r * ux;
      positions[i3 + 1] = r * uy;
      positions[i3 + 2] = r * uz;
      normals[i3 + 0] = ux;
      normals[i3 + 1] = uy;
      normals[i3 + 2] = uz;
      texCoords[i2 + 0] = u;
      texCoords[i2 + 1] = 1 - v;
    }
  }

  const numVertsAround = nlong + 1;

  for (let x = 0; x < nlong; x++) {
    for (let y = 0; y < nlat; y++) {
      const index = (x * nlat + y) * 6;
      indices[index + 0] = y * numVertsAround + x;
      indices[index + 1] = y * numVertsAround + x + 1;
      indices[index + 2] = (y + 1) * numVertsAround + x;
      indices[index + 3] = (y + 1) * numVertsAround + x;
      indices[index + 4] = y * numVertsAround + x + 1;
      indices[index + 5] = (y + 1) * numVertsAround + x + 1;
    }
  }

  return {
    indices: {
      size: 1,
      value: indices
    },
    attributes: {
      POSITION: {
        size: 3,
        value: positions
      },
      NORMAL: {
        size: 3,
        value: normals
      },
      TEXCOORD_0: {
        size: 2,
        value: texCoords
      }
    }
  };
}
},{"../geometry/geometry":"node_modules/@luma.gl/engine/dist/esm/geometry/geometry.js","@luma.gl/webgl":"node_modules/@luma.gl/webgl/dist/esm/index.js"}],"node_modules/@luma.gl/engine/dist/esm/animation/timeline.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Timeline = void 0;
let channelHandles = 1;
let animationHandles = 1;

class Timeline {
  constructor() {
    this.time = 0;
    this.channels = new Map();
    this.animations = new Map();
    this.playing = false;
    this.lastEngineTime = -1;
  }

  addChannel(props) {
    const {
      delay = 0,
      duration = Number.POSITIVE_INFINITY,
      rate = 1,
      repeat = 1
    } = props;
    const handle = channelHandles++;
    const channel = {
      time: 0,
      delay,
      duration,
      rate,
      repeat
    };

    this._setChannelTime(channel, this.time);

    this.channels.set(handle, channel);
    return handle;
  }

  removeChannel(handle) {
    this.channels.delete(handle);

    for (const [animationHandle, animation] of this.animations) {
      if (animation.channel === handle) {
        this.detachAnimation(animationHandle);
      }
    }
  }

  isFinished(handle) {
    const channel = this.channels.get(handle);

    if (channel === undefined) {
      return false;
    }

    return this.time >= channel.delay + channel.duration * channel.repeat;
  }

  getTime(handle) {
    if (handle === undefined) {
      return this.time;
    }

    const channel = this.channels.get(handle);

    if (channel === undefined) {
      return -1;
    }

    return channel.time;
  }

  setTime(time) {
    this.time = Math.max(0, time);
    const channels = this.channels.values();

    for (const channel of channels) {
      this._setChannelTime(channel, this.time);
    }

    const animations = this.animations.values();

    for (const animationData of animations) {
      const {
        animation,
        channel
      } = animationData;
      animation.setTime(this.getTime(channel));
    }
  }

  play() {
    this.playing = true;
  }

  pause() {
    this.playing = false;
    this.lastEngineTime = -1;
  }

  reset() {
    this.setTime(0);
  }

  attachAnimation(animation, channelHandle) {
    const animationHandle = animationHandles++;
    this.animations.set(animationHandle, {
      animation,
      channel: channelHandle
    });
    animation.setTime(this.getTime(channelHandle));
    return animationHandle;
  }

  detachAnimation(handle) {
    this.animations.delete(handle);
  }

  update(engineTime) {
    if (this.playing) {
      if (this.lastEngineTime === -1) {
        this.lastEngineTime = engineTime;
      }

      this.setTime(this.time + (engineTime - this.lastEngineTime));
      this.lastEngineTime = engineTime;
    }
  }

  _setChannelTime(channel, time) {
    const offsetTime = time - channel.delay;
    const totalDuration = channel.duration * channel.repeat;

    if (offsetTime >= totalDuration) {
      channel.time = channel.duration * channel.rate;
    } else {
      channel.time = Math.max(0, offsetTime) % channel.duration;
      channel.time *= channel.rate;
    }
  }

}

exports.Timeline = Timeline;
},{}],"node_modules/@luma.gl/engine/dist/esm/animation/key-frames.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KeyFrames = void 0;

class KeyFrames {
  constructor(keyFrames) {
    this._lastTime = -1;
    this.startIndex = -1;
    this.endIndex = -1;
    this.factor = 0;
    this.times = [];
    this.values = [];
    this.setKeyFrames(keyFrames);
    this.setTime(0);
  }

  setKeyFrames(keyFrames) {
    const numKeys = keyFrames.length;
    this.times.length = numKeys;
    this.values.length = numKeys;

    for (let i = 0; i < numKeys; ++i) {
      this.times[i] = keyFrames[i][0];
      this.values[i] = keyFrames[i][1];
    }

    this._calculateKeys(this._lastTime);
  }

  setTime(time) {
    time = Math.max(0, time);

    if (time !== this._lastTime) {
      this._calculateKeys(time);

      this._lastTime = time;
    }
  }

  getStartTime() {
    return this.times[this.startIndex];
  }

  getEndTime() {
    return this.times[this.endIndex];
  }

  getStartData() {
    return this.values[this.startIndex];
  }

  getEndData() {
    return this.values[this.endIndex];
  }

  _calculateKeys(time) {
    let index = 0;
    const numKeys = this.times.length;

    for (index = 0; index < numKeys - 2; ++index) {
      if (this.times[index + 1] > time) {
        break;
      }
    }

    this.startIndex = index;
    this.endIndex = index + 1;
    const startTime = this.times[this.startIndex];
    const endTime = this.times[this.endIndex];
    this.factor = Math.min(Math.max(0, (time - startTime) / (endTime - startTime)), 1);
  }

}

exports.KeyFrames = KeyFrames;
},{}],"node_modules/@luma.gl/engine/dist/esm/utils/clip-space.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _model = _interopRequireDefault(require("../lib/model"));

var _geometry = _interopRequireDefault(require("../geometry/geometry"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const CLIPSPACE_VERTEX_SHADER = `\
attribute vec2 aClipSpacePosition;
attribute vec2 aTexCoord;
attribute vec2 aCoordinate;

varying vec2 position;
varying vec2 coordinate;
varying vec2 uv;

void main(void) {
  gl_Position = vec4(aClipSpacePosition, 0., 1.);
  position = aClipSpacePosition;
  coordinate = aCoordinate;
  uv = aTexCoord;
}
`;
const POSITIONS = [-1, -1, 1, -1, -1, 1, 1, 1];

class ClipSpace extends _model.default {
  constructor(gl, opts) {
    const TEX_COORDS = POSITIONS.map(coord => coord === -1 ? 0 : coord);
    super(gl, Object.assign({}, opts, {
      vs: CLIPSPACE_VERTEX_SHADER,
      geometry: new _geometry.default({
        drawMode: 5,
        vertexCount: 4,
        attributes: {
          aClipSpacePosition: {
            size: 2,
            value: new Float32Array(POSITIONS)
          },
          aTexCoord: {
            size: 2,
            value: new Float32Array(TEX_COORDS)
          },
          aCoordinate: {
            size: 2,
            value: new Float32Array(TEX_COORDS)
          }
        }
      })
    }));
    this.setVertexCount(4);
  }

}

exports.default = ClipSpace;
},{"../lib/model":"node_modules/@luma.gl/engine/dist/esm/lib/model.js","../geometry/geometry":"node_modules/@luma.gl/engine/dist/esm/geometry/geometry.js"}],"node_modules/@luma.gl/engine/dist/esm/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "AnimationLoop", {
  enumerable: true,
  get: function () {
    return _animationLoop.default;
  }
});
Object.defineProperty(exports, "ClipSpace", {
  enumerable: true,
  get: function () {
    return _clipSpace.default;
  }
});
Object.defineProperty(exports, "ConeGeometry", {
  enumerable: true,
  get: function () {
    return _coneGeometry.default;
  }
});
Object.defineProperty(exports, "CubeGeometry", {
  enumerable: true,
  get: function () {
    return _cubeGeometry.default;
  }
});
Object.defineProperty(exports, "CylinderGeometry", {
  enumerable: true,
  get: function () {
    return _cylinderGeometry.default;
  }
});
Object.defineProperty(exports, "Geometry", {
  enumerable: true,
  get: function () {
    return _geometry.default;
  }
});
Object.defineProperty(exports, "IcoSphereGeometry", {
  enumerable: true,
  get: function () {
    return _icoSphereGeometry.default;
  }
});
Object.defineProperty(exports, "KeyFrames", {
  enumerable: true,
  get: function () {
    return _keyFrames.KeyFrames;
  }
});
Object.defineProperty(exports, "Model", {
  enumerable: true,
  get: function () {
    return _model.default;
  }
});
Object.defineProperty(exports, "PlaneGeometry", {
  enumerable: true,
  get: function () {
    return _planeGeometry.default;
  }
});
Object.defineProperty(exports, "ProgramManager", {
  enumerable: true,
  get: function () {
    return _programManager.default;
  }
});
Object.defineProperty(exports, "SphereGeometry", {
  enumerable: true,
  get: function () {
    return _sphereGeometry.default;
  }
});
Object.defineProperty(exports, "Timeline", {
  enumerable: true,
  get: function () {
    return _timeline.Timeline;
  }
});
Object.defineProperty(exports, "Transform", {
  enumerable: true,
  get: function () {
    return _transform.default;
  }
});
Object.defineProperty(exports, "TruncatedConeGeometry", {
  enumerable: true,
  get: function () {
    return _truncatedConeGeometry.default;
  }
});

var _animationLoop = _interopRequireDefault(require("./lib/animation-loop"));

var _model = _interopRequireDefault(require("./lib/model"));

var _programManager = _interopRequireDefault(require("./lib/program-manager"));

var _transform = _interopRequireDefault(require("./transform/transform"));

var _geometry = _interopRequireDefault(require("./geometry/geometry"));

var _coneGeometry = _interopRequireDefault(require("./geometries/cone-geometry"));

var _cubeGeometry = _interopRequireDefault(require("./geometries/cube-geometry"));

var _cylinderGeometry = _interopRequireDefault(require("./geometries/cylinder-geometry"));

var _icoSphereGeometry = _interopRequireDefault(require("./geometries/ico-sphere-geometry"));

var _planeGeometry = _interopRequireDefault(require("./geometries/plane-geometry"));

var _sphereGeometry = _interopRequireDefault(require("./geometries/sphere-geometry"));

var _truncatedConeGeometry = _interopRequireDefault(require("./geometries/truncated-cone-geometry"));

var _timeline = require("./animation/timeline");

var _keyFrames = require("./animation/key-frames");

var _clipSpace = _interopRequireDefault(require("./utils/clip-space"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./lib/animation-loop":"node_modules/@luma.gl/engine/dist/esm/lib/animation-loop.js","./lib/model":"node_modules/@luma.gl/engine/dist/esm/lib/model.js","./lib/program-manager":"node_modules/@luma.gl/engine/dist/esm/lib/program-manager.js","./transform/transform":"node_modules/@luma.gl/engine/dist/esm/transform/transform.js","./geometry/geometry":"node_modules/@luma.gl/engine/dist/esm/geometry/geometry.js","./geometries/cone-geometry":"node_modules/@luma.gl/engine/dist/esm/geometries/cone-geometry.js","./geometries/cube-geometry":"node_modules/@luma.gl/engine/dist/esm/geometries/cube-geometry.js","./geometries/cylinder-geometry":"node_modules/@luma.gl/engine/dist/esm/geometries/cylinder-geometry.js","./geometries/ico-sphere-geometry":"node_modules/@luma.gl/engine/dist/esm/geometries/ico-sphere-geometry.js","./geometries/plane-geometry":"node_modules/@luma.gl/engine/dist/esm/geometries/plane-geometry.js","./geometries/sphere-geometry":"node_modules/@luma.gl/engine/dist/esm/geometries/sphere-geometry.js","./geometries/truncated-cone-geometry":"node_modules/@luma.gl/engine/dist/esm/geometries/truncated-cone-geometry.js","./animation/timeline":"node_modules/@luma.gl/engine/dist/esm/animation/timeline.js","./animation/key-frames":"node_modules/@luma.gl/engine/dist/esm/animation/key-frames.js","./utils/clip-space":"node_modules/@luma.gl/engine/dist/esm/utils/clip-space.js"}],"../../.nvm/versions/node/v16.15.0/lib/node_modules/parcel-bundler/node_modules/base64-js/index.js":[function(require,module,exports) {
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],"../../.nvm/versions/node/v16.15.0/lib/node_modules/parcel-bundler/node_modules/ieee754/index.js":[function(require,module,exports) {
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],"../../.nvm/versions/node/v16.15.0/lib/node_modules/parcel-bundler/node_modules/isarray/index.js":[function(require,module,exports) {
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],"../../.nvm/versions/node/v16.15.0/lib/node_modules/parcel-bundler/node_modules/buffer/index.js":[function(require,module,exports) {

var global = arguments[3];
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

},{"base64-js":"../../.nvm/versions/node/v16.15.0/lib/node_modules/parcel-bundler/node_modules/base64-js/index.js","ieee754":"../../.nvm/versions/node/v16.15.0/lib/node_modules/parcel-bundler/node_modules/ieee754/index.js","isarray":"../../.nvm/versions/node/v16.15.0/lib/node_modules/parcel-bundler/node_modules/isarray/index.js","buffer":"../../.nvm/versions/node/v16.15.0/lib/node_modules/parcel-bundler/node_modules/buffer/index.js"}],"node_modules/@luma.gl/core/dist/esm/index.js":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "AnimationLoop", {
  enumerable: true,
  get: function () {
    return _engine.AnimationLoop;
  }
});
Object.defineProperty(exports, "Buffer", {
  enumerable: true,
  get: function () {
    return _webgl.Buffer;
  }
});
Object.defineProperty(exports, "ClipSpace", {
  enumerable: true,
  get: function () {
    return _engine.ClipSpace;
  }
});
Object.defineProperty(exports, "ConeGeometry", {
  enumerable: true,
  get: function () {
    return _engine.ConeGeometry;
  }
});
Object.defineProperty(exports, "CubeGeometry", {
  enumerable: true,
  get: function () {
    return _engine.CubeGeometry;
  }
});
Object.defineProperty(exports, "CylinderGeometry", {
  enumerable: true,
  get: function () {
    return _engine.CylinderGeometry;
  }
});
Object.defineProperty(exports, "FEATURES", {
  enumerable: true,
  get: function () {
    return _webgl.FEATURES;
  }
});
Object.defineProperty(exports, "Framebuffer", {
  enumerable: true,
  get: function () {
    return _webgl.Framebuffer;
  }
});
Object.defineProperty(exports, "Geometry", {
  enumerable: true,
  get: function () {
    return _engine.Geometry;
  }
});
Object.defineProperty(exports, "IcoSphereGeometry", {
  enumerable: true,
  get: function () {
    return _engine.IcoSphereGeometry;
  }
});
Object.defineProperty(exports, "Model", {
  enumerable: true,
  get: function () {
    return _engine.Model;
  }
});
Object.defineProperty(exports, "PlaneGeometry", {
  enumerable: true,
  get: function () {
    return _engine.PlaneGeometry;
  }
});
Object.defineProperty(exports, "Program", {
  enumerable: true,
  get: function () {
    return _webgl.Program;
  }
});
Object.defineProperty(exports, "ProgramManager", {
  enumerable: true,
  get: function () {
    return _engine.ProgramManager;
  }
});
Object.defineProperty(exports, "Renderbuffer", {
  enumerable: true,
  get: function () {
    return _webgl.Renderbuffer;
  }
});
Object.defineProperty(exports, "SphereGeometry", {
  enumerable: true,
  get: function () {
    return _engine.SphereGeometry;
  }
});
Object.defineProperty(exports, "Texture2D", {
  enumerable: true,
  get: function () {
    return _webgl.Texture2D;
  }
});
Object.defineProperty(exports, "Texture3D", {
  enumerable: true,
  get: function () {
    return _webgl.Texture3D;
  }
});
Object.defineProperty(exports, "TextureCube", {
  enumerable: true,
  get: function () {
    return _webgl.TextureCube;
  }
});
Object.defineProperty(exports, "Timeline", {
  enumerable: true,
  get: function () {
    return _engine.Timeline;
  }
});
Object.defineProperty(exports, "Transform", {
  enumerable: true,
  get: function () {
    return _engine.Transform;
  }
});
Object.defineProperty(exports, "TransformFeedback", {
  enumerable: true,
  get: function () {
    return _webgl.TransformFeedback;
  }
});
Object.defineProperty(exports, "TruncatedConeGeometry", {
  enumerable: true,
  get: function () {
    return _engine.TruncatedConeGeometry;
  }
});
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function () {
    return _webgl.assert;
  }
});
Object.defineProperty(exports, "clear", {
  enumerable: true,
  get: function () {
    return _webgl.clear;
  }
});
Object.defineProperty(exports, "cloneTextureFrom", {
  enumerable: true,
  get: function () {
    return _webgl.cloneTextureFrom;
  }
});
Object.defineProperty(exports, "copyToTexture", {
  enumerable: true,
  get: function () {
    return _webgl.copyToTexture;
  }
});
Object.defineProperty(exports, "createGLContext", {
  enumerable: true,
  get: function () {
    return _gltools.createGLContext;
  }
});
Object.defineProperty(exports, "cssToDevicePixels", {
  enumerable: true,
  get: function () {
    return _gltools.cssToDevicePixels;
  }
});
Object.defineProperty(exports, "cssToDeviceRatio", {
  enumerable: true,
  get: function () {
    return _gltools.cssToDeviceRatio;
  }
});
Object.defineProperty(exports, "dirlight", {
  enumerable: true,
  get: function () {
    return _shadertools.dirlight;
  }
});
Object.defineProperty(exports, "fp32", {
  enumerable: true,
  get: function () {
    return _shadertools.fp32;
  }
});
Object.defineProperty(exports, "fp64", {
  enumerable: true,
  get: function () {
    return _shadertools.fp64;
  }
});
Object.defineProperty(exports, "getParameters", {
  enumerable: true,
  get: function () {
    return _gltools.getParameters;
  }
});
Object.defineProperty(exports, "gouraudLighting", {
  enumerable: true,
  get: function () {
    return _shadertools.gouraudLighting;
  }
});
Object.defineProperty(exports, "hasFeature", {
  enumerable: true,
  get: function () {
    return _webgl.hasFeature;
  }
});
Object.defineProperty(exports, "hasFeatures", {
  enumerable: true,
  get: function () {
    return _webgl.hasFeatures;
  }
});
Object.defineProperty(exports, "instrumentGLContext", {
  enumerable: true,
  get: function () {
    return _gltools.instrumentGLContext;
  }
});
Object.defineProperty(exports, "isWebGL", {
  enumerable: true,
  get: function () {
    return _gltools.isWebGL;
  }
});
Object.defineProperty(exports, "isWebGL2", {
  enumerable: true,
  get: function () {
    return _gltools.isWebGL2;
  }
});
Object.defineProperty(exports, "log", {
  enumerable: true,
  get: function () {
    return _webgl.log;
  }
});
Object.defineProperty(exports, "lumaStats", {
  enumerable: true,
  get: function () {
    return _webgl.lumaStats;
  }
});
Object.defineProperty(exports, "normalizeShaderModule", {
  enumerable: true,
  get: function () {
    return _shadertools.normalizeShaderModule;
  }
});
Object.defineProperty(exports, "pbr", {
  enumerable: true,
  get: function () {
    return _shadertools.pbr;
  }
});
Object.defineProperty(exports, "phongLighting", {
  enumerable: true,
  get: function () {
    return _shadertools.phongLighting;
  }
});
Object.defineProperty(exports, "picking", {
  enumerable: true,
  get: function () {
    return _shadertools.picking;
  }
});
Object.defineProperty(exports, "project", {
  enumerable: true,
  get: function () {
    return _shadertools.project;
  }
});
Object.defineProperty(exports, "readPixelsToArray", {
  enumerable: true,
  get: function () {
    return _webgl.readPixelsToArray;
  }
});
Object.defineProperty(exports, "readPixelsToBuffer", {
  enumerable: true,
  get: function () {
    return _webgl.readPixelsToBuffer;
  }
});
Object.defineProperty(exports, "resetParameters", {
  enumerable: true,
  get: function () {
    return _gltools.resetParameters;
  }
});
Object.defineProperty(exports, "setParameters", {
  enumerable: true,
  get: function () {
    return _gltools.setParameters;
  }
});
Object.defineProperty(exports, "uid", {
  enumerable: true,
  get: function () {
    return _webgl.uid;
  }
});
Object.defineProperty(exports, "withParameters", {
  enumerable: true,
  get: function () {
    return _gltools.withParameters;
  }
});

var _gltools = require("@luma.gl/gltools");

var _webgl = require("@luma.gl/webgl");

var _engine = require("@luma.gl/engine");

var _shadertools = require("@luma.gl/shadertools");
},{"@luma.gl/gltools":"node_modules/@luma.gl/gltools/dist/esm/index.js","@luma.gl/webgl":"node_modules/@luma.gl/webgl/dist/esm/index.js","@luma.gl/engine":"node_modules/@luma.gl/engine/dist/esm/index.js","@luma.gl/shadertools":"node_modules/@luma.gl/shadertools/dist/esm/index.js","buffer":"../../.nvm/versions/node/v16.15.0/lib/node_modules/parcel-bundler/node_modules/buffer/index.js"}],"node_modules/@deck.gl/core/dist/esm/shaderlib/misc/geometry.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
const defines = '#define SMOOTH_EDGE_RADIUS 0.5';
const vs = "\n".concat(defines, "\n\nstruct VertexGeometry {\n  vec4 position;\n  vec3 worldPosition;\n  vec3 worldPositionAlt;\n  vec3 normal;\n  vec2 uv;\n  vec3 pickingColor;\n} geometry = VertexGeometry(\n  vec4(0.0, 0.0, 1.0, 0.0),\n  vec3(0.0),\n  vec3(0.0),\n  vec3(0.0),\n  vec2(0.0),\n  vec3(0.0)\n);\n");
const fs = "\n".concat(defines, "\n\nstruct FragmentGeometry {\n  vec2 uv;\n} geometry;\n\nfloat smoothedge(float edge, float x) {\n  return smoothstep(edge - SMOOTH_EDGE_RADIUS, edge + SMOOTH_EDGE_RADIUS, x);\n}\n");
var _default = {
  name: 'geometry',
  vs,
  fs
};
exports.default = _default;
},{}],"node_modules/@deck.gl/core/dist/esm/lib/constants.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UNIT = exports.PROJECTION_MODE = exports.OPERATION = exports.EVENTS = exports.COORDINATE_SYSTEM = void 0;

var _log = _interopRequireDefault(require("../utils/log"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const COORDINATE_SYSTEM = {
  DEFAULT: -1,
  LNGLAT: 1,
  METER_OFFSETS: 2,
  LNGLAT_OFFSETS: 3,
  CARTESIAN: 0
};
exports.COORDINATE_SYSTEM = COORDINATE_SYSTEM;
Object.defineProperty(COORDINATE_SYSTEM, 'IDENTITY', {
  get: () => _log.default.deprecated('COORDINATE_SYSTEM.IDENTITY', 'COORDINATE_SYSTEM.CARTESIAN')() || 0
});
const PROJECTION_MODE = {
  WEB_MERCATOR: 1,
  GLOBE: 2,
  WEB_MERCATOR_AUTO_OFFSET: 4,
  IDENTITY: 0
};
exports.PROJECTION_MODE = PROJECTION_MODE;
const UNIT = {
  common: 0,
  meters: 1,
  pixels: 2
};
exports.UNIT = UNIT;
const EVENTS = {
  click: {
    handler: 'onClick'
  },
  panstart: {
    handler: 'onDragStart'
  },
  panmove: {
    handler: 'onDrag'
  },
  panend: {
    handler: 'onDragEnd'
  }
};
exports.EVENTS = EVENTS;
const OPERATION = {
  DRAW: 'draw',
  MASK: 'mask'
};
exports.OPERATION = OPERATION;
},{"../utils/log":"node_modules/@deck.gl/core/dist/esm/utils/log.js"}],"node_modules/@deck.gl/core/dist/esm/shaderlib/project/project.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _constants = require("../../lib/constants");

const COORDINATE_SYSTEM_GLSL_CONSTANTS = Object.keys(_constants.COORDINATE_SYSTEM).map(key => "const int COORDINATE_SYSTEM_".concat(key, " = ").concat(_constants.COORDINATE_SYSTEM[key], ";")).join('');
const PROJECTION_MODE_GLSL_CONSTANTS = Object.keys(_constants.PROJECTION_MODE).map(key => "const int PROJECTION_MODE_".concat(key, " = ").concat(_constants.PROJECTION_MODE[key], ";")).join('');
const UNIT_GLSL_CONSTANTS = Object.keys(_constants.UNIT).map(key => "const int UNIT_".concat(key.toUpperCase(), " = ").concat(_constants.UNIT[key], ";")).join('');

var _default = "".concat(COORDINATE_SYSTEM_GLSL_CONSTANTS, "\n").concat(PROJECTION_MODE_GLSL_CONSTANTS, "\n").concat(UNIT_GLSL_CONSTANTS, "\n\nuniform int project_uCoordinateSystem;\nuniform int project_uProjectionMode;\nuniform float project_uScale;\nuniform bool project_uWrapLongitude;\nuniform vec3 project_uCommonUnitsPerMeter;\nuniform vec3 project_uCommonUnitsPerWorldUnit;\nuniform vec3 project_uCommonUnitsPerWorldUnit2;\nuniform vec4 project_uCenter;\nuniform mat4 project_uModelMatrix;\nuniform mat4 project_uViewProjectionMatrix;\nuniform vec2 project_uViewportSize;\nuniform float project_uDevicePixelRatio;\nuniform float project_uFocalDistance;\nuniform vec3 project_uCameraPosition;\nuniform vec3 project_uCoordinateOrigin;\nuniform vec3 project_uCommonOrigin;\nuniform bool project_uPseudoMeters;\n\nconst float TILE_SIZE = 512.0;\nconst float PI = 3.1415926536;\nconst float WORLD_SCALE = TILE_SIZE / (PI * 2.0);\nconst vec3 ZERO_64_LOW = vec3(0.0);\nconst float EARTH_RADIUS = 6370972.0;\nconst float GLOBE_RADIUS = 256.0;\nfloat project_size() {\n  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR &&\n    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT &&\n    project_uPseudoMeters == false) {\n    \n    if (geometry.position.w == 0.0) {\n      float y = clamp(geometry.worldPosition.y, -89.9, 89.9);\n      return 1.0 / cos(radians(y));\n    }\n  \n    float y = geometry.position.y / TILE_SIZE * 2.0 - 1.0;\n    float y2 = y * y;\n    float y4 = y2 * y2;\n    float y6 = y4 * y2;\n    return 1.0 + 4.9348 * y2 + 4.0587 * y4 + 1.5642 * y6;\n  }\n  return 1.0;\n}\nfloat project_size(float meters) {\n  return meters * project_uCommonUnitsPerMeter.z * project_size();\n}\n\nvec2 project_size(vec2 meters) {\n  return meters * project_uCommonUnitsPerMeter.xy * project_size();\n}\n\nvec3 project_size(vec3 meters) {\n  return meters * project_uCommonUnitsPerMeter * project_size();\n}\n\nvec4 project_size(vec4 meters) {\n  return vec4(meters.xyz * project_uCommonUnitsPerMeter, meters.w);\n}\nmat3 project_get_orientation_matrix(vec3 up) {\n  vec3 uz = normalize(up);\n  vec3 ux = abs(uz.z) == 1.0 ? vec3(1.0, 0.0, 0.0) : normalize(vec3(uz.y, -uz.x, 0));\n  vec3 uy = cross(uz, ux);\n  return mat3(ux, uy, uz);\n}\n\nbool project_needs_rotation(vec3 commonPosition, out mat3 transform) {\n  if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {\n    transform = project_get_orientation_matrix(commonPosition);\n    return true;\n  }\n  return false;\n}\nvec3 project_normal(vec3 vector) {\n  vec4 normal_modelspace = project_uModelMatrix * vec4(vector, 0.0);\n  vec3 n = normalize(normal_modelspace.xyz * project_uCommonUnitsPerMeter);\n  mat3 rotation;\n  if (project_needs_rotation(geometry.position.xyz, rotation)) {\n    n = rotation * n;\n  }\n  return n;\n}\n\nvec4 project_offset_(vec4 offset) {\n  float dy = offset.y;\n  vec3 commonUnitsPerWorldUnit = project_uCommonUnitsPerWorldUnit + project_uCommonUnitsPerWorldUnit2 * dy;\n  return vec4(offset.xyz * commonUnitsPerWorldUnit, offset.w);\n}\nvec2 project_mercator_(vec2 lnglat) {\n  float x = lnglat.x;\n  if (project_uWrapLongitude) {\n    x = mod(x + 180., 360.0) - 180.;\n  }\n  float y = clamp(lnglat.y, -89.9, 89.9);\n  return vec2(\n    radians(x) + PI,\n    PI + log(tan_fp32(PI * 0.25 + radians(y) * 0.5))\n  ) * WORLD_SCALE;\n}\n\nvec3 project_globe_(vec3 lnglatz) {\n  float lambda = radians(lnglatz.x);\n  float phi = radians(lnglatz.y);\n  float cosPhi = cos(phi);\n  float D = (lnglatz.z / EARTH_RADIUS + 1.0) * GLOBE_RADIUS;\n\n  return vec3(\n    sin(lambda) * cosPhi,\n    -cos(lambda) * cosPhi,\n    sin(phi)\n  ) * D;\n}\nvec4 project_position(vec4 position, vec3 position64Low) {\n  vec4 position_world = project_uModelMatrix * position;\n  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR) {\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n      return vec4(\n        project_mercator_(position_world.xy),\n        project_size(position_world.z),\n        position_world.w\n      );\n    }\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_CARTESIAN) {\n      position_world.xyz += project_uCoordinateOrigin;\n    }\n  }\n  if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n      return vec4(\n        project_globe_(position_world.xyz),\n        position_world.w\n      );\n    }\n  }\n  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n      if (abs(position_world.y - project_uCoordinateOrigin.y) > 0.25) {\n        return vec4(\n          project_mercator_(position_world.xy) - project_uCommonOrigin.xy,\n          project_size(position_world.z),\n          position_world.w\n        );\n      }\n    }\n  }\n  if (project_uProjectionMode == PROJECTION_MODE_IDENTITY ||\n    (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET &&\n    (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n     project_uCoordinateSystem == COORDINATE_SYSTEM_CARTESIAN))) {\n    position_world.xyz -= project_uCoordinateOrigin;\n  }\n  return project_offset_(position_world + project_uModelMatrix * vec4(position64Low, 0.0));\n}\n\nvec4 project_position(vec4 position) {\n  return project_position(position, ZERO_64_LOW);\n}\n\nvec3 project_position(vec3 position, vec3 position64Low) {\n  vec4 projected_position = project_position(vec4(position, 1.0), position64Low);\n  return projected_position.xyz;\n}\n\nvec3 project_position(vec3 position) {\n  vec4 projected_position = project_position(vec4(position, 1.0), ZERO_64_LOW);\n  return projected_position.xyz;\n}\n\nvec2 project_position(vec2 position) {\n  vec4 projected_position = project_position(vec4(position, 0.0, 1.0), ZERO_64_LOW);\n  return projected_position.xy;\n}\n\nvec4 project_common_position_to_clipspace(vec4 position, mat4 viewProjectionMatrix, vec4 center) {\n  return viewProjectionMatrix * position + center;\n}\nvec4 project_common_position_to_clipspace(vec4 position) {\n  return project_common_position_to_clipspace(position, project_uViewProjectionMatrix, project_uCenter);\n}\nvec2 project_pixel_size_to_clipspace(vec2 pixels) {\n  vec2 offset = pixels / project_uViewportSize * project_uDevicePixelRatio * 2.0;\n  return offset * project_uFocalDistance;\n}\n\nfloat project_size_to_pixel(float meters) {\n  return project_size(meters) * project_uScale;\n}\nfloat project_size_to_pixel(float size, int unit) {\n  if (unit == UNIT_METERS) return project_size_to_pixel(size);\n  if (unit == UNIT_COMMON) return size * project_uScale;\n  return size;\n}\nfloat project_pixel_size(float pixels) {\n  return pixels / project_uScale;\n}\nvec2 project_pixel_size(vec2 pixels) {\n  return pixels / project_uScale;\n}\n");

exports.default = _default;
},{"../../lib/constants":"node_modules/@deck.gl/core/dist/esm/lib/constants.js"}],"node_modules/gl-matrix/esm/common.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RANDOM = exports.EPSILON = exports.ARRAY_TYPE = void 0;
exports.equals = equals;
exports.setMatrixArrayType = setMatrixArrayType;
exports.toRadian = toRadian;

/**
 * Common utilities
 * @module glMatrix
 */
// Configuration Constants
var EPSILON = 0.000001;
exports.EPSILON = EPSILON;
var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
exports.ARRAY_TYPE = ARRAY_TYPE;
var RANDOM = Math.random;
/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array
 */

exports.RANDOM = RANDOM;

function setMatrixArrayType(type) {
  exports.ARRAY_TYPE = ARRAY_TYPE = type;
}

var degree = Math.PI / 180;
/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */

function toRadian(a) {
  return a * degree;
}
/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */


function equals(a, b) {
  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
}

if (!Math.hypot) Math.hypot = function () {
  var y = 0,
      i = arguments.length;

  while (i--) {
    y += arguments[i] * arguments[i];
  }

  return Math.sqrt(y);
};
},{}],"node_modules/gl-matrix/esm/mat4.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add = add;
exports.adjoint = adjoint;
exports.clone = clone;
exports.copy = copy;
exports.create = create;
exports.determinant = determinant;
exports.equals = equals;
exports.exactEquals = exactEquals;
exports.frob = frob;
exports.fromQuat = fromQuat;
exports.fromQuat2 = fromQuat2;
exports.fromRotation = fromRotation;
exports.fromRotationTranslation = fromRotationTranslation;
exports.fromRotationTranslationScale = fromRotationTranslationScale;
exports.fromRotationTranslationScaleOrigin = fromRotationTranslationScaleOrigin;
exports.fromScaling = fromScaling;
exports.fromTranslation = fromTranslation;
exports.fromValues = fromValues;
exports.fromXRotation = fromXRotation;
exports.fromYRotation = fromYRotation;
exports.fromZRotation = fromZRotation;
exports.frustum = frustum;
exports.getRotation = getRotation;
exports.getScaling = getScaling;
exports.getTranslation = getTranslation;
exports.identity = identity;
exports.invert = invert;
exports.lookAt = lookAt;
exports.mul = void 0;
exports.multiply = multiply;
exports.multiplyScalar = multiplyScalar;
exports.multiplyScalarAndAdd = multiplyScalarAndAdd;
exports.ortho = void 0;
exports.orthoNO = orthoNO;
exports.orthoZO = orthoZO;
exports.perspective = void 0;
exports.perspectiveFromFieldOfView = perspectiveFromFieldOfView;
exports.perspectiveNO = perspectiveNO;
exports.perspectiveZO = perspectiveZO;
exports.rotate = rotate;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.scale = scale;
exports.set = set;
exports.str = str;
exports.sub = void 0;
exports.subtract = subtract;
exports.targetTo = targetTo;
exports.translate = translate;
exports.transpose = transpose;

var glMatrix = _interopRequireWildcard(require("./common.js"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
 * @module mat4
 */

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(16);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }

  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */


function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new glMatrix.ARRAY_TYPE(16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */


function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */


function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */


function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a12 = a[6],
        a13 = a[7];
    var a23 = a[11];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }

  return out;
}
/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */


function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */


function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
  return out;
}
/**
 * Calculates the determinant of a mat4
 *
 * @param {ReadonlyMat4} a the source matrix
 * @returns {Number} determinant of a
 */


function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
/**
 * Multiplies two mat4s
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */


function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15]; // Cache only the current line of the second matrix

  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to translate
 * @param {ReadonlyVec3} v vector to translate by
 * @returns {mat4} out
 */


function translate(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;

  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }

  return out;
}
/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to scale
 * @param {ReadonlyVec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/


function scale(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @returns {mat4} out
 */


function rotate(out, a, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;

  if (len < glMatrix.EPSILON) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  a00 = a[0];
  a01 = a[1];
  a02 = a[2];
  a03 = a[3];
  a10 = a[4];
  a11 = a[5];
  a12 = a[6];
  a13 = a[7];
  a20 = a[8];
  a21 = a[9];
  a22 = a[10];
  a23 = a[11]; // Construct the elements of the rotation matrix

  b00 = x * x * t + c;
  b01 = y * x * t + z * s;
  b02 = z * x * t - y * s;
  b10 = x * y * t - z * s;
  b11 = y * y * t + c;
  b12 = z * y * t + x * s;
  b20 = x * z * t + y * s;
  b21 = y * z * t - x * s;
  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication

  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  return out;
}
/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function rotateX(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function rotateY(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function rotateZ(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyVec3} v Translation vector
 * @returns {mat4} out
 */


function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyVec3} v Scaling vector
 * @returns {mat4} out
 */


function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @returns {mat4} out
 */


function fromRotation(out, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;

  if (len < glMatrix.EPSILON) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c; // Perform rotation-specific matrix multiplication

  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function fromXRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function fromYRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = 0;
  out[2] = -s;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function fromZRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @returns {mat4} out
 */


function fromRotationTranslation(out, q, v) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 from a dual quat.
 *
 * @param {mat4} out Matrix
 * @param {ReadonlyQuat2} a Dual Quaternion
 * @returns {mat4} mat4 receiving operation result
 */


function fromQuat2(out, a) {
  var translation = new glMatrix.ARRAY_TYPE(3);
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7];
  var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense

  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }

  fromRotationTranslation(out, a, translation);
  return out;
}
/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */


function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
/**
 * Returns the scaling factor component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslationScale
 *  with a normalized Quaternion paramter, the returned vector will be
 *  the same as the scaling vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive scaling factor component
 * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */


function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.hypot(m11, m12, m13);
  out[1] = Math.hypot(m21, m22, m23);
  out[2] = Math.hypot(m31, m32, m33);
  return out;
}
/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */


function getRotation(out, mat) {
  var scaling = new glMatrix.ARRAY_TYPE(3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S = 0;

  if (trace > 0) {
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (sm23 - sm32) / S;
    out[1] = (sm31 - sm13) / S;
    out[2] = (sm12 - sm21) / S;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S;
    out[0] = 0.25 * S;
    out[1] = (sm12 + sm21) / S;
    out[2] = (sm31 + sm13) / S;
  } else if (sm22 > sm33) {
    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S;
    out[0] = (sm12 + sm21) / S;
    out[1] = 0.25 * S;
    out[2] = (sm23 + sm32) / S;
  } else {
    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S;
    out[0] = (sm31 + sm13) / S;
    out[1] = (sm23 + sm32) / S;
    out[2] = 0.25 * S;
  }

  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @param {ReadonlyVec3} s Scaling vector
 * @returns {mat4} out
 */


function fromRotationTranslationScale(out, q, v, s) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @param {ReadonlyVec3} s Scaling vector
 * @param {ReadonlyVec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */


function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  var ox = o[0];
  var oy = o[1];
  var oz = o[2];
  var out0 = (1 - (yy + zz)) * sx;
  var out1 = (xy + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx) * sz;
  var out10 = (1 - (xx + yy)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}
/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyQuat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */


function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */


function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
/**
 * Generates a perspective projection matrix with the given bounds.
 * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
 * which matches WebGL/OpenGL's clip volume.
 * Passing null/undefined/no value for far will generate infinite projection matrix.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum, can be null or Infinity
 * @returns {mat4} out
 */


function perspectiveNO(out, fovy, aspect, near, far) {
  var f = 1.0 / Math.tan(fovy / 2),
      nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;

  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }

  return out;
}
/**
 * Alias for {@link mat4.perspectiveNO}
 * @function
 */


var perspective = perspectiveNO;
/**
 * Generates a perspective projection matrix suitable for WebGPU with the given bounds.
 * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
 * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
 * Passing null/undefined/no value for far will generate infinite projection matrix.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum, can be null or Infinity
 * @returns {mat4} out
 */

exports.perspective = perspective;

function perspectiveZO(out, fovy, aspect, near, far) {
  var f = 1.0 / Math.tan(fovy / 2),
      nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;

  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = far * nf;
    out[14] = far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -near;
  }

  return out;
}
/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */


function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);
  var xScale = 2.0 / (leftTan + rightTan);
  var yScale = 2.0 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  out[4] = 0.0;
  out[5] = yScale;
  out[6] = 0.0;
  out[7] = 0.0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1.0;
  out[12] = 0.0;
  out[13] = 0.0;
  out[14] = far * near / (near - far);
  out[15] = 0.0;
  return out;
}
/**
 * Generates a orthogonal projection matrix with the given bounds.
 * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
 * which matches WebGL/OpenGL's clip volume.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */


function orthoNO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
/**
 * Alias for {@link mat4.orthoNO}
 * @function
 */


var ortho = orthoNO;
/**
 * Generates a orthogonal projection matrix with the given bounds.
 * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
 * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */

exports.ortho = ortho;

function orthoZO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = near * nf;
  out[15] = 1;
  return out;
}
/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis.
 * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {ReadonlyVec3} eye Position of the viewer
 * @param {ReadonlyVec3} center Point the viewer is looking at
 * @param {ReadonlyVec3} up vec3 pointing up
 * @returns {mat4} out
 */


function lookAt(out, eye, center, up) {
  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];

  if (Math.abs(eyex - centerx) < glMatrix.EPSILON && Math.abs(eyey - centery) < glMatrix.EPSILON && Math.abs(eyez - centerz) < glMatrix.EPSILON) {
    return identity(out);
  }

  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len = 1 / Math.hypot(z0, z1, z2);
  z0 *= len;
  z1 *= len;
  z2 *= len;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len = Math.hypot(x0, x1, x2);

  if (!len) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len = 1 / len;
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len = Math.hypot(y0, y1, y2);

  if (!len) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len = 1 / len;
    y0 *= len;
    y1 *= len;
    y2 *= len;
  }

  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
/**
 * Generates a matrix that makes something look at something else.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {ReadonlyVec3} eye Position of the viewer
 * @param {ReadonlyVec3} center Point the viewer is looking at
 * @param {ReadonlyVec3} up vec3 pointing up
 * @returns {mat4} out
 */


function targetTo(out, eye, target, up) {
  var eyex = eye[0],
      eyey = eye[1],
      eyez = eye[2],
      upx = up[0],
      upy = up[1],
      upz = up[2];
  var z0 = eyex - target[0],
      z1 = eyey - target[1],
      z2 = eyez - target[2];
  var len = z0 * z0 + z1 * z1 + z2 * z2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    z0 *= len;
    z1 *= len;
    z2 *= len;
  }

  var x0 = upy * z2 - upz * z1,
      x1 = upz * z0 - upx * z2,
      x2 = upx * z1 - upy * z0;
  len = x0 * x0 + x1 * x1 + x2 * x2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}
/**
 * Returns a string representation of a mat4
 *
 * @param {ReadonlyMat4} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */


function str(a) {
  return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
}
/**
 * Returns Frobenius norm of a mat4
 *
 * @param {ReadonlyMat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */


function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
}
/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */


function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}
/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */


function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  out[9] = a[9] + b[9] * scale;
  out[10] = a[10] + b[10] * scale;
  out[11] = a[11] + b[11] * scale;
  out[12] = a[12] + b[12] * scale;
  out[13] = a[13] + b[13] * scale;
  out[14] = a[14] + b[14] * scale;
  out[15] = a[15] + b[15] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat4} a The first matrix.
 * @param {ReadonlyMat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat4} a The first matrix.
 * @param {ReadonlyMat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7];
  var a8 = a[8],
      a9 = a[9],
      a10 = a[10],
      a11 = a[11];
  var a12 = a[12],
      a13 = a[13],
      a14 = a[14],
      a15 = a[15];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  var b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7];
  var b8 = b[8],
      b9 = b[9],
      b10 = b[10],
      b11 = b[11];
  var b12 = b[12],
      b13 = b[13],
      b14 = b[14],
      b15 = b[15];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));
}
/**
 * Alias for {@link mat4.multiply}
 * @function
 */


var mul = multiply;
/**
 * Alias for {@link mat4.subtract}
 * @function
 */

exports.mul = mul;
var sub = subtract;
exports.sub = sub;
},{"./common.js":"node_modules/gl-matrix/esm/common.js"}],"node_modules/gl-matrix/esm/vec4.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add = add;
exports.ceil = ceil;
exports.clone = clone;
exports.copy = copy;
exports.create = create;
exports.cross = cross;
exports.dist = void 0;
exports.distance = distance;
exports.div = void 0;
exports.divide = divide;
exports.dot = dot;
exports.equals = equals;
exports.exactEquals = exactEquals;
exports.floor = floor;
exports.forEach = void 0;
exports.fromValues = fromValues;
exports.inverse = inverse;
exports.len = void 0;
exports.length = length;
exports.lerp = lerp;
exports.max = max;
exports.min = min;
exports.mul = void 0;
exports.multiply = multiply;
exports.negate = negate;
exports.normalize = normalize;
exports.random = random;
exports.round = round;
exports.scale = scale;
exports.scaleAndAdd = scaleAndAdd;
exports.set = set;
exports.sqrLen = exports.sqrDist = void 0;
exports.squaredDistance = squaredDistance;
exports.squaredLength = squaredLength;
exports.str = str;
exports.sub = void 0;
exports.subtract = subtract;
exports.transformMat4 = transformMat4;
exports.transformQuat = transformQuat;
exports.zero = zero;

var glMatrix = _interopRequireWildcard(require("./common.js"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * 4 Dimensional Vector
 * @module vec4
 */

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(4);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }

  return out;
}
/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {ReadonlyVec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */


function fromValues(x, y, z, w) {
  var out = new glMatrix.ARRAY_TYPE(4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the source vector
 * @returns {vec4} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */


function set(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */


function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  out[3] = a[3] * b[3];
  return out;
}
/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */


function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  out[3] = a[3] / b[3];
  return out;
}
/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to ceil
 * @returns {vec4} out
 */


function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  out[3] = Math.ceil(a[3]);
  return out;
}
/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to floor
 * @returns {vec4} out
 */


function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  out[3] = Math.floor(a[3]);
  return out;
}
/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */


function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  out[3] = Math.min(a[3], b[3]);
  return out;
}
/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */


function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  out[3] = Math.max(a[3], b[3]);
  return out;
}
/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to round
 * @returns {vec4} out
 */


function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  out[3] = Math.round(a[3]);
  return out;
}
/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */


function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */


function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} distance between a and b
 */


function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return Math.hypot(x, y, z, w);
}
/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} squared distance between a and b
 */


function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Calculates the length of a vec4
 *
 * @param {ReadonlyVec4} a vector to calculate length of
 * @returns {Number} length of a
 */


function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return Math.hypot(x, y, z, w);
}
/**
 * Calculates the squared length of a vec4
 *
 * @param {ReadonlyVec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */


function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to negate
 * @returns {vec4} out
 */


function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = -a[3];
  return out;
}
/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to invert
 * @returns {vec4} out
 */


function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
}
/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to normalize
 * @returns {vec4} out
 */


function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len = x * x + y * y + z * z + w * w;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
  }

  out[0] = x * len;
  out[1] = y * len;
  out[2] = z * len;
  out[3] = w * len;
  return out;
}
/**
 * Calculates the dot product of two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} dot product of a and b
 */


function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}
/**
 * Returns the cross-product of three vectors in a 4-dimensional space
 *
 * @param {ReadonlyVec4} result the receiving vector
 * @param {ReadonlyVec4} U the first vector
 * @param {ReadonlyVec4} V the second vector
 * @param {ReadonlyVec4} W the third vector
 * @returns {vec4} result
 */


function cross(out, u, v, w) {
  var A = v[0] * w[1] - v[1] * w[0],
      B = v[0] * w[2] - v[2] * w[0],
      C = v[0] * w[3] - v[3] * w[0],
      D = v[1] * w[2] - v[2] * w[1],
      E = v[1] * w[3] - v[3] * w[1],
      F = v[2] * w[3] - v[3] * w[2];
  var G = u[0];
  var H = u[1];
  var I = u[2];
  var J = u[3];
  out[0] = H * F - I * E + J * D;
  out[1] = -(G * F) + I * C - J * B;
  out[2] = G * E - H * C + J * A;
  out[3] = -(G * D) + H * B - I * A;
  return out;
}
/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec4} out
 */


function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  var aw = a[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */


function random(out, scale) {
  scale = scale || 1.0; // Marsaglia, George. Choosing a Point from the Surface of a
  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.
  // http://projecteuclid.org/euclid.aoms/1177692644;

  var v1, v2, v3, v4;
  var s1, s2;

  do {
    v1 = glMatrix.RANDOM() * 2 - 1;
    v2 = glMatrix.RANDOM() * 2 - 1;
    s1 = v1 * v1 + v2 * v2;
  } while (s1 >= 1);

  do {
    v3 = glMatrix.RANDOM() * 2 - 1;
    v4 = glMatrix.RANDOM() * 2 - 1;
    s2 = v3 * v3 + v4 * v4;
  } while (s2 >= 1);

  var d = Math.sqrt((1 - s1) / s2);
  out[0] = scale * v1;
  out[1] = scale * v2;
  out[2] = scale * v3 * d;
  out[3] = scale * v4 * d;
  return out;
}
/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec4} out
 */


function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out;
}
/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to transform
 * @param {ReadonlyQuat} q quaternion to transform with
 * @returns {vec4} out
 */


function transformQuat(out, a, q) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3]; // calculate quat * vec

  var ix = qw * x + qy * z - qz * y;
  var iy = qw * y + qz * x - qx * z;
  var iz = qw * z + qx * y - qy * x;
  var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to zero
 *
 * @param {vec4} out the receiving vector
 * @returns {vec4} out
 */


function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec4} a vector to represent as a string
 * @returns {String} string representation of the vector
 */


function str(a) {
  return "vec4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec4} a The first vector.
 * @param {ReadonlyVec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec4} a The first vector.
 * @param {ReadonlyVec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}
/**
 * Alias for {@link vec4.subtract}
 * @function
 */


var sub = subtract;
/**
 * Alias for {@link vec4.multiply}
 * @function
 */

exports.sub = sub;
var mul = multiply;
/**
 * Alias for {@link vec4.divide}
 * @function
 */

exports.mul = mul;
var div = divide;
/**
 * Alias for {@link vec4.distance}
 * @function
 */

exports.div = div;
var dist = distance;
/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */

exports.dist = dist;
var sqrDist = squaredDistance;
/**
 * Alias for {@link vec4.length}
 * @function
 */

exports.sqrDist = sqrDist;
var len = length;
/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */

exports.len = len;
var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

exports.sqrLen = sqrLen;

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 4;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }

    return a;
  };
}();

exports.forEach = forEach;
},{"./common.js":"node_modules/gl-matrix/esm/common.js"}],"node_modules/@deck.gl/core/dist/esm/utils/memoize.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = memoize;

function isEqual(a, b) {
  if (a === b) {
    return true;
  }

  if (Array.isArray(a)) {
    const len = a.length;

    if (!b || b.length !== len) {
      return false;
    }

    for (let i = 0; i < len; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }

    return true;
  }

  return false;
}

function memoize(compute) {
  let cachedArgs = {};
  let cachedResult;
  return args => {
    for (const key in args) {
      if (!isEqual(args[key], cachedArgs[key])) {
        cachedResult = compute(args);
        cachedArgs = args;
        break;
      }
    }

    return cachedResult;
  };
}
},{}],"node_modules/@deck.gl/core/dist/esm/shaderlib/project/viewport-uniforms.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getOffsetOrigin = getOffsetOrigin;
exports.getUniformsFromViewport = getUniformsFromViewport;

var mat4 = _interopRequireWildcard(require("gl-matrix/mat4"));

var vec4 = _interopRequireWildcard(require("gl-matrix/vec4"));

var _constants = require("../../lib/constants");

var _memoize = _interopRequireDefault(require("../../utils/memoize"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const ZERO_VECTOR = [0, 0, 0, 0];
const VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];
const IDENTITY_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
const DEFAULT_PIXELS_PER_UNIT2 = [0, 0, 0];
const DEFAULT_COORDINATE_ORIGIN = [0, 0, 0];
const getMemoizedViewportUniforms = (0, _memoize.default)(calculateViewportUniforms);

function getOffsetOrigin(viewport, coordinateSystem, coordinateOrigin = DEFAULT_COORDINATE_ORIGIN) {
  if (coordinateOrigin.length < 3) {
    coordinateOrigin = [coordinateOrigin[0], coordinateOrigin[1], 0];
  }

  let shaderCoordinateOrigin = coordinateOrigin;
  let geospatialOrigin;
  let offsetMode = true;

  if (coordinateSystem === _constants.COORDINATE_SYSTEM.LNGLAT_OFFSETS || coordinateSystem === _constants.COORDINATE_SYSTEM.METER_OFFSETS) {
    geospatialOrigin = coordinateOrigin;
  } else {
    geospatialOrigin = viewport.isGeospatial ? [Math.fround(viewport.longitude), Math.fround(viewport.latitude), 0] : null;
  }

  switch (viewport.projectionMode) {
    case _constants.PROJECTION_MODE.WEB_MERCATOR:
      if (coordinateSystem === _constants.COORDINATE_SYSTEM.LNGLAT || coordinateSystem === _constants.COORDINATE_SYSTEM.CARTESIAN) {
        geospatialOrigin = [0, 0, 0];
        offsetMode = false;
      }

      break;

    case _constants.PROJECTION_MODE.WEB_MERCATOR_AUTO_OFFSET:
      if (coordinateSystem === _constants.COORDINATE_SYSTEM.LNGLAT) {
        shaderCoordinateOrigin = geospatialOrigin;
      } else if (coordinateSystem === _constants.COORDINATE_SYSTEM.CARTESIAN) {
        shaderCoordinateOrigin = [Math.fround(viewport.center[0]), Math.fround(viewport.center[1]), 0];
        geospatialOrigin = viewport.unprojectPosition(shaderCoordinateOrigin);
        shaderCoordinateOrigin[0] -= coordinateOrigin[0];
        shaderCoordinateOrigin[1] -= coordinateOrigin[1];
        shaderCoordinateOrigin[2] -= coordinateOrigin[2];
      }

      break;

    case _constants.PROJECTION_MODE.IDENTITY:
      shaderCoordinateOrigin = viewport.position.map(Math.fround);
      shaderCoordinateOrigin[2] = shaderCoordinateOrigin[2] || 0;
      break;

    case _constants.PROJECTION_MODE.GLOBE:
      offsetMode = false;
      geospatialOrigin = null;
      break;

    default:
      offsetMode = false;
  }

  return {
    geospatialOrigin,
    shaderCoordinateOrigin,
    offsetMode
  };
}

function calculateMatrixAndOffset(viewport, coordinateSystem, coordinateOrigin) {
  const {
    viewMatrixUncentered,
    projectionMatrix
  } = viewport;
  let {
    viewMatrix,
    viewProjectionMatrix
  } = viewport;
  let projectionCenter = ZERO_VECTOR;
  let originCommon = ZERO_VECTOR;
  let cameraPosCommon = viewport.cameraPosition;
  const {
    geospatialOrigin,
    shaderCoordinateOrigin,
    offsetMode
  } = getOffsetOrigin(viewport, coordinateSystem, coordinateOrigin);

  if (offsetMode) {
    originCommon = viewport.projectPosition(geospatialOrigin || shaderCoordinateOrigin);
    cameraPosCommon = [cameraPosCommon[0] - originCommon[0], cameraPosCommon[1] - originCommon[1], cameraPosCommon[2] - originCommon[2]];
    originCommon[3] = 1;
    projectionCenter = vec4.transformMat4([], originCommon, viewProjectionMatrix);
    viewMatrix = viewMatrixUncentered || viewMatrix;
    viewProjectionMatrix = mat4.multiply([], projectionMatrix, viewMatrix);
    viewProjectionMatrix = mat4.multiply([], viewProjectionMatrix, VECTOR_TO_POINT_MATRIX);
  }

  return {
    viewMatrix,
    viewProjectionMatrix,
    projectionCenter,
    originCommon,
    cameraPosCommon,
    shaderCoordinateOrigin,
    geospatialOrigin
  };
}

function getUniformsFromViewport({
  viewport,
  devicePixelRatio = 1,
  modelMatrix = null,
  coordinateSystem = _constants.COORDINATE_SYSTEM.DEFAULT,
  coordinateOrigin,
  autoWrapLongitude = false
} = {}) {
  if (coordinateSystem === _constants.COORDINATE_SYSTEM.DEFAULT) {
    coordinateSystem = viewport.isGeospatial ? _constants.COORDINATE_SYSTEM.LNGLAT : _constants.COORDINATE_SYSTEM.CARTESIAN;
  }

  const uniforms = getMemoizedViewportUniforms({
    viewport,
    devicePixelRatio,
    coordinateSystem,
    coordinateOrigin
  });
  uniforms.project_uWrapLongitude = autoWrapLongitude;
  uniforms.project_uModelMatrix = modelMatrix || IDENTITY_MATRIX;
  return uniforms;
}

function calculateViewportUniforms({
  viewport,
  devicePixelRatio,
  coordinateSystem,
  coordinateOrigin
}) {
  const {
    projectionCenter,
    viewProjectionMatrix,
    originCommon,
    cameraPosCommon,
    shaderCoordinateOrigin,
    geospatialOrigin
  } = calculateMatrixAndOffset(viewport, coordinateSystem, coordinateOrigin);
  const distanceScales = viewport.getDistanceScales();
  const viewportSize = [viewport.width * devicePixelRatio, viewport.height * devicePixelRatio];
  const focalDistance = vec4.transformMat4([], [0, 0, -viewport.focalDistance, 1], viewport.projectionMatrix)[3] || 1;
  const uniforms = {
    project_uCoordinateSystem: coordinateSystem,
    project_uProjectionMode: viewport.projectionMode,
    project_uCoordinateOrigin: shaderCoordinateOrigin,
    project_uCommonOrigin: originCommon.slice(0, 3),
    project_uCenter: projectionCenter,
    project_uPseudoMeters: Boolean(viewport._pseudoMeters),
    project_uViewportSize: viewportSize,
    project_uDevicePixelRatio: devicePixelRatio,
    project_uFocalDistance: focalDistance,
    project_uCommonUnitsPerMeter: distanceScales.unitsPerMeter,
    project_uCommonUnitsPerWorldUnit: distanceScales.unitsPerMeter,
    project_uCommonUnitsPerWorldUnit2: DEFAULT_PIXELS_PER_UNIT2,
    project_uScale: viewport.scale,
    project_uViewProjectionMatrix: viewProjectionMatrix,
    project_uCameraPosition: cameraPosCommon
  };

  if (geospatialOrigin) {
    const distanceScalesAtOrigin = viewport.getDistanceScales(geospatialOrigin);

    switch (coordinateSystem) {
      case _constants.COORDINATE_SYSTEM.METER_OFFSETS:
        uniforms.project_uCommonUnitsPerWorldUnit = distanceScalesAtOrigin.unitsPerMeter;
        uniforms.project_uCommonUnitsPerWorldUnit2 = distanceScalesAtOrigin.unitsPerMeter2;
        break;

      case _constants.COORDINATE_SYSTEM.LNGLAT:
      case _constants.COORDINATE_SYSTEM.LNGLAT_OFFSETS:
        if (!viewport._pseudoMeters) {
          uniforms.project_uCommonUnitsPerMeter = distanceScalesAtOrigin.unitsPerMeter;
        }

        uniforms.project_uCommonUnitsPerWorldUnit = distanceScalesAtOrigin.unitsPerDegree;
        uniforms.project_uCommonUnitsPerWorldUnit2 = distanceScalesAtOrigin.unitsPerDegree2;
        break;

      case _constants.COORDINATE_SYSTEM.CARTESIAN:
        uniforms.project_uCommonUnitsPerWorldUnit = [1, 1, distanceScalesAtOrigin.unitsPerMeter[2]];
        uniforms.project_uCommonUnitsPerWorldUnit2 = [0, 0, distanceScalesAtOrigin.unitsPerMeter2[2]];
        break;

      default:
        break;
    }
  }

  return uniforms;
}
},{"gl-matrix/mat4":"node_modules/gl-matrix/esm/mat4.js","gl-matrix/vec4":"node_modules/gl-matrix/esm/vec4.js","../../lib/constants":"node_modules/@deck.gl/core/dist/esm/lib/constants.js","../../utils/memoize":"node_modules/@deck.gl/core/dist/esm/utils/memoize.js"}],"node_modules/@deck.gl/core/dist/esm/shaderlib/project/project.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _core = require("@luma.gl/core");

var _geometry = _interopRequireDefault(require("../misc/geometry"));

var _project = _interopRequireDefault(require("./project.glsl"));

var _viewportUniforms = require("./viewport-uniforms");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const INITIAL_MODULE_OPTIONS = {};

function getUniforms(opts = INITIAL_MODULE_OPTIONS) {
  if (opts.viewport) {
    return (0, _viewportUniforms.getUniformsFromViewport)(opts);
  }

  return {};
}

var _default = {
  name: 'project',
  dependencies: [_core.fp32, _geometry.default],
  vs: _project.default,
  getUniforms
};
exports.default = _default;
},{"@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","../misc/geometry":"node_modules/@deck.gl/core/dist/esm/shaderlib/misc/geometry.js","./project.glsl":"node_modules/@deck.gl/core/dist/esm/shaderlib/project/project.glsl.js","./viewport-uniforms":"node_modules/@deck.gl/core/dist/esm/shaderlib/project/viewport-uniforms.js"}],"node_modules/@deck.gl/core/dist/esm/shaderlib/project32/project32.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _project = _interopRequireDefault(require("../project/project"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const vs = "\nvec4 project_position_to_clipspace(\n  vec3 position, vec3 position64Low, vec3 offset, out vec4 commonPosition\n) {\n  vec3 projectedPosition = project_position(position, position64Low);\n  mat3 rotation;\n  if (project_needs_rotation(projectedPosition, rotation)) {\n    // offset is specified as ENU\n    // when in globe projection, rotate offset so that the ground alighs with the surface of the globe\n    offset = rotation * offset;\n  }\n  commonPosition = vec4(projectedPosition + offset, 1.0);\n  return project_common_position_to_clipspace(commonPosition);\n}\n\nvec4 project_position_to_clipspace(\n  vec3 position, vec3 position64Low, vec3 offset\n) {\n  vec4 commonPosition;\n  return project_position_to_clipspace(position, position64Low, offset, commonPosition);\n}\n";
var _default = {
  name: 'project32',
  dependencies: [_project.default],
  vs
};
exports.default = _default;
},{"../project/project":"node_modules/@deck.gl/core/dist/esm/shaderlib/project/project.js"}],"node_modules/@math.gl/web-mercator/node_modules/gl-matrix/esm/common.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RANDOM = exports.EPSILON = exports.ARRAY_TYPE = void 0;
exports.equals = equals;
exports.setMatrixArrayType = setMatrixArrayType;
exports.toRadian = toRadian;

/**
 * Common utilities
 * @module glMatrix
 */
// Configuration Constants
var EPSILON = 0.000001;
exports.EPSILON = EPSILON;
var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
exports.ARRAY_TYPE = ARRAY_TYPE;
var RANDOM = Math.random;
/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array
 */

exports.RANDOM = RANDOM;

function setMatrixArrayType(type) {
  exports.ARRAY_TYPE = ARRAY_TYPE = type;
}

var degree = Math.PI / 180;
/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */

function toRadian(a) {
  return a * degree;
}
/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */


function equals(a, b) {
  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
}

if (!Math.hypot) Math.hypot = function () {
  var y = 0,
      i = arguments.length;

  while (i--) {
    y += arguments[i] * arguments[i];
  }

  return Math.sqrt(y);
};
},{}],"node_modules/@math.gl/web-mercator/node_modules/gl-matrix/esm/vec4.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add = add;
exports.ceil = ceil;
exports.clone = clone;
exports.copy = copy;
exports.create = create;
exports.cross = cross;
exports.dist = void 0;
exports.distance = distance;
exports.div = void 0;
exports.divide = divide;
exports.dot = dot;
exports.equals = equals;
exports.exactEquals = exactEquals;
exports.floor = floor;
exports.forEach = void 0;
exports.fromValues = fromValues;
exports.inverse = inverse;
exports.len = void 0;
exports.length = length;
exports.lerp = lerp;
exports.max = max;
exports.min = min;
exports.mul = void 0;
exports.multiply = multiply;
exports.negate = negate;
exports.normalize = normalize;
exports.random = random;
exports.round = round;
exports.scale = scale;
exports.scaleAndAdd = scaleAndAdd;
exports.set = set;
exports.sqrLen = exports.sqrDist = void 0;
exports.squaredDistance = squaredDistance;
exports.squaredLength = squaredLength;
exports.str = str;
exports.sub = void 0;
exports.subtract = subtract;
exports.transformMat4 = transformMat4;
exports.transformQuat = transformQuat;
exports.zero = zero;

var glMatrix = _interopRequireWildcard(require("./common.js"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * 4 Dimensional Vector
 * @module vec4
 */

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(4);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }

  return out;
}
/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {ReadonlyVec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */


function fromValues(x, y, z, w) {
  var out = new glMatrix.ARRAY_TYPE(4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the source vector
 * @returns {vec4} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */


function set(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */


function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  out[3] = a[3] * b[3];
  return out;
}
/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */


function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  out[3] = a[3] / b[3];
  return out;
}
/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to ceil
 * @returns {vec4} out
 */


function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  out[3] = Math.ceil(a[3]);
  return out;
}
/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to floor
 * @returns {vec4} out
 */


function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  out[3] = Math.floor(a[3]);
  return out;
}
/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */


function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  out[3] = Math.min(a[3], b[3]);
  return out;
}
/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */


function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  out[3] = Math.max(a[3], b[3]);
  return out;
}
/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to round
 * @returns {vec4} out
 */


function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  out[3] = Math.round(a[3]);
  return out;
}
/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */


function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */


function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} distance between a and b
 */


function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return Math.hypot(x, y, z, w);
}
/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} squared distance between a and b
 */


function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Calculates the length of a vec4
 *
 * @param {ReadonlyVec4} a vector to calculate length of
 * @returns {Number} length of a
 */


function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return Math.hypot(x, y, z, w);
}
/**
 * Calculates the squared length of a vec4
 *
 * @param {ReadonlyVec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */


function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to negate
 * @returns {vec4} out
 */


function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = -a[3];
  return out;
}
/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to invert
 * @returns {vec4} out
 */


function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
}
/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to normalize
 * @returns {vec4} out
 */


function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len = x * x + y * y + z * z + w * w;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
  }

  out[0] = x * len;
  out[1] = y * len;
  out[2] = z * len;
  out[3] = w * len;
  return out;
}
/**
 * Calculates the dot product of two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} dot product of a and b
 */


function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}
/**
 * Returns the cross-product of three vectors in a 4-dimensional space
 *
 * @param {ReadonlyVec4} result the receiving vector
 * @param {ReadonlyVec4} U the first vector
 * @param {ReadonlyVec4} V the second vector
 * @param {ReadonlyVec4} W the third vector
 * @returns {vec4} result
 */


function cross(out, u, v, w) {
  var A = v[0] * w[1] - v[1] * w[0],
      B = v[0] * w[2] - v[2] * w[0],
      C = v[0] * w[3] - v[3] * w[0],
      D = v[1] * w[2] - v[2] * w[1],
      E = v[1] * w[3] - v[3] * w[1],
      F = v[2] * w[3] - v[3] * w[2];
  var G = u[0];
  var H = u[1];
  var I = u[2];
  var J = u[3];
  out[0] = H * F - I * E + J * D;
  out[1] = -(G * F) + I * C - J * B;
  out[2] = G * E - H * C + J * A;
  out[3] = -(G * D) + H * B - I * A;
  return out;
}
/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec4} out
 */


function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  var aw = a[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */


function random(out, scale) {
  scale = scale || 1.0; // Marsaglia, George. Choosing a Point from the Surface of a
  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.
  // http://projecteuclid.org/euclid.aoms/1177692644;

  var v1, v2, v3, v4;
  var s1, s2;

  do {
    v1 = glMatrix.RANDOM() * 2 - 1;
    v2 = glMatrix.RANDOM() * 2 - 1;
    s1 = v1 * v1 + v2 * v2;
  } while (s1 >= 1);

  do {
    v3 = glMatrix.RANDOM() * 2 - 1;
    v4 = glMatrix.RANDOM() * 2 - 1;
    s2 = v3 * v3 + v4 * v4;
  } while (s2 >= 1);

  var d = Math.sqrt((1 - s1) / s2);
  out[0] = scale * v1;
  out[1] = scale * v2;
  out[2] = scale * v3 * d;
  out[3] = scale * v4 * d;
  return out;
}
/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec4} out
 */


function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out;
}
/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to transform
 * @param {ReadonlyQuat} q quaternion to transform with
 * @returns {vec4} out
 */


function transformQuat(out, a, q) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3]; // calculate quat * vec

  var ix = qw * x + qy * z - qz * y;
  var iy = qw * y + qz * x - qx * z;
  var iz = qw * z + qx * y - qy * x;
  var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to zero
 *
 * @param {vec4} out the receiving vector
 * @returns {vec4} out
 */


function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec4} a vector to represent as a string
 * @returns {String} string representation of the vector
 */


function str(a) {
  return "vec4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec4} a The first vector.
 * @param {ReadonlyVec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec4} a The first vector.
 * @param {ReadonlyVec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}
/**
 * Alias for {@link vec4.subtract}
 * @function
 */


var sub = subtract;
/**
 * Alias for {@link vec4.multiply}
 * @function
 */

exports.sub = sub;
var mul = multiply;
/**
 * Alias for {@link vec4.divide}
 * @function
 */

exports.mul = mul;
var div = divide;
/**
 * Alias for {@link vec4.distance}
 * @function
 */

exports.div = div;
var dist = distance;
/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */

exports.dist = dist;
var sqrDist = squaredDistance;
/**
 * Alias for {@link vec4.length}
 * @function
 */

exports.sqrDist = sqrDist;
var len = length;
/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */

exports.len = len;
var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

exports.sqrLen = sqrLen;

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 4;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }

    return a;
  };
}();

exports.forEach = forEach;
},{"./common.js":"node_modules/@math.gl/web-mercator/node_modules/gl-matrix/esm/common.js"}],"node_modules/@math.gl/web-mercator/dist/esm/math-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clamp = clamp;
exports.createMat4 = createMat4;
exports.lerp = lerp;
exports.log2 = void 0;
exports.mod = mod;
exports.transformVector = transformVector;

var vec4 = _interopRequireWildcard(require("gl-matrix/vec4"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function createMat4() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}

function transformVector(matrix, vector) {
  const result = vec4.transformMat4([], vector, matrix);
  vec4.scale(result, result, 1 / result[3]);
  return result;
}

function mod(value, divisor) {
  const modulus = value % divisor;
  return modulus < 0 ? divisor + modulus : modulus;
}

function lerp(start, end, step) {
  return step * end + (1 - step) * start;
}

function clamp(x, min, max) {
  return x < min ? min : x > max ? max : x;
}

function ieLog2(x) {
  return Math.log(x) * Math.LOG2E;
}

const log2 = Math.log2 || ieLog2;
exports.log2 = log2;
},{"gl-matrix/vec4":"node_modules/@math.gl/web-mercator/node_modules/gl-matrix/esm/vec4.js"}],"node_modules/@math.gl/web-mercator/node_modules/gl-matrix/esm/mat4.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add = add;
exports.adjoint = adjoint;
exports.clone = clone;
exports.copy = copy;
exports.create = create;
exports.determinant = determinant;
exports.equals = equals;
exports.exactEquals = exactEquals;
exports.frob = frob;
exports.fromQuat = fromQuat;
exports.fromQuat2 = fromQuat2;
exports.fromRotation = fromRotation;
exports.fromRotationTranslation = fromRotationTranslation;
exports.fromRotationTranslationScale = fromRotationTranslationScale;
exports.fromRotationTranslationScaleOrigin = fromRotationTranslationScaleOrigin;
exports.fromScaling = fromScaling;
exports.fromTranslation = fromTranslation;
exports.fromValues = fromValues;
exports.fromXRotation = fromXRotation;
exports.fromYRotation = fromYRotation;
exports.fromZRotation = fromZRotation;
exports.frustum = frustum;
exports.getRotation = getRotation;
exports.getScaling = getScaling;
exports.getTranslation = getTranslation;
exports.identity = identity;
exports.invert = invert;
exports.lookAt = lookAt;
exports.mul = void 0;
exports.multiply = multiply;
exports.multiplyScalar = multiplyScalar;
exports.multiplyScalarAndAdd = multiplyScalarAndAdd;
exports.ortho = ortho;
exports.perspective = perspective;
exports.perspectiveFromFieldOfView = perspectiveFromFieldOfView;
exports.rotate = rotate;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.scale = scale;
exports.set = set;
exports.str = str;
exports.sub = void 0;
exports.subtract = subtract;
exports.targetTo = targetTo;
exports.translate = translate;
exports.transpose = transpose;

var glMatrix = _interopRequireWildcard(require("./common.js"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
 * @module mat4
 */

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(16);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }

  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */


function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new glMatrix.ARRAY_TYPE(16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */


function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */


function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */


function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a12 = a[6],
        a13 = a[7];
    var a23 = a[11];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }

  return out;
}
/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */


function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */


function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
  return out;
}
/**
 * Calculates the determinant of a mat4
 *
 * @param {ReadonlyMat4} a the source matrix
 * @returns {Number} determinant of a
 */


function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
/**
 * Multiplies two mat4s
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */


function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15]; // Cache only the current line of the second matrix

  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to translate
 * @param {ReadonlyVec3} v vector to translate by
 * @returns {mat4} out
 */


function translate(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;

  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }

  return out;
}
/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to scale
 * @param {ReadonlyVec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/


function scale(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @returns {mat4} out
 */


function rotate(out, a, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;

  if (len < glMatrix.EPSILON) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  a00 = a[0];
  a01 = a[1];
  a02 = a[2];
  a03 = a[3];
  a10 = a[4];
  a11 = a[5];
  a12 = a[6];
  a13 = a[7];
  a20 = a[8];
  a21 = a[9];
  a22 = a[10];
  a23 = a[11]; // Construct the elements of the rotation matrix

  b00 = x * x * t + c;
  b01 = y * x * t + z * s;
  b02 = z * x * t - y * s;
  b10 = x * y * t - z * s;
  b11 = y * y * t + c;
  b12 = z * y * t + x * s;
  b20 = x * z * t + y * s;
  b21 = y * z * t - x * s;
  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication

  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  return out;
}
/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function rotateX(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function rotateY(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function rotateZ(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyVec3} v Translation vector
 * @returns {mat4} out
 */


function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyVec3} v Scaling vector
 * @returns {mat4} out
 */


function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @returns {mat4} out
 */


function fromRotation(out, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;

  if (len < glMatrix.EPSILON) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c; // Perform rotation-specific matrix multiplication

  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function fromXRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function fromYRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = 0;
  out[2] = -s;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function fromZRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @returns {mat4} out
 */


function fromRotationTranslation(out, q, v) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 from a dual quat.
 *
 * @param {mat4} out Matrix
 * @param {ReadonlyQuat2} a Dual Quaternion
 * @returns {mat4} mat4 receiving operation result
 */


function fromQuat2(out, a) {
  var translation = new glMatrix.ARRAY_TYPE(3);
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7];
  var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense

  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }

  fromRotationTranslation(out, a, translation);
  return out;
}
/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */


function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
/**
 * Returns the scaling factor component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslationScale
 *  with a normalized Quaternion paramter, the returned vector will be
 *  the same as the scaling vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive scaling factor component
 * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */


function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.hypot(m11, m12, m13);
  out[1] = Math.hypot(m21, m22, m23);
  out[2] = Math.hypot(m31, m32, m33);
  return out;
}
/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */


function getRotation(out, mat) {
  var scaling = new glMatrix.ARRAY_TYPE(3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S = 0;

  if (trace > 0) {
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (sm23 - sm32) / S;
    out[1] = (sm31 - sm13) / S;
    out[2] = (sm12 - sm21) / S;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S;
    out[0] = 0.25 * S;
    out[1] = (sm12 + sm21) / S;
    out[2] = (sm31 + sm13) / S;
  } else if (sm22 > sm33) {
    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S;
    out[0] = (sm12 + sm21) / S;
    out[1] = 0.25 * S;
    out[2] = (sm23 + sm32) / S;
  } else {
    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S;
    out[0] = (sm31 + sm13) / S;
    out[1] = (sm23 + sm32) / S;
    out[2] = 0.25 * S;
  }

  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @param {ReadonlyVec3} s Scaling vector
 * @returns {mat4} out
 */


function fromRotationTranslationScale(out, q, v, s) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @param {ReadonlyVec3} s Scaling vector
 * @param {ReadonlyVec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */


function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  var ox = o[0];
  var oy = o[1];
  var oz = o[2];
  var out0 = (1 - (yy + zz)) * sx;
  var out1 = (xy + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx) * sz;
  var out10 = (1 - (xx + yy)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}
/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyQuat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */


function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */


function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
/**
 * Generates a perspective projection matrix with the given bounds.
 * Passing null/undefined/no value for far will generate infinite projection matrix.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum, can be null or Infinity
 * @returns {mat4} out
 */


function perspective(out, fovy, aspect, near, far) {
  var f = 1.0 / Math.tan(fovy / 2),
      nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;

  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }

  return out;
}
/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */


function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);
  var xScale = 2.0 / (leftTan + rightTan);
  var yScale = 2.0 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  out[4] = 0.0;
  out[5] = yScale;
  out[6] = 0.0;
  out[7] = 0.0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1.0;
  out[12] = 0.0;
  out[13] = 0.0;
  out[14] = far * near / (near - far);
  out[15] = 0.0;
  return out;
}
/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */


function ortho(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis.
 * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {ReadonlyVec3} eye Position of the viewer
 * @param {ReadonlyVec3} center Point the viewer is looking at
 * @param {ReadonlyVec3} up vec3 pointing up
 * @returns {mat4} out
 */


function lookAt(out, eye, center, up) {
  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];

  if (Math.abs(eyex - centerx) < glMatrix.EPSILON && Math.abs(eyey - centery) < glMatrix.EPSILON && Math.abs(eyez - centerz) < glMatrix.EPSILON) {
    return identity(out);
  }

  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len = 1 / Math.hypot(z0, z1, z2);
  z0 *= len;
  z1 *= len;
  z2 *= len;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len = Math.hypot(x0, x1, x2);

  if (!len) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len = 1 / len;
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len = Math.hypot(y0, y1, y2);

  if (!len) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len = 1 / len;
    y0 *= len;
    y1 *= len;
    y2 *= len;
  }

  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
/**
 * Generates a matrix that makes something look at something else.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {ReadonlyVec3} eye Position of the viewer
 * @param {ReadonlyVec3} center Point the viewer is looking at
 * @param {ReadonlyVec3} up vec3 pointing up
 * @returns {mat4} out
 */


function targetTo(out, eye, target, up) {
  var eyex = eye[0],
      eyey = eye[1],
      eyez = eye[2],
      upx = up[0],
      upy = up[1],
      upz = up[2];
  var z0 = eyex - target[0],
      z1 = eyey - target[1],
      z2 = eyez - target[2];
  var len = z0 * z0 + z1 * z1 + z2 * z2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    z0 *= len;
    z1 *= len;
    z2 *= len;
  }

  var x0 = upy * z2 - upz * z1,
      x1 = upz * z0 - upx * z2,
      x2 = upx * z1 - upy * z0;
  len = x0 * x0 + x1 * x1 + x2 * x2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}
/**
 * Returns a string representation of a mat4
 *
 * @param {ReadonlyMat4} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */


function str(a) {
  return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
}
/**
 * Returns Frobenius norm of a mat4
 *
 * @param {ReadonlyMat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */


function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
}
/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */


function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}
/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */


function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  out[9] = a[9] + b[9] * scale;
  out[10] = a[10] + b[10] * scale;
  out[11] = a[11] + b[11] * scale;
  out[12] = a[12] + b[12] * scale;
  out[13] = a[13] + b[13] * scale;
  out[14] = a[14] + b[14] * scale;
  out[15] = a[15] + b[15] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat4} a The first matrix.
 * @param {ReadonlyMat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat4} a The first matrix.
 * @param {ReadonlyMat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7];
  var a8 = a[8],
      a9 = a[9],
      a10 = a[10],
      a11 = a[11];
  var a12 = a[12],
      a13 = a[13],
      a14 = a[14],
      a15 = a[15];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  var b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7];
  var b8 = b[8],
      b9 = b[9],
      b10 = b[10],
      b11 = b[11];
  var b12 = b[12],
      b13 = b[13],
      b14 = b[14],
      b15 = b[15];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));
}
/**
 * Alias for {@link mat4.multiply}
 * @function
 */


var mul = multiply;
/**
 * Alias for {@link mat4.subtract}
 * @function
 */

exports.mul = mul;
var sub = subtract;
exports.sub = sub;
},{"./common.js":"node_modules/@math.gl/web-mercator/node_modules/gl-matrix/esm/common.js"}],"node_modules/@math.gl/web-mercator/node_modules/gl-matrix/esm/vec2.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add = add;
exports.angle = angle;
exports.ceil = ceil;
exports.clone = clone;
exports.copy = copy;
exports.create = create;
exports.cross = cross;
exports.dist = void 0;
exports.distance = distance;
exports.div = void 0;
exports.divide = divide;
exports.dot = dot;
exports.equals = equals;
exports.exactEquals = exactEquals;
exports.floor = floor;
exports.forEach = void 0;
exports.fromValues = fromValues;
exports.inverse = inverse;
exports.len = void 0;
exports.length = length;
exports.lerp = lerp;
exports.max = max;
exports.min = min;
exports.mul = void 0;
exports.multiply = multiply;
exports.negate = negate;
exports.normalize = normalize;
exports.random = random;
exports.rotate = rotate;
exports.round = round;
exports.scale = scale;
exports.scaleAndAdd = scaleAndAdd;
exports.set = set;
exports.sqrLen = exports.sqrDist = void 0;
exports.squaredDistance = squaredDistance;
exports.squaredLength = squaredLength;
exports.str = str;
exports.sub = void 0;
exports.subtract = subtract;
exports.transformMat2 = transformMat2;
exports.transformMat2d = transformMat2d;
exports.transformMat3 = transformMat3;
exports.transformMat4 = transformMat4;
exports.zero = zero;

var glMatrix = _interopRequireWildcard(require("./common.js"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * 2 Dimensional Vector
 * @module vec2
 */

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(2);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }

  return out;
}
/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {ReadonlyVec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */


function fromValues(x, y) {
  var out = new glMatrix.ARRAY_TYPE(2);
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the source vector
 * @returns {vec2} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */


function set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}
/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */


function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}
/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */


function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}
/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to ceil
 * @returns {vec2} out
 */


function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}
/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to floor
 * @returns {vec2} out
 */


function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}
/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */


function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}
/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */


function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}
/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to round
 * @returns {vec2} out
 */


function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
}
/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */


function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}
/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */


function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} distance between a and b
 */


function distance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return Math.hypot(x, y);
}
/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} squared distance between a and b
 */


function squaredDistance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return x * x + y * y;
}
/**
 * Calculates the length of a vec2
 *
 * @param {ReadonlyVec2} a vector to calculate length of
 * @returns {Number} length of a
 */


function length(a) {
  var x = a[0],
      y = a[1];
  return Math.hypot(x, y);
}
/**
 * Calculates the squared length of a vec2
 *
 * @param {ReadonlyVec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */


function squaredLength(a) {
  var x = a[0],
      y = a[1];
  return x * x + y * y;
}
/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to negate
 * @returns {vec2} out
 */


function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}
/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to invert
 * @returns {vec2} out
 */


function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
}
/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to normalize
 * @returns {vec2} out
 */


function normalize(out, a) {
  var x = a[0],
      y = a[1];
  var len = x * x + y * y;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  return out;
}
/**
 * Calculates the dot product of two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} dot product of a and b
 */


function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}
/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec3} out
 */


function cross(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}
/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec2} out
 */


function lerp(out, a, b, t) {
  var ax = a[0],
      ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */


function random(out, scale) {
  scale = scale || 1.0;
  var r = glMatrix.RANDOM() * 2.0 * Math.PI;
  out[0] = Math.cos(r) * scale;
  out[1] = Math.sin(r) * scale;
  return out;
}
/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat2} m matrix to transform with
 * @returns {vec2} out
 */


function transformMat2(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}
/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat2d} m matrix to transform with
 * @returns {vec2} out
 */


function transformMat2d(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}
/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat3} m matrix to transform with
 * @returns {vec2} out
 */


function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec2} out
 */


function transformMat4(out, a, m) {
  var x = a[0];
  var y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}
/**
 * Rotate a 2D vector
 * @param {vec2} out The receiving vec2
 * @param {ReadonlyVec2} a The vec2 point to rotate
 * @param {ReadonlyVec2} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec2} out
 */


function rotate(out, a, b, rad) {
  //Translate point to the origin
  var p0 = a[0] - b[0],
      p1 = a[1] - b[1],
      sinC = Math.sin(rad),
      cosC = Math.cos(rad); //perform rotation and translate to correct position

  out[0] = p0 * cosC - p1 * sinC + b[0];
  out[1] = p0 * sinC + p1 * cosC + b[1];
  return out;
}
/**
 * Get the angle between two 2D vectors
 * @param {ReadonlyVec2} a The first operand
 * @param {ReadonlyVec2} b The second operand
 * @returns {Number} The angle in radians
 */


function angle(a, b) {
  var x1 = a[0],
      y1 = a[1],
      x2 = b[0],
      y2 = b[1],
      // mag is the product of the magnitudes of a and b
  mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2),
      // mag &&.. short circuits if mag == 0
  cosine = mag && (x1 * x2 + y1 * y2) / mag; // Math.min(Math.max(cosine, -1), 1) clamps the cosine between -1 and 1

  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
/**
 * Set the components of a vec2 to zero
 *
 * @param {vec2} out the receiving vector
 * @returns {vec2} out
 */


function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec2} a vector to represent as a string
 * @returns {String} string representation of the vector
 */


function str(a) {
  return "vec2(" + a[0] + ", " + a[1] + ")";
}
/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec2} a The first vector.
 * @param {ReadonlyVec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec2} a The first vector.
 * @param {ReadonlyVec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1];
  var b0 = b[0],
      b1 = b[1];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));
}
/**
 * Alias for {@link vec2.length}
 * @function
 */


var len = length;
/**
 * Alias for {@link vec2.subtract}
 * @function
 */

exports.len = len;
var sub = subtract;
/**
 * Alias for {@link vec2.multiply}
 * @function
 */

exports.sub = sub;
var mul = multiply;
/**
 * Alias for {@link vec2.divide}
 * @function
 */

exports.mul = mul;
var div = divide;
/**
 * Alias for {@link vec2.distance}
 * @function
 */

exports.div = div;
var dist = distance;
/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */

exports.dist = dist;
var sqrDist = squaredDistance;
/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */

exports.sqrDist = sqrDist;
var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

exports.sqrLen = sqrLen;

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 2;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }

    return a;
  };
}();

exports.forEach = forEach;
},{"./common.js":"node_modules/@math.gl/web-mercator/node_modules/gl-matrix/esm/common.js"}],"node_modules/@math.gl/web-mercator/node_modules/gl-matrix/esm/vec3.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add = add;
exports.angle = angle;
exports.bezier = bezier;
exports.ceil = ceil;
exports.clone = clone;
exports.copy = copy;
exports.create = create;
exports.cross = cross;
exports.dist = void 0;
exports.distance = distance;
exports.div = void 0;
exports.divide = divide;
exports.dot = dot;
exports.equals = equals;
exports.exactEquals = exactEquals;
exports.floor = floor;
exports.forEach = void 0;
exports.fromValues = fromValues;
exports.hermite = hermite;
exports.inverse = inverse;
exports.len = void 0;
exports.length = length;
exports.lerp = lerp;
exports.max = max;
exports.min = min;
exports.mul = void 0;
exports.multiply = multiply;
exports.negate = negate;
exports.normalize = normalize;
exports.random = random;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.round = round;
exports.scale = scale;
exports.scaleAndAdd = scaleAndAdd;
exports.set = set;
exports.sqrLen = exports.sqrDist = void 0;
exports.squaredDistance = squaredDistance;
exports.squaredLength = squaredLength;
exports.str = str;
exports.sub = void 0;
exports.subtract = subtract;
exports.transformMat3 = transformMat3;
exports.transformMat4 = transformMat4;
exports.transformQuat = transformQuat;
exports.zero = zero;

var glMatrix = _interopRequireWildcard(require("./common.js"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(3);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  return out;
}
/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {ReadonlyVec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Calculates the length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate length of
 * @returns {Number} length of a
 */


function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}
/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */


function fromValues(x, y, z) {
  var out = new glMatrix.ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the source vector
 * @returns {vec3} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */


function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */


function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */


function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}
/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to ceil
 * @returns {vec3} out
 */


function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}
/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to floor
 * @returns {vec3} out
 */


function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}
/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */


function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}
/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */


function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}
/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to round
 * @returns {vec3} out
 */


function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}
/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */


function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */


function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} distance between a and b
 */


function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.hypot(x, y, z);
}
/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} squared distance between a and b
 */


function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}
/**
 * Calculates the squared length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */


function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}
/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to negate
 * @returns {vec3} out
 */


function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to invert
 * @returns {vec3} out
 */


function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}
/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to normalize
 * @returns {vec3} out
 */


function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len = x * x + y * y + z * z;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  out[2] = a[2] * len;
  return out;
}
/**
 * Calculates the dot product of two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} dot product of a and b
 */


function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */


function cross(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2];
  var bx = b[0],
      by = b[1],
      bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */


function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {ReadonlyVec3} c the third operand
 * @param {ReadonlyVec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */


function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {ReadonlyVec3} c the third operand
 * @param {ReadonlyVec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */


function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */


function random(out, scale) {
  scale = scale || 1.0;
  var r = glMatrix.RANDOM() * 2.0 * Math.PI;
  var z = glMatrix.RANDOM() * 2.0 - 1.0;
  var zScale = Math.sqrt(1.0 - z * z) * scale;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}
/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec3} out
 */


function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat3} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */


function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
/**
 * Transforms the vec3 with a quat
 * Can also be used for dual quaternions. (Multiply it with the real part)
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyQuat} q quaternion to transform with
 * @returns {vec3} out
 */


function transformQuat(out, a, q) {
  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3];
  var x = a[0],
      y = a[1],
      z = a[2]; // var qvec = [qx, qy, qz];
  // var uv = vec3.cross([], qvec, a);

  var uvx = qy * z - qz * y,
      uvy = qz * x - qx * z,
      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);

  var uuvx = qy * uvz - qz * uvy,
      uuvy = qz * uvx - qx * uvz,
      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);

  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2; // vec3.scale(uuv, uuv, 2);

  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));

  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */


function rotateX(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0];
  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */


function rotateY(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */


function rotateZ(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
  r[2] = p[2]; //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Get the angle between two 3D vectors
 * @param {ReadonlyVec3} a The first operand
 * @param {ReadonlyVec3} b The second operand
 * @returns {Number} The angle in radians
 */


function angle(a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      bx = b[0],
      by = b[1],
      bz = b[2],
      mag1 = Math.sqrt(ax * ax + ay * ay + az * az),
      mag2 = Math.sqrt(bx * bx + by * by + bz * bz),
      mag = mag1 * mag2,
      cosine = mag && dot(a, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
/**
 * Set the components of a vec3 to zero
 *
 * @param {vec3} out the receiving vector
 * @returns {vec3} out
 */


function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */


function str(a) {
  return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec3} a The first vector.
 * @param {ReadonlyVec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec3} a The first vector.
 * @param {ReadonlyVec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));
}
/**
 * Alias for {@link vec3.subtract}
 * @function
 */


var sub = subtract;
/**
 * Alias for {@link vec3.multiply}
 * @function
 */

exports.sub = sub;
var mul = multiply;
/**
 * Alias for {@link vec3.divide}
 * @function
 */

exports.mul = mul;
var div = divide;
/**
 * Alias for {@link vec3.distance}
 * @function
 */

exports.div = div;
var dist = distance;
/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */

exports.dist = dist;
var sqrDist = squaredDistance;
/**
 * Alias for {@link vec3.length}
 * @function
 */

exports.sqrDist = sqrDist;
var len = length;
/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */

exports.len = len;
var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

exports.sqrLen = sqrLen;

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 3;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }

    return a;
  };
}();

exports.forEach = forEach;
},{"./common.js":"node_modules/@math.gl/web-mercator/node_modules/gl-matrix/esm/common.js"}],"node_modules/@math.gl/web-mercator/dist/esm/assert.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = assert;

function assert(condition, message) {
  if (!condition) {
    throw new Error(message || '@math.gl/web-mercator: assertion failed.');
  }
}
},{}],"node_modules/@math.gl/web-mercator/dist/esm/web-mercator-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MAX_LATITUDE = exports.DEFAULT_ALTITUDE = void 0;
exports.addMetersToLngLat = addMetersToLngLat;
exports.altitudeToFovy = altitudeToFovy;
exports.fovyToAltitude = fovyToAltitude;
exports.getDistanceScales = getDistanceScales;
exports.getMeterZoom = getMeterZoom;
exports.getProjectionMatrix = getProjectionMatrix;
exports.getProjectionParameters = getProjectionParameters;
exports.getViewMatrix = getViewMatrix;
exports.lngLatToWorld = lngLatToWorld;
exports.pixelsToWorld = pixelsToWorld;
exports.scaleToZoom = scaleToZoom;
exports.worldToLngLat = worldToLngLat;
exports.worldToPixels = worldToPixels;
exports.zoomToScale = zoomToScale;

var _mathUtils = require("./math-utils");

var mat4 = _interopRequireWildcard(require("gl-matrix/mat4"));

var vec2 = _interopRequireWildcard(require("gl-matrix/vec2"));

var vec3 = _interopRequireWildcard(require("gl-matrix/vec3"));

var _assert = _interopRequireDefault(require("./assert"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const PI = Math.PI;
const PI_4 = PI / 4;
const DEGREES_TO_RADIANS = PI / 180;
const RADIANS_TO_DEGREES = 180 / PI;
const TILE_SIZE = 512;
const EARTH_CIRCUMFERENCE = 40.03e6;
const MAX_LATITUDE = 85.051129;
exports.MAX_LATITUDE = MAX_LATITUDE;
const DEFAULT_ALTITUDE = 1.5;
exports.DEFAULT_ALTITUDE = DEFAULT_ALTITUDE;

function zoomToScale(zoom) {
  return Math.pow(2, zoom);
}

function scaleToZoom(scale) {
  return (0, _mathUtils.log2)(scale);
}

function lngLatToWorld([lng, lat]) {
  (0, _assert.default)(Number.isFinite(lng));
  (0, _assert.default)(Number.isFinite(lat) && lat >= -90 && lat <= 90, 'invalid latitude');
  const lambda2 = lng * DEGREES_TO_RADIANS;
  const phi2 = lat * DEGREES_TO_RADIANS;
  const x = TILE_SIZE * (lambda2 + PI) / (2 * PI);
  const y = TILE_SIZE * (PI + Math.log(Math.tan(PI_4 + phi2 * 0.5))) / (2 * PI);
  return [x, y];
}

function worldToLngLat([x, y]) {
  const lambda2 = x / TILE_SIZE * (2 * PI) - PI;
  const phi2 = 2 * (Math.atan(Math.exp(y / TILE_SIZE * (2 * PI) - PI)) - PI_4);
  return [lambda2 * RADIANS_TO_DEGREES, phi2 * RADIANS_TO_DEGREES];
}

function getMeterZoom({
  latitude
}) {
  (0, _assert.default)(Number.isFinite(latitude));
  const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);
  return scaleToZoom(EARTH_CIRCUMFERENCE * latCosine) - 9;
}

function getDistanceScales({
  latitude,
  longitude,
  highPrecision = false
}) {
  (0, _assert.default)(Number.isFinite(latitude) && Number.isFinite(longitude));
  const result = {};
  const worldSize = TILE_SIZE;
  const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);
  const unitsPerDegreeX = worldSize / 360;
  const unitsPerDegreeY = unitsPerDegreeX / latCosine;
  const altUnitsPerMeter = worldSize / EARTH_CIRCUMFERENCE / latCosine;
  result.unitsPerMeter = [altUnitsPerMeter, altUnitsPerMeter, altUnitsPerMeter];
  result.metersPerUnit = [1 / altUnitsPerMeter, 1 / altUnitsPerMeter, 1 / altUnitsPerMeter];
  result.unitsPerDegree = [unitsPerDegreeX, unitsPerDegreeY, altUnitsPerMeter];
  result.degreesPerUnit = [1 / unitsPerDegreeX, 1 / unitsPerDegreeY, 1 / altUnitsPerMeter];

  if (highPrecision) {
    const latCosine2 = DEGREES_TO_RADIANS * Math.tan(latitude * DEGREES_TO_RADIANS) / latCosine;
    const unitsPerDegreeY2 = unitsPerDegreeX * latCosine2 / 2;
    const altUnitsPerDegree2 = worldSize / EARTH_CIRCUMFERENCE * latCosine2;
    const altUnitsPerMeter2 = altUnitsPerDegree2 / unitsPerDegreeY * altUnitsPerMeter;
    result.unitsPerDegree2 = [0, unitsPerDegreeY2, altUnitsPerDegree2];
    result.unitsPerMeter2 = [altUnitsPerMeter2, 0, altUnitsPerMeter2];
  }

  return result;
}

function addMetersToLngLat(lngLatZ, xyz) {
  const [longitude, latitude, z0] = lngLatZ;
  const [x, y, z] = xyz;
  const {
    unitsPerMeter,
    unitsPerMeter2
  } = getDistanceScales({
    longitude,
    latitude,
    highPrecision: true
  });
  const worldspace = lngLatToWorld(lngLatZ);
  worldspace[0] += x * (unitsPerMeter[0] + unitsPerMeter2[0] * y);
  worldspace[1] += y * (unitsPerMeter[1] + unitsPerMeter2[1] * y);
  const newLngLat = worldToLngLat(worldspace);
  const newZ = (z0 || 0) + (z || 0);
  return Number.isFinite(z0) || Number.isFinite(z) ? [newLngLat[0], newLngLat[1], newZ] : newLngLat;
}

function getViewMatrix({
  height,
  pitch,
  bearing,
  altitude,
  scale,
  center = null
}) {
  const vm = (0, _mathUtils.createMat4)();
  mat4.translate(vm, vm, [0, 0, -altitude]);
  mat4.rotateX(vm, vm, -pitch * DEGREES_TO_RADIANS);
  mat4.rotateZ(vm, vm, bearing * DEGREES_TO_RADIANS);
  scale /= height;
  mat4.scale(vm, vm, [scale, scale, scale]);

  if (center) {
    mat4.translate(vm, vm, vec3.negate([], center));
  }

  return vm;
}

function getProjectionParameters({
  width,
  height,
  fovy = altitudeToFovy(DEFAULT_ALTITUDE),
  altitude,
  pitch = 0,
  nearZMultiplier = 1,
  farZMultiplier = 1
}) {
  if (altitude !== undefined) {
    fovy = altitudeToFovy(altitude);
  }

  const halfFov = 0.5 * fovy * DEGREES_TO_RADIANS;
  const focalDistance = fovyToAltitude(fovy);
  const pitchRadians = pitch * DEGREES_TO_RADIANS;
  const topHalfSurfaceDistance = Math.sin(halfFov) * focalDistance / Math.sin(Math.min(Math.max(Math.PI / 2 - pitchRadians - halfFov, 0.01), Math.PI - 0.01));
  const farZ = Math.sin(pitchRadians) * topHalfSurfaceDistance + focalDistance;
  return {
    fov: 2 * halfFov,
    aspect: width / height,
    focalDistance,
    near: nearZMultiplier,
    far: farZ * farZMultiplier
  };
}

function getProjectionMatrix({
  width,
  height,
  pitch,
  altitude,
  fovy,
  nearZMultiplier,
  farZMultiplier
}) {
  const {
    fov,
    aspect,
    near,
    far
  } = getProjectionParameters({
    width,
    height,
    altitude,
    fovy,
    pitch,
    nearZMultiplier,
    farZMultiplier
  });
  const projectionMatrix = mat4.perspective([], fov, aspect, near, far);
  return projectionMatrix;
}

function altitudeToFovy(altitude) {
  return 2 * Math.atan(0.5 / altitude) * RADIANS_TO_DEGREES;
}

function fovyToAltitude(fovy) {
  return 0.5 / Math.tan(0.5 * fovy * DEGREES_TO_RADIANS);
}

function worldToPixels(xyz, pixelProjectionMatrix) {
  const [x, y, z = 0] = xyz;
  (0, _assert.default)(Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(z));
  return (0, _mathUtils.transformVector)(pixelProjectionMatrix, [x, y, z, 1]);
}

function pixelsToWorld(xyz, pixelUnprojectionMatrix, targetZ = 0) {
  const [x, y, z] = xyz;
  (0, _assert.default)(Number.isFinite(x) && Number.isFinite(y), 'invalid pixel coordinate');

  if (Number.isFinite(z)) {
    const coord = (0, _mathUtils.transformVector)(pixelUnprojectionMatrix, [x, y, z, 1]);
    return coord;
  }

  const coord0 = (0, _mathUtils.transformVector)(pixelUnprojectionMatrix, [x, y, 0, 1]);
  const coord1 = (0, _mathUtils.transformVector)(pixelUnprojectionMatrix, [x, y, 1, 1]);
  const z0 = coord0[2];
  const z1 = coord1[2];
  const t = z0 === z1 ? 0 : ((targetZ || 0) - z0) / (z1 - z0);
  return vec2.lerp([], coord0, coord1, t);
}
},{"./math-utils":"node_modules/@math.gl/web-mercator/dist/esm/math-utils.js","gl-matrix/mat4":"node_modules/@math.gl/web-mercator/node_modules/gl-matrix/esm/mat4.js","gl-matrix/vec2":"node_modules/@math.gl/web-mercator/node_modules/gl-matrix/esm/vec2.js","gl-matrix/vec3":"node_modules/@math.gl/web-mercator/node_modules/gl-matrix/esm/vec3.js","./assert":"node_modules/@math.gl/web-mercator/dist/esm/assert.js"}],"node_modules/@math.gl/web-mercator/dist/esm/fit-bounds.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = fitBounds;

var _assert = _interopRequireDefault(require("./assert"));

var _mathUtils = require("./math-utils");

var _webMercatorUtils = require("./web-mercator-utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function fitBounds({
  width,
  height,
  bounds,
  minExtent = 0,
  maxZoom = 24,
  padding = 0,
  offset = [0, 0]
}) {
  const [[west, south], [east, north]] = bounds;

  if (Number.isFinite(padding)) {
    const p = padding;
    padding = {
      top: p,
      bottom: p,
      left: p,
      right: p
    };
  } else {
    (0, _assert.default)(Number.isFinite(padding.top) && Number.isFinite(padding.bottom) && Number.isFinite(padding.left) && Number.isFinite(padding.right));
  }

  const nw = (0, _webMercatorUtils.lngLatToWorld)([west, (0, _mathUtils.clamp)(north, -_webMercatorUtils.MAX_LATITUDE, _webMercatorUtils.MAX_LATITUDE)]);
  const se = (0, _webMercatorUtils.lngLatToWorld)([east, (0, _mathUtils.clamp)(south, -_webMercatorUtils.MAX_LATITUDE, _webMercatorUtils.MAX_LATITUDE)]);
  const size = [Math.max(Math.abs(se[0] - nw[0]), minExtent), Math.max(Math.abs(se[1] - nw[1]), minExtent)];
  const targetSize = [width - padding.left - padding.right - Math.abs(offset[0]) * 2, height - padding.top - padding.bottom - Math.abs(offset[1]) * 2];
  (0, _assert.default)(targetSize[0] > 0 && targetSize[1] > 0);
  const scaleX = targetSize[0] / size[0];
  const scaleY = targetSize[1] / size[1];
  const offsetX = (padding.right - padding.left) / 2 / scaleX;
  const offsetY = (padding.bottom - padding.top) / 2 / scaleY;
  const center = [(se[0] + nw[0]) / 2 + offsetX, (se[1] + nw[1]) / 2 + offsetY];
  const centerLngLat = (0, _webMercatorUtils.worldToLngLat)(center);
  const zoom = Math.min(maxZoom, (0, _mathUtils.log2)(Math.abs(Math.min(scaleX, scaleY))));
  (0, _assert.default)(Number.isFinite(zoom));
  return {
    longitude: centerLngLat[0],
    latitude: centerLngLat[1],
    zoom
  };
}
},{"./assert":"node_modules/@math.gl/web-mercator/dist/esm/assert.js","./math-utils":"node_modules/@math.gl/web-mercator/dist/esm/math-utils.js","./web-mercator-utils":"node_modules/@math.gl/web-mercator/dist/esm/web-mercator-utils.js"}],"node_modules/@math.gl/web-mercator/dist/esm/get-bounds.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getBounds;

var _webMercatorUtils = require("./web-mercator-utils");

var vec2 = _interopRequireWildcard(require("gl-matrix/vec2"));

var _mathUtils = require("./math-utils");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const DEGREES_TO_RADIANS = Math.PI / 180;

function getBounds(viewport, z = 0) {
  const {
    width,
    height,
    unproject
  } = viewport;
  const unprojectOps = {
    targetZ: z
  };
  const bottomLeft = unproject([0, height], unprojectOps);
  const bottomRight = unproject([width, height], unprojectOps);
  let topLeft;
  let topRight;
  const halfFov = viewport.fovy ? 0.5 * viewport.fovy * DEGREES_TO_RADIANS : Math.atan(0.5 / viewport.altitude);
  const angleToGround = (90 - viewport.pitch) * DEGREES_TO_RADIANS;

  if (halfFov > angleToGround - 0.01) {
    topLeft = unprojectOnFarPlane(viewport, 0, z);
    topRight = unprojectOnFarPlane(viewport, width, z);
  } else {
    topLeft = unproject([0, 0], unprojectOps);
    topRight = unproject([width, 0], unprojectOps);
  }

  return [bottomLeft, bottomRight, topRight, topLeft];
}

function unprojectOnFarPlane(viewport, x, targetZ) {
  const {
    pixelUnprojectionMatrix
  } = viewport;
  const coord0 = (0, _mathUtils.transformVector)(pixelUnprojectionMatrix, [x, 0, 1, 1]);
  const coord1 = (0, _mathUtils.transformVector)(pixelUnprojectionMatrix, [x, viewport.height, 1, 1]);
  const z = targetZ * viewport.distanceScales.unitsPerMeter[2];
  const t = (z - coord0[2]) / (coord1[2] - coord0[2]);
  const coord = vec2.lerp([], coord0, coord1, t);
  const result = (0, _webMercatorUtils.worldToLngLat)(coord);
  result[2] = targetZ;
  return result;
}
},{"./web-mercator-utils":"node_modules/@math.gl/web-mercator/dist/esm/web-mercator-utils.js","gl-matrix/vec2":"node_modules/@math.gl/web-mercator/node_modules/gl-matrix/esm/vec2.js","./math-utils":"node_modules/@math.gl/web-mercator/dist/esm/math-utils.js"}],"node_modules/@math.gl/web-mercator/dist/esm/web-mercator-viewport.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _mathUtils = require("./math-utils");

var _webMercatorUtils = require("./web-mercator-utils");

var _fitBounds = _interopRequireDefault(require("./fit-bounds"));

var _getBounds = _interopRequireDefault(require("./get-bounds"));

var mat4 = _interopRequireWildcard(require("gl-matrix/mat4"));

var vec2 = _interopRequireWildcard(require("gl-matrix/vec2"));

var vec3 = _interopRequireWildcard(require("gl-matrix/vec3"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class WebMercatorViewport {
  constructor({
    width,
    height,
    latitude = 0,
    longitude = 0,
    zoom = 0,
    pitch = 0,
    bearing = 0,
    altitude = null,
    fovy = null,
    position = null,
    nearZMultiplier = 0.02,
    farZMultiplier = 1.01
  } = {
    width: 1,
    height: 1
  }) {
    width = width || 1;
    height = height || 1;

    if (fovy === null && altitude === null) {
      altitude = _webMercatorUtils.DEFAULT_ALTITUDE;
      fovy = (0, _webMercatorUtils.altitudeToFovy)(altitude);
    } else if (fovy === null) {
      fovy = (0, _webMercatorUtils.altitudeToFovy)(altitude);
    } else if (altitude === null) {
      altitude = (0, _webMercatorUtils.fovyToAltitude)(fovy);
    }

    const scale = (0, _webMercatorUtils.zoomToScale)(zoom);
    altitude = Math.max(0.75, altitude);
    const distanceScales = (0, _webMercatorUtils.getDistanceScales)({
      longitude,
      latitude
    });
    const center = (0, _webMercatorUtils.lngLatToWorld)([longitude, latitude]);
    center[2] = 0;

    if (position) {
      vec3.add(center, center, vec3.mul([], position, distanceScales.unitsPerMeter));
    }

    this.projectionMatrix = (0, _webMercatorUtils.getProjectionMatrix)({
      width,
      height,
      pitch,
      fovy,
      nearZMultiplier,
      farZMultiplier
    });
    this.viewMatrix = (0, _webMercatorUtils.getViewMatrix)({
      height,
      scale,
      center,
      pitch,
      bearing,
      altitude
    });
    this.width = width;
    this.height = height;
    this.scale = scale;
    this.latitude = latitude;
    this.longitude = longitude;
    this.zoom = zoom;
    this.pitch = pitch;
    this.bearing = bearing;
    this.altitude = altitude;
    this.fovy = fovy;
    this.center = center;
    this.meterOffset = position || [0, 0, 0];
    this.distanceScales = distanceScales;

    this._initMatrices();

    this.equals = this.equals.bind(this);
    this.project = this.project.bind(this);
    this.unproject = this.unproject.bind(this);
    this.projectPosition = this.projectPosition.bind(this);
    this.unprojectPosition = this.unprojectPosition.bind(this);
    Object.freeze(this);
  }

  _initMatrices() {
    const {
      width,
      height,
      projectionMatrix,
      viewMatrix
    } = this;
    const vpm = (0, _mathUtils.createMat4)();
    mat4.multiply(vpm, vpm, projectionMatrix);
    mat4.multiply(vpm, vpm, viewMatrix);
    this.viewProjectionMatrix = vpm;
    const m = (0, _mathUtils.createMat4)();
    mat4.scale(m, m, [width / 2, -height / 2, 1]);
    mat4.translate(m, m, [1, -1, 0]);
    mat4.multiply(m, m, vpm);
    const mInverse = mat4.invert((0, _mathUtils.createMat4)(), m);

    if (!mInverse) {
      throw new Error('Pixel project matrix not invertible');
    }

    this.pixelProjectionMatrix = m;
    this.pixelUnprojectionMatrix = mInverse;
  }

  equals(viewport) {
    if (!(viewport instanceof WebMercatorViewport)) {
      return false;
    }

    return viewport.width === this.width && viewport.height === this.height && mat4.equals(viewport.projectionMatrix, this.projectionMatrix) && mat4.equals(viewport.viewMatrix, this.viewMatrix);
  }

  project(xyz, {
    topLeft = true
  } = {}) {
    const worldPosition = this.projectPosition(xyz);
    const coord = (0, _webMercatorUtils.worldToPixels)(worldPosition, this.pixelProjectionMatrix);
    const [x, y] = coord;
    const y2 = topLeft ? y : this.height - y;
    return xyz.length === 2 ? [x, y2] : [x, y2, coord[2]];
  }

  unproject(xyz, {
    topLeft = true,
    targetZ = undefined
  } = {}) {
    const [x, y, z] = xyz;
    const y2 = topLeft ? y : this.height - y;
    const targetZWorld = targetZ && targetZ * this.distanceScales.unitsPerMeter[2];
    const coord = (0, _webMercatorUtils.pixelsToWorld)([x, y2, z], this.pixelUnprojectionMatrix, targetZWorld);
    const [X, Y, Z] = this.unprojectPosition(coord);

    if (Number.isFinite(z)) {
      return [X, Y, Z];
    }

    return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];
  }

  projectPosition(xyz) {
    const [X, Y] = (0, _webMercatorUtils.lngLatToWorld)(xyz);
    const Z = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];
    return [X, Y, Z];
  }

  unprojectPosition(xyz) {
    const [X, Y] = (0, _webMercatorUtils.worldToLngLat)(xyz);
    const Z = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];
    return [X, Y, Z];
  }

  projectFlat(lngLat) {
    return (0, _webMercatorUtils.lngLatToWorld)(lngLat);
  }

  unprojectFlat(xy) {
    return (0, _webMercatorUtils.worldToLngLat)(xy);
  }

  getMapCenterByLngLatPosition({
    lngLat,
    pos
  }) {
    const fromLocation = (0, _webMercatorUtils.pixelsToWorld)(pos, this.pixelUnprojectionMatrix);
    const toLocation = (0, _webMercatorUtils.lngLatToWorld)(lngLat);
    const translate = vec2.add([], toLocation, vec2.negate([], fromLocation));
    const newCenter = vec2.add([], this.center, translate);
    return (0, _webMercatorUtils.worldToLngLat)(newCenter);
  }

  getLocationAtPoint({
    lngLat,
    pos
  }) {
    return this.getMapCenterByLngLatPosition({
      lngLat,
      pos
    });
  }

  fitBounds(bounds, options = {}) {
    const {
      width,
      height
    } = this;
    const {
      longitude,
      latitude,
      zoom
    } = (0, _fitBounds.default)(Object.assign({
      width,
      height,
      bounds
    }, options));
    return new WebMercatorViewport({
      width,
      height,
      longitude,
      latitude,
      zoom
    });
  }

  getBounds(options) {
    const corners = this.getBoundingRegion(options);
    const west = Math.min(...corners.map(p => p[0]));
    const east = Math.max(...corners.map(p => p[0]));
    const south = Math.min(...corners.map(p => p[1]));
    const north = Math.max(...corners.map(p => p[1]));
    return [[west, south], [east, north]];
  }

  getBoundingRegion(options = {}) {
    return (0, _getBounds.default)(this, options.z || 0);
  }

}

exports.default = WebMercatorViewport;
},{"./math-utils":"node_modules/@math.gl/web-mercator/dist/esm/math-utils.js","./web-mercator-utils":"node_modules/@math.gl/web-mercator/dist/esm/web-mercator-utils.js","./fit-bounds":"node_modules/@math.gl/web-mercator/dist/esm/fit-bounds.js","./get-bounds":"node_modules/@math.gl/web-mercator/dist/esm/get-bounds.js","gl-matrix/mat4":"node_modules/@math.gl/web-mercator/node_modules/gl-matrix/esm/mat4.js","gl-matrix/vec2":"node_modules/@math.gl/web-mercator/node_modules/gl-matrix/esm/vec2.js","gl-matrix/vec3":"node_modules/@math.gl/web-mercator/node_modules/gl-matrix/esm/vec3.js"}],"node_modules/@math.gl/web-mercator/dist/esm/normalize-viewport-props.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = normalizeViewportProps;

var _webMercatorUtils = require("./web-mercator-utils");

var _mathUtils = require("./math-utils");

const TILE_SIZE = 512;

function normalizeViewportProps({
  width,
  height,
  longitude,
  latitude,
  zoom,
  pitch = 0,
  bearing = 0
}) {
  if (longitude < -180 || longitude > 180) {
    longitude = (0, _mathUtils.mod)(longitude + 180, 360) - 180;
  }

  if (bearing < -180 || bearing > 180) {
    bearing = (0, _mathUtils.mod)(bearing + 180, 360) - 180;
  }

  const minZoom = (0, _mathUtils.log2)(height / TILE_SIZE);

  if (zoom <= minZoom) {
    zoom = minZoom;
    latitude = 0;
  } else {
    const halfHeightPixels = height / 2 / Math.pow(2, zoom);
    const minLatitude = (0, _webMercatorUtils.worldToLngLat)([0, halfHeightPixels])[1];

    if (latitude < minLatitude) {
      latitude = minLatitude;
    } else {
      const maxLatitude = (0, _webMercatorUtils.worldToLngLat)([0, TILE_SIZE - halfHeightPixels])[1];

      if (latitude > maxLatitude) {
        latitude = maxLatitude;
      }
    }
  }

  return {
    width,
    height,
    longitude,
    latitude,
    zoom,
    pitch,
    bearing
  };
}
},{"./web-mercator-utils":"node_modules/@math.gl/web-mercator/dist/esm/web-mercator-utils.js","./math-utils":"node_modules/@math.gl/web-mercator/dist/esm/math-utils.js"}],"node_modules/@math.gl/web-mercator/dist/esm/fly-to-viewport.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = flyToViewport;
exports.getFlyToDuration = getFlyToDuration;

var _mathUtils = require("./math-utils");

var _webMercatorUtils = require("./web-mercator-utils");

var vec2 = _interopRequireWildcard(require("gl-matrix/vec2"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const EPSILON = 0.01;
const VIEWPORT_TRANSITION_PROPS = ['longitude', 'latitude', 'zoom'];
const DEFAULT_OPTS = {
  curve: 1.414,
  speed: 1.2
};

function flyToViewport(startProps, endProps, t, opts = {}) {
  const viewport = {};
  const {
    startZoom,
    startCenterXY,
    uDelta,
    w0,
    u1,
    S,
    rho,
    rho2,
    r0
  } = getFlyToTransitionParams(startProps, endProps, opts);

  if (u1 < EPSILON) {
    for (const key of VIEWPORT_TRANSITION_PROPS) {
      const startValue = startProps[key];
      const endValue = endProps[key];
      viewport[key] = (0, _mathUtils.lerp)(startValue, endValue, t);
    }

    return viewport;
  }

  const s = t * S;
  const w = Math.cosh(r0) / Math.cosh(r0 + rho * s);
  const u = w0 * ((Math.cosh(r0) * Math.tanh(r0 + rho * s) - Math.sinh(r0)) / rho2) / u1;
  const scaleIncrement = 1 / w;
  const newZoom = startZoom + (0, _webMercatorUtils.scaleToZoom)(scaleIncrement);
  const newCenterWorld = vec2.scale([], uDelta, u);
  vec2.add(newCenterWorld, newCenterWorld, startCenterXY);
  const newCenter = (0, _webMercatorUtils.worldToLngLat)(newCenterWorld);
  viewport.longitude = newCenter[0];
  viewport.latitude = newCenter[1];
  viewport.zoom = newZoom;
  return viewport;
}

function getFlyToDuration(startProps, endProps, opts = {}) {
  opts = Object.assign({}, DEFAULT_OPTS, opts);
  const {
    screenSpeed,
    speed,
    maxDuration
  } = opts;
  const {
    S,
    rho
  } = getFlyToTransitionParams(startProps, endProps, opts);
  const length = 1000 * S;
  let duration;

  if (Number.isFinite(screenSpeed)) {
    duration = length / (screenSpeed / rho);
  } else {
    duration = length / speed;
  }

  return Number.isFinite(maxDuration) && duration > maxDuration ? 0 : duration;
}

function getFlyToTransitionParams(startProps, endProps, opts) {
  opts = Object.assign({}, DEFAULT_OPTS, opts);
  const rho = opts.curve;
  const startZoom = startProps.zoom;
  const startCenter = [startProps.longitude, startProps.latitude];
  const startScale = (0, _webMercatorUtils.zoomToScale)(startZoom);
  const endZoom = endProps.zoom;
  const endCenter = [endProps.longitude, endProps.latitude];
  const scale = (0, _webMercatorUtils.zoomToScale)(endZoom - startZoom);
  const startCenterXY = (0, _webMercatorUtils.lngLatToWorld)(startCenter);
  const endCenterXY = (0, _webMercatorUtils.lngLatToWorld)(endCenter);
  const uDelta = vec2.sub([], endCenterXY, startCenterXY);
  const w0 = Math.max(startProps.width, startProps.height);
  const w1 = w0 / scale;
  const u1 = vec2.length(uDelta) * startScale;

  const _u1 = Math.max(u1, EPSILON);

  const rho2 = rho * rho;
  const b0 = (w1 * w1 - w0 * w0 + rho2 * rho2 * _u1 * _u1) / (2 * w0 * rho2 * _u1);
  const b1 = (w1 * w1 - w0 * w0 - rho2 * rho2 * _u1 * _u1) / (2 * w1 * rho2 * _u1);
  const r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0);
  const r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
  const S = (r1 - r0) / rho;
  return {
    startZoom,
    startCenterXY,
    uDelta,
    w0,
    u1,
    S,
    rho,
    rho2,
    r0,
    r1
  };
}
},{"./math-utils":"node_modules/@math.gl/web-mercator/dist/esm/math-utils.js","./web-mercator-utils":"node_modules/@math.gl/web-mercator/dist/esm/web-mercator-utils.js","gl-matrix/vec2":"node_modules/@math.gl/web-mercator/node_modules/gl-matrix/esm/vec2.js"}],"node_modules/@math.gl/web-mercator/dist/esm/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "MAX_LATITUDE", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.MAX_LATITUDE;
  }
});
Object.defineProperty(exports, "WebMercatorViewport", {
  enumerable: true,
  get: function () {
    return _webMercatorViewport.default;
  }
});
Object.defineProperty(exports, "addMetersToLngLat", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.addMetersToLngLat;
  }
});
Object.defineProperty(exports, "altitudeToFovy", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.altitudeToFovy;
  }
});
Object.defineProperty(exports, "default", {
  enumerable: true,
  get: function () {
    return _webMercatorViewport.default;
  }
});
Object.defineProperty(exports, "fitBounds", {
  enumerable: true,
  get: function () {
    return _fitBounds.default;
  }
});
Object.defineProperty(exports, "flyToViewport", {
  enumerable: true,
  get: function () {
    return _flyToViewport.default;
  }
});
Object.defineProperty(exports, "fovyToAltitude", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.fovyToAltitude;
  }
});
Object.defineProperty(exports, "getBounds", {
  enumerable: true,
  get: function () {
    return _getBounds.default;
  }
});
Object.defineProperty(exports, "getDistanceScales", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.getDistanceScales;
  }
});
Object.defineProperty(exports, "getFlyToDuration", {
  enumerable: true,
  get: function () {
    return _flyToViewport.getFlyToDuration;
  }
});
Object.defineProperty(exports, "getMeterZoom", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.getMeterZoom;
  }
});
Object.defineProperty(exports, "getProjectionMatrix", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.getProjectionMatrix;
  }
});
Object.defineProperty(exports, "getProjectionParameters", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.getProjectionParameters;
  }
});
Object.defineProperty(exports, "getViewMatrix", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.getViewMatrix;
  }
});
Object.defineProperty(exports, "lngLatToWorld", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.lngLatToWorld;
  }
});
Object.defineProperty(exports, "normalizeViewportProps", {
  enumerable: true,
  get: function () {
    return _normalizeViewportProps.default;
  }
});
Object.defineProperty(exports, "pixelsToWorld", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.pixelsToWorld;
  }
});
Object.defineProperty(exports, "scaleToZoom", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.scaleToZoom;
  }
});
Object.defineProperty(exports, "worldToLngLat", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.worldToLngLat;
  }
});
Object.defineProperty(exports, "worldToPixels", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.worldToPixels;
  }
});
Object.defineProperty(exports, "zoomToScale", {
  enumerable: true,
  get: function () {
    return _webMercatorUtils.zoomToScale;
  }
});

var _webMercatorViewport = _interopRequireDefault(require("./web-mercator-viewport"));

var _getBounds = _interopRequireDefault(require("./get-bounds"));

var _fitBounds = _interopRequireDefault(require("./fit-bounds"));

var _normalizeViewportProps = _interopRequireDefault(require("./normalize-viewport-props"));

var _flyToViewport = _interopRequireWildcard(require("./fly-to-viewport"));

var _webMercatorUtils = require("./web-mercator-utils");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./web-mercator-viewport":"node_modules/@math.gl/web-mercator/dist/esm/web-mercator-viewport.js","./get-bounds":"node_modules/@math.gl/web-mercator/dist/esm/get-bounds.js","./fit-bounds":"node_modules/@math.gl/web-mercator/dist/esm/fit-bounds.js","./normalize-viewport-props":"node_modules/@math.gl/web-mercator/dist/esm/normalize-viewport-props.js","./fly-to-viewport":"node_modules/@math.gl/web-mercator/dist/esm/fly-to-viewport.js","./web-mercator-utils":"node_modules/@math.gl/web-mercator/dist/esm/web-mercator-utils.js"}],"node_modules/@deck.gl/core/dist/esm/shaderlib/shadow/shadow.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _constants = require("../../lib/constants");

var _project = _interopRequireDefault(require("../project/project"));

var _core = require("@math.gl/core");

var _memoize = _interopRequireDefault(require("../../utils/memoize"));

var _webMercator = require("@math.gl/web-mercator");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const vs = "\nconst int max_lights = 2;\nuniform mat4 shadow_uViewProjectionMatrices[max_lights];\nuniform vec4 shadow_uProjectCenters[max_lights];\nuniform bool shadow_uDrawShadowMap;\nuniform bool shadow_uUseShadowMap;\nuniform int shadow_uLightId;\nuniform float shadow_uLightCount;\n\nvarying vec3 shadow_vPosition[max_lights];\n\nvec4 shadow_setVertexPosition(vec4 position_commonspace) {\n  if (shadow_uDrawShadowMap) {\n    return project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[shadow_uLightId], shadow_uProjectCenters[shadow_uLightId]);\n  }\n  if (shadow_uUseShadowMap) {\n    for (int i = 0; i < max_lights; i++) {\n      if(i < int(shadow_uLightCount)) {\n        vec4 shadowMap_position = project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[i], shadow_uProjectCenters[i]);\n        shadow_vPosition[i] = (shadowMap_position.xyz / shadowMap_position.w + 1.0) / 2.0;\n      }\n    }\n  }\n  return gl_Position;\n}\n";
const fs = "\nconst int max_lights = 2;\nuniform bool shadow_uDrawShadowMap;\nuniform bool shadow_uUseShadowMap;\nuniform sampler2D shadow_uShadowMap0;\nuniform sampler2D shadow_uShadowMap1;\nuniform vec4 shadow_uColor;\nuniform float shadow_uLightCount;\n\nvarying vec3 shadow_vPosition[max_lights];\n\nconst vec4 bitPackShift = vec4(1.0, 255.0, 65025.0, 16581375.0);\nconst vec4 bitUnpackShift = 1.0 / bitPackShift;\nconst vec4 bitMask = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0,  0.0);\n\nfloat shadow_getShadowWeight(vec3 position, sampler2D shadowMap) {\n  vec4 rgbaDepth = texture2D(shadowMap, position.xy);\n\n  float z = dot(rgbaDepth, bitUnpackShift);\n  return smoothstep(0.001, 0.01, position.z - z);\n}\n\nvec4 shadow_filterShadowColor(vec4 color) {\n  if (shadow_uDrawShadowMap) {\n    vec4 rgbaDepth = fract(gl_FragCoord.z * bitPackShift);\n    rgbaDepth -= rgbaDepth.gbaa * bitMask;\n    return rgbaDepth;\n  }\n  if (shadow_uUseShadowMap) {\n    float shadowAlpha = 0.0;\n    shadowAlpha += shadow_getShadowWeight(shadow_vPosition[0], shadow_uShadowMap0);\n    if(shadow_uLightCount > 1.0) {\n      shadowAlpha += shadow_getShadowWeight(shadow_vPosition[1], shadow_uShadowMap1);\n    }\n    shadowAlpha *= shadow_uColor.a / shadow_uLightCount;\n    float blendedAlpha = shadowAlpha + color.a * (1.0 - shadowAlpha);\n\n    return vec4(\n      mix(color.rgb, shadow_uColor.rgb, shadowAlpha / blendedAlpha),\n      blendedAlpha\n    );\n  }\n  return color;\n}\n";
const getMemoizedViewportCenterPosition = (0, _memoize.default)(getViewportCenterPosition);
const getMemoizedViewProjectionMatrices = (0, _memoize.default)(getViewProjectionMatrices);
const DEFAULT_SHADOW_COLOR = [0, 0, 0, 1.0];
const VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];

function screenToCommonSpace(xyz, pixelUnprojectionMatrix) {
  const [x, y, z] = xyz;
  const coord = (0, _webMercator.pixelsToWorld)([x, y, z], pixelUnprojectionMatrix);

  if (Number.isFinite(z)) {
    return coord;
  }

  return [coord[0], coord[1], 0];
}

function getViewportCenterPosition({
  viewport,
  center
}) {
  return new _core.Matrix4(viewport.viewProjectionMatrix).invert().transform(center);
}

function getViewProjectionMatrices({
  viewport,
  shadowMatrices
}) {
  const projectionMatrices = [];
  const pixelUnprojectionMatrix = viewport.pixelUnprojectionMatrix;
  const farZ = viewport.isGeospatial ? undefined : 1;
  const corners = [[0, 0, farZ], [viewport.width, 0, farZ], [0, viewport.height, farZ], [viewport.width, viewport.height, farZ], [0, 0, -1], [viewport.width, 0, -1], [0, viewport.height, -1], [viewport.width, viewport.height, -1]].map(pixel => screenToCommonSpace(pixel, pixelUnprojectionMatrix));

  for (const shadowMatrix of shadowMatrices) {
    const viewMatrix = shadowMatrix.clone().translate(new _core.Vector3(viewport.center).negate());
    const positions = corners.map(corner => viewMatrix.transform(corner));
    const projectionMatrix = new _core.Matrix4().ortho({
      left: Math.min(...positions.map(position => position[0])),
      right: Math.max(...positions.map(position => position[0])),
      bottom: Math.min(...positions.map(position => position[1])),
      top: Math.max(...positions.map(position => position[1])),
      near: Math.min(...positions.map(position => -position[2])),
      far: Math.max(...positions.map(position => -position[2]))
    });
    projectionMatrices.push(projectionMatrix.multiplyRight(shadowMatrix));
  }

  return projectionMatrices;
}

function createShadowUniforms(opts = {}, context = {}) {
  const uniforms = {
    shadow_uDrawShadowMap: Boolean(opts.drawToShadowMap),
    shadow_uUseShadowMap: opts.shadowMaps ? opts.shadowMaps.length > 0 : false,
    shadow_uColor: opts.shadowColor || DEFAULT_SHADOW_COLOR,
    shadow_uLightId: opts.shadowLightId || 0,
    shadow_uLightCount: opts.shadowMatrices.length
  };
  const center = getMemoizedViewportCenterPosition({
    viewport: opts.viewport,
    center: context.project_uCenter
  });
  const projectCenters = [];
  const viewProjectionMatrices = getMemoizedViewProjectionMatrices({
    shadowMatrices: opts.shadowMatrices,
    viewport: opts.viewport
  }).slice();

  for (let i = 0; i < opts.shadowMatrices.length; i++) {
    const viewProjectionMatrix = viewProjectionMatrices[i];
    const viewProjectionMatrixCentered = viewProjectionMatrix.clone().translate(new _core.Vector3(opts.viewport.center).negate());

    if (context.project_uCoordinateSystem === _constants.COORDINATE_SYSTEM.LNGLAT && context.project_uProjectionMode === _constants.PROJECTION_MODE.WEB_MERCATOR) {
      viewProjectionMatrices[i] = viewProjectionMatrixCentered;
      projectCenters[i] = center;
    } else {
      viewProjectionMatrices[i] = viewProjectionMatrix.clone().multiplyRight(VECTOR_TO_POINT_MATRIX);
      projectCenters[i] = viewProjectionMatrixCentered.transform(center);
    }
  }

  for (let i = 0; i < viewProjectionMatrices.length; i++) {
    uniforms["shadow_uViewProjectionMatrices[".concat(i, "]")] = viewProjectionMatrices[i];
    uniforms["shadow_uProjectCenters[".concat(i, "]")] = projectCenters[i];

    if (opts.shadowMaps && opts.shadowMaps.length > 0) {
      uniforms["shadow_uShadowMap".concat(i)] = opts.shadowMaps[i];
    } else {
      uniforms["shadow_uShadowMap".concat(i)] = opts.dummyShadowMap;
    }
  }

  return uniforms;
}

var _default = {
  name: 'shadow',
  dependencies: [_project.default],
  vs,
  fs,
  inject: {
    'vs:DECKGL_FILTER_GL_POSITION': "\n    position = shadow_setVertexPosition(geometry.position);\n    ",
    'fs:DECKGL_FILTER_COLOR': "\n    color = shadow_filterShadowColor(color);\n    "
  },
  getUniforms: (opts = {}, context = {}) => {
    if (opts.drawToShadowMap || opts.shadowMaps && opts.shadowMaps.length > 0) {
      const {
        shadowEnabled = true
      } = opts;
      return shadowEnabled && opts.shadowMatrices && opts.shadowMatrices.length > 0 ? createShadowUniforms(opts, context) : {
        shadow_uDrawShadowMap: false,
        shadow_uUseShadowMap: false
      };
    }

    return {};
  }
};
exports.default = _default;
},{"../../lib/constants":"node_modules/@deck.gl/core/dist/esm/lib/constants.js","../project/project":"node_modules/@deck.gl/core/dist/esm/shaderlib/project/project.js","@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js","../../utils/memoize":"node_modules/@deck.gl/core/dist/esm/utils/memoize.js","@math.gl/web-mercator":"node_modules/@math.gl/web-mercator/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/shaderlib/picking/picking.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _core = require("@luma.gl/core");

var _default = {
  inject: {
    'vs:DECKGL_FILTER_GL_POSITION': "\n    // for picking depth values\n    picking_setPickingAttribute(position.z / position.w);\n  ",
    'vs:DECKGL_FILTER_COLOR': "\n  picking_setPickingColor(geometry.pickingColor);\n  ",
    'fs:DECKGL_FILTER_COLOR': {
      order: 99,
      injection: "\n  // use highlight color if this fragment belongs to the selected object.\n  color = picking_filterHighlightColor(color);\n\n  // use picking color if rendering to picking FBO.\n  color = picking_filterPickingColor(color);\n    "
    }
  },
  ..._core.picking
};
exports.default = _default;
},{"@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/shaderlib/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createProgramManager = createProgramManager;
Object.defineProperty(exports, "gouraudLighting", {
  enumerable: true,
  get: function () {
    return _core.gouraudLighting;
  }
});
Object.defineProperty(exports, "phongLighting", {
  enumerable: true,
  get: function () {
    return _core.phongLighting;
  }
});
Object.defineProperty(exports, "picking", {
  enumerable: true,
  get: function () {
    return _picking.default;
  }
});
Object.defineProperty(exports, "project", {
  enumerable: true,
  get: function () {
    return _project.default;
  }
});
Object.defineProperty(exports, "project32", {
  enumerable: true,
  get: function () {
    return _project2.default;
  }
});
Object.defineProperty(exports, "shadow", {
  enumerable: true,
  get: function () {
    return _shadow.default;
  }
});

var _core = require("@luma.gl/core");

var _project = _interopRequireDefault(require("./project/project"));

var _project2 = _interopRequireDefault(require("./project32/project32"));

var _shadow = _interopRequireDefault(require("./shadow/shadow"));

var _picking = _interopRequireDefault(require("./picking/picking"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const DEFAULT_MODULES = [_project.default];
const SHADER_HOOKS = ['vs:DECKGL_FILTER_SIZE(inout vec3 size, VertexGeometry geometry)', 'vs:DECKGL_FILTER_GL_POSITION(inout vec4 position, VertexGeometry geometry)', 'vs:DECKGL_FILTER_COLOR(inout vec4 color, VertexGeometry geometry)', 'fs:DECKGL_FILTER_COLOR(inout vec4 color, FragmentGeometry geometry)'];

function createProgramManager(gl) {
  const programManager = _core.ProgramManager.getDefaultProgramManager(gl);

  for (const shaderModule of DEFAULT_MODULES) {
    programManager.addDefaultModule(shaderModule);
  }

  for (const shaderHook of SHADER_HOOKS) {
    programManager.addShaderHook(shaderHook);
  }

  return programManager;
}
},{"@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","./project/project":"node_modules/@deck.gl/core/dist/esm/shaderlib/project/project.js","./project32/project32":"node_modules/@deck.gl/core/dist/esm/shaderlib/project32/project32.js","./shadow/shadow":"node_modules/@deck.gl/core/dist/esm/shaderlib/shadow/shadow.js","./picking/picking":"node_modules/@deck.gl/core/dist/esm/shaderlib/picking/picking.js"}],"node_modules/@deck.gl/core/dist/esm/effects/lighting/ambient-light.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AmbientLight = void 0;
const DEFAULT_LIGHT_COLOR = [255, 255, 255];
const DEFAULT_LIGHT_INTENSITY = 1.0;
let idCount = 0;

class AmbientLight {
  constructor(props = {}) {
    const {
      color = DEFAULT_LIGHT_COLOR
    } = props;
    const {
      intensity = DEFAULT_LIGHT_INTENSITY
    } = props;
    this.id = props.id || "ambient-".concat(idCount++);
    this.color = color;
    this.intensity = intensity;
    this.type = 'ambient';
  }

}

exports.AmbientLight = AmbientLight;
},{}],"node_modules/@deck.gl/core/dist/esm/effects/lighting/directional-light.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DirectionalLight = void 0;

var _core = require("@math.gl/core");

const DEFAULT_LIGHT_COLOR = [255, 255, 255];
const DEFAULT_LIGHT_INTENSITY = 1.0;
const DEFAULT_LIGHT_DIRECTION = [0.0, 0.0, -1.0];
let idCount = 0;

class DirectionalLight {
  constructor(props = {}) {
    const {
      color = DEFAULT_LIGHT_COLOR
    } = props;
    const {
      intensity = DEFAULT_LIGHT_INTENSITY
    } = props;
    const {
      direction = DEFAULT_LIGHT_DIRECTION
    } = props;
    const {
      _shadow = false
    } = props;
    this.id = props.id || "directional-".concat(idCount++);
    this.color = color;
    this.intensity = intensity;
    this.type = 'directional';
    this.direction = new _core.Vector3(direction).normalize().toArray();
    this.shadow = _shadow;
  }

  getProjectedLight() {
    return this;
  }

}

exports.DirectionalLight = DirectionalLight;
},{"@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/lib/effect.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class Effect {
  constructor(props = {}) {
    (0, _defineProperty2.default)(this, "id", void 0);
    (0, _defineProperty2.default)(this, "props", void 0);
    (0, _defineProperty2.default)(this, "useInPicking", void 0);
    const {
      id = 'effect'
    } = props;
    this.id = id;
    this.props = { ...props
    };
    this.useInPicking = false;
  }

  preRender() {}

  getModuleParameters(layer) {}

  cleanup() {}

}

exports.default = Effect;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js"}],"node_modules/@deck.gl/core/dist/esm/passes/pass.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class Pass {
  constructor(gl, props = {
    id: 'pass'
  }) {
    (0, _defineProperty2.default)(this, "id", void 0);
    (0, _defineProperty2.default)(this, "gl", void 0);
    (0, _defineProperty2.default)(this, "props", void 0);
    const {
      id
    } = props;
    this.id = id;
    this.gl = gl;
    this.props = { ...props
    };
  }

  setProps(props) {
    Object.assign(this.props, props);
  }

  render(params) {}

  cleanup() {}

}

exports.default = Pass;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js"}],"node_modules/@deck.gl/core/dist/esm/passes/layers-pass.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
exports.layerIndexResolver = layerIndexResolver;

var _pass = _interopRequireDefault(require("./pass"));

var _core = require("@luma.gl/core");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class LayersPass extends _pass.default {
  render(options) {
    const gl = this.gl;
    (0, _core.setParameters)(gl, {
      framebuffer: options.target
    });
    return this._drawLayers(options);
  }

  _drawLayers(options) {
    const {
      target,
      moduleParameters,
      viewports,
      views,
      onViewportActive,
      clearCanvas = true
    } = options;
    options.pass = options.pass || 'unknown';
    const gl = this.gl;

    if (clearCanvas) {
      clearGLCanvas(gl);
    }

    const renderStats = [];

    for (const viewport of viewports) {
      const view = views && views[viewport.id];
      onViewportActive(viewport);

      const drawLayerParams = this._getDrawLayerParams(viewport, options);

      const subViewports = viewport.subViewports || [viewport];

      for (const subViewport of subViewports) {
        const stats = this._drawLayersInViewport(gl, {
          target,
          moduleParameters,
          viewport: subViewport,
          view,
          pass: options.pass,
          layers: options.layers
        }, drawLayerParams);

        renderStats.push(stats);
      }
    }

    return renderStats;
  }

  _getDrawLayerParams(viewport, {
    layers,
    pass,
    layerFilter,
    effects,
    moduleParameters
  }) {
    const drawLayerParams = [];
    const indexResolver = layerIndexResolver();
    const drawContext = {
      layer: layers[0],
      viewport,
      isPicking: pass.startsWith('picking'),
      renderPass: pass
    };
    const layerFilterCache = {};

    for (let layerIndex = 0; layerIndex < layers.length; layerIndex++) {
      const layer = layers[layerIndex];

      const shouldDrawLayer = this._shouldDrawLayer(layer, drawContext, layerFilter, layerFilterCache);

      const layerRenderIndex = indexResolver(layer, shouldDrawLayer);
      const layerParam = {
        shouldDrawLayer,
        layerRenderIndex
      };

      if (shouldDrawLayer) {
        layerParam.moduleParameters = this._getModuleParameters(layer, effects, pass, moduleParameters);
        layerParam.layerParameters = this.getLayerParameters(layer, layerIndex, viewport);
      }

      drawLayerParams[layerIndex] = layerParam;
    }

    return drawLayerParams;
  }

  _drawLayersInViewport(gl, {
    layers,
    moduleParameters: globalModuleParameters,
    pass,
    target,
    viewport,
    view
  }, drawLayerParams) {
    const glViewport = getGLViewport(gl, {
      moduleParameters: globalModuleParameters,
      target,
      viewport
    });

    if (view && view.props.clear) {
      const clearOpts = view.props.clear === true ? {
        color: true,
        depth: true
      } : view.props.clear;
      (0, _core.withParameters)(gl, {
        scissorTest: true,
        scissor: glViewport
      }, () => (0, _core.clear)(gl, clearOpts));
    }

    const renderStatus = {
      totalCount: layers.length,
      visibleCount: 0,
      compositeCount: 0,
      pickableCount: 0
    };
    (0, _core.setParameters)(gl, {
      viewport: glViewport
    });

    for (let layerIndex = 0; layerIndex < layers.length; layerIndex++) {
      const layer = layers[layerIndex];
      const {
        shouldDrawLayer,
        layerRenderIndex,
        moduleParameters,
        layerParameters
      } = drawLayerParams[layerIndex];

      if (shouldDrawLayer && layer.props.pickable) {
        renderStatus.pickableCount++;
      }

      if (layer.isComposite) {
        renderStatus.compositeCount++;
      } else if (shouldDrawLayer) {
        renderStatus.visibleCount++;
        moduleParameters.viewport = viewport;

        try {
          layer.drawLayer({
            moduleParameters,
            uniforms: {
              layerIndex: layerRenderIndex
            },
            parameters: layerParameters
          });
        } catch (err) {
          layer.raiseError(err, "drawing ".concat(layer, " to ").concat(pass));
        }
      }
    }

    return renderStatus;
  }

  shouldDrawLayer(layer) {
    return true;
  }

  getModuleParameters(layer, effects) {
    return null;
  }

  getLayerParameters(layer, layerIndex, viewport) {
    return layer.props.parameters;
  }

  _shouldDrawLayer(layer, drawContext, layerFilter, layerFilterCache) {
    const shouldDrawLayer = this.shouldDrawLayer(layer) && layer.props.visible;

    if (!shouldDrawLayer) {
      return false;
    }

    drawContext.layer = layer;
    let parent = layer.parent;

    while (parent) {
      if (!parent.props.visible || !parent.filterSubLayer(drawContext)) {
        return false;
      }

      drawContext.layer = parent;
      parent = parent.parent;
    }

    if (layerFilter) {
      const rootLayerId = drawContext.layer.id;

      if (!(rootLayerId in layerFilterCache)) {
        layerFilterCache[rootLayerId] = layerFilter(drawContext);
      }

      if (!layerFilterCache[rootLayerId]) {
        return false;
      }
    }

    layer.activateViewport(drawContext.viewport);
    return true;
  }

  _getModuleParameters(layer, effects, pass, overrides) {
    var _layer$internalState;

    const moduleParameters = Object.assign(Object.create(((_layer$internalState = layer.internalState) === null || _layer$internalState === void 0 ? void 0 : _layer$internalState.propsInTransition) || layer.props), {
      autoWrapLongitude: layer.wrapLongitude,
      viewport: layer.context.viewport,
      mousePosition: layer.context.mousePosition,
      pickingActive: 0,
      devicePixelRatio: (0, _core.cssToDeviceRatio)(this.gl)
    });

    if (effects) {
      for (const effect of effects) {
        Object.assign(moduleParameters, effect.getModuleParameters(layer));
      }
    }

    return Object.assign(moduleParameters, this.getModuleParameters(layer, effects), overrides);
  }

}

exports.default = LayersPass;

function layerIndexResolver(startIndex = 0, layerIndices = {}) {
  const resolvers = {};

  const resolveLayerIndex = (layer, isDrawn) => {
    const indexOverride = layer.props._offset;
    const layerId = layer.id;
    const parentId = layer.parent && layer.parent.id;
    let index;

    if (parentId && !(parentId in layerIndices)) {
      resolveLayerIndex(layer.parent, false);
    }

    if (parentId in resolvers) {
      const resolver = resolvers[parentId] = resolvers[parentId] || layerIndexResolver(layerIndices[parentId], layerIndices);
      index = resolver(layer, isDrawn);
      resolvers[layerId] = resolver;
    } else if (Number.isFinite(indexOverride)) {
      index = indexOverride + (layerIndices[parentId] || 0);
      resolvers[layerId] = null;
    } else {
      index = startIndex;
    }

    if (isDrawn && index >= startIndex) {
      startIndex = index + 1;
    }

    layerIndices[layerId] = index;
    return index;
  };

  return resolveLayerIndex;
}

function getGLViewport(gl, {
  moduleParameters,
  target,
  viewport
}) {
  const useTarget = target && target.id !== 'default-framebuffer';
  const pixelRatio = moduleParameters && moduleParameters.devicePixelRatio || (0, _core.cssToDeviceRatio)(gl);
  const height = useTarget ? target.height : gl.drawingBufferHeight;
  const dimensions = viewport;
  return [dimensions.x * pixelRatio, height - (dimensions.y + dimensions.height) * pixelRatio, dimensions.width * pixelRatio, dimensions.height * pixelRatio];
}

function clearGLCanvas(gl) {
  const width = gl.drawingBufferWidth;
  const height = gl.drawingBufferHeight;
  (0, _core.setParameters)(gl, {
    viewport: [0, 0, width, height]
  });
  gl.clear(16384 | 256);
}
},{"./pass":"node_modules/@deck.gl/core/dist/esm/passes/pass.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/passes/shadow-pass.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));

var _layersPass = _interopRequireDefault(require("./layers-pass"));

var _core = require("@luma.gl/core");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class ShadowPass extends _layersPass.default {
  constructor(gl, props) {
    super(gl, props);
    (0, _defineProperty2.default)(this, "shadowMap", void 0);
    (0, _defineProperty2.default)(this, "depthBuffer", void 0);
    (0, _defineProperty2.default)(this, "fbo", void 0);
    this.shadowMap = new _core.Texture2D(gl, {
      width: 1,
      height: 1,
      parameters: {
        [10241]: 9729,
        [10240]: 9729,
        [10242]: 33071,
        [10243]: 33071
      }
    });
    this.depthBuffer = new _core.Renderbuffer(gl, {
      format: 33189,
      width: 1,
      height: 1
    });
    this.fbo = new _core.Framebuffer(gl, {
      id: 'shadowmap',
      width: 1,
      height: 1,
      attachments: {
        [36064]: this.shadowMap,
        [36096]: this.depthBuffer
      }
    });
  }

  render(params) {
    const target = this.fbo;
    (0, _core.withParameters)(this.gl, {
      depthRange: [0, 1],
      depthTest: true,
      blend: false,
      clearColor: [1, 1, 1, 1]
    }, () => {
      const viewport = params.viewports[0];
      const pixelRatio = (0, _core.cssToDeviceRatio)(this.gl);
      const width = viewport.width * pixelRatio;
      const height = viewport.height * pixelRatio;

      if (width !== target.width || height !== target.height) {
        target.resize({
          width,
          height
        });
      }

      super.render({ ...params,
        target,
        pass: 'shadow'
      });
    });
  }

  shouldDrawLayer(layer) {
    return layer.props.shadowEnabled !== false;
  }

  getModuleParameters() {
    return {
      drawToShadowMap: true
    };
  }

  delete() {
    if (this.fbo) {
      this.fbo.delete();
      this.fbo = null;
    }

    if (this.shadowMap) {
      this.shadowMap.delete();
      this.shadowMap = null;
    }

    if (this.depthBuffer) {
      this.depthBuffer.delete();
      this.depthBuffer = null;
    }
  }

}

exports.default = ShadowPass;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./layers-pass":"node_modules/@deck.gl/core/dist/esm/passes/layers-pass.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/effects/lighting/lighting-effect.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _core = require("@luma.gl/core");

var _ambientLight = require("./ambient-light");

var _directionalLight = require("./directional-light");

var _effect = _interopRequireDefault(require("../../lib/effect"));

var _core2 = require("@math.gl/core");

var _shadowPass = _interopRequireDefault(require("../../passes/shadow-pass"));

var _shadow = _interopRequireDefault(require("../../shaderlib/shadow/shadow"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const DEFAULT_AMBIENT_LIGHT_PROPS = {
  color: [255, 255, 255],
  intensity: 1.0
};
const DEFAULT_DIRECTIONAL_LIGHT_PROPS = [{
  color: [255, 255, 255],
  intensity: 1.0,
  direction: [-1, 3, -1]
}, {
  color: [255, 255, 255],
  intensity: 0.9,
  direction: [1, -8, -2.5]
}];
const DEFAULT_SHADOW_COLOR = [0, 0, 0, 200 / 255];

class LightingEffect extends _effect.default {
  constructor(props) {
    super(props);
    this.ambientLight = null;
    this.directionalLights = [];
    this.pointLights = [];
    this.shadowColor = DEFAULT_SHADOW_COLOR;
    this.shadowPasses = [];
    this.shadowMaps = [];
    this.dummyShadowMap = null;
    this.shadow = false;
    this.programManager = null;

    for (const key in props) {
      const lightSource = props[key];

      switch (lightSource.type) {
        case 'ambient':
          this.ambientLight = lightSource;
          break;

        case 'directional':
          this.directionalLights.push(lightSource);
          break;

        case 'point':
          this.pointLights.push(lightSource);
          break;

        default:
      }
    }

    this._applyDefaultLights();

    this.shadow = this.directionalLights.some(light => light.shadow);
  }

  preRender(gl, {
    layers,
    layerFilter,
    viewports,
    onViewportActive,
    views
  }) {
    if (!this.shadow) return;
    this.shadowMatrices = this._createLightMatrix();

    if (this.shadowPasses.length === 0) {
      this._createShadowPasses(gl);
    }

    if (!this.programManager) {
      this.programManager = _core.ProgramManager.getDefaultProgramManager(gl);

      if (_shadow.default) {
        this.programManager.addDefaultModule(_shadow.default);
      }
    }

    if (!this.dummyShadowMap) {
      this.dummyShadowMap = new _core.Texture2D(gl, {
        width: 1,
        height: 1
      });
    }

    for (let i = 0; i < this.shadowPasses.length; i++) {
      const shadowPass = this.shadowPasses[i];
      shadowPass.render({
        layers,
        layerFilter,
        viewports,
        onViewportActive,
        views,
        moduleParameters: {
          shadowLightId: i,
          dummyShadowMap: this.dummyShadowMap,
          shadowMatrices: this.shadowMatrices
        }
      });
    }
  }

  getModuleParameters(layer) {
    const parameters = this.shadow ? {
      shadowMaps: this.shadowMaps,
      dummyShadowMap: this.dummyShadowMap,
      shadowColor: this.shadowColor,
      shadowMatrices: this.shadowMatrices
    } : {};
    parameters.lightSources = {
      ambientLight: this.ambientLight,
      directionalLights: this.directionalLights.map(directionalLight => directionalLight.getProjectedLight({
        layer
      })),
      pointLights: this.pointLights.map(pointLight => pointLight.getProjectedLight({
        layer
      }))
    };
    return parameters;
  }

  cleanup() {
    for (const shadowPass of this.shadowPasses) {
      shadowPass.delete();
    }

    this.shadowPasses.length = 0;
    this.shadowMaps.length = 0;

    if (this.dummyShadowMap) {
      this.dummyShadowMap.delete();
      this.dummyShadowMap = null;
    }

    if (this.shadow && this.programManager) {
      this.programManager.removeDefaultModule(_shadow.default);
      this.programManager = null;
    }
  }

  _createLightMatrix() {
    const lightMatrices = [];

    for (const light of this.directionalLights) {
      const viewMatrix = new _core2.Matrix4().lookAt({
        eye: new _core2.Vector3(light.direction).negate()
      });
      lightMatrices.push(viewMatrix);
    }

    return lightMatrices;
  }

  _createShadowPasses(gl) {
    for (let i = 0; i < this.directionalLights.length; i++) {
      const shadowPass = new _shadowPass.default(gl);
      this.shadowPasses[i] = shadowPass;
      this.shadowMaps[i] = shadowPass.shadowMap;
    }
  }

  _applyDefaultLights() {
    const {
      ambientLight,
      pointLights,
      directionalLights
    } = this;

    if (!ambientLight && pointLights.length === 0 && directionalLights.length === 0) {
      this.ambientLight = new _ambientLight.AmbientLight(DEFAULT_AMBIENT_LIGHT_PROPS);
      this.directionalLights.push(new _directionalLight.DirectionalLight(DEFAULT_DIRECTIONAL_LIGHT_PROPS[0]), new _directionalLight.DirectionalLight(DEFAULT_DIRECTIONAL_LIGHT_PROPS[1]));
    }
  }

}

exports.default = LightingEffect;
},{"@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","./ambient-light":"node_modules/@deck.gl/core/dist/esm/effects/lighting/ambient-light.js","./directional-light":"node_modules/@deck.gl/core/dist/esm/effects/lighting/directional-light.js","../../lib/effect":"node_modules/@deck.gl/core/dist/esm/lib/effect.js","@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js","../../passes/shadow-pass":"node_modules/@deck.gl/core/dist/esm/passes/shadow-pass.js","../../shaderlib/shadow/shadow":"node_modules/@deck.gl/core/dist/esm/shaderlib/shadow/shadow.js"}],"node_modules/@deck.gl/core/dist/esm/utils/typed-array-manager.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.TypedArrayManager = void 0;

class TypedArrayManager {
  constructor(props) {
    this._pool = [];
    this.props = {
      overAlloc: 2,
      poolSize: 100
    };
    this.setProps(props);
  }

  setProps(props) {
    Object.assign(this.props, props);
  }

  allocate(typedArray, count, {
    size = 1,
    type,
    padding = 0,
    copy = false,
    initialize = false,
    maxCount
  }) {
    const Type = type || typedArray && typedArray.constructor || Float32Array;
    const newSize = count * size + padding;

    if (ArrayBuffer.isView(typedArray)) {
      if (newSize <= typedArray.length) {
        return typedArray;
      }

      if (newSize * typedArray.BYTES_PER_ELEMENT <= typedArray.buffer.byteLength) {
        return new Type(typedArray.buffer, 0, newSize);
      }
    }

    let maxSize;

    if (maxCount) {
      maxSize = maxCount * size + padding;
    }

    const newArray = this._allocate(Type, newSize, initialize, maxSize);

    if (typedArray && copy) {
      newArray.set(typedArray);
    } else if (!initialize) {
      newArray.fill(0, 0, 4);
    }

    this._release(typedArray);

    return newArray;
  }

  release(typedArray) {
    this._release(typedArray);
  }

  _allocate(Type, size, initialize, maxSize) {
    let sizeToAllocate = Math.max(Math.ceil(size * this.props.overAlloc), 1);

    if (sizeToAllocate > maxSize) {
      sizeToAllocate = maxSize;
    }

    const pool = this._pool;
    const byteLength = Type.BYTES_PER_ELEMENT * sizeToAllocate;
    const i = pool.findIndex(b => b.byteLength >= byteLength);

    if (i >= 0) {
      const array = new Type(pool.splice(i, 1)[0], 0, sizeToAllocate);

      if (initialize) {
        array.fill(0);
      }

      return array;
    }

    return new Type(sizeToAllocate);
  }

  _release(typedArray) {
    if (!ArrayBuffer.isView(typedArray)) {
      return;
    }

    const pool = this._pool;
    const {
      buffer
    } = typedArray;
    const {
      byteLength
    } = buffer;
    const i = pool.findIndex(b => b.byteLength >= byteLength);

    if (i < 0) {
      pool.push(buffer);
    } else if (i > 0 || pool.length < this.props.poolSize) {
      pool.splice(i, 0, buffer);
    }

    if (pool.length > this.props.poolSize) {
      pool.shift();
    }
  }

}

exports.TypedArrayManager = TypedArrayManager;

var _default = new TypedArrayManager();

exports.default = _default;
},{}],"node_modules/math.gl/dist/esm/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _core = require("@math.gl/core");

Object.keys(_core).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _core[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _core[key];
    }
  });
});
},{"@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/utils/math-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createMat4 = createMat4;
exports.fp64LowPart = fp64LowPart;
exports.getCameraPosition = getCameraPosition;
exports.getFrustumPlanes = getFrustumPlanes;
exports.mod = mod;
exports.toDoublePrecisionArray = toDoublePrecisionArray;

var _typedArrayManager = _interopRequireDefault(require("./typed-array-manager"));

var _math = require("math.gl");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function createMat4() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}

function mod(value, divisor) {
  const modulus = value % divisor;
  return modulus < 0 ? divisor + modulus : modulus;
}

function getCameraPosition(viewMatrixInverse) {
  return [viewMatrixInverse[12], viewMatrixInverse[13], viewMatrixInverse[14]];
}

function getFrustumPlanes(viewProjectionMatrix) {
  return {
    left: getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[0], viewProjectionMatrix[7] + viewProjectionMatrix[4], viewProjectionMatrix[11] + viewProjectionMatrix[8], viewProjectionMatrix[15] + viewProjectionMatrix[12]),
    right: getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[0], viewProjectionMatrix[7] - viewProjectionMatrix[4], viewProjectionMatrix[11] - viewProjectionMatrix[8], viewProjectionMatrix[15] - viewProjectionMatrix[12]),
    bottom: getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[1], viewProjectionMatrix[7] + viewProjectionMatrix[5], viewProjectionMatrix[11] + viewProjectionMatrix[9], viewProjectionMatrix[15] + viewProjectionMatrix[13]),
    top: getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[1], viewProjectionMatrix[7] - viewProjectionMatrix[5], viewProjectionMatrix[11] - viewProjectionMatrix[9], viewProjectionMatrix[15] - viewProjectionMatrix[13]),
    near: getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[2], viewProjectionMatrix[7] + viewProjectionMatrix[6], viewProjectionMatrix[11] + viewProjectionMatrix[10], viewProjectionMatrix[15] + viewProjectionMatrix[14]),
    far: getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[2], viewProjectionMatrix[7] - viewProjectionMatrix[6], viewProjectionMatrix[11] - viewProjectionMatrix[10], viewProjectionMatrix[15] - viewProjectionMatrix[14])
  };
}

const scratchVector = new _math.Vector3();

function getFrustumPlane(a, b, c, d) {
  scratchVector.set(a, b, c);
  const L = scratchVector.len();
  return {
    distance: d / L,
    normal: new _math.Vector3(-a / L, -b / L, -c / L)
  };
}

function fp64LowPart(x) {
  return x - Math.fround(x);
}

let scratchArray;

function toDoublePrecisionArray(typedArray, options) {
  const {
    size = 1,
    startIndex = 0
  } = options;
  const endIndex = options.endIndex !== undefined ? options.endIndex : typedArray.length;
  const count = (endIndex - startIndex) / size;
  scratchArray = _typedArrayManager.default.allocate(scratchArray, count, {
    type: Float32Array,
    size: size * 2
  });
  let sourceIndex = startIndex;
  let targetIndex = 0;

  while (sourceIndex < endIndex) {
    for (let j = 0; j < size; j++) {
      const value = typedArray[sourceIndex++];
      scratchArray[targetIndex + j] = value;
      scratchArray[targetIndex + j + size] = fp64LowPart(value);
    }

    targetIndex += size * 2;
  }

  return scratchArray.subarray(0, count * size * 2);
}
},{"./typed-array-manager":"node_modules/@deck.gl/core/dist/esm/utils/typed-array-manager.js","math.gl":"node_modules/math.gl/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/viewports/viewport.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _log = _interopRequireDefault(require("../utils/log"));

var _mathUtils = require("../utils/math-utils");

var _core = require("@math.gl/core");

var mat4 = _interopRequireWildcard(require("gl-matrix/mat4"));

var _webMercator = require("@math.gl/web-mercator");

var _constants = require("../lib/constants");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const DEGREES_TO_RADIANS = Math.PI / 180;
const IDENTITY = (0, _mathUtils.createMat4)();
const ZERO_VECTOR = [0, 0, 0];
const DEFAULT_ZOOM = 0;
const DEFAULT_DISTANCE_SCALES = {
  unitsPerMeter: [1, 1, 1],
  metersPerUnit: [1, 1, 1]
};

class Viewport {
  constructor(opts = {}) {
    const {
      id = null,
      x = 0,
      y = 0,
      width = 1,
      height = 1
    } = opts;
    this.id = id || this.constructor.displayName || 'viewport';
    this.x = x;
    this.y = y;
    this.width = width || 1;
    this.height = height || 1;
    this._frustumPlanes = {};

    this._initViewMatrix(opts);

    this._initProjectionMatrix(opts);

    this._initPixelMatrices();

    this.equals = this.equals.bind(this);
    this.project = this.project.bind(this);
    this.unproject = this.unproject.bind(this);
    this.projectPosition = this.projectPosition.bind(this);
    this.unprojectPosition = this.unprojectPosition.bind(this);
    this.projectFlat = this.projectFlat.bind(this);
    this.unprojectFlat = this.unprojectFlat.bind(this);
  }

  get metersPerPixel() {
    return this.distanceScales.metersPerUnit[2] / this.scale;
  }

  get projectionMode() {
    if (this.isGeospatial) {
      return this.zoom < 12 ? _constants.PROJECTION_MODE.WEB_MERCATOR : _constants.PROJECTION_MODE.WEB_MERCATOR_AUTO_OFFSET;
    }

    return _constants.PROJECTION_MODE.IDENTITY;
  }

  equals(viewport) {
    if (!(viewport instanceof Viewport)) {
      return false;
    }

    if (this === viewport) {
      return true;
    }

    return viewport.width === this.width && viewport.height === this.height && viewport.scale === this.scale && (0, _core.equals)(viewport.projectionMatrix, this.projectionMatrix) && (0, _core.equals)(viewport.viewMatrix, this.viewMatrix);
  }

  project(xyz, {
    topLeft = true
  } = {}) {
    const worldPosition = this.projectPosition(xyz);
    const coord = (0, _webMercator.worldToPixels)(worldPosition, this.pixelProjectionMatrix);
    const [x, y] = coord;
    const y2 = topLeft ? y : this.height - y;
    return xyz.length === 2 ? [x, y2] : [x, y2, coord[2]];
  }

  unproject(xyz, {
    topLeft = true,
    targetZ
  } = {}) {
    const [x, y, z] = xyz;
    const y2 = topLeft ? y : this.height - y;
    const targetZWorld = targetZ && targetZ * this.distanceScales.unitsPerMeter[2];
    const coord = (0, _webMercator.pixelsToWorld)([x, y2, z], this.pixelUnprojectionMatrix, targetZWorld);
    const [X, Y, Z] = this.unprojectPosition(coord);

    if (Number.isFinite(z)) {
      return [X, Y, Z];
    }

    return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];
  }

  projectPosition(xyz) {
    const [X, Y] = this.projectFlat(xyz);
    const Z = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];
    return [X, Y, Z];
  }

  unprojectPosition(xyz) {
    const [X, Y] = this.unprojectFlat(xyz);
    const Z = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];
    return [X, Y, Z];
  }

  projectFlat(xyz) {
    if (this.isGeospatial) {
      const result = (0, _webMercator.lngLatToWorld)(xyz);
      result[1] = (0, _core.clamp)(result[1], -318, 830);
      return result;
    }

    return xyz;
  }

  unprojectFlat(xyz) {
    if (this.isGeospatial) {
      return (0, _webMercator.worldToLngLat)(xyz);
    }

    return xyz;
  }

  getBounds(options = {}) {
    const unprojectOption = {
      targetZ: options.z || 0
    };
    const topLeft = this.unproject([0, 0], unprojectOption);
    const topRight = this.unproject([this.width, 0], unprojectOption);
    const bottomLeft = this.unproject([0, this.height], unprojectOption);
    const bottomRight = this.unproject([this.width, this.height], unprojectOption);
    return [Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]), Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]), Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]), Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1])];
  }

  getDistanceScales(coordinateOrigin = null) {
    if (coordinateOrigin) {
      return (0, _webMercator.getDistanceScales)({
        longitude: coordinateOrigin[0],
        latitude: coordinateOrigin[1],
        highPrecision: true
      });
    }

    return this.distanceScales;
  }

  containsPixel({
    x,
    y,
    width = 1,
    height = 1
  }) {
    return x < this.x + this.width && this.x < x + width && y < this.y + this.height && this.y < y + height;
  }

  getFrustumPlanes() {
    if (this._frustumPlanes.near) {
      return this._frustumPlanes;
    }

    Object.assign(this._frustumPlanes, (0, _mathUtils.getFrustumPlanes)(this.viewProjectionMatrix));
    return this._frustumPlanes;
  }

  panByPosition(coords, pixel) {
    return null;
  }

  getCameraPosition() {
    return this.cameraPosition;
  }

  getCameraDirection() {
    return this.cameraDirection;
  }

  getCameraUp() {
    return this.cameraUp;
  }

  _createProjectionMatrix({
    orthographic,
    fovyRadians,
    aspect,
    focalDistance,
    near,
    far
  }) {
    return orthographic ? new _core.Matrix4().orthographic({
      fovy: fovyRadians,
      aspect,
      focalDistance,
      near,
      far
    }) : new _core.Matrix4().perspective({
      fovy: fovyRadians,
      aspect,
      near,
      far
    });
  }

  _initViewMatrix(opts) {
    const {
      viewMatrix = IDENTITY,
      longitude = null,
      latitude = null,
      zoom = null,
      position = null,
      modelMatrix = null,
      focalDistance = 1,
      distanceScales = null
    } = opts;
    this.isGeospatial = Number.isFinite(latitude) && Number.isFinite(longitude);
    this.zoom = zoom;

    if (!Number.isFinite(this.zoom)) {
      this.zoom = this.isGeospatial ? (0, _webMercator.getMeterZoom)({
        latitude
      }) + Math.log2(focalDistance) : DEFAULT_ZOOM;
    }

    const scale = Math.pow(2, this.zoom);
    this.scale = scale;
    this.distanceScales = this.isGeospatial ? (0, _webMercator.getDistanceScales)({
      latitude,
      longitude
    }) : distanceScales || DEFAULT_DISTANCE_SCALES;
    this.focalDistance = focalDistance;
    this.distanceScales.metersPerUnit = new _core.Vector3(this.distanceScales.metersPerUnit);
    this.distanceScales.unitsPerMeter = new _core.Vector3(this.distanceScales.unitsPerMeter);
    this.position = ZERO_VECTOR;
    this.meterOffset = ZERO_VECTOR;

    if (position) {
      this.position = position;
      this.modelMatrix = modelMatrix;
      this.meterOffset = modelMatrix ? modelMatrix.transformVector(position) : position;
    }

    if (this.isGeospatial) {
      this.longitude = longitude;
      this.latitude = latitude;
      this.center = this._getCenterInWorld({
        longitude,
        latitude
      });
    } else {
      this.center = position ? this.projectPosition(position) : [0, 0, 0];
    }

    this.viewMatrixUncentered = viewMatrix;
    this.viewMatrix = new _core.Matrix4().multiplyRight(this.viewMatrixUncentered).translate(new _core.Vector3(this.center || ZERO_VECTOR).negate());
  }

  _getCenterInWorld({
    longitude,
    latitude
  }) {
    const {
      meterOffset,
      distanceScales
    } = this;
    const center = new _core.Vector3(this.projectPosition([longitude, latitude, 0]));

    if (meterOffset) {
      const commonPosition = new _core.Vector3(meterOffset).scale(distanceScales.unitsPerMeter);
      center.add(commonPosition);
    }

    return center;
  }

  _initProjectionMatrix(opts) {
    const {
      projectionMatrix = null,
      orthographic = false,
      fovyRadians,
      fovy = 75,
      near = 0.1,
      far = 1000,
      focalDistance = 1
    } = opts;
    this.projectionMatrix = projectionMatrix || this._createProjectionMatrix({
      orthographic,
      fovyRadians: fovyRadians || fovy * DEGREES_TO_RADIANS,
      aspect: this.width / this.height,
      focalDistance,
      near,
      far
    });
  }

  _initPixelMatrices() {
    const vpm = (0, _mathUtils.createMat4)();
    mat4.multiply(vpm, vpm, this.projectionMatrix);
    mat4.multiply(vpm, vpm, this.viewMatrix);
    this.viewProjectionMatrix = vpm;
    this.viewMatrixInverse = mat4.invert([], this.viewMatrix) || this.viewMatrix;
    this.cameraPosition = (0, _mathUtils.getCameraPosition)(this.viewMatrixInverse);
    const viewportMatrix = (0, _mathUtils.createMat4)();
    const pixelProjectionMatrix = (0, _mathUtils.createMat4)();
    mat4.scale(viewportMatrix, viewportMatrix, [this.width / 2, -this.height / 2, 1]);
    mat4.translate(viewportMatrix, viewportMatrix, [1, -1, 0]);
    mat4.multiply(pixelProjectionMatrix, viewportMatrix, this.viewProjectionMatrix);
    this.pixelProjectionMatrix = pixelProjectionMatrix;
    this.viewportMatrix = viewportMatrix;
    this.pixelUnprojectionMatrix = mat4.invert((0, _mathUtils.createMat4)(), this.pixelProjectionMatrix);

    if (!this.pixelUnprojectionMatrix) {
      _log.default.warn('Pixel project matrix not invertible')();
    }
  }

}

exports.default = Viewport;
Viewport.displayName = 'Viewport';
},{"../utils/log":"node_modules/@deck.gl/core/dist/esm/utils/log.js","../utils/math-utils":"node_modules/@deck.gl/core/dist/esm/utils/math-utils.js","@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js","gl-matrix/mat4":"node_modules/gl-matrix/esm/mat4.js","@math.gl/web-mercator":"node_modules/@math.gl/web-mercator/dist/esm/index.js","../lib/constants":"node_modules/@deck.gl/core/dist/esm/lib/constants.js"}],"node_modules/gl-matrix/esm/vec2.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add = add;
exports.angle = angle;
exports.ceil = ceil;
exports.clone = clone;
exports.copy = copy;
exports.create = create;
exports.cross = cross;
exports.dist = void 0;
exports.distance = distance;
exports.div = void 0;
exports.divide = divide;
exports.dot = dot;
exports.equals = equals;
exports.exactEquals = exactEquals;
exports.floor = floor;
exports.forEach = void 0;
exports.fromValues = fromValues;
exports.inverse = inverse;
exports.len = void 0;
exports.length = length;
exports.lerp = lerp;
exports.max = max;
exports.min = min;
exports.mul = void 0;
exports.multiply = multiply;
exports.negate = negate;
exports.normalize = normalize;
exports.random = random;
exports.rotate = rotate;
exports.round = round;
exports.scale = scale;
exports.scaleAndAdd = scaleAndAdd;
exports.set = set;
exports.sqrLen = exports.sqrDist = void 0;
exports.squaredDistance = squaredDistance;
exports.squaredLength = squaredLength;
exports.str = str;
exports.sub = void 0;
exports.subtract = subtract;
exports.transformMat2 = transformMat2;
exports.transformMat2d = transformMat2d;
exports.transformMat3 = transformMat3;
exports.transformMat4 = transformMat4;
exports.zero = zero;

var glMatrix = _interopRequireWildcard(require("./common.js"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * 2 Dimensional Vector
 * @module vec2
 */

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(2);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }

  return out;
}
/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {ReadonlyVec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */


function fromValues(x, y) {
  var out = new glMatrix.ARRAY_TYPE(2);
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the source vector
 * @returns {vec2} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */


function set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}
/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */


function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}
/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */


function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}
/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to ceil
 * @returns {vec2} out
 */


function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}
/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to floor
 * @returns {vec2} out
 */


function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}
/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */


function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}
/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */


function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}
/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to round
 * @returns {vec2} out
 */


function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
}
/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */


function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}
/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */


function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} distance between a and b
 */


function distance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return Math.hypot(x, y);
}
/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} squared distance between a and b
 */


function squaredDistance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return x * x + y * y;
}
/**
 * Calculates the length of a vec2
 *
 * @param {ReadonlyVec2} a vector to calculate length of
 * @returns {Number} length of a
 */


function length(a) {
  var x = a[0],
      y = a[1];
  return Math.hypot(x, y);
}
/**
 * Calculates the squared length of a vec2
 *
 * @param {ReadonlyVec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */


function squaredLength(a) {
  var x = a[0],
      y = a[1];
  return x * x + y * y;
}
/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to negate
 * @returns {vec2} out
 */


function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}
/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to invert
 * @returns {vec2} out
 */


function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
}
/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to normalize
 * @returns {vec2} out
 */


function normalize(out, a) {
  var x = a[0],
      y = a[1];
  var len = x * x + y * y;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  return out;
}
/**
 * Calculates the dot product of two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} dot product of a and b
 */


function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}
/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec3} out
 */


function cross(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}
/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec2} out
 */


function lerp(out, a, b, t) {
  var ax = a[0],
      ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */


function random(out, scale) {
  scale = scale || 1.0;
  var r = glMatrix.RANDOM() * 2.0 * Math.PI;
  out[0] = Math.cos(r) * scale;
  out[1] = Math.sin(r) * scale;
  return out;
}
/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat2} m matrix to transform with
 * @returns {vec2} out
 */


function transformMat2(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}
/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat2d} m matrix to transform with
 * @returns {vec2} out
 */


function transformMat2d(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}
/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat3} m matrix to transform with
 * @returns {vec2} out
 */


function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec2} out
 */


function transformMat4(out, a, m) {
  var x = a[0];
  var y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}
/**
 * Rotate a 2D vector
 * @param {vec2} out The receiving vec2
 * @param {ReadonlyVec2} a The vec2 point to rotate
 * @param {ReadonlyVec2} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec2} out
 */


function rotate(out, a, b, rad) {
  //Translate point to the origin
  var p0 = a[0] - b[0],
      p1 = a[1] - b[1],
      sinC = Math.sin(rad),
      cosC = Math.cos(rad); //perform rotation and translate to correct position

  out[0] = p0 * cosC - p1 * sinC + b[0];
  out[1] = p0 * sinC + p1 * cosC + b[1];
  return out;
}
/**
 * Get the angle between two 2D vectors
 * @param {ReadonlyVec2} a The first operand
 * @param {ReadonlyVec2} b The second operand
 * @returns {Number} The angle in radians
 */


function angle(a, b) {
  var x1 = a[0],
      y1 = a[1],
      x2 = b[0],
      y2 = b[1],
      // mag is the product of the magnitudes of a and b
  mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2),
      // mag &&.. short circuits if mag == 0
  cosine = mag && (x1 * x2 + y1 * y2) / mag; // Math.min(Math.max(cosine, -1), 1) clamps the cosine between -1 and 1

  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
/**
 * Set the components of a vec2 to zero
 *
 * @param {vec2} out the receiving vector
 * @returns {vec2} out
 */


function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec2} a vector to represent as a string
 * @returns {String} string representation of the vector
 */


function str(a) {
  return "vec2(" + a[0] + ", " + a[1] + ")";
}
/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec2} a The first vector.
 * @param {ReadonlyVec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec2} a The first vector.
 * @param {ReadonlyVec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1];
  var b0 = b[0],
      b1 = b[1];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));
}
/**
 * Alias for {@link vec2.length}
 * @function
 */


var len = length;
/**
 * Alias for {@link vec2.subtract}
 * @function
 */

exports.len = len;
var sub = subtract;
/**
 * Alias for {@link vec2.multiply}
 * @function
 */

exports.sub = sub;
var mul = multiply;
/**
 * Alias for {@link vec2.divide}
 * @function
 */

exports.mul = mul;
var div = divide;
/**
 * Alias for {@link vec2.distance}
 * @function
 */

exports.div = div;
var dist = distance;
/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */

exports.dist = dist;
var sqrDist = squaredDistance;
/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */

exports.sqrDist = sqrDist;
var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

exports.sqrLen = sqrLen;

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 2;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }

    return a;
  };
}();

exports.forEach = forEach;
},{"./common.js":"node_modules/gl-matrix/esm/common.js"}],"node_modules/@deck.gl/core/dist/esm/viewports/web-mercator-viewport.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _viewport = _interopRequireDefault(require("./viewport"));

var _webMercator = require("@math.gl/web-mercator");

var vec2 = _interopRequireWildcard(require("gl-matrix/vec2"));

var _core = require("@math.gl/core");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const TILE_SIZE = 512;
const EARTH_CIRCUMFERENCE = 40.03e6;
const DEGREES_TO_RADIANS = Math.PI / 180;

function unitsPerMeter(latitude) {
  const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);
  return TILE_SIZE / EARTH_CIRCUMFERENCE / latCosine;
}

class WebMercatorViewport extends _viewport.default {
  constructor(opts = {}) {
    const {
      latitude = 0,
      longitude = 0,
      zoom = 11,
      pitch = 0,
      bearing = 0,
      nearZMultiplier = 0.1,
      farZMultiplier = 1.01,
      orthographic = false,
      projectionMatrix,
      repeat = false,
      worldOffset = 0,
      legacyMeterSizes = false
    } = opts;
    let {
      width,
      height,
      altitude = 1.5
    } = opts;
    const scale = Math.pow(2, zoom);
    width = width || 1;
    height = height || 1;
    let fovy;
    let projectionParameters = null;

    if (projectionMatrix) {
      altitude = projectionMatrix[5] / 2;
      fovy = (0, _webMercator.altitudeToFovy)(altitude);
    } else {
      if (opts.fovy) {
        fovy = opts.fovy;
        altitude = (0, _webMercator.fovyToAltitude)(fovy);
      } else {
        fovy = (0, _webMercator.altitudeToFovy)(altitude);
      }

      projectionParameters = (0, _webMercator.getProjectionParameters)({
        width,
        height,
        pitch,
        fovy,
        nearZMultiplier,
        farZMultiplier
      });
    }

    let viewMatrixUncentered = (0, _webMercator.getViewMatrix)({
      height,
      pitch,
      bearing,
      scale,
      altitude
    });

    if (worldOffset) {
      const viewOffset = new _core.Matrix4().translate([512 * worldOffset, 0, 0]);
      viewMatrixUncentered = viewOffset.multiplyLeft(viewMatrixUncentered);
    }

    super({ ...opts,
      width,
      height,
      viewMatrix: viewMatrixUncentered,
      longitude,
      latitude,
      zoom,
      ...projectionParameters,
      fovy,
      focalDistance: altitude
    });
    this.latitude = latitude;
    this.longitude = longitude;
    this.zoom = zoom;
    this.pitch = pitch;
    this.bearing = bearing;
    this.altitude = altitude;
    this.fovy = fovy;
    this.orthographic = orthographic;
    this._subViewports = repeat ? [] : null;
    this._pseudoMeters = legacyMeterSizes;
    Object.freeze(this);
  }

  get subViewports() {
    if (this._subViewports && !this._subViewports.length) {
      const bounds = this.getBounds();
      const minOffset = Math.floor((bounds[0] + 180) / 360);
      const maxOffset = Math.ceil((bounds[2] - 180) / 360);

      for (let x = minOffset; x <= maxOffset; x++) {
        const offsetViewport = x ? new WebMercatorViewport({ ...this,
          worldOffset: x
        }) : this;

        this._subViewports.push(offsetViewport);
      }
    }

    return this._subViewports;
  }

  projectPosition(xyz) {
    if (this._pseudoMeters) {
      return super.projectPosition(xyz);
    }

    const [X, Y] = this.projectFlat(xyz);
    const Z = (xyz[2] || 0) * unitsPerMeter(xyz[1]);
    return [X, Y, Z];
  }

  unprojectPosition(xyz) {
    if (this._pseudoMeters) {
      return super.unprojectPosition(xyz);
    }

    const [X, Y] = this.unprojectFlat(xyz);
    const Z = (xyz[2] || 0) / unitsPerMeter(Y);
    return [X, Y, Z];
  }

  addMetersToLngLat(lngLatZ, xyz) {
    return (0, _webMercator.addMetersToLngLat)(lngLatZ, xyz);
  }

  panByPosition(coords, pixel) {
    const fromLocation = (0, _webMercator.pixelsToWorld)(pixel, this.pixelUnprojectionMatrix);
    const toLocation = this.projectFlat(coords);
    const translate = vec2.add([], toLocation, vec2.negate([], fromLocation));
    const newCenter = vec2.add([], this.center, translate);
    const [longitude, latitude] = this.unprojectFlat(newCenter);
    return {
      longitude,
      latitude
    };
  }

  getBounds(options = {}) {
    const corners = (0, _webMercator.getBounds)(this, options.z || 0);
    return [Math.min(corners[0][0], corners[1][0], corners[2][0], corners[3][0]), Math.min(corners[0][1], corners[1][1], corners[2][1], corners[3][1]), Math.max(corners[0][0], corners[1][0], corners[2][0], corners[3][0]), Math.max(corners[0][1], corners[1][1], corners[2][1], corners[3][1])];
  }

  fitBounds(bounds, options = {}) {
    const {
      width,
      height
    } = this;
    const {
      longitude,
      latitude,
      zoom
    } = (0, _webMercator.fitBounds)({
      width,
      height,
      bounds,
      ...options
    });
    return new WebMercatorViewport({
      width,
      height,
      longitude,
      latitude,
      zoom
    });
  }

}

exports.default = WebMercatorViewport;
WebMercatorViewport.displayName = 'WebMercatorViewport';
},{"./viewport":"node_modules/@deck.gl/core/dist/esm/viewports/viewport.js","@math.gl/web-mercator":"node_modules/@math.gl/web-mercator/dist/esm/index.js","gl-matrix/vec2":"node_modules/gl-matrix/esm/vec2.js","@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js"}],"node_modules/gl-matrix/esm/vec3.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add = add;
exports.angle = angle;
exports.bezier = bezier;
exports.ceil = ceil;
exports.clone = clone;
exports.copy = copy;
exports.create = create;
exports.cross = cross;
exports.dist = void 0;
exports.distance = distance;
exports.div = void 0;
exports.divide = divide;
exports.dot = dot;
exports.equals = equals;
exports.exactEquals = exactEquals;
exports.floor = floor;
exports.forEach = void 0;
exports.fromValues = fromValues;
exports.hermite = hermite;
exports.inverse = inverse;
exports.len = void 0;
exports.length = length;
exports.lerp = lerp;
exports.max = max;
exports.min = min;
exports.mul = void 0;
exports.multiply = multiply;
exports.negate = negate;
exports.normalize = normalize;
exports.random = random;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.round = round;
exports.scale = scale;
exports.scaleAndAdd = scaleAndAdd;
exports.set = set;
exports.sqrLen = exports.sqrDist = void 0;
exports.squaredDistance = squaredDistance;
exports.squaredLength = squaredLength;
exports.str = str;
exports.sub = void 0;
exports.subtract = subtract;
exports.transformMat3 = transformMat3;
exports.transformMat4 = transformMat4;
exports.transformQuat = transformQuat;
exports.zero = zero;

var glMatrix = _interopRequireWildcard(require("./common.js"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(3);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  return out;
}
/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {ReadonlyVec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Calculates the length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate length of
 * @returns {Number} length of a
 */


function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}
/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */


function fromValues(x, y, z) {
  var out = new glMatrix.ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the source vector
 * @returns {vec3} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */


function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */


function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */


function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}
/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to ceil
 * @returns {vec3} out
 */


function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}
/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to floor
 * @returns {vec3} out
 */


function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}
/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */


function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}
/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */


function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}
/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to round
 * @returns {vec3} out
 */


function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}
/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */


function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */


function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} distance between a and b
 */


function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.hypot(x, y, z);
}
/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} squared distance between a and b
 */


function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}
/**
 * Calculates the squared length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */


function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}
/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to negate
 * @returns {vec3} out
 */


function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to invert
 * @returns {vec3} out
 */


function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}
/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to normalize
 * @returns {vec3} out
 */


function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len = x * x + y * y + z * z;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  out[2] = a[2] * len;
  return out;
}
/**
 * Calculates the dot product of two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} dot product of a and b
 */


function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */


function cross(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2];
  var bx = b[0],
      by = b[1],
      bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */


function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {ReadonlyVec3} c the third operand
 * @param {ReadonlyVec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */


function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {ReadonlyVec3} c the third operand
 * @param {ReadonlyVec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */


function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */


function random(out, scale) {
  scale = scale || 1.0;
  var r = glMatrix.RANDOM() * 2.0 * Math.PI;
  var z = glMatrix.RANDOM() * 2.0 - 1.0;
  var zScale = Math.sqrt(1.0 - z * z) * scale;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}
/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec3} out
 */


function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat3} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */


function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
/**
 * Transforms the vec3 with a quat
 * Can also be used for dual quaternions. (Multiply it with the real part)
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyQuat} q quaternion to transform with
 * @returns {vec3} out
 */


function transformQuat(out, a, q) {
  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3];
  var x = a[0],
      y = a[1],
      z = a[2]; // var qvec = [qx, qy, qz];
  // var uv = vec3.cross([], qvec, a);

  var uvx = qy * z - qz * y,
      uvy = qz * x - qx * z,
      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);

  var uuvx = qy * uvz - qz * uvy,
      uuvy = qz * uvx - qx * uvz,
      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);

  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2; // vec3.scale(uuv, uuv, 2);

  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));

  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */


function rotateX(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0];
  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */


function rotateY(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */


function rotateZ(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
  r[2] = p[2]; //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Get the angle between two 3D vectors
 * @param {ReadonlyVec3} a The first operand
 * @param {ReadonlyVec3} b The second operand
 * @returns {Number} The angle in radians
 */


function angle(a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      bx = b[0],
      by = b[1],
      bz = b[2],
      mag1 = Math.sqrt(ax * ax + ay * ay + az * az),
      mag2 = Math.sqrt(bx * bx + by * by + bz * bz),
      mag = mag1 * mag2,
      cosine = mag && dot(a, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
/**
 * Set the components of a vec3 to zero
 *
 * @param {vec3} out the receiving vector
 * @returns {vec3} out
 */


function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */


function str(a) {
  return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec3} a The first vector.
 * @param {ReadonlyVec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec3} a The first vector.
 * @param {ReadonlyVec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));
}
/**
 * Alias for {@link vec3.subtract}
 * @function
 */


var sub = subtract;
/**
 * Alias for {@link vec3.multiply}
 * @function
 */

exports.sub = sub;
var mul = multiply;
/**
 * Alias for {@link vec3.divide}
 * @function
 */

exports.mul = mul;
var div = divide;
/**
 * Alias for {@link vec3.distance}
 * @function
 */

exports.div = div;
var dist = distance;
/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */

exports.dist = dist;
var sqrDist = squaredDistance;
/**
 * Alias for {@link vec3.length}
 * @function
 */

exports.sqrDist = sqrDist;
var len = length;
/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */

exports.len = len;
var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

exports.sqrLen = sqrLen;

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 3;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }

    return a;
  };
}();

exports.forEach = forEach;
},{"./common.js":"node_modules/gl-matrix/esm/common.js"}],"node_modules/@deck.gl/core/dist/esm/shaderlib/project/project-functions.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getWorldPosition = getWorldPosition;
exports.projectPosition = projectPosition;

var _constants = require("../../lib/constants");

var _viewportUniforms = require("./viewport-uniforms");

var _webMercatorViewport = _interopRequireDefault(require("../../viewports/web-mercator-viewport"));

var vec4 = _interopRequireWildcard(require("gl-matrix/vec4"));

var vec3 = _interopRequireWildcard(require("gl-matrix/vec3"));

var _webMercator = require("@math.gl/web-mercator");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function lngLatZToWorldPosition(lngLatZ, viewport, offsetMode = false) {
  const p = viewport.projectPosition(lngLatZ);

  if (offsetMode && viewport instanceof _webMercatorViewport.default) {
    const [longitude, latitude, z = 0] = lngLatZ;
    const distanceScales = viewport.getDistanceScales([longitude, latitude]);
    p[2] = z * distanceScales.unitsPerMeter[2];
  }

  return p;
}

function normalizeParameters(opts) {
  const normalizedParams = { ...opts
  };
  let {
    coordinateSystem
  } = opts;
  const {
    viewport,
    coordinateOrigin,
    fromCoordinateSystem,
    fromCoordinateOrigin
  } = opts;

  if (coordinateSystem === _constants.COORDINATE_SYSTEM.DEFAULT) {
    coordinateSystem = viewport.isGeospatial ? _constants.COORDINATE_SYSTEM.LNGLAT : _constants.COORDINATE_SYSTEM.CARTESIAN;
  }

  if (fromCoordinateSystem === undefined) {
    normalizedParams.fromCoordinateSystem = coordinateSystem;
  }

  if (fromCoordinateOrigin === undefined) {
    normalizedParams.fromCoordinateOrigin = coordinateOrigin;
  }

  normalizedParams.coordinateSystem = coordinateSystem;
  return normalizedParams;
}

function getWorldPosition(position, {
  viewport,
  modelMatrix,
  coordinateSystem,
  coordinateOrigin,
  offsetMode
}) {
  let [x, y, z = 0] = position;

  if (modelMatrix) {
    [x, y, z] = vec4.transformMat4([], [x, y, z, 1.0], modelMatrix);
  }

  switch (coordinateSystem) {
    case _constants.COORDINATE_SYSTEM.LNGLAT:
      return lngLatZToWorldPosition([x, y, z], viewport, offsetMode);

    case _constants.COORDINATE_SYSTEM.LNGLAT_OFFSETS:
      return lngLatZToWorldPosition([x + coordinateOrigin[0], y + coordinateOrigin[1], z + (coordinateOrigin[2] || 0)], viewport, offsetMode);

    case _constants.COORDINATE_SYSTEM.METER_OFFSETS:
      return lngLatZToWorldPosition((0, _webMercator.addMetersToLngLat)(coordinateOrigin, [x, y, z]), viewport, offsetMode);

    case _constants.COORDINATE_SYSTEM.CARTESIAN:
    default:
      return viewport.isGeospatial ? [x + coordinateOrigin[0], y + coordinateOrigin[1], z + coordinateOrigin[2]] : viewport.projectPosition([x, y, z]);
  }
}

function projectPosition(position, params) {
  const {
    viewport,
    coordinateSystem,
    coordinateOrigin,
    modelMatrix,
    fromCoordinateSystem,
    fromCoordinateOrigin
  } = normalizeParameters(params);
  const {
    geospatialOrigin,
    shaderCoordinateOrigin,
    offsetMode
  } = (0, _viewportUniforms.getOffsetOrigin)(viewport, coordinateSystem, coordinateOrigin);
  const worldPosition = getWorldPosition(position, {
    viewport,
    modelMatrix,
    coordinateSystem: fromCoordinateSystem,
    coordinateOrigin: fromCoordinateOrigin,
    offsetMode
  });

  if (offsetMode) {
    const positionCommonSpace = viewport.projectPosition(geospatialOrigin || shaderCoordinateOrigin);
    vec3.sub(worldPosition, worldPosition, positionCommonSpace);
  }

  return worldPosition;
}
},{"../../lib/constants":"node_modules/@deck.gl/core/dist/esm/lib/constants.js","./viewport-uniforms":"node_modules/@deck.gl/core/dist/esm/shaderlib/project/viewport-uniforms.js","../../viewports/web-mercator-viewport":"node_modules/@deck.gl/core/dist/esm/viewports/web-mercator-viewport.js","gl-matrix/vec4":"node_modules/gl-matrix/esm/vec4.js","gl-matrix/vec3":"node_modules/gl-matrix/esm/vec3.js","@math.gl/web-mercator":"node_modules/@math.gl/web-mercator/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/lifecycle/constants.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LIFECYCLE = exports.COMPONENT_SYMBOL = exports.ASYNC_RESOLVED_SYMBOL = exports.ASYNC_ORIGINAL_SYMBOL = exports.ASYNC_DEFAULTS_SYMBOL = void 0;
const LIFECYCLE = {
  NO_STATE: 'Awaiting state',
  MATCHED: 'Matched. State transferred from previous layer',
  INITIALIZED: 'Initialized',
  AWAITING_GC: 'Discarded. Awaiting garbage collection',
  AWAITING_FINALIZATION: 'No longer matched. Awaiting garbage collection',
  FINALIZED: 'Finalized! Awaiting garbage collection'
};
exports.LIFECYCLE = LIFECYCLE;
const COMPONENT_SYMBOL = Symbol.for('component');
exports.COMPONENT_SYMBOL = COMPONENT_SYMBOL;
const ASYNC_DEFAULTS_SYMBOL = Symbol.for('asyncPropDefaults');
exports.ASYNC_DEFAULTS_SYMBOL = ASYNC_DEFAULTS_SYMBOL;
const ASYNC_ORIGINAL_SYMBOL = Symbol.for('asyncPropOriginal');
exports.ASYNC_ORIGINAL_SYMBOL = ASYNC_ORIGINAL_SYMBOL;
const ASYNC_RESOLVED_SYMBOL = Symbol.for('asyncPropResolved');
exports.ASYNC_RESOLVED_SYMBOL = ASYNC_RESOLVED_SYMBOL;
},{}],"node_modules/@deck.gl/core/dist/esm/utils/flatten.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fillArray = fillArray;
exports.flatten = flatten;

function flatten(array, filter = () => true) {
  if (!Array.isArray(array)) {
    return filter(array) ? [array] : [];
  }

  return flattenArray(array, filter, []);
}

function flattenArray(array, filter, result) {
  let index = -1;

  while (++index < array.length) {
    const value = array[index];

    if (Array.isArray(value)) {
      flattenArray(value, filter, result);
    } else if (filter(value)) {
      result.push(value);
    }
  }

  return result;
}

function fillArray({
  target,
  source,
  start = 0,
  count = 1
}) {
  const length = source.length;
  const total = count * length;
  let copied = 0;

  for (let i = start; copied < length; copied++) {
    target[i++] = source[copied];
  }

  while (copied < total) {
    if (copied < total - copied) {
      target.copyWithin(start + copied, start, start + copied);
      copied *= 2;
    } else {
      target.copyWithin(start + copied, start, start + total - copied);
      copied = total;
    }
  }

  return target;
}
},{}],"node_modules/@deck.gl/core/dist/esm/lib/resource/resource.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _core = require("@loaders.gl/core");

class Resource {
  constructor(id, data, context) {
    this.id = id;
    this.context = context;
    this._loadCount = 0;
    this._subscribers = new Set();
    this.setData(data);
  }

  subscribe(consumer) {
    this._subscribers.add(consumer);
  }

  unsubscribe(consumer) {
    this._subscribers.delete(consumer);
  }

  inUse() {
    return this._subscribers.size > 0;
  }

  delete() {}

  getData() {
    return this.isLoaded ? this._error ? Promise.reject(this._error) : this._content : this._loader.then(() => this.getData());
  }

  setData(data, forceUpdate) {
    if (data === this._data && !forceUpdate) {
      return;
    }

    this._data = data;
    const loadCount = ++this._loadCount;
    let loader = data;

    if (typeof data === 'string') {
      loader = (0, _core.load)(data);
    }

    if (loader instanceof Promise) {
      this.isLoaded = false;
      this._loader = loader.then(result => {
        if (this._loadCount === loadCount) {
          this.isLoaded = true;
          this._error = null;
          this._content = result;
        }
      }).catch(error => {
        if (this._loadCount === loadCount) {
          this.isLoaded = true;
          this._error = error || true;
        }
      });
    } else {
      this.isLoaded = true;
      this._error = null;
      this._content = data;
    }

    for (const subscriber of this._subscribers) {
      subscriber.onChange(this.getData());
    }
  }

}

exports.default = Resource;
},{"@loaders.gl/core":"node_modules/@loaders.gl/core/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/lib/resource/resource-manager.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _resource = _interopRequireDefault(require("./resource"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class ResourceManager {
  constructor({
    gl,
    protocol
  }) {
    this.protocol = protocol || 'resource://';
    this._context = {
      gl,
      resourceManager: this
    };
    this._resources = {};
    this._consumers = {};
    this._pruneRequest = null;
  }

  contains(resourceId) {
    if (resourceId.startsWith(this.protocol)) {
      return true;
    }

    return resourceId in this._resources;
  }

  add({
    resourceId,
    data,
    forceUpdate = false,
    persistent = true
  }) {
    let res = this._resources[resourceId];

    if (res) {
      res.setData(data, forceUpdate);
    } else {
      res = new _resource.default(resourceId, data, this._context);
      this._resources[resourceId] = res;
    }

    res.persistent = persistent;
  }

  remove(resourceId) {
    const res = this._resources[resourceId];

    if (res) {
      res.delete();
      delete this._resources[resourceId];
    }
  }

  unsubscribe({
    consumerId
  }) {
    const consumer = this._consumers[consumerId];

    if (consumer) {
      for (const requestId in consumer) {
        const request = consumer[requestId];

        if (request.resource) {
          request.resource.unsubscribe(request);
        }
      }

      delete this._consumers[consumerId];
      this.prune();
    }
  }

  subscribe({
    resourceId,
    onChange,
    consumerId,
    requestId = 'default'
  }) {
    const {
      _resources: resources,
      protocol
    } = this;

    if (resourceId.startsWith(protocol)) {
      resourceId = resourceId.replace(protocol, '');

      if (!resources[resourceId]) {
        this.add({
          resourceId,
          data: null,
          persistent: false
        });
      }
    }

    const res = resources[resourceId];

    this._track(consumerId, requestId, res, onChange);

    if (res) {
      return res.getData();
    }

    return undefined;
  }

  prune() {
    if (!this._pruneRequest) {
      this._pruneRequest = setTimeout(() => this._prune(), 0);
    }
  }

  finalize() {
    for (const key in this._resources) {
      this._resources[key].delete();
    }
  }

  _track(consumerId, requestId, resource, onChange) {
    const consumers = this._consumers;
    const consumer = consumers[consumerId] = consumers[consumerId] || {};
    const request = consumer[requestId] || {};

    if (request.resource) {
      request.resource.unsubscribe(request);
      request.resource = null;
      this.prune();
    }

    if (resource) {
      consumer[requestId] = request;
      request.onChange = onChange;
      request.resource = resource;
      resource.subscribe(request);
    }
  }

  _prune() {
    this._pruneRequest = null;

    for (const key of Object.keys(this._resources)) {
      const res = this._resources[key];

      if (!res.persistent && !res.inUse()) {
        res.delete();
        delete this._resources[key];
      }
    }
  }

}

exports.default = ResourceManager;
},{"./resource":"node_modules/@deck.gl/core/dist/esm/lib/resource/resource.js"}],"node_modules/@deck.gl/core/dist/esm/lib/layer-manager.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _core = require("@luma.gl/core");

var _constants = require("../lifecycle/constants");

var _log = _interopRequireDefault(require("../utils/log"));

var _debug = _interopRequireDefault(require("../debug"));

var _flatten = require("../utils/flatten");

var _stats = require("@probe.gl/stats");

var _resourceManager = _interopRequireDefault(require("./resource/resource-manager"));

var _viewport = _interopRequireDefault(require("../viewports/viewport"));

var _shaderlib = require("../shaderlib");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const TRACE_SET_LAYERS = 'layerManager.setLayers';
const TRACE_ACTIVATE_VIEWPORT = 'layerManager.activateViewport';
const INITIAL_CONTEXT = Object.seal({
  layerManager: null,
  resourceManager: null,
  deck: null,
  gl: null,
  stats: null,
  shaderCache: null,
  pickingFBO: null,
  mousePosition: null,
  userData: {}
});

class LayerManager {
  constructor(gl, {
    deck,
    stats,
    viewport,
    timeline
  } = {}) {
    this.lastRenderedLayers = [];
    this.layers = [];
    this.resourceManager = new _resourceManager.default({
      gl,
      protocol: 'deck://'
    });
    this.context = { ...INITIAL_CONTEXT,
      layerManager: this,
      gl,
      deck,
      programManager: gl && (0, _shaderlib.createProgramManager)(gl),
      stats: stats || new _stats.Stats({
        id: 'deck.gl'
      }),
      viewport: viewport || new _viewport.default({
        id: 'DEFAULT-INITIAL-VIEWPORT'
      }),
      timeline: timeline || new _core.Timeline(),
      resourceManager: this.resourceManager
    };
    this._nextLayers = null;
    this._needsRedraw = 'Initial render';
    this._needsUpdate = false;
    this._debug = false;
    this.activateViewport = this.activateViewport.bind(this);
    Object.seal(this);
  }

  finalize() {
    this.resourceManager.finalize();

    for (const layer of this.layers) {
      this._finalizeLayer(layer);
    }
  }

  needsRedraw(opts = {
    clearRedrawFlags: false
  }) {
    let redraw = this._needsRedraw;

    if (opts.clearRedrawFlags) {
      this._needsRedraw = false;
    }

    for (const layer of this.layers) {
      const layerNeedsRedraw = layer.getNeedsRedraw(opts);
      redraw = redraw || layerNeedsRedraw;
    }

    return redraw;
  }

  needsUpdate() {
    if (this._nextLayers && this._nextLayers !== this.lastRenderedLayers) {
      return 'layers changed';
    }

    return this._needsUpdate;
  }

  setNeedsRedraw(reason) {
    this._needsRedraw = this._needsRedraw || reason;
  }

  setNeedsUpdate(reason) {
    this._needsUpdate = this._needsUpdate || reason;
  }

  getLayers({
    layerIds = null
  } = {}) {
    return layerIds ? this.layers.filter(layer => layerIds.find(layerId => layer.id.indexOf(layerId) === 0)) : this.layers;
  }

  setProps(props) {
    if ('debug' in props) {
      this._debug = props.debug;
    }

    if ('userData' in props) {
      this.context.userData = props.userData;
    }

    if ('layers' in props) {
      this._nextLayers = props.layers;
    }

    if ('onError' in props) {
      this.context.onError = props.onError;
    }
  }

  setLayers(newLayers, reason) {
    (0, _debug.default)(TRACE_SET_LAYERS, this, reason, newLayers);
    this.lastRenderedLayers = newLayers;
    newLayers = (0, _flatten.flatten)(newLayers, Boolean);

    for (const layer of newLayers) {
      layer.context = this.context;
    }

    this._updateLayers(this.layers, newLayers);

    return this;
  }

  updateLayers() {
    const reason = this.needsUpdate();

    if (reason) {
      this.setNeedsRedraw("updating layers: ".concat(reason));
      this.setLayers(this._nextLayers || this.lastRenderedLayers, reason);
    }

    this._nextLayers = null;
  }

  activateViewport(viewport) {
    (0, _debug.default)(TRACE_ACTIVATE_VIEWPORT, this, viewport);

    if (viewport) {
      this.context.viewport = viewport;
    }

    return this;
  }

  _handleError(stage, error, layer) {
    layer.raiseError(error, "".concat(stage, " of ").concat(layer));
  }

  _updateLayers(oldLayers, newLayers) {
    const oldLayerMap = {};

    for (const oldLayer of oldLayers) {
      if (oldLayerMap[oldLayer.id]) {
        _log.default.warn("Multiple old layers with same id ".concat(oldLayer.id))();
      } else {
        oldLayerMap[oldLayer.id] = oldLayer;
      }
    }

    const generatedLayers = [];

    this._updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers);

    this._finalizeOldLayers(oldLayerMap);

    let needsUpdate = false;

    for (const layer of generatedLayers) {
      if (layer.hasUniformTransition()) {
        needsUpdate = true;
        break;
      }
    }

    this._needsUpdate = needsUpdate;
    this.layers = generatedLayers;
  }

  _updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers) {
    for (const newLayer of newLayers) {
      newLayer.context = this.context;
      const oldLayer = oldLayerMap[newLayer.id];

      if (oldLayer === null) {
        _log.default.warn("Multiple new layers with same id ".concat(newLayer.id))();
      }

      oldLayerMap[newLayer.id] = null;
      let sublayers = null;

      try {
        if (this._debug && oldLayer !== newLayer) {
          newLayer.validateProps();
        }

        if (!oldLayer) {
          this._initializeLayer(newLayer);
        } else {
          this._transferLayerState(oldLayer, newLayer);

          this._updateLayer(newLayer);
        }

        generatedLayers.push(newLayer);
        sublayers = newLayer.isComposite && newLayer.getSubLayers();
      } catch (err) {
        this._handleError('matching', err, newLayer);
      }

      if (sublayers) {
        this._updateSublayersRecursively(sublayers, oldLayerMap, generatedLayers);
      }
    }
  }

  _finalizeOldLayers(oldLayerMap) {
    for (const layerId in oldLayerMap) {
      const layer = oldLayerMap[layerId];

      if (layer) {
        this._finalizeLayer(layer);
      }
    }
  }

  _initializeLayer(layer) {
    try {
      layer._initialize();

      layer.lifecycle = _constants.LIFECYCLE.INITIALIZED;
    } catch (err) {
      this._handleError('initialization', err, layer);
    }
  }

  _transferLayerState(oldLayer, newLayer) {
    newLayer._transferState(oldLayer);

    newLayer.lifecycle = _constants.LIFECYCLE.MATCHED;

    if (newLayer !== oldLayer) {
      oldLayer.lifecycle = _constants.LIFECYCLE.AWAITING_GC;
    }
  }

  _updateLayer(layer) {
    try {
      layer._update();
    } catch (err) {
      this._handleError('update', err, layer);
    }
  }

  _finalizeLayer(layer) {
    this._needsRedraw = this._needsRedraw || "finalized ".concat(layer);
    layer.lifecycle = _constants.LIFECYCLE.AWAITING_FINALIZATION;

    try {
      layer._finalize();

      layer.lifecycle = _constants.LIFECYCLE.FINALIZED;
    } catch (err) {
      this._handleError('finalization', err, layer);
    }
  }

}

exports.default = LayerManager;
},{"@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","../lifecycle/constants":"node_modules/@deck.gl/core/dist/esm/lifecycle/constants.js","../utils/log":"node_modules/@deck.gl/core/dist/esm/utils/log.js","../debug":"node_modules/@deck.gl/core/dist/esm/debug/index.js","../utils/flatten":"node_modules/@deck.gl/core/dist/esm/utils/flatten.js","@probe.gl/stats":"node_modules/@probe.gl/stats/dist/esm/index.js","./resource/resource-manager":"node_modules/@deck.gl/core/dist/esm/lib/resource/resource-manager.js","../viewports/viewport":"node_modules/@deck.gl/core/dist/esm/viewports/viewport.js","../shaderlib":"node_modules/@deck.gl/core/dist/esm/shaderlib/index.js"}],"node_modules/@deck.gl/core/dist/esm/utils/deep-equal.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deepEqual = deepEqual;

function deepEqual(a, b) {
  if (a === b) {
    return true;
  }

  if (!a || !b) {
    return false;
  }

  for (const key in a) {
    const aValue = a[key];
    const bValue = b[key];
    const equals = aValue === bValue || Array.isArray(aValue) && Array.isArray(bValue) && deepEqual(aValue, bValue);

    if (!equals) {
      return false;
    }
  }

  return true;
}
},{}],"node_modules/@deck.gl/core/dist/esm/lib/view-manager.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _deepEqual = require("../utils/deep-equal");

var _log = _interopRequireDefault(require("../utils/log"));

var _flatten = require("../utils/flatten");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class ViewManager {
  constructor(props = {}) {
    this.views = [];
    this.width = 100;
    this.height = 100;
    this.viewState = {};
    this.controllers = {};
    this.timeline = props.timeline;
    this._viewports = [];
    this._viewportMap = {};
    this._isUpdating = false;
    this._needsRedraw = 'Initial render';
    this._needsUpdate = true;
    this._eventManager = props.eventManager;
    this._eventCallbacks = {
      onViewStateChange: props.onViewStateChange,
      onInteractionStateChange: props.onInteractionStateChange
    };
    Object.seal(this);
    this.setProps(props);
  }

  finalize() {
    for (const key in this.controllers) {
      if (this.controllers[key]) {
        this.controllers[key].finalize();
      }
    }

    this.controllers = {};
  }

  needsRedraw(opts = {
    clearRedrawFlags: false
  }) {
    const redraw = this._needsRedraw;

    if (opts.clearRedrawFlags) {
      this._needsRedraw = false;
    }

    return redraw;
  }

  setNeedsUpdate(reason) {
    this._needsUpdate = this._needsUpdate || reason;
    this._needsRedraw = this._needsRedraw || reason;
  }

  updateViewStates() {
    for (const viewId in this.controllers) {
      const controller = this.controllers[viewId];

      if (controller) {
        controller.updateTransition();
      }
    }
  }

  getViewports(rect) {
    if (rect) {
      return this._viewports.filter(viewport => viewport.containsPixel(rect));
    }

    return this._viewports;
  }

  getViews() {
    const viewMap = {};
    this.views.forEach(view => {
      viewMap[view.id] = view;
    });
    return viewMap;
  }

  getView(viewOrViewId) {
    return typeof viewOrViewId === 'string' ? this.views.find(view => view.id === viewOrViewId) : viewOrViewId;
  }

  getViewState(viewId) {
    const view = this.getView(viewId);
    const viewState = view && this.viewState[view.getViewStateId()] || this.viewState;
    return view ? view.filterViewState(viewState) : viewState;
  }

  getViewport(viewId) {
    return this._viewportMap[viewId];
  }

  unproject(xyz, opts) {
    const viewports = this.getViewports();
    const pixel = {
      x: xyz[0],
      y: xyz[1]
    };

    for (let i = viewports.length - 1; i >= 0; --i) {
      const viewport = viewports[i];

      if (viewport.containsPixel(pixel)) {
        const p = xyz.slice();
        p[0] -= viewport.x;
        p[1] -= viewport.y;
        return viewport.unproject(p, opts);
      }
    }

    return null;
  }

  setProps(props) {
    if ('views' in props) {
      this._setViews(props.views);
    }

    if ('viewState' in props) {
      this._setViewState(props.viewState);
    }

    if ('width' in props || 'height' in props) {
      this._setSize(props.width, props.height);
    }

    if (!this._isUpdating) {
      this._update();
    }
  }

  _update() {
    this._isUpdating = true;

    if (this._needsUpdate) {
      this._needsUpdate = false;

      this._rebuildViewports();
    }

    if (this._needsUpdate) {
      this._needsUpdate = false;

      this._rebuildViewports();
    }

    this._isUpdating = false;
  }

  _setSize(width, height) {
    if (width !== this.width || height !== this.height) {
      this.width = width;
      this.height = height;
      this.setNeedsUpdate('Size changed');
    }
  }

  _setViews(views) {
    views = (0, _flatten.flatten)(views, Boolean);

    const viewsChanged = this._diffViews(views, this.views);

    if (viewsChanged) {
      this.setNeedsUpdate('views changed');
    }

    this.views = views;
  }

  _setViewState(viewState) {
    if (viewState) {
      const viewStateChanged = !(0, _deepEqual.deepEqual)(viewState, this.viewState);

      if (viewStateChanged) {
        this.setNeedsUpdate('viewState changed');
      }

      this.viewState = viewState;
    } else {
      _log.default.warn('missing `viewState` or `initialViewState`')();
    }
  }

  _onViewStateChange(viewId, event) {
    event.viewId = viewId;

    if (this._eventCallbacks.onViewStateChange) {
      this._eventCallbacks.onViewStateChange(event);
    }
  }

  _createController(view, props) {
    const Controller = props.type;
    const controller = new Controller({
      timeline: this.timeline,
      eventManager: this._eventManager,
      onViewStateChange: this._onViewStateChange.bind(this, props.id),
      onStateChange: this._eventCallbacks.onInteractionStateChange,
      makeViewport: viewState => view._getViewport(viewState, {
        width: viewState.width,
        height: viewState.height
      }),
      ...props
    });
    return controller;
  }

  _updateController(view, viewState, viewport, controller) {
    let controllerProps = view.controller;

    if (controllerProps) {
      controllerProps = { ...viewState,
        ...view.props,
        ...controllerProps,
        id: view.id,
        x: viewport.x,
        y: viewport.y,
        width: viewport.width,
        height: viewport.height
      };

      if (controller) {
        controller.setProps(controllerProps);
      } else {
        controller = this._createController(view, controllerProps);
      }

      return controller;
    }

    return null;
  }

  _rebuildViewports() {
    const {
      width,
      height,
      views
    } = this;
    const oldControllers = this.controllers;
    this._viewports = [];
    this.controllers = {};
    let invalidateControllers = false;

    for (let i = views.length; i--;) {
      const view = views[i];
      const viewState = this.getViewState(view);
      const viewport = view.makeViewport({
        width,
        height,
        viewState
      });
      let oldController = oldControllers[view.id];

      if (view.controller && !oldController) {
        invalidateControllers = true;
      }

      if ((invalidateControllers || !view.controller) && oldController) {
        oldController.finalize();
        oldController = null;
      }

      this.controllers[view.id] = this._updateController(view, viewState, viewport, oldController);

      this._viewports.unshift(viewport);
    }

    for (const id in oldControllers) {
      if (oldControllers[id] && !this.controllers[id]) {
        oldControllers[id].finalize();
      }
    }

    this._buildViewportMap();
  }

  _buildViewportMap() {
    this._viewportMap = {};

    this._viewports.forEach(viewport => {
      if (viewport.id) {
        this._viewportMap[viewport.id] = this._viewportMap[viewport.id] || viewport;
      }
    });
  }

  _diffViews(newViews, oldViews) {
    if (newViews.length !== oldViews.length) {
      return true;
    }

    return newViews.some((_, i) => !newViews[i].equals(oldViews[i]));
  }

}

exports.default = ViewManager;
},{"../utils/deep-equal":"node_modules/@deck.gl/core/dist/esm/utils/deep-equal.js","../utils/log":"node_modules/@deck.gl/core/dist/esm/utils/log.js","../utils/flatten":"node_modules/@deck.gl/core/dist/esm/utils/flatten.js"}],"node_modules/@deck.gl/core/dist/esm/utils/positions.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPosition = getPosition;
exports.parsePosition = parsePosition;
const PERCENT_OR_PIXELS_REGEX = /([0-9]+\.?[0-9]*)(%|px)/;

function parsePosition(value) {
  switch (typeof value) {
    case 'number':
      return {
        position: value,
        relative: false
      };

    case 'string':
      const match = PERCENT_OR_PIXELS_REGEX.exec(value);

      if (match && match.length >= 3) {
        const relative = match[2] === '%';
        const position = parseFloat(match[1]);
        return {
          position: relative ? position / 100 : position,
          relative
        };
      }

    default:
      throw new Error("Could not parse position string ".concat(value));
  }
}

function getPosition(position, extent) {
  return position.relative ? Math.round(position.position * extent) : position.position;
}
},{}],"node_modules/@deck.gl/core/dist/esm/utils/assert.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = assert;

function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'deck.gl: assertion failed.');
  }
}
},{}],"node_modules/@deck.gl/core/dist/esm/views/view.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _viewport = _interopRequireDefault(require("../viewports/viewport"));

var _positions = require("../utils/positions");

var _deepEqual = require("../utils/deep-equal");

var _assert = _interopRequireDefault(require("../utils/assert"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class View {
  constructor(props = {}) {
    const {
      id = null,
      x = 0,
      y = 0,
      width = '100%',
      height = '100%',
      viewportInstance,
      type = _viewport.default
    } = props;
    (0, _assert.default)(!viewportInstance || viewportInstance instanceof _viewport.default);
    this.viewportInstance = viewportInstance;
    this.id = id || this.constructor.displayName || 'view';
    this.type = type;
    this.props = { ...props,
      id: this.id
    };

    this._parseDimensions({
      x,
      y,
      width,
      height
    });

    this.equals = this.equals.bind(this);
    Object.seal(this);
  }

  equals(view) {
    if (this === view) {
      return true;
    }

    if (this.viewportInstance) {
      return view.viewportInstance && this.viewportInstance.equals(view.viewportInstance);
    }

    const viewChanged = (0, _deepEqual.deepEqual)(this.props, view.props);
    return viewChanged;
  }

  makeViewport({
    width,
    height,
    viewState
  }) {
    if (this.viewportInstance) {
      return this.viewportInstance;
    }

    viewState = this.filterViewState(viewState);
    const viewportDimensions = this.getDimensions({
      width,
      height
    });
    return this._getViewport(viewState, viewportDimensions);
  }

  getViewStateId() {
    switch (typeof this.props.viewState) {
      case 'string':
        return this.props.viewState;

      case 'object':
        return this.props.viewState && this.props.viewState.id;

      default:
        return this.id;
    }
  }

  filterViewState(viewState) {
    if (this.props.viewState && typeof this.props.viewState === 'object') {
      if (!this.props.viewState.id) {
        return this.props.viewState;
      }

      const newViewState = { ...viewState
      };

      for (const key in this.props.viewState) {
        if (key !== 'id') {
          newViewState[key] = this.props.viewState[key];
        }
      }

      return newViewState;
    }

    return viewState;
  }

  getDimensions({
    width,
    height
  }) {
    return {
      x: (0, _positions.getPosition)(this._x, width),
      y: (0, _positions.getPosition)(this._y, height),
      width: (0, _positions.getPosition)(this._width, width),
      height: (0, _positions.getPosition)(this._height, height)
    };
  }

  _getControllerProps(defaultOpts) {
    let opts = this.props.controller;

    if (!opts) {
      return null;
    }

    if (opts === true) {
      return defaultOpts;
    }

    if (typeof opts === 'function') {
      opts = {
        type: opts
      };
    }

    return { ...defaultOpts,
      ...opts
    };
  }

  _getViewport(viewState, viewportDimensions) {
    const {
      type: ViewportType
    } = this;
    return new ViewportType({ ...viewState,
      ...this.props,
      ...viewportDimensions
    });
  }

  _parseDimensions({
    x,
    y,
    width,
    height
  }) {
    this._x = (0, _positions.parsePosition)(x);
    this._y = (0, _positions.parsePosition)(y);
    this._width = (0, _positions.parsePosition)(width);
    this._height = (0, _positions.parsePosition)(height);
  }

}

exports.default = View;
},{"../viewports/viewport":"node_modules/@deck.gl/core/dist/esm/viewports/viewport.js","../utils/positions":"node_modules/@deck.gl/core/dist/esm/utils/positions.js","../utils/deep-equal":"node_modules/@deck.gl/core/dist/esm/utils/deep-equal.js","../utils/assert":"node_modules/@deck.gl/core/dist/esm/utils/assert.js"}],"node_modules/@deck.gl/core/dist/esm/transitions/transition.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function noop() {}

const DEFAULT_SETTINGS = {
  onStart: noop,
  onUpdate: noop,
  onInterrupt: noop,
  onEnd: noop
};

class Transition {
  constructor(timeline) {
    this._inProgress = false;
    this._handle = null;
    this.timeline = timeline;
    this.settings = {};
  }

  get inProgress() {
    return this._inProgress;
  }

  start(props) {
    this.cancel();
    this.settings = { ...DEFAULT_SETTINGS,
      ...props
    };
    this._inProgress = true;
    this.settings.onStart(this);
  }

  end() {
    if (this._inProgress) {
      this.timeline.removeChannel(this._handle);
      this._handle = null;
      this._inProgress = false;
      this.settings.onEnd(this);
    }
  }

  cancel() {
    if (this._inProgress) {
      this.settings.onInterrupt(this);
      this.timeline.removeChannel(this._handle);
      this._handle = null;
      this._inProgress = false;
    }
  }

  update() {
    if (!this._inProgress) {
      return false;
    }

    if (this._handle === null) {
      const {
        timeline,
        settings
      } = this;
      this._handle = timeline.addChannel({
        delay: timeline.getTime(),
        duration: settings.duration
      });
    }

    this.time = this.timeline.getTime(this._handle);

    this._onUpdate();

    this.settings.onUpdate(this);

    if (this.timeline.isFinished(this._handle)) {
      this.end();
    }

    return true;
  }

  _onUpdate() {}

}

exports.default = Transition;
},{}],"node_modules/@deck.gl/core/dist/esm/controllers/transition-manager.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.TRANSITION_EVENTS = void 0;

var _transition = _interopRequireDefault(require("../transitions/transition"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const noop = () => {};

const TRANSITION_EVENTS = {
  BREAK: 1,
  SNAP_TO_END: 2,
  IGNORE: 3
};
exports.TRANSITION_EVENTS = TRANSITION_EVENTS;
const DEFAULT_PROPS = {
  transitionEasing: t => t,
  transitionInterruption: TRANSITION_EVENTS.BREAK,
  onTransitionStart: noop,
  onTransitionInterrupt: noop,
  onTransitionEnd: noop
};

class TransitionManager {
  constructor(ControllerState, props = {}) {
    this.ControllerState = ControllerState;
    this.props = { ...DEFAULT_PROPS,
      ...props
    };
    this.propsInTransition = null;
    this.transition = new _transition.default(props.timeline);
    this.onViewStateChange = props.onViewStateChange || noop;
    this.onStateChange = props.onStateChange || noop;
    this._onTransitionUpdate = this._onTransitionUpdate.bind(this);
  }

  finalize() {
    this.transition.cancel();
  }

  getViewportInTransition() {
    return this.propsInTransition;
  }

  processViewStateChange(nextProps) {
    let transitionTriggered = false;
    const currentProps = this.props;
    nextProps = { ...DEFAULT_PROPS,
      ...nextProps
    };
    this.props = nextProps;

    if (this._shouldIgnoreViewportChange(currentProps, nextProps)) {
      return transitionTriggered;
    }

    if (this._isTransitionEnabled(nextProps)) {
      const {
        interruption,
        endProps
      } = this.transition.settings;
      const startProps = { ...currentProps,
        ...(interruption === TRANSITION_EVENTS.SNAP_TO_END ? endProps : this.propsInTransition || currentProps)
      };

      this._triggerTransition(startProps, nextProps);

      transitionTriggered = true;
    } else {
      this.transition.cancel();
    }

    return transitionTriggered;
  }

  updateTransition() {
    this.transition.update();
  }

  _isTransitionEnabled(props) {
    const {
      transitionDuration,
      transitionInterpolator
    } = props;
    return (transitionDuration > 0 || transitionDuration === 'auto') && Boolean(transitionInterpolator);
  }

  _isUpdateDueToCurrentTransition(props) {
    if (this.transition.inProgress) {
      return this.transition.settings.interpolator.arePropsEqual(props, this.propsInTransition);
    }

    return false;
  }

  _shouldIgnoreViewportChange(currentProps, nextProps) {
    if (this.transition.inProgress) {
      return this.transition.settings.interruption === TRANSITION_EVENTS.IGNORE || this._isUpdateDueToCurrentTransition(nextProps);
    } else if (this._isTransitionEnabled(nextProps)) {
      return nextProps.transitionInterpolator.arePropsEqual(currentProps, nextProps);
    }

    return true;
  }

  _triggerTransition(startProps, endProps) {
    const startViewstate = new this.ControllerState(startProps);
    const endViewStateProps = new this.ControllerState(endProps).shortestPathFrom(startViewstate);
    const {
      transitionInterpolator
    } = endProps;
    const duration = transitionInterpolator.getDuration ? transitionInterpolator.getDuration(startProps, endProps) : endProps.transitionDuration;

    if (duration === 0) {
      return;
    }

    const initialProps = endProps.transitionInterpolator.initializeProps(startProps, endViewStateProps);
    this.propsInTransition = {};
    this.duration = duration;
    this.transition.start({
      duration,
      easing: endProps.transitionEasing,
      interpolator: endProps.transitionInterpolator,
      interruption: endProps.transitionInterruption,
      startProps: initialProps.start,
      endProps: initialProps.end,
      onStart: endProps.onTransitionStart,
      onUpdate: this._onTransitionUpdate,
      onInterrupt: this._onTransitionEnd(endProps.onTransitionInterrupt),
      onEnd: this._onTransitionEnd(endProps.onTransitionEnd)
    });
    this.onStateChange({
      inTransition: true
    });
    this.updateTransition();
  }

  _onTransitionEnd(callback) {
    return transition => {
      this.propsInTransition = null;
      this.onStateChange({
        inTransition: false,
        isZooming: false,
        isPanning: false,
        isRotating: false
      });
      callback(transition);
    };
  }

  _onTransitionUpdate(transition) {
    const {
      time,
      settings: {
        interpolator,
        startProps,
        endProps,
        duration,
        easing
      }
    } = transition;
    const t = easing(time / duration);
    const viewport = interpolator.interpolateProps(startProps, endProps, t);
    this.propsInTransition = new this.ControllerState({ ...this.props,
      ...viewport
    }).getViewportProps();
    this.onViewStateChange({
      viewState: this.propsInTransition,
      oldViewState: this.props
    });
  }

}

exports.default = TransitionManager;
},{"../transitions/transition":"node_modules/@deck.gl/core/dist/esm/transitions/transition.js"}],"node_modules/@deck.gl/core/dist/esm/transitions/transition-interpolator.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _core = require("@math.gl/core");

var _assert = _interopRequireDefault(require("../utils/assert"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class TransitionInterpolator {
  constructor(opts = {}) {
    if (Array.isArray(opts)) {
      opts = {
        compare: opts,
        extract: opts,
        required: opts
      };
    }

    const {
      compare,
      extract,
      required
    } = opts;
    this._propsToCompare = compare;
    this._propsToExtract = extract;
    this._requiredProps = required;
  }

  arePropsEqual(currentProps, nextProps) {
    for (const key of this._propsToCompare || Object.keys(nextProps)) {
      if (!(key in currentProps) || !(key in nextProps) || !(0, _core.equals)(currentProps[key], nextProps[key])) {
        return false;
      }
    }

    return true;
  }

  initializeProps(startProps, endProps) {
    let result;

    if (this._propsToExtract) {
      const startViewStateProps = {};
      const endViewStateProps = {};

      for (const key of this._propsToExtract) {
        startViewStateProps[key] = startProps[key];
        endViewStateProps[key] = endProps[key];
      }

      result = {
        start: startViewStateProps,
        end: endViewStateProps
      };
    } else {
      result = {
        start: startProps,
        end: endProps
      };
    }

    this._checkRequiredProps(result.start);

    this._checkRequiredProps(result.end);

    return result;
  }

  interpolateProps(startProps, endProps, t) {
    return endProps;
  }

  getDuration(startProps, endProps) {
    return endProps.transitionDuration;
  }

  _checkRequiredProps(props) {
    if (!this._requiredProps) {
      return;
    }

    this._requiredProps.forEach(propName => {
      const value = props[propName];
      (0, _assert.default)(Number.isFinite(value) || Array.isArray(value), "".concat(propName, " is required for transition"));
    });
  }

}

exports.default = TransitionInterpolator;
},{"@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js","../utils/assert":"node_modules/@deck.gl/core/dist/esm/utils/assert.js"}],"node_modules/@deck.gl/core/dist/esm/transitions/linear-interpolator.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _transitionInterpolator = _interopRequireDefault(require("./transition-interpolator"));

var _core = require("@math.gl/core");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const DEFAULT_PROPS = ['longitude', 'latitude', 'zoom', 'bearing', 'pitch'];
const DEFAULT_REQUIRED_PROPS = ['longitude', 'latitude', 'zoom'];

class LinearInterpolator extends _transitionInterpolator.default {
  constructor(opts = {}) {
    const transitionProps = Array.isArray(opts) ? opts : opts.transitionProps;
    super(transitionProps || {
      compare: DEFAULT_PROPS,
      extract: DEFAULT_PROPS,
      required: DEFAULT_REQUIRED_PROPS
    });
    this.opts = opts;
  }

  initializeProps(startProps, endProps) {
    const result = super.initializeProps(startProps, endProps);
    const {
      makeViewport,
      around
    } = this.opts;

    if (makeViewport && around) {
      const startViewport = makeViewport(startProps);
      const endViewport = makeViewport(endProps);
      const aroundPosition = startViewport.unproject(around);
      result.start.around = around;
      Object.assign(result.end, {
        around: endViewport.project(aroundPosition),
        aroundPosition,
        width: endProps.width,
        height: endProps.height
      });
    }

    return result;
  }

  interpolateProps(startProps, endProps, t) {
    const propsInTransition = {};

    for (const key of this._propsToExtract) {
      propsInTransition[key] = (0, _core.lerp)(startProps[key] || 0, endProps[key] || 0, t);
    }

    if (endProps.aroundPosition) {
      const viewport = this.opts.makeViewport({ ...endProps,
        ...propsInTransition
      });
      Object.assign(propsInTransition, viewport.panByPosition(endProps.aroundPosition, (0, _core.lerp)(startProps.around, endProps.around, t)));
    }

    return propsInTransition;
  }

}

exports.default = LinearInterpolator;
},{"./transition-interpolator":"node_modules/@deck.gl/core/dist/esm/transitions/transition-interpolator.js","@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/controllers/controller.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));

var _transitionManager = _interopRequireWildcard(require("./transition-manager"));

var _linearInterpolator = _interopRequireDefault(require("../transitions/linear-interpolator"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const NO_TRANSITION_PROPS = {
  transitionDuration: 0
};
const LINEAR_TRANSITION_PROPS = {
  transitionDuration: 300,
  transitionEasing: t => t,
  transitionInterruption: _transitionManager.TRANSITION_EVENTS.BREAK
};
const DEFAULT_INERTIA = 300;

const INERTIA_EASING = t => 1 - (1 - t) * (1 - t);

const EVENT_TYPES = {
  WHEEL: ['wheel'],
  PAN: ['panstart', 'panmove', 'panend'],
  PINCH: ['pinchstart', 'pinchmove', 'pinchend'],
  TRIPLE_PAN: ['tripanstart', 'tripanmove', 'tripanend'],
  DOUBLE_TAP: ['doubletap'],
  KEYBOARD: ['keydown']
};

class Controller {
  constructor(ControllerState, options = {}) {
    (0, _defineProperty2.default)(this, "ControllerState", void 0);
    (0, _defineProperty2.default)(this, "controllerState", null);
    (0, _defineProperty2.default)(this, "controllerStateProps", null);
    (0, _defineProperty2.default)(this, "transitionManager", void 0);
    (0, _defineProperty2.default)(this, "_transition", void 0);
    (0, _defineProperty2.default)(this, "_events", null);
    (0, _defineProperty2.default)(this, "eventManager", null);
    (0, _defineProperty2.default)(this, "_interactionState", {
      isDragging: false
    });
    (0, _defineProperty2.default)(this, "_customEvents", []);
    (0, _defineProperty2.default)(this, "onViewStateChange", null);
    (0, _defineProperty2.default)(this, "onStateChange", null);
    (0, _defineProperty2.default)(this, "makeViewport", void 0);
    (0, _defineProperty2.default)(this, "_eventStartBlocked", void 0);
    (0, _defineProperty2.default)(this, "_state", void 0);
    (0, _defineProperty2.default)(this, "_panMove", void 0);
    (0, _defineProperty2.default)(this, "invertPan", void 0);
    (0, _defineProperty2.default)(this, "dragMode", 'rotate');
    (0, _defineProperty2.default)(this, "inertia", 0);
    (0, _defineProperty2.default)(this, "scrollZoom", true);
    (0, _defineProperty2.default)(this, "dragPan", true);
    (0, _defineProperty2.default)(this, "dragRotate", true);
    (0, _defineProperty2.default)(this, "doubleClickZoom", true);
    (0, _defineProperty2.default)(this, "touchZoom", true);
    (0, _defineProperty2.default)(this, "touchRotate", false);
    (0, _defineProperty2.default)(this, "keyboard", true);
    this.ControllerState = ControllerState;
    this.transitionManager = new _transitionManager.default(ControllerState, { ...options,
      onViewStateChange: this._onTransition.bind(this),
      onStateChange: this._setInteractionState.bind(this)
    });
    const linearTransitionProps = this.linearTransitionProps;
    this._transition = linearTransitionProps && { ...LINEAR_TRANSITION_PROPS,
      transitionInterpolator: new _linearInterpolator.default({
        transitionProps: linearTransitionProps
      })
    };
    this.handleEvent = this.handleEvent.bind(this);
    this.setProps(options);
  }

  get linearTransitionProps() {
    return null;
  }

  set events(customEvents) {
    this.toggleEvents(this._customEvents, false);
    this.toggleEvents(customEvents, true);
    this._customEvents = customEvents;
    this.setProps(this.controllerStateProps);
  }

  finalize() {
    for (const eventName in this._events) {
      if (this._events[eventName]) {
        this.eventManager.off(eventName, this.handleEvent);
      }
    }

    this.transitionManager.finalize();
  }

  handleEvent(event) {
    const {
      ControllerState
    } = this;
    this.controllerState = new ControllerState({
      makeViewport: this.makeViewport,
      ...this.controllerStateProps,
      ...this._state
    });
    const eventStartBlocked = this._eventStartBlocked;

    switch (event.type) {
      case 'panstart':
        return eventStartBlocked ? false : this._onPanStart(event);

      case 'panmove':
        return this._onPan(event);

      case 'panend':
        return this._onPanEnd(event);

      case 'pinchstart':
        return eventStartBlocked ? false : this._onPinchStart(event);

      case 'pinchmove':
        return this._onPinch(event);

      case 'pinchend':
        return this._onPinchEnd(event);

      case 'tripanstart':
        return eventStartBlocked ? false : this._onTriplePanStart(event);

      case 'tripanmove':
        return this._onTriplePan(event);

      case 'tripanend':
        return this._onTriplePanEnd(event);

      case 'doubletap':
        return this._onDoubleTap(event);

      case 'wheel':
        return this._onWheel(event);

      case 'keydown':
        return this._onKeyDown(event);

      default:
        return false;
    }
  }

  getCenter(event) {
    const {
      x,
      y
    } = this.controllerStateProps;
    const {
      offsetCenter
    } = event;
    return [offsetCenter.x - x, offsetCenter.y - y];
  }

  isPointInBounds(pos, event) {
    const {
      width,
      height
    } = this.controllerStateProps;

    if (event && event.handled) {
      return false;
    }

    const inside = pos[0] >= 0 && pos[0] <= width && pos[1] >= 0 && pos[1] <= height;

    if (inside && event) {
      event.stopPropagation();
    }

    return inside;
  }

  isFunctionKeyPressed(event) {
    const {
      srcEvent
    } = event;
    return Boolean(srcEvent.metaKey || srcEvent.altKey || srcEvent.ctrlKey || srcEvent.shiftKey);
  }

  isDragging() {
    return this._interactionState.isDragging;
  }

  blockEvents(timeout) {
    const timer = setTimeout(() => {
      if (this._eventStartBlocked === timer) {
        this._eventStartBlocked = null;
      }
    }, timeout);
    this._eventStartBlocked = timer;
  }

  setProps(props) {
    if ('onViewStateChange' in props) {
      this.onViewStateChange = props.onViewStateChange;
    }

    if ('onStateChange' in props) {
      this.onStateChange = props.onStateChange;
    }

    if ('makeViewport' in props) {
      this.makeViewport = props.makeViewport;
    }

    if ('dragMode' in props) {
      this.dragMode = props.dragMode;
    }

    this.controllerStateProps = props;

    if ('eventManager' in props && this.eventManager !== props.eventManager) {
      this.eventManager = props.eventManager;
      this._events = {};
      this.toggleEvents(this._customEvents, true);
    }

    if (!('transitionInterpolator' in props)) {
      props.transitionInterpolator = this._getTransitionProps().transitionInterpolator;
    }

    this.transitionManager.processViewStateChange(props);
    let {
      inertia
    } = props;

    if (inertia === true) {
      inertia = DEFAULT_INERTIA;
    }

    this.inertia = inertia;
    const {
      scrollZoom = true,
      dragPan = true,
      dragRotate = true,
      doubleClickZoom = true,
      touchZoom = true,
      touchRotate = false,
      keyboard = true
    } = props;
    const isInteractive = Boolean(this.onViewStateChange);
    this.toggleEvents(EVENT_TYPES.WHEEL, isInteractive && scrollZoom);
    this.toggleEvents(EVENT_TYPES.PAN, isInteractive && (dragPan || dragRotate));
    this.toggleEvents(EVENT_TYPES.PINCH, isInteractive && (touchZoom || touchRotate));
    this.toggleEvents(EVENT_TYPES.TRIPLE_PAN, isInteractive && touchRotate);
    this.toggleEvents(EVENT_TYPES.DOUBLE_TAP, isInteractive && doubleClickZoom);
    this.toggleEvents(EVENT_TYPES.KEYBOARD, isInteractive && keyboard);
    this.scrollZoom = scrollZoom;
    this.dragPan = dragPan;
    this.dragRotate = dragRotate;
    this.doubleClickZoom = doubleClickZoom;
    this.touchZoom = touchZoom;
    this.touchRotate = touchRotate;
    this.keyboard = keyboard;
  }

  updateTransition() {
    this.transitionManager.updateTransition();
  }

  toggleEvents(eventNames, enabled) {
    if (this.eventManager) {
      eventNames.forEach(eventName => {
        if (this._events[eventName] !== enabled) {
          this._events[eventName] = enabled;

          if (enabled) {
            this.eventManager.on(eventName, this.handleEvent);
          } else {
            this.eventManager.off(eventName, this.handleEvent);
          }
        }
      });
    }
  }

  updateViewport(newControllerState, extraProps = {}, interactionState = {}) {
    const viewState = { ...newControllerState.getViewportProps(),
      ...extraProps
    };
    const changed = this.controllerState !== newControllerState;
    this._state = newControllerState.getState();

    this._setInteractionState(interactionState);

    if (changed) {
      const oldViewState = this.controllerState ? this.controllerState.getViewportProps() : null;

      if (this.onViewStateChange) {
        this.onViewStateChange({
          viewState,
          interactionState: this._interactionState,
          oldViewState
        });
      }
    }
  }

  _onTransition(params) {
    if (this.onViewStateChange) {
      params.interactionState = this._interactionState;
      this.onViewStateChange(params);
    }
  }

  _setInteractionState(newStates) {
    Object.assign(this._interactionState, newStates);

    if (this.onStateChange) {
      this.onStateChange(this._interactionState);
    }
  }

  _onPanStart(event) {
    const pos = this.getCenter(event);

    if (!this.isPointInBounds(pos, event)) {
      return false;
    }

    let alternateMode = this.isFunctionKeyPressed(event) || event.rightButton;

    if (this.invertPan || this.dragMode === 'pan') {
      alternateMode = !alternateMode;
    }

    const newControllerState = this.controllerState[alternateMode ? 'panStart' : 'rotateStart']({
      pos
    });
    this._panMove = alternateMode;
    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
      isDragging: true
    });
    return true;
  }

  _onPan(event) {
    if (!this.isDragging()) {
      return false;
    }

    return this._panMove ? this._onPanMove(event) : this._onPanRotate(event);
  }

  _onPanEnd(event) {
    if (!this.isDragging()) {
      return false;
    }

    return this._panMove ? this._onPanMoveEnd(event) : this._onPanRotateEnd(event);
  }

  _onPanMove(event) {
    if (!this.dragPan) {
      return false;
    }

    const pos = this.getCenter(event);
    const newControllerState = this.controllerState.pan({
      pos
    });
    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
      isDragging: true,
      isPanning: true
    });
    return true;
  }

  _onPanMoveEnd(event) {
    const {
      inertia
    } = this;

    if (this.dragPan && inertia && event.velocity) {
      const pos = this.getCenter(event);
      const endPos = [pos[0] + event.velocityX * inertia / 2, pos[1] + event.velocityY * inertia / 2];
      const newControllerState = this.controllerState.pan({
        pos: endPos
      }).panEnd();
      this.updateViewport(newControllerState, { ...this._getTransitionProps(),
        transitionDuration: inertia,
        transitionEasing: INERTIA_EASING
      }, {
        isDragging: false,
        isPanning: true
      });
    } else {
      const newControllerState = this.controllerState.panEnd();
      this.updateViewport(newControllerState, null, {
        isDragging: false,
        isPanning: false
      });
    }

    return true;
  }

  _onPanRotate(event) {
    if (!this.dragRotate) {
      return false;
    }

    const pos = this.getCenter(event);
    const newControllerState = this.controllerState.rotate({
      pos
    });
    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
      isDragging: true,
      isRotating: true
    });
    return true;
  }

  _onPanRotateEnd(event) {
    const {
      inertia
    } = this;

    if (this.dragRotate && inertia && event.velocity) {
      const pos = this.getCenter(event);
      const endPos = [pos[0] + event.velocityX * inertia / 2, pos[1] + event.velocityY * inertia / 2];
      const newControllerState = this.controllerState.rotate({
        pos: endPos
      }).rotateEnd();
      this.updateViewport(newControllerState, { ...this._getTransitionProps(),
        transitionDuration: inertia,
        transitionEasing: INERTIA_EASING
      }, {
        isDragging: false,
        isRotating: true
      });
    } else {
      const newControllerState = this.controllerState.rotateEnd();
      this.updateViewport(newControllerState, null, {
        isDragging: false,
        isRotating: false
      });
    }

    return true;
  }

  _onWheel(event) {
    if (!this.scrollZoom) {
      return false;
    }

    event.preventDefault();
    const pos = this.getCenter(event);

    if (!this.isPointInBounds(pos, event)) {
      return false;
    }

    const {
      speed = 0.01,
      smooth = false
    } = this.scrollZoom;
    const {
      delta
    } = event;
    let scale = 2 / (1 + Math.exp(-Math.abs(delta * speed)));

    if (delta < 0 && scale !== 0) {
      scale = 1 / scale;
    }

    const newControllerState = this.controllerState.zoom({
      pos,
      scale
    });
    this.updateViewport(newControllerState, { ...this._getTransitionProps({
        around: pos
      }),
      transitionDuration: smooth ? 250 : 1
    }, {
      isZooming: true,
      isPanning: true
    });
    return true;
  }

  _onTriplePanStart(event) {
    const pos = this.getCenter(event);

    if (!this.isPointInBounds(pos, event)) {
      return false;
    }

    const newControllerState = this.controllerState.rotateStart({
      pos
    });
    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
      isDragging: true
    });
    return true;
  }

  _onTriplePan(event) {
    if (!this.touchRotate) {
      return false;
    }

    if (!this.isDragging()) {
      return false;
    }

    const pos = this.getCenter(event);
    pos[0] -= event.deltaX;
    const newControllerState = this.controllerState.rotate({
      pos
    });
    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
      isDragging: true,
      isRotating: true
    });
    return true;
  }

  _onTriplePanEnd(event) {
    if (!this.isDragging()) {
      return false;
    }

    const {
      inertia
    } = this;

    if (this.touchRotate && inertia && event.velocityY) {
      const pos = this.getCenter(event);
      const endPos = [pos[0], pos[1] += event.velocityY * inertia / 2];
      const newControllerState = this.controllerState.rotate({
        pos: endPos
      });
      this.updateViewport(newControllerState, { ...this._getTransitionProps(),
        transitionDuration: inertia,
        transitionEasing: INERTIA_EASING
      }, {
        isDragging: false,
        isRotating: true
      });
      this.blockEvents(inertia);
    } else {
      const newControllerState = this.controllerState.rotateEnd();
      this.updateViewport(newControllerState, null, {
        isDragging: false,
        isRotating: false
      });
    }

    return true;
  }

  _onPinchStart(event) {
    const pos = this.getCenter(event);

    if (!this.isPointInBounds(pos, event)) {
      return false;
    }

    const newControllerState = this.controllerState.zoomStart({
      pos
    }).rotateStart({
      pos
    });
    this._startPinchRotation = event.rotation;
    this._lastPinchEvent = event;
    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
      isDragging: true
    });
    return true;
  }

  _onPinch(event) {
    if (!this.touchZoom && !this.touchRotate) {
      return false;
    }

    if (!this.isDragging()) {
      return false;
    }

    let newControllerState = this.controllerState;

    if (this.touchZoom) {
      const {
        scale
      } = event;
      const pos = this.getCenter(event);
      newControllerState = newControllerState.zoom({
        pos,
        scale
      });
    }

    if (this.touchRotate) {
      const {
        rotation
      } = event;
      newControllerState = newControllerState.rotate({
        deltaAngleX: this._startPinchRotation - rotation
      });
    }

    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
      isDragging: true,
      isPanning: this.touchZoom,
      isZooming: this.touchZoom,
      isRotating: this.touchRotate
    });
    this._lastPinchEvent = event;
    return true;
  }

  _onPinchEnd(event) {
    if (!this.isDragging()) {
      return false;
    }

    const {
      inertia,
      _lastPinchEvent
    } = this;

    if (this.touchZoom && inertia && _lastPinchEvent && event.scale !== _lastPinchEvent.scale) {
      const pos = this.getCenter(event);
      let newControllerState = this.controllerState.rotateEnd();
      const z = Math.log2(event.scale);

      const velocityZ = (z - Math.log2(_lastPinchEvent.scale)) / (event.deltaTime - _lastPinchEvent.deltaTime);

      const endScale = Math.pow(2, z + velocityZ * inertia / 2);
      newControllerState = newControllerState.zoom({
        pos,
        scale: endScale
      }).zoomEnd();
      this.updateViewport(newControllerState, { ...this._getTransitionProps({
          around: pos
        }),
        transitionDuration: inertia,
        transitionEasing: INERTIA_EASING
      }, {
        isDragging: false,
        isPanning: this.touchZoom,
        isZooming: this.touchZoom,
        isRotating: false
      });
      this.blockEvents(inertia);
    } else {
      const newControllerState = this.controllerState.zoomEnd().rotateEnd();
      this.updateViewport(newControllerState, null, {
        isDragging: false,
        isPanning: false,
        isZooming: false,
        isRotating: false
      });
    }

    this._startPinchRotation = null;
    this._lastPinchEvent = null;
    return true;
  }

  _onDoubleTap(event) {
    if (!this.doubleClickZoom) {
      return false;
    }

    const pos = this.getCenter(event);

    if (!this.isPointInBounds(pos, event)) {
      return false;
    }

    const isZoomOut = this.isFunctionKeyPressed(event);
    const newControllerState = this.controllerState.zoom({
      pos,
      scale: isZoomOut ? 0.5 : 2
    });
    this.updateViewport(newControllerState, this._getTransitionProps({
      around: pos
    }), {
      isZooming: true,
      isPanning: true
    });
    this.blockEvents(100);
    return true;
  }

  _onKeyDown(event) {
    if (!this.keyboard) {
      return false;
    }

    const funcKey = this.isFunctionKeyPressed(event);
    const {
      zoomSpeed,
      moveSpeed,
      rotateSpeedX,
      rotateSpeedY
    } = this.keyboard;
    const {
      controllerState
    } = this;
    let newControllerState;
    const interactionState = {};

    switch (event.srcEvent.code) {
      case 'Minus':
        newControllerState = funcKey ? controllerState.zoomOut(zoomSpeed).zoomOut(zoomSpeed) : controllerState.zoomOut(zoomSpeed);
        interactionState.isZooming = true;
        break;

      case 'Equal':
        newControllerState = funcKey ? controllerState.zoomIn(zoomSpeed).zoomIn(zoomSpeed) : controllerState.zoomIn(zoomSpeed);
        interactionState.isZooming = true;
        break;

      case 'ArrowLeft':
        if (funcKey) {
          newControllerState = controllerState.rotateLeft(rotateSpeedX);
          interactionState.isRotating = true;
        } else {
          newControllerState = controllerState.moveLeft(moveSpeed);
          interactionState.isPanning = true;
        }

        break;

      case 'ArrowRight':
        if (funcKey) {
          newControllerState = controllerState.rotateRight(rotateSpeedX);
          interactionState.isRotating = true;
        } else {
          newControllerState = controllerState.moveRight(moveSpeed);
          interactionState.isPanning = true;
        }

        break;

      case 'ArrowUp':
        if (funcKey) {
          newControllerState = controllerState.rotateUp(rotateSpeedY);
          interactionState.isRotating = true;
        } else {
          newControllerState = controllerState.moveUp(moveSpeed);
          interactionState.isPanning = true;
        }

        break;

      case 'ArrowDown':
        if (funcKey) {
          newControllerState = controllerState.rotateDown(rotateSpeedY);
          interactionState.isRotating = true;
        } else {
          newControllerState = controllerState.moveDown(moveSpeed);
          interactionState.isPanning = true;
        }

        break;

      default:
        return false;
    }

    this.updateViewport(newControllerState, this._getTransitionProps(), interactionState);
    return true;
  }

  _getTransitionProps(opts) {
    const {
      _transition
    } = this;

    if (!_transition) {
      return NO_TRANSITION_PROPS;
    }

    return opts ? { ..._transition,
      transitionInterpolator: new _linearInterpolator.default({ ...opts,
        transitionProps: this.linearTransitionProps,
        makeViewport: this.controllerState.makeViewport
      })
    } : _transition;
  }

}

exports.default = Controller;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./transition-manager":"node_modules/@deck.gl/core/dist/esm/controllers/transition-manager.js","../transitions/linear-interpolator":"node_modules/@deck.gl/core/dist/esm/transitions/linear-interpolator.js"}],"node_modules/@deck.gl/core/dist/esm/controllers/view-state.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class ViewState {
  constructor(opts) {
    (0, _defineProperty2.default)(this, "_viewportProps", void 0);
    (0, _defineProperty2.default)(this, "_state", void 0);
    this._viewportProps = this._applyConstraints(opts);
  }

  getViewportProps() {
    return this._viewportProps;
  }

  getState() {
    return this._state;
  }

  shortestPathFrom(viewState) {
    return this._viewportProps;
  }

  _applyConstraints(props) {
    return props;
  }

}

exports.default = ViewState;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js"}],"node_modules/@deck.gl/core/dist/esm/controllers/map-controller.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.MapState = void 0;

var _core = require("@math.gl/core");

var _controller = _interopRequireDefault(require("./controller"));

var _viewState = _interopRequireDefault(require("./view-state"));

var _webMercator = require("@math.gl/web-mercator");

var _assert = _interopRequireDefault(require("../utils/assert"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const PITCH_MOUSE_THRESHOLD = 5;
const PITCH_ACCEL = 1.2;
const DEFAULT_STATE = {
  pitch: 0,
  bearing: 0,
  altitude: 1.5,
  minZoom: 0,
  maxZoom: 20,
  minPitch: 0,
  maxPitch: 60,
  position: [0, 0, 0]
};

class MapState extends _viewState.default {
  constructor(options) {
    options = { ...DEFAULT_STATE,
      ...options
    };
    const {
      makeViewport,
      width,
      height,
      latitude,
      longitude,
      zoom,
      bearing,
      pitch,
      altitude,
      position,
      maxZoom,
      minZoom,
      maxPitch,
      minPitch,
      startPanLngLat,
      startZoomLngLat,
      startRotatePos,
      startBearing,
      startPitch,
      startZoom,
      normalize
    } = options || {};
    (0, _assert.default)(Number.isFinite(longitude));
    (0, _assert.default)(Number.isFinite(latitude));
    (0, _assert.default)(Number.isFinite(zoom));
    super({
      width,
      height,
      latitude,
      longitude,
      zoom,
      bearing,
      pitch,
      altitude,
      maxZoom,
      minZoom,
      maxPitch,
      minPitch,
      normalize,
      position
    });
    this._state = {
      startPanLngLat,
      startZoomLngLat,
      startRotatePos,
      startBearing,
      startPitch,
      startZoom
    };
    this.makeViewport = makeViewport;
  }

  panStart({
    pos
  }) {
    return this._getUpdatedState({
      startPanLngLat: this._unproject(pos)
    });
  }

  pan({
    pos,
    startPos
  }) {
    const startPanLngLat = this._state.startPanLngLat || this._unproject(startPos);

    if (!startPanLngLat) {
      return this;
    }

    const viewport = this.makeViewport(this._viewportProps);
    const newProps = viewport.panByPosition(startPanLngLat, pos);
    return this._getUpdatedState(newProps);
  }

  panEnd() {
    return this._getUpdatedState({
      startPanLngLat: null
    });
  }

  rotateStart({
    pos
  }) {
    return this._getUpdatedState({
      startRotatePos: pos,
      startBearing: this._viewportProps.bearing,
      startPitch: this._viewportProps.pitch
    });
  }

  rotate({
    pos,
    deltaAngleX = 0,
    deltaAngleY = 0
  }) {
    const {
      startRotatePos,
      startBearing,
      startPitch
    } = this._state;

    if (!startRotatePos || !Number.isFinite(startBearing) || !Number.isFinite(startPitch)) {
      return this;
    }

    let newRotation;

    if (pos) {
      newRotation = this._calculateNewPitchAndBearing({ ...this._getRotationParams(pos, startRotatePos),
        startBearing,
        startPitch
      });
    } else {
      newRotation = {
        bearing: startBearing + deltaAngleX,
        pitch: startPitch + deltaAngleY
      };
    }

    return this._getUpdatedState(newRotation);
  }

  rotateEnd() {
    return this._getUpdatedState({
      startBearing: null,
      startPitch: null
    });
  }

  zoomStart({
    pos
  }) {
    return this._getUpdatedState({
      startZoomLngLat: this._unproject(pos),
      startZoom: this._viewportProps.zoom
    });
  }

  zoom({
    pos,
    startPos,
    scale
  }) {
    let {
      startZoom,
      startZoomLngLat
    } = this._state;

    if (!Number.isFinite(startZoom)) {
      startZoom = this._viewportProps.zoom;
      startZoomLngLat = this._unproject(startPos) || this._unproject(pos);
    }

    const zoom = this._calculateNewZoom({
      scale,
      startZoom
    });

    const zoomedViewport = this.makeViewport({ ...this._viewportProps,
      zoom
    });
    return this._getUpdatedState({
      zoom,
      ...zoomedViewport.panByPosition(startZoomLngLat, pos)
    });
  }

  zoomEnd() {
    return this._getUpdatedState({
      startZoomLngLat: null,
      startZoom: null
    });
  }

  zoomIn(speed = 2) {
    return this._zoomFromCenter(speed);
  }

  zoomOut(speed = 2) {
    return this._zoomFromCenter(1 / speed);
  }

  moveLeft(speed = 100) {
    return this._panFromCenter([speed, 0]);
  }

  moveRight(speed = 100) {
    return this._panFromCenter([-speed, 0]);
  }

  moveUp(speed = 100) {
    return this._panFromCenter([0, speed]);
  }

  moveDown(speed = 100) {
    return this._panFromCenter([0, -speed]);
  }

  rotateLeft(speed = 15) {
    return this._getUpdatedState({
      bearing: this._viewportProps.bearing - speed
    });
  }

  rotateRight(speed = 15) {
    return this._getUpdatedState({
      bearing: this._viewportProps.bearing + speed
    });
  }

  rotateUp(speed = 10) {
    return this._getUpdatedState({
      pitch: this._viewportProps.pitch + speed
    });
  }

  rotateDown(speed = 10) {
    return this._getUpdatedState({
      pitch: this._viewportProps.pitch - speed
    });
  }

  shortestPathFrom(viewState) {
    const fromProps = viewState.getViewportProps();
    const props = { ...this._viewportProps
    };
    const {
      bearing,
      longitude
    } = props;

    if (Math.abs(bearing - fromProps.bearing) > 180) {
      props.bearing = bearing < 0 ? bearing + 360 : bearing - 360;
    }

    if (Math.abs(longitude - fromProps.longitude) > 180) {
      props.longitude = longitude < 0 ? longitude + 360 : longitude - 360;
    }

    return props;
  }

  _zoomFromCenter(scale) {
    const {
      width,
      height
    } = this._viewportProps;
    return this.zoom({
      pos: [width / 2, height / 2],
      scale
    });
  }

  _panFromCenter(offset) {
    const {
      width,
      height
    } = this._viewportProps;
    return this.pan({
      startPos: [width / 2, height / 2],
      pos: [width / 2 + offset[0], height / 2 + offset[1]]
    });
  }

  _getUpdatedState(newProps) {
    return new this.constructor({
      makeViewport: this.makeViewport,
      ...this._viewportProps,
      ...this._state,
      ...newProps
    });
  }

  _applyConstraints(props) {
    const {
      maxZoom,
      minZoom,
      zoom
    } = props;
    props.zoom = (0, _core.clamp)(zoom, minZoom, maxZoom);
    const {
      maxPitch,
      minPitch,
      pitch
    } = props;
    props.pitch = (0, _core.clamp)(pitch, minPitch, maxPitch);
    const {
      normalize = true
    } = props;

    if (normalize) {
      Object.assign(props, (0, _webMercator.normalizeViewportProps)(props));
    }

    return props;
  }

  _unproject(pos) {
    const viewport = this.makeViewport(this._viewportProps);
    return pos && viewport.unproject(pos);
  }

  _calculateNewZoom({
    scale,
    startZoom
  }) {
    const {
      maxZoom,
      minZoom
    } = this._viewportProps;
    const zoom = startZoom + Math.log2(scale);
    return (0, _core.clamp)(zoom, minZoom, maxZoom);
  }

  _calculateNewPitchAndBearing({
    deltaScaleX,
    deltaScaleY,
    startBearing,
    startPitch
  }) {
    deltaScaleY = (0, _core.clamp)(deltaScaleY, -1, 1);
    const {
      minPitch,
      maxPitch
    } = this._viewportProps;
    const bearing = startBearing + 180 * deltaScaleX;
    let pitch = startPitch;

    if (deltaScaleY > 0) {
      pitch = startPitch + deltaScaleY * (maxPitch - startPitch);
    } else if (deltaScaleY < 0) {
      pitch = startPitch - deltaScaleY * (minPitch - startPitch);
    }

    return {
      pitch,
      bearing
    };
  }

  _getRotationParams(pos, startPos) {
    const deltaX = pos[0] - startPos[0];
    const deltaY = pos[1] - startPos[1];
    const centerY = pos[1];
    const startY = startPos[1];
    const {
      width,
      height
    } = this._viewportProps;
    const deltaScaleX = deltaX / width;
    let deltaScaleY = 0;

    if (deltaY > 0) {
      if (Math.abs(height - startY) > PITCH_MOUSE_THRESHOLD) {
        deltaScaleY = deltaY / (startY - height) * PITCH_ACCEL;
      }
    } else if (deltaY < 0) {
      if (startY > PITCH_MOUSE_THRESHOLD) {
        deltaScaleY = 1 - centerY / startY;
      }
    }

    deltaScaleY = Math.min(1, Math.max(-1, deltaScaleY));
    return {
      deltaScaleX,
      deltaScaleY
    };
  }

}

exports.MapState = MapState;

class MapController extends _controller.default {
  constructor(props) {
    props.dragMode = props.dragMode || 'pan';
    super(MapState, props);
  }

  setProps(props) {
    props.position = props.position || [0, 0, 0];
    const oldProps = this.controllerStateProps;
    super.setProps(props);
    const dimensionChanged = !oldProps || oldProps.height !== props.height;

    if (dimensionChanged) {
      this.updateViewport(new this.ControllerState({
        makeViewport: this.makeViewport,
        ...this.controllerStateProps,
        ...this._state
      }));
    }
  }

  get linearTransitionProps() {
    return ['longitude', 'latitude', 'zoom', 'bearing', 'pitch', 'position'];
  }

}

exports.default = MapController;
},{"@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js","./controller":"node_modules/@deck.gl/core/dist/esm/controllers/controller.js","./view-state":"node_modules/@deck.gl/core/dist/esm/controllers/view-state.js","@math.gl/web-mercator":"node_modules/@math.gl/web-mercator/dist/esm/index.js","../utils/assert":"node_modules/@deck.gl/core/dist/esm/utils/assert.js"}],"node_modules/@deck.gl/core/dist/esm/views/map-view.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _view = _interopRequireDefault(require("./view"));

var _webMercatorViewport = _interopRequireDefault(require("../viewports/web-mercator-viewport"));

var _mapController = _interopRequireDefault(require("../controllers/map-controller"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class MapView extends _view.default {
  constructor(props) {
    super({ ...props,
      type: _webMercatorViewport.default
    });
  }

  get controller() {
    return this._getControllerProps({
      type: _mapController.default
    });
  }

}

exports.default = MapView;
MapView.displayName = 'MapView';
},{"./view":"node_modules/@deck.gl/core/dist/esm/views/view.js","../viewports/web-mercator-viewport":"node_modules/@deck.gl/core/dist/esm/viewports/web-mercator-viewport.js","../controllers/map-controller":"node_modules/@deck.gl/core/dist/esm/controllers/map-controller.js"}],"node_modules/@deck.gl/core/dist/esm/passes/mask-pass.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));

var _core = require("@luma.gl/core");

var _constants = require("../lib/constants");

var _layersPass = _interopRequireDefault(require("./layers-pass"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class MaskPass extends _layersPass.default {
  constructor(gl, props) {
    super(gl, props);
    (0, _defineProperty2.default)(this, "maskMap", void 0);
    (0, _defineProperty2.default)(this, "fbo", void 0);
    const {
      mapSize = 2048
    } = props;
    this.maskMap = new _core.Texture2D(gl, {
      width: mapSize,
      height: mapSize,
      parameters: {
        [10241]: 9729,
        [10240]: 9729,
        [10242]: 33071,
        [10243]: 33071
      }
    });
    this.fbo = new _core.Framebuffer(gl, {
      id: 'maskmap',
      width: mapSize,
      height: mapSize,
      attachments: {
        [36064]: this.maskMap
      }
    });
  }

  render(options) {
    const gl = this.gl;
    const colorMask = [false, false, false, false];
    colorMask[options.channel] = true;
    return (0, _core.withParameters)(gl, {
      clearColor: [255, 255, 255, 255],
      blend: true,
      blendFunc: [0, 1],
      blendEquation: 32778,
      colorMask,
      depthTest: false
    }, () => super.render({ ...options,
      target: this.fbo,
      pass: 'mask'
    }));
  }

  shouldDrawLayer(layer) {
    return layer.props.operation === _constants.OPERATION.MASK;
  }

  delete() {
    this.fbo.delete();
    this.maskMap.delete();
  }

}

exports.default = MaskPass;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","../lib/constants":"node_modules/@deck.gl/core/dist/esm/lib/constants.js","./layers-pass":"node_modules/@deck.gl/core/dist/esm/passes/layers-pass.js"}],"node_modules/@deck.gl/core/dist/esm/controllers/orbit-controller.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.OrbitState = void 0;

var _core = require("@math.gl/core");

var _controller = _interopRequireDefault(require("./controller"));

var _viewState = _interopRequireDefault(require("./view-state"));

var _mathUtils = require("../utils/math-utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const DEFAULT_STATE = {
  rotationX: 0,
  rotationOrbit: 0,
  zoom: 0,
  target: [0, 0, 0],
  minRotationX: -90,
  maxRotationX: 90,
  minZoom: -Infinity,
  maxZoom: Infinity
};

class OrbitState extends _viewState.default {
  constructor({
    makeViewport,
    width,
    height,
    rotationX = DEFAULT_STATE.rotationX,
    rotationOrbit = DEFAULT_STATE.rotationOrbit,
    target = DEFAULT_STATE.target,
    zoom = DEFAULT_STATE.zoom,
    minRotationX = DEFAULT_STATE.minRotationX,
    maxRotationX = DEFAULT_STATE.maxRotationX,
    minZoom = DEFAULT_STATE.minZoom,
    maxZoom = DEFAULT_STATE.maxZoom,
    startPanPosition,
    startRotatePos,
    startRotationX,
    startRotationOrbit,
    startZoomPosition,
    startZoom
  }) {
    super({
      width,
      height,
      rotationX,
      rotationOrbit,
      target,
      zoom,
      minRotationX,
      maxRotationX,
      minZoom,
      maxZoom
    });
    this._state = {
      startPanPosition,
      startRotatePos,
      startRotationX,
      startRotationOrbit,
      startZoomPosition,
      startZoom
    };
    this.makeViewport = makeViewport;
  }

  panStart({
    pos
  }) {
    return this._getUpdatedState({
      startPanPosition: this._unproject(pos)
    });
  }

  pan({
    pos,
    startPosition
  }) {
    const startPanPosition = this._state.startPanPosition || startPosition;

    if (!startPanPosition) {
      return this;
    }

    const viewport = this.makeViewport(this._viewportProps);
    const newProps = viewport.panByPosition(startPanPosition, pos);
    return this._getUpdatedState(newProps);
  }

  panEnd() {
    return this._getUpdatedState({
      startPanPosition: null
    });
  }

  rotateStart({
    pos
  }) {
    return this._getUpdatedState({
      startRotatePos: pos,
      startRotationX: this._viewportProps.rotationX,
      startRotationOrbit: this._viewportProps.rotationOrbit
    });
  }

  rotate({
    pos,
    deltaAngleX = 0,
    deltaAngleY = 0
  }) {
    const {
      startRotatePos,
      startRotationX,
      startRotationOrbit
    } = this._state;
    const {
      width,
      height
    } = this._viewportProps;

    if (!startRotatePos || !Number.isFinite(startRotationX) || !Number.isFinite(startRotationOrbit)) {
      return this;
    }

    let newRotation;

    if (pos) {
      let deltaScaleX = (pos[0] - startRotatePos[0]) / width;
      const deltaScaleY = (pos[1] - startRotatePos[1]) / height;

      if (startRotationX < -90 || startRotationX > 90) {
        deltaScaleX *= -1;
      }

      newRotation = {
        rotationX: startRotationX + deltaScaleY * 180,
        rotationOrbit: startRotationOrbit + deltaScaleX * 180
      };
    } else {
      newRotation = {
        rotationX: startRotationX + deltaAngleY,
        rotationOrbit: startRotationOrbit + deltaAngleX
      };
    }

    return this._getUpdatedState(newRotation);
  }

  rotateEnd() {
    return this._getUpdatedState({
      startRotationX: null,
      startRotationOrbit: null
    });
  }

  shortestPathFrom(viewState) {
    const fromProps = viewState.getViewportProps();
    const props = { ...this._viewportProps
    };
    const {
      rotationOrbit
    } = props;

    if (Math.abs(rotationOrbit - fromProps.rotationOrbit) > 180) {
      props.rotationOrbit = rotationOrbit < 0 ? rotationOrbit + 360 : rotationOrbit - 360;
    }

    return props;
  }

  zoomStart({
    pos
  }) {
    return this._getUpdatedState({
      startZoomPosition: this._unproject(pos),
      startZoom: this._viewportProps.zoom
    });
  }

  zoom({
    pos,
    startPos,
    scale
  }) {
    const {
      zoom
    } = this._viewportProps;
    let {
      startZoom,
      startZoomPosition
    } = this._state;

    if (!Number.isFinite(startZoom)) {
      startZoom = zoom;
      startZoomPosition = this._unproject(startPos) || this._unproject(pos);
    }

    const newZoom = this._calculateNewZoom({
      scale,
      startZoom
    });

    const zoomedViewport = this.makeViewport({ ...this._viewportProps,
      zoom: newZoom
    });
    return this._getUpdatedState({
      zoom: newZoom,
      ...zoomedViewport.panByPosition(startZoomPosition, pos)
    });
  }

  zoomEnd() {
    return this._getUpdatedState({
      startZoomPosition: null,
      startZoom: null
    });
  }

  zoomIn(speed = 2) {
    return this._getUpdatedState({
      zoom: this._calculateNewZoom({
        scale: speed
      })
    });
  }

  zoomOut(speed = 2) {
    return this._getUpdatedState({
      zoom: this._calculateNewZoom({
        scale: 1 / speed
      })
    });
  }

  moveLeft(speed = 50) {
    return this._panFromCenter([-speed, 0]);
  }

  moveRight(speed = 50) {
    return this._panFromCenter([speed, 0]);
  }

  moveUp(speed = 50) {
    return this._panFromCenter([0, -speed]);
  }

  moveDown(speed = 50) {
    return this._panFromCenter([0, speed]);
  }

  rotateLeft(speed = 15) {
    return this._getUpdatedState({
      rotationOrbit: this._viewportProps.rotationOrbit - speed
    });
  }

  rotateRight(speed = 15) {
    return this._getUpdatedState({
      rotationOrbit: this._viewportProps.rotationOrbit + speed
    });
  }

  rotateUp(speed = 10) {
    return this._getUpdatedState({
      rotationX: this._viewportProps.rotationX - speed
    });
  }

  rotateDown(speed = 10) {
    return this._getUpdatedState({
      rotationX: this._viewportProps.rotationX + speed
    });
  }

  _unproject(pos) {
    const viewport = this.makeViewport(this._viewportProps);
    return pos && viewport.unproject(pos);
  }

  _calculateNewZoom({
    scale,
    startZoom
  }) {
    const {
      maxZoom,
      minZoom
    } = this._viewportProps;

    if (!Number.isFinite(startZoom)) {
      startZoom = this._viewportProps.zoom;
    }

    const zoom = startZoom + Math.log2(scale);
    return (0, _core.clamp)(zoom, minZoom, maxZoom);
  }

  _panFromCenter(offset) {
    const {
      width,
      height,
      target
    } = this._viewportProps;
    return this.pan({
      startPosition: target,
      pos: [width / 2 + offset[0], height / 2 + offset[1]]
    });
  }

  _getUpdatedState(newProps) {
    return new this.constructor({ ...this._viewportProps,
      ...this._state,
      ...newProps
    });
  }

  _applyConstraints(props) {
    const {
      maxZoom,
      minZoom,
      zoom,
      maxRotationX,
      minRotationX,
      rotationOrbit
    } = props;
    props.zoom = (0, _core.clamp)(zoom, minZoom, maxZoom);
    props.rotationX = (0, _core.clamp)(props.rotationX, minRotationX, maxRotationX);

    if (rotationOrbit < -180 || rotationOrbit > 180) {
      props.rotationOrbit = (0, _mathUtils.mod)(rotationOrbit + 180, 360) - 180;
    }

    return props;
  }

}

exports.OrbitState = OrbitState;

class OrbitController extends _controller.default {
  constructor(props) {
    super(OrbitState, props);
  }

  get linearTransitionProps() {
    return ['target', 'zoom', 'rotationX', 'rotationOrbit'];
  }

}

exports.default = OrbitController;
},{"@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js","./controller":"node_modules/@deck.gl/core/dist/esm/controllers/controller.js","./view-state":"node_modules/@deck.gl/core/dist/esm/controllers/view-state.js","../utils/math-utils":"node_modules/@deck.gl/core/dist/esm/utils/math-utils.js"}],"node_modules/@deck.gl/core/dist/esm/controllers/orthographic-controller.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));

var _core = require("@math.gl/core");

var _controller = _interopRequireDefault(require("./controller"));

var _orbitController = require("./orbit-controller");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class OrthographicState extends _orbitController.OrbitState {
  constructor(props) {
    super(props);
    (0, _defineProperty2.default)(this, "zoomAxis", void 0);
    this.zoomAxis = props.zoomAxis || 'all';
  }

  _applyConstraints(props) {
    const {
      maxZoom,
      minZoom,
      zoom
    } = props;
    props.zoom = Array.isArray(zoom) ? [(0, _core.clamp)(zoom[0], minZoom, maxZoom), (0, _core.clamp)(zoom[1], minZoom, maxZoom)] : (0, _core.clamp)(zoom, minZoom, maxZoom);
    return props;
  }

  _calculateNewZoom({
    scale,
    startZoom
  }) {
    const {
      maxZoom,
      minZoom
    } = this._viewportProps;

    if (!startZoom && startZoom !== 0) {
      startZoom = this._viewportProps.zoom;
    }

    let deltaZoom = Math.log2(scale);

    if (Array.isArray(startZoom)) {
      let [newZoomX, newZoomY] = startZoom;

      switch (this.zoomAxis) {
        case 'X':
          newZoomX = (0, _core.clamp)(newZoomX + deltaZoom, minZoom, maxZoom);
          break;

        case 'Y':
          newZoomY = (0, _core.clamp)(newZoomY + deltaZoom, minZoom, maxZoom);
          break;

        default:
          let z = Math.min(newZoomX + deltaZoom, newZoomY + deltaZoom);

          if (z < minZoom) {
            deltaZoom += minZoom - z;
          }

          z = Math.max(newZoomX + deltaZoom, newZoomY + deltaZoom);

          if (z > maxZoom) {
            deltaZoom += maxZoom - z;
          }

          newZoomX += deltaZoom;
          newZoomY += deltaZoom;
      }

      return [newZoomX, newZoomY];
    }

    return (0, _core.clamp)(startZoom + deltaZoom, minZoom, maxZoom);
  }

}

class OrthographicController extends _controller.default {
  constructor(props) {
    props.dragMode = props.dragMode || 'pan';
    super(OrthographicState, props);
  }

  _onPanRotate(event) {
    return false;
  }

  get linearTransitionProps() {
    return ['target', 'zoom'];
  }

}

exports.default = OrthographicController;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js","./controller":"node_modules/@deck.gl/core/dist/esm/controllers/controller.js","./orbit-controller":"node_modules/@deck.gl/core/dist/esm/controllers/orbit-controller.js"}],"node_modules/@deck.gl/core/dist/esm/views/orthographic-view.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _view = _interopRequireDefault(require("./view"));

var _viewport = _interopRequireDefault(require("../viewports/viewport"));

var _core = require("@math.gl/core");

var _webMercator = require("@math.gl/web-mercator");

var vec2 = _interopRequireWildcard(require("gl-matrix/vec2"));

var _orthographicController = _interopRequireDefault(require("../controllers/orthographic-controller"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const viewMatrix = new _core.Matrix4().lookAt({
  eye: [0, 0, 1]
});

function getProjectionMatrix({
  width,
  height,
  near,
  far
}) {
  width = width || 1;
  height = height || 1;
  return new _core.Matrix4().ortho({
    left: -width / 2,
    right: width / 2,
    bottom: -height / 2,
    top: height / 2,
    near,
    far
  });
}

class OrthographicViewport extends _viewport.default {
  constructor(props) {
    const {
      width,
      height,
      near = 0.1,
      far = 1000,
      zoom = 0,
      target = [0, 0, 0],
      flipY = true
    } = props;
    const zoomX = Array.isArray(zoom) ? zoom[0] : zoom;
    const zoomY = Array.isArray(zoom) ? zoom[1] : zoom;
    const zoom_ = Math.min(zoomX, zoomY);
    const scale = Math.pow(2, zoom_);
    let distanceScales;

    if (zoomX !== zoomY) {
      const scaleX = Math.pow(2, zoomX);
      const scaleY = Math.pow(2, zoomY);
      distanceScales = {
        unitsPerMeter: [scaleX / scale, scaleY / scale, 1],
        metersPerUnit: [scale / scaleX, scale / scaleY, 1]
      };
    }

    super({ ...props,
      longitude: null,
      position: target,
      viewMatrix: viewMatrix.clone().scale([scale, scale * (flipY ? -1 : 1), scale]),
      projectionMatrix: getProjectionMatrix({
        width,
        height,
        near,
        far
      }),
      zoom: zoom_,
      distanceScales
    });
  }

  projectFlat([X, Y]) {
    const {
      unitsPerMeter
    } = this.distanceScales;
    return [X * unitsPerMeter[0], Y * unitsPerMeter[1]];
  }

  unprojectFlat([x, y]) {
    const {
      metersPerUnit
    } = this.distanceScales;
    return [x * metersPerUnit[0], y * metersPerUnit[1]];
  }

  panByPosition(coords, pixel) {
    const fromLocation = (0, _webMercator.pixelsToWorld)(pixel, this.pixelUnprojectionMatrix);
    const toLocation = this.projectFlat(coords);
    const translate = vec2.add([], toLocation, vec2.negate([], fromLocation));
    const newCenter = vec2.add([], this.center, translate);
    return {
      target: this.unprojectFlat(newCenter)
    };
  }

}

class OrthographicView extends _view.default {
  constructor(props) {
    super({ ...props,
      type: OrthographicViewport
    });
  }

  get controller() {
    return this._getControllerProps({
      type: _orthographicController.default
    });
  }

}

exports.default = OrthographicView;
OrthographicView.displayName = 'OrthographicView';
},{"./view":"node_modules/@deck.gl/core/dist/esm/views/view.js","../viewports/viewport":"node_modules/@deck.gl/core/dist/esm/viewports/viewport.js","@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js","@math.gl/web-mercator":"node_modules/@math.gl/web-mercator/dist/esm/index.js","gl-matrix/vec2":"node_modules/gl-matrix/esm/vec2.js","../controllers/orthographic-controller":"node_modules/@deck.gl/core/dist/esm/controllers/orthographic-controller.js"}],"node_modules/@deck.gl/core/dist/esm/effects/mask/utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getMaskBounds = getMaskBounds;
exports.getMaskViewport = getMaskViewport;

var _orthographicView = _interopRequireDefault(require("../../views/orthographic-view"));

var _webMercatorViewport = _interopRequireDefault(require("../../viewports/web-mercator-viewport"));

var _webMercator = require("@math.gl/web-mercator");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getMaskBounds({
  layers,
  viewport
}) {
  let bounds = null;

  for (const layer of layers) {
    const subLayerBounds = layer.getBounds();

    if (subLayerBounds) {
      if (bounds) {
        bounds[0] = Math.min(bounds[0], subLayerBounds[0][0]);
        bounds[1] = Math.min(bounds[1], subLayerBounds[0][1]);
        bounds[2] = Math.max(bounds[2], subLayerBounds[1][0]);
        bounds[3] = Math.max(bounds[3], subLayerBounds[1][1]);
      } else {
        bounds = [subLayerBounds[0][0], subLayerBounds[0][1], subLayerBounds[1][0], subLayerBounds[1][1]];
      }
    }
  }

  const viewportBounds = viewport.getBounds();

  if (!bounds) {
    return viewportBounds;
  }

  const paddedBounds = _doubleBounds(viewportBounds);

  if (bounds[2] - bounds[0] < paddedBounds[2] - paddedBounds[0] || bounds[3] - bounds[1] < paddedBounds[3] - paddedBounds[1]) {
    return bounds;
  }

  bounds[0] = Math.max(bounds[0], paddedBounds[0]);
  bounds[1] = Math.max(bounds[1], paddedBounds[1]);
  bounds[2] = Math.min(bounds[2], paddedBounds[2]);
  bounds[3] = Math.min(bounds[3], paddedBounds[3]);
  return bounds;
}

function getMaskViewport({
  bounds,
  viewport,
  width,
  height
}) {
  if (bounds[2] <= bounds[0] || bounds[3] <= bounds[1]) {
    return null;
  }

  const padding = 1;
  width -= padding * 2;
  height -= padding * 2;

  if (viewport instanceof _webMercatorViewport.default) {
    const {
      longitude,
      latitude,
      zoom
    } = (0, _webMercator.fitBounds)({
      width,
      height,
      bounds: [[bounds[0], bounds[1]], [bounds[2], bounds[3]]],
      maxZoom: 20
    });
    return new _webMercatorViewport.default({
      longitude,
      latitude,
      zoom,
      x: padding,
      y: padding,
      width,
      height
    });
  }

  const center = [(bounds[0] + bounds[2]) / 2, (bounds[1] + bounds[3]) / 2, 0];
  const scale = Math.min(20, width / (bounds[2] - bounds[0]), height / (bounds[3] - bounds[1]));
  return new _orthographicView.default({
    x: padding,
    y: padding
  }).makeViewport({
    width,
    height,
    viewState: {
      target: center,
      zoom: Math.log2(scale)
    }
  });
}

function _doubleBounds(bounds) {
  const size = {
    x: bounds[2] - bounds[0],
    y: bounds[3] - bounds[1]
  };
  const center = {
    x: bounds[0] + 0.5 * size.x,
    y: bounds[1] + 0.5 * size.y
  };
  return [center.x - size.x, center.y - size.y, center.x + size.x, center.y + size.y];
}
},{"../../views/orthographic-view":"node_modules/@deck.gl/core/dist/esm/views/orthographic-view.js","../../viewports/web-mercator-viewport":"node_modules/@deck.gl/core/dist/esm/viewports/web-mercator-viewport.js","@math.gl/web-mercator":"node_modules/@math.gl/web-mercator/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/effects/mask/mask-effect.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _core = require("@luma.gl/core");

var _core2 = require("@math.gl/core");

var _maskPass = _interopRequireDefault(require("../../passes/mask-pass"));

var _effect = _interopRequireDefault(require("../../lib/effect"));

var _constants = require("../../lib/constants");

var _utils = require("./utils");

var _log = _interopRequireDefault(require("../../utils/log"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class MaskEffect extends _effect.default {
  constructor(props) {
    super(props);
    this.dummyMaskMap = null;
    this.useInPicking = true;
    this.channels = [];
    this.masks = null;
  }

  preRender(gl, {
    layers,
    layerFilter,
    viewports,
    onViewportActive,
    views
  }) {
    if (!this.dummyMaskMap) {
      this.dummyMaskMap = new _core.Texture2D(gl, {
        width: 1,
        height: 1
      });
    }

    const maskLayers = layers.filter(l => l.props.operation === _constants.OPERATION.MASK && l.props.visible);

    if (maskLayers.length === 0) {
      this.masks = null;
      this.channels.length = 0;
      return;
    }

    this.masks = {};

    if (!this.maskPass) {
      this.maskPass = new _maskPass.default(gl, {
        id: 'default-mask'
      });
      this.maskMap = this.maskPass.maskMap;
    }

    const channelMap = this._sortMaskChannels(maskLayers);

    const viewport = viewports[0];
    const viewportChanged = !this.lastViewport || !this.lastViewport.equals(viewport);

    for (const maskId in channelMap) {
      this._renderChannel(channelMap[maskId], {
        layerFilter,
        onViewportActive,
        views,
        viewport,
        viewportChanged
      });
    }
  }

  _renderChannel(channelInfo, {
    layerFilter,
    onViewportActive,
    views,
    viewport,
    viewportChanged
  }) {
    const oldChannelInfo = this.channels[channelInfo.index];
    const maskChanged = channelInfo === oldChannelInfo || oldChannelInfo.layers.length !== channelInfo.layers.length || channelInfo.layerBounds.some((b, i) => b !== oldChannelInfo.layerBounds[i]);
    channelInfo.bounds = oldChannelInfo.bounds;
    channelInfo.maskBounds = oldChannelInfo.maskBounds;
    this.channels[channelInfo.index] = channelInfo;

    if (maskChanged || viewportChanged) {
      this.lastViewport = viewport;
      channelInfo.bounds = (0, _utils.getMaskBounds)({
        layers: channelInfo.layers,
        viewport
      });

      if (maskChanged || !(0, _core2.equals)(channelInfo.bounds, oldChannelInfo.bounds)) {
        const {
          maskPass,
          maskMap
        } = this;
        const maskViewport = (0, _utils.getMaskViewport)({
          bounds: channelInfo.bounds,
          viewport,
          width: maskMap.width,
          height: maskMap.height
        });
        channelInfo.maskBounds = maskViewport ? maskViewport.getBounds() : [0, 0, 1, 1];
        maskPass.render({
          channel: channelInfo.index,
          layers: channelInfo.layers,
          layerFilter,
          viewports: maskViewport ? [maskViewport] : [],
          onViewportActive,
          views,
          moduleParameters: {
            devicePixelRatio: 1
          }
        });
      }
    }

    this.masks[channelInfo.id] = {
      index: channelInfo.index,
      bounds: channelInfo.maskBounds,
      coordinateOrigin: channelInfo.coordinateOrigin,
      coordinateSystem: channelInfo.coordinateSystem
    };
  }

  _sortMaskChannels(maskLayers) {
    const channelMap = {};
    let channelCount = 0;

    for (const layer of maskLayers) {
      const {
        id
      } = layer.root;
      let channelInfo = channelMap[id];

      if (!channelInfo) {
        if (++channelCount > 4) {
          _log.default.warn('Too many mask layers. The max supported is 4')();

          continue;
        }

        channelInfo = {
          id,
          index: this.channels.findIndex(c => (c === null || c === void 0 ? void 0 : c.id) === id),
          layers: [],
          layerBounds: [],
          coordinateOrigin: layer.root.props.coordinateOrigin,
          coordinateSystem: layer.root.props.coordinateSystem
        };
        channelMap[id] = channelInfo;
      }

      channelInfo.layers.push(layer);
      channelInfo.layerBounds.push(layer.getBounds());
    }

    for (let i = 0; i < 4; i++) {
      const channelInfo = this.channels[i];

      if (!channelInfo || !(channelInfo.id in channelMap)) {
        this.channels[i] = null;
      }
    }

    for (const maskId in channelMap) {
      const channelInfo = channelMap[maskId];

      if (channelInfo.index < 0) {
        channelInfo.index = this.channels.findIndex(c => !c);
        this.channels[channelInfo.index] = channelInfo;
      }
    }

    return channelMap;
  }

  getModuleParameters() {
    return {
      maskMap: this.masks ? this.maskMap : this.dummyMaskMap,
      maskChannels: this.masks
    };
  }

  cleanup() {
    if (this.dummyMaskMap) {
      this.dummyMaskMap.delete();
      this.dummyMaskMap = null;
    }

    if (this.maskPass) {
      this.maskPass.delete();
      this.maskPass = null;
      this.maskMap = null;
    }

    this.lastViewport = null;
    this.masks = null;
    this.channels.length = 0;
  }

}

exports.default = MaskEffect;
},{"@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js","../../passes/mask-pass":"node_modules/@deck.gl/core/dist/esm/passes/mask-pass.js","../../lib/effect":"node_modules/@deck.gl/core/dist/esm/lib/effect.js","../../lib/constants":"node_modules/@deck.gl/core/dist/esm/lib/constants.js","./utils":"node_modules/@deck.gl/core/dist/esm/effects/mask/utils.js","../../utils/log":"node_modules/@deck.gl/core/dist/esm/utils/log.js"}],"node_modules/@deck.gl/core/dist/esm/lib/effect-manager.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));

var _deepEqual = require("../utils/deep-equal");

var _lightingEffect = _interopRequireDefault(require("../effects/lighting/lighting-effect"));

var _maskEffect = _interopRequireDefault(require("../effects/mask/mask-effect"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const DEFAULT_LIGHTING_EFFECT = new _lightingEffect.default();

class EffectManager {
  constructor() {
    (0, _defineProperty2.default)(this, "effects", void 0);
    (0, _defineProperty2.default)(this, "_internalEffects", void 0);
    (0, _defineProperty2.default)(this, "_needsRedraw", void 0);
    this.effects = [];
    this._internalEffects = [];
    this._needsRedraw = 'Initial render';
    this.setEffects();
  }

  setProps(props) {
    if ('effects' in props) {
      if (props.effects.length !== this.effects.length || !(0, _deepEqual.deepEqual)(props.effects, this.effects)) {
        this.setEffects(props.effects);
        this._needsRedraw = 'effects changed';
      }
    }
  }

  needsRedraw(opts = {
    clearRedrawFlags: false
  }) {
    const redraw = this._needsRedraw;

    if (opts.clearRedrawFlags) {
      this._needsRedraw = false;
    }

    return redraw;
  }

  getEffects() {
    return this._internalEffects;
  }

  finalize() {
    this.cleanup();
  }

  setEffects(effects = []) {
    this.cleanup();
    this.effects = effects;
    this._internalEffects = effects.slice();

    this._internalEffects.push(new _maskEffect.default());

    if (!effects.some(effect => effect instanceof _lightingEffect.default)) {
      this._internalEffects.push(DEFAULT_LIGHTING_EFFECT);
    }
  }

  cleanup() {
    for (const effect of this.effects) {
      effect.cleanup();
    }

    for (const effect of this._internalEffects) {
      effect.cleanup();
    }

    this.effects.length = 0;
    this._internalEffects.length = 0;
  }

}

exports.default = EffectManager;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","../utils/deep-equal":"node_modules/@deck.gl/core/dist/esm/utils/deep-equal.js","../effects/lighting/lighting-effect":"node_modules/@deck.gl/core/dist/esm/effects/lighting/lighting-effect.js","../effects/mask/mask-effect":"node_modules/@deck.gl/core/dist/esm/effects/mask/mask-effect.js"}],"node_modules/@deck.gl/core/dist/esm/passes/draw-layers-pass.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _constants = require("../lib/constants");

var _layersPass = _interopRequireDefault(require("./layers-pass"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class DrawLayersPass extends _layersPass.default {
  shouldDrawLayer(layer) {
    return layer.props.operation === _constants.OPERATION.DRAW;
  }

}

exports.default = DrawLayersPass;
},{"../lib/constants":"node_modules/@deck.gl/core/dist/esm/lib/constants.js","./layers-pass":"node_modules/@deck.gl/core/dist/esm/passes/layers-pass.js"}],"node_modules/@deck.gl/core/dist/esm/passes/pick-layers-pass.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));

var _layersPass = _interopRequireDefault(require("./layers-pass"));

var _core = require("@luma.gl/core");

var _constants = require("../lib/constants");

var _log = _interopRequireDefault(require("../utils/log"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const PICKING_PARAMETERS = {
  blendFunc: [1, 0, 32771, 0],
  blendEquation: 32774
};

class PickLayersPass extends _layersPass.default {
  constructor(...args) {
    super(...args);
    (0, _defineProperty2.default)(this, "pickZ", void 0);
    (0, _defineProperty2.default)(this, "_colors", null);
  }

  render(props) {
    if (props.pickingFBO) {
      return this._drawPickingBuffer(props);
    }

    return super.render(props);
  }

  _drawPickingBuffer({
    layers,
    layerFilter,
    views,
    viewports,
    onViewportActive,
    pickingFBO,
    deviceRect: {
      x,
      y,
      width,
      height
    },
    effects,
    pass = 'picking',
    pickZ
  }) {
    const gl = this.gl;
    this.pickZ = pickZ;
    const encodedColors = pickZ ? null : {
      byLayer: new Map(),
      byAlpha: []
    };
    this._colors = encodedColors;
    const renderStatus = (0, _core.withParameters)(gl, {
      scissorTest: true,
      scissor: [x, y, width, height],
      clearColor: [0, 0, 0, 0],
      depthMask: true,
      depthTest: true,
      depthRange: [0, 1],
      colorMask: [true, true, true, true],
      ...PICKING_PARAMETERS,
      blend: !pickZ
    }, () => super.render({
      target: pickingFBO,
      layers,
      layerFilter,
      views,
      viewports,
      onViewportActive,
      effects: effects === null || effects === void 0 ? void 0 : effects.filter(e => e.useInPicking),
      pass
    }));
    this._colors = null;
    const decodePickingColor = encodedColors && decodeColor.bind(null, encodedColors);
    return {
      decodePickingColor,
      stats: renderStatus
    };
  }

  shouldDrawLayer(layer) {
    return layer.props.pickable && layer.props.operation === _constants.OPERATION.DRAW;
  }

  getModuleParameters() {
    return {
      pickingActive: 1,
      pickingAttribute: this.pickZ,
      lightSources: {}
    };
  }

  getLayerParameters(layer, layerIndex, viewport) {
    const pickParameters = { ...layer.props.parameters
    };

    if (!this._colors) {
      pickParameters.blend = false;
    } else {
      Object.assign(pickParameters, PICKING_PARAMETERS);
      pickParameters.blend = true;
      pickParameters.blendColor = encodeColor(this._colors, layer, viewport);
    }

    return pickParameters;
  }

}

exports.default = PickLayersPass;

function encodeColor(encoded, layer, viewport) {
  const {
    byLayer,
    byAlpha
  } = encoded;
  let a;
  let entry = byLayer.get(layer);

  if (entry) {
    entry.viewports.push(viewport);
    a = entry.a;
  } else {
    a = byLayer.size + 1;

    if (a <= 255) {
      entry = {
        a,
        layer,
        viewports: [viewport]
      };
      byLayer.set(layer, entry);
      byAlpha[a] = entry;
    } else {
      _log.default.warn('Too many pickable layers, only picking the first 255')();

      a = 0;
    }
  }

  return [0, 0, 0, a / 255];
}

function decodeColor(encoded, pickedColor) {
  const entry = encoded.byAlpha[pickedColor[3]];
  return entry && {
    pickedLayer: entry.layer,
    pickedViewports: entry.viewports,
    pickedObjectIndex: entry.layer.decodePickingColor(pickedColor)
  };
}
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./layers-pass":"node_modules/@deck.gl/core/dist/esm/passes/layers-pass.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","../lib/constants":"node_modules/@deck.gl/core/dist/esm/lib/constants.js","../utils/log":"node_modules/@deck.gl/core/dist/esm/utils/log.js"}],"node_modules/@deck.gl/core/dist/esm/lib/deck-renderer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _debug = _interopRequireDefault(require("../debug"));

var _drawLayersPass = _interopRequireDefault(require("../passes/draw-layers-pass"));

var _pickLayersPass = _interopRequireDefault(require("../passes/pick-layers-pass"));

var _core = require("@luma.gl/core");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const TRACE_RENDER_LAYERS = 'deckRenderer.renderLayers';

class DeckRenderer {
  constructor(gl) {
    this.gl = gl;
    this.layerFilter = null;
    this.drawPickingColors = false;
    this.drawLayersPass = new _drawLayersPass.default(gl);
    this.pickLayersPass = new _pickLayersPass.default(gl);
    this.renderCount = 0;
    this._needsRedraw = 'Initial render';
    this.renderBuffers = [];
    this.lastPostProcessEffect = null;
  }

  setProps(props) {
    if ('layerFilter' in props && this.layerFilter !== props.layerFilter) {
      this.layerFilter = props.layerFilter;
      this._needsRedraw = 'layerFilter changed';
    }

    if ('drawPickingColors' in props && this.drawPickingColors !== props.drawPickingColors) {
      this.drawPickingColors = props.drawPickingColors;
      this._needsRedraw = 'drawPickingColors changed';
    }
  }

  renderLayers(opts) {
    const layerPass = this.drawPickingColors ? this.pickLayersPass : this.drawLayersPass;
    opts.layerFilter = opts.layerFilter || this.layerFilter;
    opts.effects = opts.effects || [];
    opts.target = opts.target || _core.Framebuffer.getDefaultFramebuffer(this.gl);

    this._preRender(opts.effects, opts);

    const outputBuffer = this.lastPostProcessEffect ? this.renderBuffers[0] : opts.target;
    const renderStats = layerPass.render({ ...opts,
      target: outputBuffer
    });

    this._postRender(opts.effects, opts);

    this.renderCount++;
    (0, _debug.default)(TRACE_RENDER_LAYERS, this, renderStats, opts);
  }

  needsRedraw(opts = {
    clearRedrawFlags: false
  }) {
    const redraw = this._needsRedraw;

    if (opts.clearRedrawFlags) {
      this._needsRedraw = false;
    }

    return redraw;
  }

  finalize() {
    const {
      renderBuffers
    } = this;

    for (const buffer of renderBuffers) {
      buffer.delete();
    }

    renderBuffers.length = 0;
  }

  _preRender(effects, opts) {
    let lastPostProcessEffect = null;

    for (const effect of effects) {
      effect.preRender(this.gl, opts);

      if (effect.postRender) {
        lastPostProcessEffect = effect;
      }
    }

    if (lastPostProcessEffect) {
      this._resizeRenderBuffers();
    }

    this.lastPostProcessEffect = lastPostProcessEffect;
  }

  _resizeRenderBuffers() {
    const {
      renderBuffers
    } = this;

    if (renderBuffers.length === 0) {
      renderBuffers.push(new _core.Framebuffer(this.gl), new _core.Framebuffer(this.gl));
    }

    for (const buffer of renderBuffers) {
      buffer.resize();
    }
  }

  _postRender(effects, opts) {
    const {
      renderBuffers
    } = this;
    const params = {
      inputBuffer: renderBuffers[0],
      swapBuffer: renderBuffers[1],
      target: null
    };

    for (const effect of effects) {
      if (effect.postRender) {
        if (effect === this.lastPostProcessEffect) {
          params.target = opts.target;
          effect.postRender(this.gl, params);
          break;
        }

        const buffer = effect.postRender(this.gl, params);
        params.inputBuffer = buffer;
        params.swapBuffer = buffer === renderBuffers[0] ? renderBuffers[1] : renderBuffers[0];
      }
    }
  }

}

exports.default = DeckRenderer;
},{"../debug":"node_modules/@deck.gl/core/dist/esm/debug/index.js","../passes/draw-layers-pass":"node_modules/@deck.gl/core/dist/esm/passes/draw-layers-pass.js","../passes/pick-layers-pass":"node_modules/@deck.gl/core/dist/esm/passes/pick-layers-pass.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/lib/picking/query-object.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getClosestObject = getClosestObject;
exports.getUniqueObjects = getUniqueObjects;

var _log = _interopRequireDefault(require("../../utils/log"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const NO_PICKED_OBJECT = {
  pickedColor: null,
  pickedLayer: null,
  pickedObjectIndex: -1
};

function getClosestObject({
  pickedColors,
  decodePickingColor,
  deviceX,
  deviceY,
  deviceRadius,
  deviceRect
}) {
  if (pickedColors) {
    const {
      x,
      y,
      width,
      height
    } = deviceRect;
    let minSquareDistanceToCenter = deviceRadius * deviceRadius;
    let closestPixelIndex = -1;
    let i = 0;

    for (let row = 0; row < height; row++) {
      const dy = row + y - deviceY;
      const dy2 = dy * dy;

      if (dy2 > minSquareDistanceToCenter) {
        i += 4 * width;
      } else {
        for (let col = 0; col < width; col++) {
          const pickedLayerIndex = pickedColors[i + 3] - 1;

          if (pickedLayerIndex >= 0) {
            const dx = col + x - deviceX;
            const d2 = dx * dx + dy2;

            if (d2 <= minSquareDistanceToCenter) {
              minSquareDistanceToCenter = d2;
              closestPixelIndex = i;
            }
          }

          i += 4;
        }
      }
    }

    if (closestPixelIndex >= 0) {
      const pickedColor = pickedColors.slice(closestPixelIndex, closestPixelIndex + 4);
      const pickedObject = decodePickingColor(pickedColor);

      if (pickedObject) {
        const dy = Math.floor(closestPixelIndex / 4 / width);
        const dx = closestPixelIndex / 4 - dy * width;
        return { ...pickedObject,
          pickedColor,
          pickedX: x + dx,
          pickedY: y + dy
        };
      }

      _log.default.error('Picked non-existent layer. Is picking buffer corrupt?')();
    }
  }

  return NO_PICKED_OBJECT;
}

function getUniqueObjects({
  pickedColors,
  decodePickingColor
}) {
  const uniqueColors = new Map();

  if (pickedColors) {
    for (let i = 0; i < pickedColors.length; i += 4) {
      const pickedLayerIndex = pickedColors[i + 3] - 1;

      if (pickedLayerIndex >= 0) {
        const pickedColor = pickedColors.slice(i, i + 4);
        const colorKey = pickedColor.join(',');

        if (!uniqueColors.has(colorKey)) {
          const pickedObject = decodePickingColor(pickedColor);

          if (pickedObject) {
            uniqueColors.set(colorKey, { ...pickedObject,
              pickedColor
            });
          } else {
            _log.default.error('Picked non-existent layer. Is picking buffer corrupt?')();
          }
        }
      }
    }
  }

  return Array.from(uniqueColors.values());
}
},{"../../utils/log":"node_modules/@deck.gl/core/dist/esm/utils/log.js"}],"node_modules/@deck.gl/core/dist/esm/lib/picking/pick-info.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getEmptyPickingInfo = getEmptyPickingInfo;
exports.getLayerPickingInfo = getLayerPickingInfo;
exports.processPickInfo = processPickInfo;

function getEmptyPickingInfo({
  pickInfo,
  viewports,
  pixelRatio,
  x,
  y,
  z
}) {
  let pickedViewport = viewports[0];

  if (viewports.length > 1) {
    pickedViewport = getViewportFromCoordinates((pickInfo === null || pickInfo === void 0 ? void 0 : pickInfo.pickedViewports) || viewports, {
      x,
      y
    });
  }

  const coordinate = pickedViewport && pickedViewport.unproject([x - pickedViewport.x, y - pickedViewport.y, z]);
  return {
    color: null,
    layer: null,
    viewport: pickedViewport,
    index: -1,
    picked: false,
    x,
    y,
    pixel: [x, y],
    coordinate,
    devicePixel: pickInfo && 'pickedX' in pickInfo ? [pickInfo.pickedX, pickInfo.pickedY] : null,
    pixelRatio
  };
}

function processPickInfo(opts) {
  const {
    pickInfo,
    lastPickedInfo,
    mode,
    layers
  } = opts;
  const {
    pickedColor,
    pickedLayer,
    pickedObjectIndex
  } = pickInfo;
  const affectedLayers = pickedLayer ? [pickedLayer] : [];

  if (mode === 'hover') {
    const lastPickedObjectIndex = lastPickedInfo.index;
    const lastPickedLayerId = lastPickedInfo.layerId;
    const pickedLayerId = pickedLayer && pickedLayer.props.id;

    if (pickedLayerId !== lastPickedLayerId || pickedObjectIndex !== lastPickedObjectIndex) {
      if (pickedLayerId !== lastPickedLayerId) {
        const lastPickedLayer = layers.find(layer => layer.props.id === lastPickedLayerId);

        if (lastPickedLayer) {
          affectedLayers.unshift(lastPickedLayer);
        }
      }

      lastPickedInfo.layerId = pickedLayerId;
      lastPickedInfo.index = pickedObjectIndex;
      lastPickedInfo.info = null;
    }
  }

  const baseInfo = getEmptyPickingInfo(opts);
  const infos = new Map();
  infos.set(null, baseInfo);
  affectedLayers.forEach(layer => {
    let info = { ...baseInfo
    };

    if (layer === pickedLayer) {
      info.color = pickedColor;
      info.index = pickedObjectIndex;
      info.picked = true;
    }

    info = getLayerPickingInfo({
      layer,
      info,
      mode
    });

    if (layer === pickedLayer && mode === 'hover') {
      lastPickedInfo.info = info;
    }

    infos.set(info.layer.id, info);

    if (mode === 'hover') {
      info.layer.updateAutoHighlight(info);
    }
  });
  return infos;
}

function getLayerPickingInfo({
  layer,
  info,
  mode
}) {
  while (layer && info) {
    const sourceLayer = info.layer || null;
    info.sourceLayer = sourceLayer;
    info.layer = layer;
    info = layer.getPickingInfo({
      info,
      mode,
      sourceLayer
    });
    layer = layer.parent;
  }

  return info;
}

function getViewportFromCoordinates(viewports, pixel) {
  for (let i = viewports.length - 1; i >= 0; i--) {
    const viewport = viewports[i];

    if (viewport.containsPixel(pixel)) {
      return viewport;
    }
  }

  return viewports[0];
}
},{}],"node_modules/@deck.gl/core/dist/esm/lib/deck-picker.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _core = require("@luma.gl/core");

var _pickLayersPass = _interopRequireDefault(require("../passes/pick-layers-pass"));

var _queryObject = require("./picking/query-object");

var _pickInfo = require("./picking/pick-info");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class DeckPicker {
  constructor(gl) {
    this.gl = gl;
    this.pickingFBO = null;
    this.pickLayersPass = new _pickLayersPass.default(gl);
    this.layerFilter = null;
    this.lastPickedInfo = {
      index: -1,
      layerId: null,
      info: null
    };
  }

  setProps(props) {
    if ('layerFilter' in props) {
      this.layerFilter = props.layerFilter;
    }

    if ('_pickable' in props) {
      this._pickable = props._pickable;
    }
  }

  finalize() {
    if (this.pickingFBO) {
      this.pickingFBO.delete();
    }

    if (this.depthFBO) {
      this.depthFBO.color.delete();
      this.depthFBO.delete();
    }
  }

  pickObject(opts) {
    return this._pickClosestObject(opts);
  }

  pickObjects(opts) {
    return this._pickVisibleObjects(opts);
  }

  getLastPickedObject({
    x,
    y,
    layers,
    viewports
  }, lastPickedInfo = this.lastPickedInfo.info) {
    const lastPickedLayerId = lastPickedInfo && lastPickedInfo.layer && lastPickedInfo.layer.id;
    const lastPickedViewportId = lastPickedInfo && lastPickedInfo.viewport && lastPickedInfo.viewport.id;
    const layer = lastPickedLayerId ? layers.find(l => l.id === lastPickedLayerId) : null;
    const viewport = lastPickedViewportId && viewports.find(v => v.id === lastPickedViewportId) || viewports[0];
    const coordinate = viewport && viewport.unproject([x - viewport.x, y - viewport.y]);
    const info = {
      x,
      y,
      viewport,
      coordinate,
      layer
    };
    return { ...lastPickedInfo,
      ...info
    };
  }

  _resizeBuffer() {
    const {
      gl
    } = this;

    if (!this.pickingFBO) {
      this.pickingFBO = new _core.Framebuffer(gl);

      if (_core.Framebuffer.isSupported(gl, {
        colorBufferFloat: true
      })) {
        this.depthFBO = new _core.Framebuffer(gl);
        this.depthFBO.attach({
          [36064]: new _core.Texture2D(gl, {
            format: (0, _core.isWebGL2)(gl) ? 34836 : 6408,
            type: 5126
          })
        });
      }
    }

    this.pickingFBO.resize({
      width: gl.canvas.width,
      height: gl.canvas.height
    });

    if (this.depthFBO) {
      this.depthFBO.resize({
        width: gl.canvas.width,
        height: gl.canvas.height
      });
    }

    return this.pickingFBO;
  }

  _getPickable(layers) {
    if (this._pickable === false) {
      return null;
    }

    const pickableLayers = layers.filter(layer => layer.isPickable() && !layer.isComposite);
    return pickableLayers.length ? pickableLayers : null;
  }

  _pickClosestObject({
    layers,
    views,
    viewports,
    x,
    y,
    radius = 0,
    depth = 1,
    mode = 'query',
    unproject3D,
    onViewportActive,
    effects
  }) {
    layers = this._getPickable(layers);

    if (!layers) {
      return {
        result: [],
        emptyInfo: (0, _pickInfo.getEmptyPickingInfo)({
          viewports,
          x,
          y
        })
      };
    }

    this._resizeBuffer();

    const pixelRatio = (0, _core.cssToDeviceRatio)(this.gl);
    const devicePixelRange = (0, _core.cssToDevicePixels)(this.gl, [x, y], true);
    const devicePixel = [devicePixelRange.x + Math.floor(devicePixelRange.width / 2), devicePixelRange.y + Math.floor(devicePixelRange.height / 2)];
    const deviceRadius = Math.round(radius * pixelRatio);
    const {
      width,
      height
    } = this.pickingFBO;

    const deviceRect = this._getPickingRect({
      deviceX: devicePixel[0],
      deviceY: devicePixel[1],
      deviceRadius,
      deviceWidth: width,
      deviceHeight: height
    });

    let infos;
    const result = [];
    const affectedLayers = new Set();

    for (let i = 0; i < depth; i++) {
      const pickedResult = deviceRect && this._drawAndSample({
        layers,
        views,
        viewports,
        onViewportActive,
        deviceRect,
        effects,
        pass: "picking:".concat(mode),
        redrawReason: mode
      });

      const pickInfo = (0, _queryObject.getClosestObject)({ ...pickedResult,
        deviceX: devicePixel[0],
        deviceY: devicePixel[1],
        deviceRadius,
        deviceRect
      });
      let z;

      if (pickInfo.pickedLayer && unproject3D && this.depthFBO) {
        const pickedResultPass2 = this._drawAndSample({
          layers: [pickInfo.pickedLayer],
          views,
          viewports,
          onViewportActive,
          deviceRect: {
            x: pickInfo.pickedX,
            y: pickInfo.pickedY,
            width: 1,
            height: 1
          },
          effects,
          pass: "picking:".concat(mode),
          redrawReason: 'pick-z',
          pickZ: true
        });

        z = pickedResultPass2.pickedColors[0];
      }

      if (pickInfo.pickedLayer && i + 1 < depth) {
        affectedLayers.add(pickInfo.pickedLayer);
        pickInfo.pickedLayer.disablePickingIndex(pickInfo.pickedObjectIndex);
      }

      infos = (0, _pickInfo.processPickInfo)({
        pickInfo,
        lastPickedInfo: this.lastPickedInfo,
        mode,
        layers,
        viewports,
        x,
        y,
        z,
        pixelRatio
      });

      for (const info of infos.values()) {
        if (info.layer) {
          result.push(info);
        }
      }

      if (!pickInfo.pickedColor) {
        break;
      }
    }

    for (const layer of affectedLayers) {
      layer.restorePickingColors();
    }

    return {
      result,
      emptyInfo: infos && infos.get(null)
    };
  }

  _pickVisibleObjects({
    layers,
    views,
    viewports,
    x,
    y,
    width = 1,
    height = 1,
    mode = 'query',
    maxObjects = null,
    onViewportActive,
    effects
  }) {
    layers = this._getPickable(layers);

    if (!layers) {
      return [];
    }

    this._resizeBuffer();

    const pixelRatio = (0, _core.cssToDeviceRatio)(this.gl);
    const leftTop = (0, _core.cssToDevicePixels)(this.gl, [x, y], true);
    const deviceLeft = leftTop.x;
    const deviceTop = leftTop.y + leftTop.height;
    const rightBottom = (0, _core.cssToDevicePixels)(this.gl, [x + width, y + height], true);
    const deviceRight = rightBottom.x + rightBottom.width;
    const deviceBottom = rightBottom.y;
    const deviceRect = {
      x: deviceLeft,
      y: deviceBottom,
      width: deviceRight - deviceLeft,
      height: deviceTop - deviceBottom
    };

    const pickedResult = this._drawAndSample({
      layers,
      views,
      viewports,
      onViewportActive,
      deviceRect,
      effects,
      pass: "picking:".concat(mode),
      redrawReason: mode
    });

    const pickInfos = (0, _queryObject.getUniqueObjects)(pickedResult);
    const uniqueInfos = new Map();
    const isMaxObjects = Number.isFinite(maxObjects);

    for (let i = 0; i < pickInfos.length; i++) {
      if (isMaxObjects && uniqueInfos.size >= maxObjects) {
        break;
      }

      const pickInfo = pickInfos[i];
      let info = {
        color: pickInfo.pickedColor,
        layer: null,
        index: pickInfo.pickedObjectIndex,
        picked: true,
        x,
        y,
        width,
        height,
        pixelRatio
      };
      info = (0, _pickInfo.getLayerPickingInfo)({
        layer: pickInfo.pickedLayer,
        info,
        mode
      });

      if (!uniqueInfos.has(info.object)) {
        uniqueInfos.set(info.object, info);
      }
    }

    return Array.from(uniqueInfos.values());
  }

  _drawAndSample({
    layers,
    views,
    viewports,
    onViewportActive,
    deviceRect,
    effects,
    pass,
    redrawReason,
    pickZ
  }) {
    const pickingFBO = pickZ ? this.depthFBO : this.pickingFBO;
    const {
      decodePickingColor
    } = this.pickLayersPass.render({
      layers,
      layerFilter: this.layerFilter,
      views,
      viewports,
      onViewportActive,
      pickingFBO,
      deviceRect,
      effects,
      pass,
      redrawReason,
      pickZ
    });
    const {
      x,
      y,
      width,
      height
    } = deviceRect;
    const pickedColors = new (pickZ ? Float32Array : Uint8Array)(width * height * 4);
    (0, _core.readPixelsToArray)(pickingFBO, {
      sourceX: x,
      sourceY: y,
      sourceWidth: width,
      sourceHeight: height,
      target: pickedColors
    });
    return {
      pickedColors,
      decodePickingColor
    };
  }

  _getPickingRect({
    deviceX,
    deviceY,
    deviceRadius,
    deviceWidth,
    deviceHeight
  }) {
    const x = Math.max(0, deviceX - deviceRadius);
    const y = Math.max(0, deviceY - deviceRadius);
    const width = Math.min(deviceWidth, deviceX + deviceRadius + 1) - x;
    const height = Math.min(deviceHeight, deviceY + deviceRadius + 1) - y;

    if (width <= 0 || height <= 0) {
      return null;
    }

    return {
      x,
      y,
      width,
      height
    };
  }

}

exports.default = DeckPicker;
},{"@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","../passes/pick-layers-pass":"node_modules/@deck.gl/core/dist/esm/passes/pick-layers-pass.js","./picking/query-object":"node_modules/@deck.gl/core/dist/esm/lib/picking/query-object.js","./picking/pick-info":"node_modules/@deck.gl/core/dist/esm/lib/picking/pick-info.js"}],"node_modules/@deck.gl/core/dist/esm/lib/tooltip.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
const defaultStyle = {
  zIndex: 1,
  position: 'absolute',
  pointerEvents: 'none',
  color: '#a0a7b4',
  backgroundColor: '#29323c',
  padding: '10px',
  top: 0,
  left: 0,
  display: 'none'
};

class Tooltip {
  constructor(canvas) {
    const canvasParent = canvas.parentElement;

    if (canvasParent) {
      this.el = document.createElement('div');
      this.el.className = 'deck-tooltip';
      Object.assign(this.el.style, defaultStyle);
      canvasParent.appendChild(this.el);
    }

    this.isVisible = false;
  }

  setTooltip(displayInfo, x, y) {
    const el = this.el;

    if (typeof displayInfo === 'string') {
      el.innerText = displayInfo;
    } else if (!displayInfo) {
      this.isVisible = false;
      el.style.display = 'none';
      return;
    } else {
      if ('text' in displayInfo) {
        el.innerText = displayInfo.text;
      }

      if ('html' in displayInfo) {
        el.innerHTML = displayInfo.html;
      }

      if ('className' in displayInfo) {
        el.className = displayInfo.className;
      }

      Object.assign(el.style, displayInfo.style);
    }

    this.isVisible = true;
    el.style.display = 'block';
    el.style.transform = "translate(".concat(x, "px, ").concat(y, "px)");
  }

  remove() {
    if (this.el) {
      this.el.remove();
    }
  }

}

exports.default = Tooltip;
},{}],"node_modules/hammerjs/hammer.js":[function(require,module,exports) {
var define;
/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */
(function (window, document, exportName, undefined) {
  'use strict';

  var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
  var TEST_ELEMENT = document.createElement('div');
  var TYPE_FUNCTION = 'function';
  var round = Math.round;
  var abs = Math.abs;
  var now = Date.now;
  /**
   * set a timeout with a given scope
   * @param {Function} fn
   * @param {Number} timeout
   * @param {Object} context
   * @returns {number}
   */

  function setTimeoutContext(fn, timeout, context) {
    return setTimeout(bindFn(fn, context), timeout);
  }
  /**
   * if the argument is an array, we want to execute the fn on each entry
   * if it aint an array we don't want to do a thing.
   * this is used by all the methods that accept a single and array argument.
   * @param {*|Array} arg
   * @param {String} fn
   * @param {Object} [context]
   * @returns {Boolean}
   */


  function invokeArrayArg(arg, fn, context) {
    if (Array.isArray(arg)) {
      each(arg, context[fn], context);
      return true;
    }

    return false;
  }
  /**
   * walk objects and arrays
   * @param {Object} obj
   * @param {Function} iterator
   * @param {Object} context
   */


  function each(obj, iterator, context) {
    var i;

    if (!obj) {
      return;
    }

    if (obj.forEach) {
      obj.forEach(iterator, context);
    } else if (obj.length !== undefined) {
      i = 0;

      while (i < obj.length) {
        iterator.call(context, obj[i], i, obj);
        i++;
      }
    } else {
      for (i in obj) {
        obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
      }
    }
  }
  /**
   * wrap a method with a deprecation warning and stack trace
   * @param {Function} method
   * @param {String} name
   * @param {String} message
   * @returns {Function} A new function wrapping the supplied method.
   */


  function deprecate(method, name, message) {
    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
    return function () {
      var e = new Error('get-stack-trace');
      var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '').replace(/^\s+at\s+/gm, '').replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';
      var log = window.console && (window.console.warn || window.console.log);

      if (log) {
        log.call(window.console, deprecationMessage, stack);
      }

      return method.apply(this, arguments);
    };
  }
  /**
   * extend object.
   * means that properties in dest will be overwritten by the ones in src.
   * @param {Object} target
   * @param {...Object} objects_to_assign
   * @returns {Object} target
   */


  var assign;

  if (typeof Object.assign !== 'function') {
    assign = function assign(target) {
      if (target === undefined || target === null) {
        throw new TypeError('Cannot convert undefined or null to object');
      }

      var output = Object(target);

      for (var index = 1; index < arguments.length; index++) {
        var source = arguments[index];

        if (source !== undefined && source !== null) {
          for (var nextKey in source) {
            if (source.hasOwnProperty(nextKey)) {
              output[nextKey] = source[nextKey];
            }
          }
        }
      }

      return output;
    };
  } else {
    assign = Object.assign;
  }
  /**
   * extend object.
   * means that properties in dest will be overwritten by the ones in src.
   * @param {Object} dest
   * @param {Object} src
   * @param {Boolean} [merge=false]
   * @returns {Object} dest
   */


  var extend = deprecate(function extend(dest, src, merge) {
    var keys = Object.keys(src);
    var i = 0;

    while (i < keys.length) {
      if (!merge || merge && dest[keys[i]] === undefined) {
        dest[keys[i]] = src[keys[i]];
      }

      i++;
    }

    return dest;
  }, 'extend', 'Use `assign`.');
  /**
   * merge the values from src in the dest.
   * means that properties that exist in dest will not be overwritten by src
   * @param {Object} dest
   * @param {Object} src
   * @returns {Object} dest
   */

  var merge = deprecate(function merge(dest, src) {
    return extend(dest, src, true);
  }, 'merge', 'Use `assign`.');
  /**
   * simple class inheritance
   * @param {Function} child
   * @param {Function} base
   * @param {Object} [properties]
   */

  function inherit(child, base, properties) {
    var baseP = base.prototype,
        childP;
    childP = child.prototype = Object.create(baseP);
    childP.constructor = child;
    childP._super = baseP;

    if (properties) {
      assign(childP, properties);
    }
  }
  /**
   * simple function bind
   * @param {Function} fn
   * @param {Object} context
   * @returns {Function}
   */


  function bindFn(fn, context) {
    return function boundFn() {
      return fn.apply(context, arguments);
    };
  }
  /**
   * let a boolean value also be a function that must return a boolean
   * this first item in args will be used as the context
   * @param {Boolean|Function} val
   * @param {Array} [args]
   * @returns {Boolean}
   */


  function boolOrFn(val, args) {
    if (typeof val == TYPE_FUNCTION) {
      return val.apply(args ? args[0] || undefined : undefined, args);
    }

    return val;
  }
  /**
   * use the val2 when val1 is undefined
   * @param {*} val1
   * @param {*} val2
   * @returns {*}
   */


  function ifUndefined(val1, val2) {
    return val1 === undefined ? val2 : val1;
  }
  /**
   * addEventListener with multiple events at once
   * @param {EventTarget} target
   * @param {String} types
   * @param {Function} handler
   */


  function addEventListeners(target, types, handler) {
    each(splitStr(types), function (type) {
      target.addEventListener(type, handler, false);
    });
  }
  /**
   * removeEventListener with multiple events at once
   * @param {EventTarget} target
   * @param {String} types
   * @param {Function} handler
   */


  function removeEventListeners(target, types, handler) {
    each(splitStr(types), function (type) {
      target.removeEventListener(type, handler, false);
    });
  }
  /**
   * find if a node is in the given parent
   * @method hasParent
   * @param {HTMLElement} node
   * @param {HTMLElement} parent
   * @return {Boolean} found
   */


  function hasParent(node, parent) {
    while (node) {
      if (node == parent) {
        return true;
      }

      node = node.parentNode;
    }

    return false;
  }
  /**
   * small indexOf wrapper
   * @param {String} str
   * @param {String} find
   * @returns {Boolean} found
   */


  function inStr(str, find) {
    return str.indexOf(find) > -1;
  }
  /**
   * split string on whitespace
   * @param {String} str
   * @returns {Array} words
   */


  function splitStr(str) {
    return str.trim().split(/\s+/g);
  }
  /**
   * find if a array contains the object using indexOf or a simple polyFill
   * @param {Array} src
   * @param {String} find
   * @param {String} [findByKey]
   * @return {Boolean|Number} false when not found, or the index
   */


  function inArray(src, find, findByKey) {
    if (src.indexOf && !findByKey) {
      return src.indexOf(find);
    } else {
      var i = 0;

      while (i < src.length) {
        if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {
          return i;
        }

        i++;
      }

      return -1;
    }
  }
  /**
   * convert array-like objects to real arrays
   * @param {Object} obj
   * @returns {Array}
   */


  function toArray(obj) {
    return Array.prototype.slice.call(obj, 0);
  }
  /**
   * unique array with objects based on a key (like 'id') or just by the array's value
   * @param {Array} src [{id:1},{id:2},{id:1}]
   * @param {String} [key]
   * @param {Boolean} [sort=False]
   * @returns {Array} [{id:1},{id:2}]
   */


  function uniqueArray(src, key, sort) {
    var results = [];
    var values = [];
    var i = 0;

    while (i < src.length) {
      var val = key ? src[i][key] : src[i];

      if (inArray(values, val) < 0) {
        results.push(src[i]);
      }

      values[i] = val;
      i++;
    }

    if (sort) {
      if (!key) {
        results = results.sort();
      } else {
        results = results.sort(function sortUniqueArray(a, b) {
          return a[key] > b[key];
        });
      }
    }

    return results;
  }
  /**
   * get the prefixed property
   * @param {Object} obj
   * @param {String} property
   * @returns {String|Undefined} prefixed
   */


  function prefixed(obj, property) {
    var prefix, prop;
    var camelProp = property[0].toUpperCase() + property.slice(1);
    var i = 0;

    while (i < VENDOR_PREFIXES.length) {
      prefix = VENDOR_PREFIXES[i];
      prop = prefix ? prefix + camelProp : property;

      if (prop in obj) {
        return prop;
      }

      i++;
    }

    return undefined;
  }
  /**
   * get a unique id
   * @returns {number} uniqueId
   */


  var _uniqueId = 1;

  function uniqueId() {
    return _uniqueId++;
  }
  /**
   * get the window object of an element
   * @param {HTMLElement} element
   * @returns {DocumentView|Window}
   */


  function getWindowForElement(element) {
    var doc = element.ownerDocument || element;
    return doc.defaultView || doc.parentWindow || window;
  }

  var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
  var SUPPORT_TOUCH = ('ontouchstart' in window);
  var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
  var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
  var INPUT_TYPE_TOUCH = 'touch';
  var INPUT_TYPE_PEN = 'pen';
  var INPUT_TYPE_MOUSE = 'mouse';
  var INPUT_TYPE_KINECT = 'kinect';
  var COMPUTE_INTERVAL = 25;
  var INPUT_START = 1;
  var INPUT_MOVE = 2;
  var INPUT_END = 4;
  var INPUT_CANCEL = 8;
  var DIRECTION_NONE = 1;
  var DIRECTION_LEFT = 2;
  var DIRECTION_RIGHT = 4;
  var DIRECTION_UP = 8;
  var DIRECTION_DOWN = 16;
  var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
  var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
  var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
  var PROPS_XY = ['x', 'y'];
  var PROPS_CLIENT_XY = ['clientX', 'clientY'];
  /**
   * create new input type manager
   * @param {Manager} manager
   * @param {Function} callback
   * @returns {Input}
   * @constructor
   */

  function Input(manager, callback) {
    var self = this;
    this.manager = manager;
    this.callback = callback;
    this.element = manager.element;
    this.target = manager.options.inputTarget; // smaller wrapper around the handler, for the scope and the enabled state of the manager,
    // so when disabled the input events are completely bypassed.

    this.domHandler = function (ev) {
      if (boolOrFn(manager.options.enable, [manager])) {
        self.handler(ev);
      }
    };

    this.init();
  }

  Input.prototype = {
    /**
     * should handle the inputEvent data and trigger the callback
     * @virtual
     */
    handler: function () {},

    /**
     * bind the events
     */
    init: function () {
      this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
      this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
      this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    },

    /**
     * unbind the events
     */
    destroy: function () {
      this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
      this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
      this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    }
  };
  /**
   * create new input type manager
   * called by the Manager constructor
   * @param {Hammer} manager
   * @returns {Input}
   */

  function createInputInstance(manager) {
    var Type;
    var inputClass = manager.options.inputClass;

    if (inputClass) {
      Type = inputClass;
    } else if (SUPPORT_POINTER_EVENTS) {
      Type = PointerEventInput;
    } else if (SUPPORT_ONLY_TOUCH) {
      Type = TouchInput;
    } else if (!SUPPORT_TOUCH) {
      Type = MouseInput;
    } else {
      Type = TouchMouseInput;
    }

    return new Type(manager, inputHandler);
  }
  /**
   * handle input events
   * @param {Manager} manager
   * @param {String} eventType
   * @param {Object} input
   */


  function inputHandler(manager, eventType, input) {
    var pointersLen = input.pointers.length;
    var changedPointersLen = input.changedPointers.length;
    var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;
    var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
    input.isFirst = !!isFirst;
    input.isFinal = !!isFinal;

    if (isFirst) {
      manager.session = {};
    } // source event is the normalized value of the domEvents
    // like 'touchstart, mouseup, pointerdown'


    input.eventType = eventType; // compute scale, rotation etc

    computeInputData(manager, input); // emit secret event

    manager.emit('hammer.input', input);
    manager.recognize(input);
    manager.session.prevInput = input;
  }
  /**
   * extend the data with some usable properties like scale, rotate, velocity etc
   * @param {Object} manager
   * @param {Object} input
   */


  function computeInputData(manager, input) {
    var session = manager.session;
    var pointers = input.pointers;
    var pointersLength = pointers.length; // store the first input to calculate the distance and direction

    if (!session.firstInput) {
      session.firstInput = simpleCloneInputData(input);
    } // to compute scale and rotation we need to store the multiple touches


    if (pointersLength > 1 && !session.firstMultiple) {
      session.firstMultiple = simpleCloneInputData(input);
    } else if (pointersLength === 1) {
      session.firstMultiple = false;
    }

    var firstInput = session.firstInput;
    var firstMultiple = session.firstMultiple;
    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
    var center = input.center = getCenter(pointers);
    input.timeStamp = now();
    input.deltaTime = input.timeStamp - firstInput.timeStamp;
    input.angle = getAngle(offsetCenter, center);
    input.distance = getDistance(offsetCenter, center);
    computeDeltaXY(session, input);
    input.offsetDirection = getDirection(input.deltaX, input.deltaY);
    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
    input.overallVelocityX = overallVelocity.x;
    input.overallVelocityY = overallVelocity.y;
    input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;
    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
    input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;
    computeIntervalInputData(session, input); // find the correct target

    var target = manager.element;

    if (hasParent(input.srcEvent.target, target)) {
      target = input.srcEvent.target;
    }

    input.target = target;
  }

  function computeDeltaXY(session, input) {
    var center = input.center;
    var offset = session.offsetDelta || {};
    var prevDelta = session.prevDelta || {};
    var prevInput = session.prevInput || {};

    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
      prevDelta = session.prevDelta = {
        x: prevInput.deltaX || 0,
        y: prevInput.deltaY || 0
      };
      offset = session.offsetDelta = {
        x: center.x,
        y: center.y
      };
    }

    input.deltaX = prevDelta.x + (center.x - offset.x);
    input.deltaY = prevDelta.y + (center.y - offset.y);
  }
  /**
   * velocity is calculated every x ms
   * @param {Object} session
   * @param {Object} input
   */


  function computeIntervalInputData(session, input) {
    var last = session.lastInterval || input,
        deltaTime = input.timeStamp - last.timeStamp,
        velocity,
        velocityX,
        velocityY,
        direction;

    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
      var deltaX = input.deltaX - last.deltaX;
      var deltaY = input.deltaY - last.deltaY;
      var v = getVelocity(deltaTime, deltaX, deltaY);
      velocityX = v.x;
      velocityY = v.y;
      velocity = abs(v.x) > abs(v.y) ? v.x : v.y;
      direction = getDirection(deltaX, deltaY);
      session.lastInterval = input;
    } else {
      // use latest velocity info if it doesn't overtake a minimum period
      velocity = last.velocity;
      velocityX = last.velocityX;
      velocityY = last.velocityY;
      direction = last.direction;
    }

    input.velocity = velocity;
    input.velocityX = velocityX;
    input.velocityY = velocityY;
    input.direction = direction;
  }
  /**
   * create a simple clone from the input used for storage of firstInput and firstMultiple
   * @param {Object} input
   * @returns {Object} clonedInputData
   */


  function simpleCloneInputData(input) {
    // make a simple copy of the pointers because we will get a reference if we don't
    // we only need clientXY for the calculations
    var pointers = [];
    var i = 0;

    while (i < input.pointers.length) {
      pointers[i] = {
        clientX: round(input.pointers[i].clientX),
        clientY: round(input.pointers[i].clientY)
      };
      i++;
    }

    return {
      timeStamp: now(),
      pointers: pointers,
      center: getCenter(pointers),
      deltaX: input.deltaX,
      deltaY: input.deltaY
    };
  }
  /**
   * get the center of all the pointers
   * @param {Array} pointers
   * @return {Object} center contains `x` and `y` properties
   */


  function getCenter(pointers) {
    var pointersLength = pointers.length; // no need to loop when only one touch

    if (pointersLength === 1) {
      return {
        x: round(pointers[0].clientX),
        y: round(pointers[0].clientY)
      };
    }

    var x = 0,
        y = 0,
        i = 0;

    while (i < pointersLength) {
      x += pointers[i].clientX;
      y += pointers[i].clientY;
      i++;
    }

    return {
      x: round(x / pointersLength),
      y: round(y / pointersLength)
    };
  }
  /**
   * calculate the velocity between two points. unit is in px per ms.
   * @param {Number} deltaTime
   * @param {Number} x
   * @param {Number} y
   * @return {Object} velocity `x` and `y`
   */


  function getVelocity(deltaTime, x, y) {
    return {
      x: x / deltaTime || 0,
      y: y / deltaTime || 0
    };
  }
  /**
   * get the direction between two points
   * @param {Number} x
   * @param {Number} y
   * @return {Number} direction
   */


  function getDirection(x, y) {
    if (x === y) {
      return DIRECTION_NONE;
    }

    if (abs(x) >= abs(y)) {
      return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }

    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
  }
  /**
   * calculate the absolute distance between two points
   * @param {Object} p1 {x, y}
   * @param {Object} p2 {x, y}
   * @param {Array} [props] containing x and y keys
   * @return {Number} distance
   */


  function getDistance(p1, p2, props) {
    if (!props) {
      props = PROPS_XY;
    }

    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];
    return Math.sqrt(x * x + y * y);
  }
  /**
   * calculate the angle between two coordinates
   * @param {Object} p1
   * @param {Object} p2
   * @param {Array} [props] containing x and y keys
   * @return {Number} angle
   */


  function getAngle(p1, p2, props) {
    if (!props) {
      props = PROPS_XY;
    }

    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];
    return Math.atan2(y, x) * 180 / Math.PI;
  }
  /**
   * calculate the rotation degrees between two pointersets
   * @param {Array} start array of pointers
   * @param {Array} end array of pointers
   * @return {Number} rotation
   */


  function getRotation(start, end) {
    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
  }
  /**
   * calculate the scale factor between two pointersets
   * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
   * @param {Array} start array of pointers
   * @param {Array} end array of pointers
   * @return {Number} scale
   */


  function getScale(start, end) {
    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
  }

  var MOUSE_INPUT_MAP = {
    mousedown: INPUT_START,
    mousemove: INPUT_MOVE,
    mouseup: INPUT_END
  };
  var MOUSE_ELEMENT_EVENTS = 'mousedown';
  var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';
  /**
   * Mouse events input
   * @constructor
   * @extends Input
   */

  function MouseInput() {
    this.evEl = MOUSE_ELEMENT_EVENTS;
    this.evWin = MOUSE_WINDOW_EVENTS;
    this.pressed = false; // mousedown state

    Input.apply(this, arguments);
  }

  inherit(MouseInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function MEhandler(ev) {
      var eventType = MOUSE_INPUT_MAP[ev.type]; // on start we want to have the left mouse button down

      if (eventType & INPUT_START && ev.button === 0) {
        this.pressed = true;
      }

      if (eventType & INPUT_MOVE && ev.which !== 1) {
        eventType = INPUT_END;
      } // mouse must be down


      if (!this.pressed) {
        return;
      }

      if (eventType & INPUT_END) {
        this.pressed = false;
      }

      this.callback(this.manager, eventType, {
        pointers: [ev],
        changedPointers: [ev],
        pointerType: INPUT_TYPE_MOUSE,
        srcEvent: ev
      });
    }
  });
  var POINTER_INPUT_MAP = {
    pointerdown: INPUT_START,
    pointermove: INPUT_MOVE,
    pointerup: INPUT_END,
    pointercancel: INPUT_CANCEL,
    pointerout: INPUT_CANCEL
  }; // in IE10 the pointer types is defined as an enum

  var IE10_POINTER_TYPE_ENUM = {
    2: INPUT_TYPE_TOUCH,
    3: INPUT_TYPE_PEN,
    4: INPUT_TYPE_MOUSE,
    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816

  };
  var POINTER_ELEMENT_EVENTS = 'pointerdown';
  var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel'; // IE10 has prefixed support, and case-sensitive

  if (window.MSPointerEvent && !window.PointerEvent) {
    POINTER_ELEMENT_EVENTS = 'MSPointerDown';
    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
  }
  /**
   * Pointer events input
   * @constructor
   * @extends Input
   */


  function PointerEventInput() {
    this.evEl = POINTER_ELEMENT_EVENTS;
    this.evWin = POINTER_WINDOW_EVENTS;
    Input.apply(this, arguments);
    this.store = this.manager.session.pointerEvents = [];
  }

  inherit(PointerEventInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function PEhandler(ev) {
      var store = this.store;
      var removePointer = false;
      var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
      var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
      var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
      var isTouch = pointerType == INPUT_TYPE_TOUCH; // get index of the event in the store

      var storeIndex = inArray(store, ev.pointerId, 'pointerId'); // start and mouse must be down

      if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
        if (storeIndex < 0) {
          store.push(ev);
          storeIndex = store.length - 1;
        }
      } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
        removePointer = true;
      } // it not found, so the pointer hasn't been down (so it's probably a hover)


      if (storeIndex < 0) {
        return;
      } // update the event in the store


      store[storeIndex] = ev;
      this.callback(this.manager, eventType, {
        pointers: store,
        changedPointers: [ev],
        pointerType: pointerType,
        srcEvent: ev
      });

      if (removePointer) {
        // remove from the store
        store.splice(storeIndex, 1);
      }
    }
  });
  var SINGLE_TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
  };
  var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
  var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';
  /**
   * Touch events input
   * @constructor
   * @extends Input
   */

  function SingleTouchInput() {
    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
    this.started = false;
    Input.apply(this, arguments);
  }

  inherit(SingleTouchInput, Input, {
    handler: function TEhandler(ev) {
      var type = SINGLE_TOUCH_INPUT_MAP[ev.type]; // should we handle the touch events?

      if (type === INPUT_START) {
        this.started = true;
      }

      if (!this.started) {
        return;
      }

      var touches = normalizeSingleTouches.call(this, ev, type); // when done, reset the started state

      if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
        this.started = false;
      }

      this.callback(this.manager, type, {
        pointers: touches[0],
        changedPointers: touches[1],
        pointerType: INPUT_TYPE_TOUCH,
        srcEvent: ev
      });
    }
  });
  /**
   * @this {TouchInput}
   * @param {Object} ev
   * @param {Number} type flag
   * @returns {undefined|Array} [all, changed]
   */

  function normalizeSingleTouches(ev, type) {
    var all = toArray(ev.touches);
    var changed = toArray(ev.changedTouches);

    if (type & (INPUT_END | INPUT_CANCEL)) {
      all = uniqueArray(all.concat(changed), 'identifier', true);
    }

    return [all, changed];
  }

  var TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
  };
  var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';
  /**
   * Multi-user touch events input
   * @constructor
   * @extends Input
   */

  function TouchInput() {
    this.evTarget = TOUCH_TARGET_EVENTS;
    this.targetIds = {};
    Input.apply(this, arguments);
  }

  inherit(TouchInput, Input, {
    handler: function MTEhandler(ev) {
      var type = TOUCH_INPUT_MAP[ev.type];
      var touches = getTouches.call(this, ev, type);

      if (!touches) {
        return;
      }

      this.callback(this.manager, type, {
        pointers: touches[0],
        changedPointers: touches[1],
        pointerType: INPUT_TYPE_TOUCH,
        srcEvent: ev
      });
    }
  });
  /**
   * @this {TouchInput}
   * @param {Object} ev
   * @param {Number} type flag
   * @returns {undefined|Array} [all, changed]
   */

  function getTouches(ev, type) {
    var allTouches = toArray(ev.touches);
    var targetIds = this.targetIds; // when there is only one touch, the process can be simplified

    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
      targetIds[allTouches[0].identifier] = true;
      return [allTouches, allTouches];
    }

    var i,
        targetTouches,
        changedTouches = toArray(ev.changedTouches),
        changedTargetTouches = [],
        target = this.target; // get target touches from touches

    targetTouches = allTouches.filter(function (touch) {
      return hasParent(touch.target, target);
    }); // collect touches

    if (type === INPUT_START) {
      i = 0;

      while (i < targetTouches.length) {
        targetIds[targetTouches[i].identifier] = true;
        i++;
      }
    } // filter changed touches to only contain touches that exist in the collected target ids


    i = 0;

    while (i < changedTouches.length) {
      if (targetIds[changedTouches[i].identifier]) {
        changedTargetTouches.push(changedTouches[i]);
      } // cleanup removed touches


      if (type & (INPUT_END | INPUT_CANCEL)) {
        delete targetIds[changedTouches[i].identifier];
      }

      i++;
    }

    if (!changedTargetTouches.length) {
      return;
    }

    return [// merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
    uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];
  }
  /**
   * Combined touch and mouse input
   *
   * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
   * This because touch devices also emit mouse events while doing a touch.
   *
   * @constructor
   * @extends Input
   */


  var DEDUP_TIMEOUT = 2500;
  var DEDUP_DISTANCE = 25;

  function TouchMouseInput() {
    Input.apply(this, arguments);
    var handler = bindFn(this.handler, this);
    this.touch = new TouchInput(this.manager, handler);
    this.mouse = new MouseInput(this.manager, handler);
    this.primaryTouch = null;
    this.lastTouches = [];
  }

  inherit(TouchMouseInput, Input, {
    /**
     * handle mouse and touch events
     * @param {Hammer} manager
     * @param {String} inputEvent
     * @param {Object} inputData
     */
    handler: function TMEhandler(manager, inputEvent, inputData) {
      var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH,
          isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;

      if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
        return;
      } // when we're in a touch event, record touches to  de-dupe synthetic mouse event


      if (isTouch) {
        recordTouches.call(this, inputEvent, inputData);
      } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
        return;
      }

      this.callback(manager, inputEvent, inputData);
    },

    /**
     * remove the event listeners
     */
    destroy: function destroy() {
      this.touch.destroy();
      this.mouse.destroy();
    }
  });

  function recordTouches(eventType, eventData) {
    if (eventType & INPUT_START) {
      this.primaryTouch = eventData.changedPointers[0].identifier;
      setLastTouch.call(this, eventData);
    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
      setLastTouch.call(this, eventData);
    }
  }

  function setLastTouch(eventData) {
    var touch = eventData.changedPointers[0];

    if (touch.identifier === this.primaryTouch) {
      var lastTouch = {
        x: touch.clientX,
        y: touch.clientY
      };
      this.lastTouches.push(lastTouch);
      var lts = this.lastTouches;

      var removeLastTouch = function () {
        var i = lts.indexOf(lastTouch);

        if (i > -1) {
          lts.splice(i, 1);
        }
      };

      setTimeout(removeLastTouch, DEDUP_TIMEOUT);
    }
  }

  function isSyntheticEvent(eventData) {
    var x = eventData.srcEvent.clientX,
        y = eventData.srcEvent.clientY;

    for (var i = 0; i < this.lastTouches.length; i++) {
      var t = this.lastTouches[i];
      var dx = Math.abs(x - t.x),
          dy = Math.abs(y - t.y);

      if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
        return true;
      }
    }

    return false;
  }

  var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
  var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined; // magical touchAction value

  var TOUCH_ACTION_COMPUTE = 'compute';
  var TOUCH_ACTION_AUTO = 'auto';
  var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented

  var TOUCH_ACTION_NONE = 'none';
  var TOUCH_ACTION_PAN_X = 'pan-x';
  var TOUCH_ACTION_PAN_Y = 'pan-y';
  var TOUCH_ACTION_MAP = getTouchActionProps();
  /**
   * Touch Action
   * sets the touchAction property or uses the js alternative
   * @param {Manager} manager
   * @param {String} value
   * @constructor
   */

  function TouchAction(manager, value) {
    this.manager = manager;
    this.set(value);
  }

  TouchAction.prototype = {
    /**
     * set the touchAction value on the element or enable the polyfill
     * @param {String} value
     */
    set: function (value) {
      // find out the touch-action by the event handlers
      if (value == TOUCH_ACTION_COMPUTE) {
        value = this.compute();
      }

      if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
        this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
      }

      this.actions = value.toLowerCase().trim();
    },

    /**
     * just re-set the touchAction value
     */
    update: function () {
      this.set(this.manager.options.touchAction);
    },

    /**
     * compute the value for the touchAction property based on the recognizer's settings
     * @returns {String} value
     */
    compute: function () {
      var actions = [];
      each(this.manager.recognizers, function (recognizer) {
        if (boolOrFn(recognizer.options.enable, [recognizer])) {
          actions = actions.concat(recognizer.getTouchAction());
        }
      });
      return cleanTouchActions(actions.join(' '));
    },

    /**
     * this method is called on each input cycle and provides the preventing of the browser behavior
     * @param {Object} input
     */
    preventDefaults: function (input) {
      var srcEvent = input.srcEvent;
      var direction = input.offsetDirection; // if the touch action did prevented once this session

      if (this.manager.session.prevented) {
        srcEvent.preventDefault();
        return;
      }

      var actions = this.actions;
      var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
      var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
      var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];

      if (hasNone) {
        //do not prevent defaults if this is a tap gesture
        var isTapPointer = input.pointers.length === 1;
        var isTapMovement = input.distance < 2;
        var isTapTouchTime = input.deltaTime < 250;

        if (isTapPointer && isTapMovement && isTapTouchTime) {
          return;
        }
      }

      if (hasPanX && hasPanY) {
        // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
        return;
      }

      if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {
        return this.preventSrc(srcEvent);
      }
    },

    /**
     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
     * @param {Object} srcEvent
     */
    preventSrc: function (srcEvent) {
      this.manager.session.prevented = true;
      srcEvent.preventDefault();
    }
  };
  /**
   * when the touchActions are collected they are not a valid value, so we need to clean things up. *
   * @param {String} actions
   * @returns {*}
   */

  function cleanTouchActions(actions) {
    // none
    if (inStr(actions, TOUCH_ACTION_NONE)) {
      return TOUCH_ACTION_NONE;
    }

    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y); // if both pan-x and pan-y are set (different recognizers
    // for different directions, e.g. horizontal pan but vertical swipe?)
    // we need none (as otherwise with pan-x pan-y combined none of these
    // recognizers will work, since the browser would handle all panning

    if (hasPanX && hasPanY) {
      return TOUCH_ACTION_NONE;
    } // pan-x OR pan-y


    if (hasPanX || hasPanY) {
      return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
    } // manipulation


    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
      return TOUCH_ACTION_MANIPULATION;
    }

    return TOUCH_ACTION_AUTO;
  }

  function getTouchActionProps() {
    if (!NATIVE_TOUCH_ACTION) {
      return false;
    }

    var touchMap = {};
    var cssSupports = window.CSS && window.CSS.supports;
    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function (val) {
      // If css.supports is not supported but there is native touch-action assume it supports
      // all values. This is the case for IE 10 and 11.
      touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;
    });
    return touchMap;
  }
  /**
   * Recognizer flow explained; *
   * All recognizers have the initial state of POSSIBLE when a input session starts.
   * The definition of a input session is from the first input until the last input, with all it's movement in it. *
   * Example session for mouse-input: mousedown -> mousemove -> mouseup
   *
   * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
   * which determines with state it should be.
   *
   * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
   * POSSIBLE to give it another change on the next cycle.
   *
   *               Possible
   *                  |
   *            +-----+---------------+
   *            |                     |
   *      +-----+-----+               |
   *      |           |               |
   *   Failed      Cancelled          |
   *                          +-------+------+
   *                          |              |
   *                      Recognized       Began
   *                                         |
   *                                      Changed
   *                                         |
   *                                  Ended/Recognized
   */


  var STATE_POSSIBLE = 1;
  var STATE_BEGAN = 2;
  var STATE_CHANGED = 4;
  var STATE_ENDED = 8;
  var STATE_RECOGNIZED = STATE_ENDED;
  var STATE_CANCELLED = 16;
  var STATE_FAILED = 32;
  /**
   * Recognizer
   * Every recognizer needs to extend from this class.
   * @constructor
   * @param {Object} options
   */

  function Recognizer(options) {
    this.options = assign({}, this.defaults, options || {});
    this.id = uniqueId();
    this.manager = null; // default is enable true

    this.options.enable = ifUndefined(this.options.enable, true);
    this.state = STATE_POSSIBLE;
    this.simultaneous = {};
    this.requireFail = [];
  }

  Recognizer.prototype = {
    /**
     * @virtual
     * @type {Object}
     */
    defaults: {},

    /**
     * set options
     * @param {Object} options
     * @return {Recognizer}
     */
    set: function (options) {
      assign(this.options, options); // also update the touchAction, in case something changed about the directions/enabled state

      this.manager && this.manager.touchAction.update();
      return this;
    },

    /**
     * recognize simultaneous with an other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    recognizeWith: function (otherRecognizer) {
      if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
        return this;
      }

      var simultaneous = this.simultaneous;
      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);

      if (!simultaneous[otherRecognizer.id]) {
        simultaneous[otherRecognizer.id] = otherRecognizer;
        otherRecognizer.recognizeWith(this);
      }

      return this;
    },

    /**
     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRecognizeWith: function (otherRecognizer) {
      if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
        return this;
      }

      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
      delete this.simultaneous[otherRecognizer.id];
      return this;
    },

    /**
     * recognizer can only run when an other is failing
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    requireFailure: function (otherRecognizer) {
      if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
        return this;
      }

      var requireFail = this.requireFail;
      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);

      if (inArray(requireFail, otherRecognizer) === -1) {
        requireFail.push(otherRecognizer);
        otherRecognizer.requireFailure(this);
      }

      return this;
    },

    /**
     * drop the requireFailure link. it does not remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRequireFailure: function (otherRecognizer) {
      if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
        return this;
      }

      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
      var index = inArray(this.requireFail, otherRecognizer);

      if (index > -1) {
        this.requireFail.splice(index, 1);
      }

      return this;
    },

    /**
     * has require failures boolean
     * @returns {boolean}
     */
    hasRequireFailures: function () {
      return this.requireFail.length > 0;
    },

    /**
     * if the recognizer can recognize simultaneous with an other recognizer
     * @param {Recognizer} otherRecognizer
     * @returns {Boolean}
     */
    canRecognizeWith: function (otherRecognizer) {
      return !!this.simultaneous[otherRecognizer.id];
    },

    /**
     * You should use `tryEmit` instead of `emit` directly to check
     * that all the needed recognizers has failed before emitting.
     * @param {Object} input
     */
    emit: function (input) {
      var self = this;
      var state = this.state;

      function emit(event) {
        self.manager.emit(event, input);
      } // 'panstart' and 'panmove'


      if (state < STATE_ENDED) {
        emit(self.options.event + stateStr(state));
      }

      emit(self.options.event); // simple 'eventName' events

      if (input.additionalEvent) {
        // additional event(panleft, panright, pinchin, pinchout...)
        emit(input.additionalEvent);
      } // panend and pancancel


      if (state >= STATE_ENDED) {
        emit(self.options.event + stateStr(state));
      }
    },

    /**
     * Check that all the require failure recognizers has failed,
     * if true, it emits a gesture event,
     * otherwise, setup the state to FAILED.
     * @param {Object} input
     */
    tryEmit: function (input) {
      if (this.canEmit()) {
        return this.emit(input);
      } // it's failing anyway


      this.state = STATE_FAILED;
    },

    /**
     * can we emit?
     * @returns {boolean}
     */
    canEmit: function () {
      var i = 0;

      while (i < this.requireFail.length) {
        if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
          return false;
        }

        i++;
      }

      return true;
    },

    /**
     * update the recognizer
     * @param {Object} inputData
     */
    recognize: function (inputData) {
      // make a new copy of the inputData
      // so we can change the inputData without messing up the other recognizers
      var inputDataClone = assign({}, inputData); // is is enabled and allow recognizing?

      if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
        this.reset();
        this.state = STATE_FAILED;
        return;
      } // reset when we've reached the end


      if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
        this.state = STATE_POSSIBLE;
      }

      this.state = this.process(inputDataClone); // the recognizer has recognized a gesture
      // so trigger an event

      if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
        this.tryEmit(inputDataClone);
      }
    },

    /**
     * return the state of the recognizer
     * the actual recognizing happens in this method
     * @virtual
     * @param {Object} inputData
     * @returns {Const} STATE
     */
    process: function (inputData) {},
    // jshint ignore:line

    /**
     * return the preferred touch-action
     * @virtual
     * @returns {Array}
     */
    getTouchAction: function () {},

    /**
     * called when the gesture isn't allowed to recognize
     * like when another is being recognized or it is disabled
     * @virtual
     */
    reset: function () {}
  };
  /**
   * get a usable string, used as event postfix
   * @param {Const} state
   * @returns {String} state
   */

  function stateStr(state) {
    if (state & STATE_CANCELLED) {
      return 'cancel';
    } else if (state & STATE_ENDED) {
      return 'end';
    } else if (state & STATE_CHANGED) {
      return 'move';
    } else if (state & STATE_BEGAN) {
      return 'start';
    }

    return '';
  }
  /**
   * direction cons to string
   * @param {Const} direction
   * @returns {String}
   */


  function directionStr(direction) {
    if (direction == DIRECTION_DOWN) {
      return 'down';
    } else if (direction == DIRECTION_UP) {
      return 'up';
    } else if (direction == DIRECTION_LEFT) {
      return 'left';
    } else if (direction == DIRECTION_RIGHT) {
      return 'right';
    }

    return '';
  }
  /**
   * get a recognizer by name if it is bound to a manager
   * @param {Recognizer|String} otherRecognizer
   * @param {Recognizer} recognizer
   * @returns {Recognizer}
   */


  function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
    var manager = recognizer.manager;

    if (manager) {
      return manager.get(otherRecognizer);
    }

    return otherRecognizer;
  }
  /**
   * This recognizer is just used as a base for the simple attribute recognizers.
   * @constructor
   * @extends Recognizer
   */


  function AttrRecognizer() {
    Recognizer.apply(this, arguments);
  }

  inherit(AttrRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof AttrRecognizer
     */
    defaults: {
      /**
       * @type {Number}
       * @default 1
       */
      pointers: 1
    },

    /**
     * Used to check if it the recognizer receives valid input, like input.distance > 10.
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {Boolean} recognized
     */
    attrTest: function (input) {
      var optionPointers = this.options.pointers;
      return optionPointers === 0 || input.pointers.length === optionPointers;
    },

    /**
     * Process the input and return the state for the recognizer
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {*} State
     */
    process: function (input) {
      var state = this.state;
      var eventType = input.eventType;
      var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
      var isValid = this.attrTest(input); // on cancel input and we've recognized before, return STATE_CANCELLED

      if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
        return state | STATE_CANCELLED;
      } else if (isRecognized || isValid) {
        if (eventType & INPUT_END) {
          return state | STATE_ENDED;
        } else if (!(state & STATE_BEGAN)) {
          return STATE_BEGAN;
        }

        return state | STATE_CHANGED;
      }

      return STATE_FAILED;
    }
  });
  /**
   * Pan
   * Recognized when the pointer is down and moved in the allowed direction.
   * @constructor
   * @extends AttrRecognizer
   */

  function PanRecognizer() {
    AttrRecognizer.apply(this, arguments);
    this.pX = null;
    this.pY = null;
  }

  inherit(PanRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PanRecognizer
     */
    defaults: {
      event: 'pan',
      threshold: 10,
      pointers: 1,
      direction: DIRECTION_ALL
    },
    getTouchAction: function () {
      var direction = this.options.direction;
      var actions = [];

      if (direction & DIRECTION_HORIZONTAL) {
        actions.push(TOUCH_ACTION_PAN_Y);
      }

      if (direction & DIRECTION_VERTICAL) {
        actions.push(TOUCH_ACTION_PAN_X);
      }

      return actions;
    },
    directionTest: function (input) {
      var options = this.options;
      var hasMoved = true;
      var distance = input.distance;
      var direction = input.direction;
      var x = input.deltaX;
      var y = input.deltaY; // lock to axis?

      if (!(direction & options.direction)) {
        if (options.direction & DIRECTION_HORIZONTAL) {
          direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
          hasMoved = x != this.pX;
          distance = Math.abs(input.deltaX);
        } else {
          direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
          hasMoved = y != this.pY;
          distance = Math.abs(input.deltaY);
        }
      }

      input.direction = direction;
      return hasMoved && distance > options.threshold && direction & options.direction;
    },
    attrTest: function (input) {
      return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
    },
    emit: function (input) {
      this.pX = input.deltaX;
      this.pY = input.deltaY;
      var direction = directionStr(input.direction);

      if (direction) {
        input.additionalEvent = this.options.event + direction;
      }

      this._super.emit.call(this, input);
    }
  });
  /**
   * Pinch
   * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
   * @constructor
   * @extends AttrRecognizer
   */

  function PinchRecognizer() {
    AttrRecognizer.apply(this, arguments);
  }

  inherit(PinchRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
      event: 'pinch',
      threshold: 0,
      pointers: 2
    },
    getTouchAction: function () {
      return [TOUCH_ACTION_NONE];
    },
    attrTest: function (input) {
      return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
    },
    emit: function (input) {
      if (input.scale !== 1) {
        var inOut = input.scale < 1 ? 'in' : 'out';
        input.additionalEvent = this.options.event + inOut;
      }

      this._super.emit.call(this, input);
    }
  });
  /**
   * Press
   * Recognized when the pointer is down for x ms without any movement.
   * @constructor
   * @extends Recognizer
   */

  function PressRecognizer() {
    Recognizer.apply(this, arguments);
    this._timer = null;
    this._input = null;
  }

  inherit(PressRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PressRecognizer
     */
    defaults: {
      event: 'press',
      pointers: 1,
      time: 251,
      // minimal time of the pointer to be pressed
      threshold: 9 // a minimal movement is ok, but keep it low

    },
    getTouchAction: function () {
      return [TOUCH_ACTION_AUTO];
    },
    process: function (input) {
      var options = this.options;
      var validPointers = input.pointers.length === options.pointers;
      var validMovement = input.distance < options.threshold;
      var validTime = input.deltaTime > options.time;
      this._input = input; // we only allow little movement
      // and we've reached an end event, so a tap is possible

      if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {
        this.reset();
      } else if (input.eventType & INPUT_START) {
        this.reset();
        this._timer = setTimeoutContext(function () {
          this.state = STATE_RECOGNIZED;
          this.tryEmit();
        }, options.time, this);
      } else if (input.eventType & INPUT_END) {
        return STATE_RECOGNIZED;
      }

      return STATE_FAILED;
    },
    reset: function () {
      clearTimeout(this._timer);
    },
    emit: function (input) {
      if (this.state !== STATE_RECOGNIZED) {
        return;
      }

      if (input && input.eventType & INPUT_END) {
        this.manager.emit(this.options.event + 'up', input);
      } else {
        this._input.timeStamp = now();
        this.manager.emit(this.options.event, this._input);
      }
    }
  });
  /**
   * Rotate
   * Recognized when two or more pointer are moving in a circular motion.
   * @constructor
   * @extends AttrRecognizer
   */

  function RotateRecognizer() {
    AttrRecognizer.apply(this, arguments);
  }

  inherit(RotateRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof RotateRecognizer
     */
    defaults: {
      event: 'rotate',
      threshold: 0,
      pointers: 2
    },
    getTouchAction: function () {
      return [TOUCH_ACTION_NONE];
    },
    attrTest: function (input) {
      return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
    }
  });
  /**
   * Swipe
   * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
   * @constructor
   * @extends AttrRecognizer
   */

  function SwipeRecognizer() {
    AttrRecognizer.apply(this, arguments);
  }

  inherit(SwipeRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof SwipeRecognizer
     */
    defaults: {
      event: 'swipe',
      threshold: 10,
      velocity: 0.3,
      direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
      pointers: 1
    },
    getTouchAction: function () {
      return PanRecognizer.prototype.getTouchAction.call(this);
    },
    attrTest: function (input) {
      var direction = this.options.direction;
      var velocity;

      if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
        velocity = input.overallVelocity;
      } else if (direction & DIRECTION_HORIZONTAL) {
        velocity = input.overallVelocityX;
      } else if (direction & DIRECTION_VERTICAL) {
        velocity = input.overallVelocityY;
      }

      return this._super.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers == this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
    },
    emit: function (input) {
      var direction = directionStr(input.offsetDirection);

      if (direction) {
        this.manager.emit(this.options.event + direction, input);
      }

      this.manager.emit(this.options.event, input);
    }
  });
  /**
   * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
   * between the given interval and position. The delay option can be used to recognize multi-taps without firing
   * a single tap.
   *
   * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
   * multi-taps being recognized.
   * @constructor
   * @extends Recognizer
   */

  function TapRecognizer() {
    Recognizer.apply(this, arguments); // previous time and center,
    // used for tap counting

    this.pTime = false;
    this.pCenter = false;
    this._timer = null;
    this._input = null;
    this.count = 0;
  }

  inherit(TapRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
      event: 'tap',
      pointers: 1,
      taps: 1,
      interval: 300,
      // max time between the multi-tap taps
      time: 250,
      // max time of the pointer to be down (like finger on the screen)
      threshold: 9,
      // a minimal movement is ok, but keep it low
      posThreshold: 10 // a multi-tap can be a bit off the initial position

    },
    getTouchAction: function () {
      return [TOUCH_ACTION_MANIPULATION];
    },
    process: function (input) {
      var options = this.options;
      var validPointers = input.pointers.length === options.pointers;
      var validMovement = input.distance < options.threshold;
      var validTouchTime = input.deltaTime < options.time;
      this.reset();

      if (input.eventType & INPUT_START && this.count === 0) {
        return this.failTimeout();
      } // we only allow little movement
      // and we've reached an end event, so a tap is possible


      if (validMovement && validTouchTime && validPointers) {
        if (input.eventType != INPUT_END) {
          return this.failTimeout();
        }

        var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
        var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;
        this.pTime = input.timeStamp;
        this.pCenter = input.center;

        if (!validMultiTap || !validInterval) {
          this.count = 1;
        } else {
          this.count += 1;
        }

        this._input = input; // if tap count matches we have recognized it,
        // else it has began recognizing...

        var tapCount = this.count % options.taps;

        if (tapCount === 0) {
          // no failing requirements, immediately trigger the tap event
          // or wait as long as the multitap interval to trigger
          if (!this.hasRequireFailures()) {
            return STATE_RECOGNIZED;
          } else {
            this._timer = setTimeoutContext(function () {
              this.state = STATE_RECOGNIZED;
              this.tryEmit();
            }, options.interval, this);
            return STATE_BEGAN;
          }
        }
      }

      return STATE_FAILED;
    },
    failTimeout: function () {
      this._timer = setTimeoutContext(function () {
        this.state = STATE_FAILED;
      }, this.options.interval, this);
      return STATE_FAILED;
    },
    reset: function () {
      clearTimeout(this._timer);
    },
    emit: function () {
      if (this.state == STATE_RECOGNIZED) {
        this._input.tapCount = this.count;
        this.manager.emit(this.options.event, this._input);
      }
    }
  });
  /**
   * Simple way to create a manager with a default set of recognizers.
   * @param {HTMLElement} element
   * @param {Object} [options]
   * @constructor
   */

  function Hammer(element, options) {
    options = options || {};
    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
    return new Manager(element, options);
  }
  /**
   * @const {string}
   */


  Hammer.VERSION = '2.0.7';
  /**
   * default settings
   * @namespace
   */

  Hammer.defaults = {
    /**
     * set if DOM events are being triggered.
     * But this is slower and unused by simple implementations, so disabled by default.
     * @type {Boolean}
     * @default false
     */
    domEvents: false,

    /**
     * The value for the touchAction property/fallback.
     * When set to `compute` it will magically set the correct value based on the added recognizers.
     * @type {String}
     * @default compute
     */
    touchAction: TOUCH_ACTION_COMPUTE,

    /**
     * @type {Boolean}
     * @default true
     */
    enable: true,

    /**
     * EXPERIMENTAL FEATURE -- can be removed/changed
     * Change the parent input target element.
     * If Null, then it is being set the to main element.
     * @type {Null|EventTarget}
     * @default null
     */
    inputTarget: null,

    /**
     * force an input class
     * @type {Null|Function}
     * @default null
     */
    inputClass: null,

    /**
     * Default recognizer setup when calling `Hammer()`
     * When creating a new Manager these will be skipped.
     * @type {Array}
     */
    preset: [// RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
    [RotateRecognizer, {
      enable: false
    }], [PinchRecognizer, {
      enable: false
    }, ['rotate']], [SwipeRecognizer, {
      direction: DIRECTION_HORIZONTAL
    }], [PanRecognizer, {
      direction: DIRECTION_HORIZONTAL
    }, ['swipe']], [TapRecognizer], [TapRecognizer, {
      event: 'doubletap',
      taps: 2
    }, ['tap']], [PressRecognizer]],

    /**
     * Some CSS properties can be used to improve the working of Hammer.
     * Add them to this method and they will be set when creating a new Manager.
     * @namespace
     */
    cssProps: {
      /**
       * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
       * @type {String}
       * @default 'none'
       */
      userSelect: 'none',

      /**
       * Disable the Windows Phone grippers when pressing an element.
       * @type {String}
       * @default 'none'
       */
      touchSelect: 'none',

      /**
       * Disables the default callout shown when you touch and hold a touch target.
       * On iOS, when you touch and hold a touch target such as a link, Safari displays
       * a callout containing information about the link. This property allows you to disable that callout.
       * @type {String}
       * @default 'none'
       */
      touchCallout: 'none',

      /**
       * Specifies whether zooming is enabled. Used by IE10>
       * @type {String}
       * @default 'none'
       */
      contentZooming: 'none',

      /**
       * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
       * @type {String}
       * @default 'none'
       */
      userDrag: 'none',

      /**
       * Overrides the highlight color shown when the user taps a link or a JavaScript
       * clickable element in iOS. This property obeys the alpha value, if specified.
       * @type {String}
       * @default 'rgba(0,0,0,0)'
       */
      tapHighlightColor: 'rgba(0,0,0,0)'
    }
  };
  var STOP = 1;
  var FORCED_STOP = 2;
  /**
   * Manager
   * @param {HTMLElement} element
   * @param {Object} [options]
   * @constructor
   */

  function Manager(element, options) {
    this.options = assign({}, Hammer.defaults, options || {});
    this.options.inputTarget = this.options.inputTarget || element;
    this.handlers = {};
    this.session = {};
    this.recognizers = [];
    this.oldCssProps = {};
    this.element = element;
    this.input = createInputInstance(this);
    this.touchAction = new TouchAction(this, this.options.touchAction);
    toggleCssProps(this, true);
    each(this.options.recognizers, function (item) {
      var recognizer = this.add(new item[0](item[1]));
      item[2] && recognizer.recognizeWith(item[2]);
      item[3] && recognizer.requireFailure(item[3]);
    }, this);
  }

  Manager.prototype = {
    /**
     * set options
     * @param {Object} options
     * @returns {Manager}
     */
    set: function (options) {
      assign(this.options, options); // Options that need a little more setup

      if (options.touchAction) {
        this.touchAction.update();
      }

      if (options.inputTarget) {
        // Clean up existing event listeners and reinitialize
        this.input.destroy();
        this.input.target = options.inputTarget;
        this.input.init();
      }

      return this;
    },

    /**
     * stop recognizing for this session.
     * This session will be discarded, when a new [input]start event is fired.
     * When forced, the recognizer cycle is stopped immediately.
     * @param {Boolean} [force]
     */
    stop: function (force) {
      this.session.stopped = force ? FORCED_STOP : STOP;
    },

    /**
     * run the recognizers!
     * called by the inputHandler function on every movement of the pointers (touches)
     * it walks through all the recognizers and tries to detect the gesture that is being made
     * @param {Object} inputData
     */
    recognize: function (inputData) {
      var session = this.session;

      if (session.stopped) {
        return;
      } // run the touch-action polyfill


      this.touchAction.preventDefaults(inputData);
      var recognizer;
      var recognizers = this.recognizers; // this holds the recognizer that is being recognized.
      // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
      // if no recognizer is detecting a thing, it is set to `null`

      var curRecognizer = session.curRecognizer; // reset when the last recognizer is recognized
      // or when we're in a new session

      if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {
        curRecognizer = session.curRecognizer = null;
      }

      var i = 0;

      while (i < recognizers.length) {
        recognizer = recognizers[i]; // find out if we are allowed try to recognize the input for this one.
        // 1.   allow if the session is NOT forced stopped (see the .stop() method)
        // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
        //      that is being recognized.
        // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
        //      this can be setup with the `recognizeWith()` method on the recognizer.

        if (session.stopped !== FORCED_STOP && ( // 1
        !curRecognizer || recognizer == curRecognizer || // 2
        recognizer.canRecognizeWith(curRecognizer))) {
          // 3
          recognizer.recognize(inputData);
        } else {
          recognizer.reset();
        } // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
        // current active recognizer. but only if we don't already have an active recognizer


        if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
          curRecognizer = session.curRecognizer = recognizer;
        }

        i++;
      }
    },

    /**
     * get a recognizer by its event name.
     * @param {Recognizer|String} recognizer
     * @returns {Recognizer|Null}
     */
    get: function (recognizer) {
      if (recognizer instanceof Recognizer) {
        return recognizer;
      }

      var recognizers = this.recognizers;

      for (var i = 0; i < recognizers.length; i++) {
        if (recognizers[i].options.event == recognizer) {
          return recognizers[i];
        }
      }

      return null;
    },

    /**
     * add a recognizer to the manager
     * existing recognizers with the same event name will be removed
     * @param {Recognizer} recognizer
     * @returns {Recognizer|Manager}
     */
    add: function (recognizer) {
      if (invokeArrayArg(recognizer, 'add', this)) {
        return this;
      } // remove existing


      var existing = this.get(recognizer.options.event);

      if (existing) {
        this.remove(existing);
      }

      this.recognizers.push(recognizer);
      recognizer.manager = this;
      this.touchAction.update();
      return recognizer;
    },

    /**
     * remove a recognizer by name or instance
     * @param {Recognizer|String} recognizer
     * @returns {Manager}
     */
    remove: function (recognizer) {
      if (invokeArrayArg(recognizer, 'remove', this)) {
        return this;
      }

      recognizer = this.get(recognizer); // let's make sure this recognizer exists

      if (recognizer) {
        var recognizers = this.recognizers;
        var index = inArray(recognizers, recognizer);

        if (index !== -1) {
          recognizers.splice(index, 1);
          this.touchAction.update();
        }
      }

      return this;
    },

    /**
     * bind event
     * @param {String} events
     * @param {Function} handler
     * @returns {EventEmitter} this
     */
    on: function (events, handler) {
      if (events === undefined) {
        return;
      }

      if (handler === undefined) {
        return;
      }

      var handlers = this.handlers;
      each(splitStr(events), function (event) {
        handlers[event] = handlers[event] || [];
        handlers[event].push(handler);
      });
      return this;
    },

    /**
     * unbind event, leave emit blank to remove all handlers
     * @param {String} events
     * @param {Function} [handler]
     * @returns {EventEmitter} this
     */
    off: function (events, handler) {
      if (events === undefined) {
        return;
      }

      var handlers = this.handlers;
      each(splitStr(events), function (event) {
        if (!handler) {
          delete handlers[event];
        } else {
          handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
        }
      });
      return this;
    },

    /**
     * emit event to the listeners
     * @param {String} event
     * @param {Object} data
     */
    emit: function (event, data) {
      // we also want to trigger dom events
      if (this.options.domEvents) {
        triggerDomEvent(event, data);
      } // no handlers, so skip it all


      var handlers = this.handlers[event] && this.handlers[event].slice();

      if (!handlers || !handlers.length) {
        return;
      }

      data.type = event;

      data.preventDefault = function () {
        data.srcEvent.preventDefault();
      };

      var i = 0;

      while (i < handlers.length) {
        handlers[i](data);
        i++;
      }
    },

    /**
     * destroy the manager and unbinds all events
     * it doesn't unbind dom events, that is the user own responsibility
     */
    destroy: function () {
      this.element && toggleCssProps(this, false);
      this.handlers = {};
      this.session = {};
      this.input.destroy();
      this.element = null;
    }
  };
  /**
   * add/remove the css properties as defined in manager.options.cssProps
   * @param {Manager} manager
   * @param {Boolean} add
   */

  function toggleCssProps(manager, add) {
    var element = manager.element;

    if (!element.style) {
      return;
    }

    var prop;
    each(manager.options.cssProps, function (value, name) {
      prop = prefixed(element.style, name);

      if (add) {
        manager.oldCssProps[prop] = element.style[prop];
        element.style[prop] = value;
      } else {
        element.style[prop] = manager.oldCssProps[prop] || '';
      }
    });

    if (!add) {
      manager.oldCssProps = {};
    }
  }
  /**
   * trigger dom event
   * @param {String} event
   * @param {Object} data
   */


  function triggerDomEvent(event, data) {
    var gestureEvent = document.createEvent('Event');
    gestureEvent.initEvent(event, true, true);
    gestureEvent.gesture = data;
    data.target.dispatchEvent(gestureEvent);
  }

  assign(Hammer, {
    INPUT_START: INPUT_START,
    INPUT_MOVE: INPUT_MOVE,
    INPUT_END: INPUT_END,
    INPUT_CANCEL: INPUT_CANCEL,
    STATE_POSSIBLE: STATE_POSSIBLE,
    STATE_BEGAN: STATE_BEGAN,
    STATE_CHANGED: STATE_CHANGED,
    STATE_ENDED: STATE_ENDED,
    STATE_RECOGNIZED: STATE_RECOGNIZED,
    STATE_CANCELLED: STATE_CANCELLED,
    STATE_FAILED: STATE_FAILED,
    DIRECTION_NONE: DIRECTION_NONE,
    DIRECTION_LEFT: DIRECTION_LEFT,
    DIRECTION_RIGHT: DIRECTION_RIGHT,
    DIRECTION_UP: DIRECTION_UP,
    DIRECTION_DOWN: DIRECTION_DOWN,
    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
    DIRECTION_VERTICAL: DIRECTION_VERTICAL,
    DIRECTION_ALL: DIRECTION_ALL,
    Manager: Manager,
    Input: Input,
    TouchAction: TouchAction,
    TouchInput: TouchInput,
    MouseInput: MouseInput,
    PointerEventInput: PointerEventInput,
    TouchMouseInput: TouchMouseInput,
    SingleTouchInput: SingleTouchInput,
    Recognizer: Recognizer,
    AttrRecognizer: AttrRecognizer,
    Tap: TapRecognizer,
    Pan: PanRecognizer,
    Swipe: SwipeRecognizer,
    Pinch: PinchRecognizer,
    Rotate: RotateRecognizer,
    Press: PressRecognizer,
    on: addEventListeners,
    off: removeEventListeners,
    each: each,
    merge: merge,
    extend: extend,
    assign: assign,
    inherit: inherit,
    bindFn: bindFn,
    prefixed: prefixed
  }); // this prevents errors when Hammer is loaded in the presence of an AMD
  //  style loader but by script tag, not by the loader.

  var freeGlobal = typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}; // jshint ignore:line

  freeGlobal.Hammer = Hammer;

  if (typeof define === 'function' && define.amd) {
    define(function () {
      return Hammer;
    });
  } else if (typeof module != 'undefined' && module.exports) {
    module.exports = Hammer;
  } else {
    window[exportName] = Hammer;
  }
})(window, document, 'Hammer');
},{}],"node_modules/mjolnir.js/dist/esm/utils/hammer-overrides.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.enhanceMouseInput = enhanceMouseInput;
exports.enhancePointerEventInput = enhancePointerEventInput;
const INPUT_START = 1;
const INPUT_MOVE = 2;
const INPUT_END = 4;
const MOUSE_INPUT_MAP = {
  mousedown: INPUT_START,
  mousemove: INPUT_MOVE,
  mouseup: INPUT_END
};

function some(array, predict) {
  for (let i = 0; i < array.length; i++) {
    if (predict(array[i])) {
      return true;
    }
  }

  return false;
}

function enhancePointerEventInput(PointerEventInput) {
  const oldHandler = PointerEventInput.prototype.handler;

  PointerEventInput.prototype.handler = function handler(ev) {
    const store = this.store;

    if (ev.button > 0 && ev.type === 'pointerdown') {
      if (!some(store, e => e.pointerId === ev.pointerId)) {
        store.push(ev);
      }
    }

    oldHandler.call(this, ev);
  };
}

function enhanceMouseInput(MouseInput) {
  MouseInput.prototype.handler = function handler(ev) {
    let eventType = MOUSE_INPUT_MAP[ev.type];

    if (eventType & INPUT_START && ev.button >= 0) {
      this.pressed = true;
    }

    if (eventType & INPUT_MOVE && ev.which === 0) {
      eventType = INPUT_END;
    }

    if (!this.pressed) {
      return;
    }

    if (eventType & INPUT_END) {
      this.pressed = false;
    }

    this.callback(this.manager, eventType, {
      pointers: [ev],
      changedPointers: [ev],
      pointerType: 'mouse',
      srcEvent: ev
    });
  };
}
},{}],"node_modules/mjolnir.js/dist/esm/utils/hammer.browser.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.Manager = void 0;

var _hammerjs = _interopRequireDefault(require("hammerjs"));

var _hammerOverrides = require("./hammer-overrides");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _hammerOverrides.enhancePointerEventInput)(_hammerjs.default.PointerEventInput);
(0, _hammerOverrides.enhanceMouseInput)(_hammerjs.default.MouseInput);
const Manager = _hammerjs.default.Manager;
exports.Manager = Manager;
var _default = _hammerjs.default;
exports.default = _default;
},{"hammerjs":"node_modules/hammerjs/hammer.js","./hammer-overrides":"node_modules/mjolnir.js/dist/esm/utils/hammer-overrides.js"}],"node_modules/mjolnir.js/dist/esm/constants.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RECOGNIZER_FALLBACK_MAP = exports.RECOGNIZER_COMPATIBLE_MAP = exports.RECOGNIZERS = exports.INPUT_EVENT_TYPES = exports.GESTURE_EVENT_ALIASES = exports.EVENT_RECOGNIZER_MAP = exports.BASIC_EVENT_ALIASES = void 0;

var _hammer = _interopRequireDefault(require("./utils/hammer"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const RECOGNIZERS = _hammer.default ? [[_hammer.default.Pan, {
  event: 'tripan',
  pointers: 3,
  threshold: 0,
  enable: false
}], [_hammer.default.Rotate, {
  enable: false
}], [_hammer.default.Pinch, {
  enable: false
}], [_hammer.default.Swipe, {
  enable: false
}], [_hammer.default.Pan, {
  threshold: 0,
  enable: false
}], [_hammer.default.Press, {
  enable: false
}], [_hammer.default.Tap, {
  event: 'doubletap',
  taps: 2,
  enable: false
}], [_hammer.default.Tap, {
  event: 'anytap',
  enable: false
}], [_hammer.default.Tap, {
  enable: false
}]] : null;
exports.RECOGNIZERS = RECOGNIZERS;
const RECOGNIZER_COMPATIBLE_MAP = {
  tripan: ['rotate', 'pinch', 'pan'],
  rotate: ['pinch'],
  pinch: ['pan'],
  pan: ['press', 'doubletap', 'anytap', 'tap'],
  doubletap: ['anytap'],
  anytap: ['tap']
};
exports.RECOGNIZER_COMPATIBLE_MAP = RECOGNIZER_COMPATIBLE_MAP;
const RECOGNIZER_FALLBACK_MAP = {
  doubletap: ['tap']
};
exports.RECOGNIZER_FALLBACK_MAP = RECOGNIZER_FALLBACK_MAP;
const BASIC_EVENT_ALIASES = {
  pointerdown: 'pointerdown',
  pointermove: 'pointermove',
  pointerup: 'pointerup',
  touchstart: 'pointerdown',
  touchmove: 'pointermove',
  touchend: 'pointerup',
  mousedown: 'pointerdown',
  mousemove: 'pointermove',
  mouseup: 'pointerup'
};
exports.BASIC_EVENT_ALIASES = BASIC_EVENT_ALIASES;
const INPUT_EVENT_TYPES = {
  KEY_EVENTS: ['keydown', 'keyup'],
  MOUSE_EVENTS: ['mousedown', 'mousemove', 'mouseup', 'mouseover', 'mouseout', 'mouseleave'],
  WHEEL_EVENTS: ['wheel', 'mousewheel']
};
exports.INPUT_EVENT_TYPES = INPUT_EVENT_TYPES;
const EVENT_RECOGNIZER_MAP = {
  tap: 'tap',
  anytap: 'anytap',
  doubletap: 'doubletap',
  press: 'press',
  pinch: 'pinch',
  pinchin: 'pinch',
  pinchout: 'pinch',
  pinchstart: 'pinch',
  pinchmove: 'pinch',
  pinchend: 'pinch',
  pinchcancel: 'pinch',
  rotate: 'rotate',
  rotatestart: 'rotate',
  rotatemove: 'rotate',
  rotateend: 'rotate',
  rotatecancel: 'rotate',
  tripan: 'tripan',
  tripanstart: 'tripan',
  tripanmove: 'tripan',
  tripanup: 'tripan',
  tripandown: 'tripan',
  tripanleft: 'tripan',
  tripanright: 'tripan',
  tripanend: 'tripan',
  tripancancel: 'tripan',
  pan: 'pan',
  panstart: 'pan',
  panmove: 'pan',
  panup: 'pan',
  pandown: 'pan',
  panleft: 'pan',
  panright: 'pan',
  panend: 'pan',
  pancancel: 'pan',
  swipe: 'swipe',
  swipeleft: 'swipe',
  swiperight: 'swipe',
  swipeup: 'swipe',
  swipedown: 'swipe'
};
exports.EVENT_RECOGNIZER_MAP = EVENT_RECOGNIZER_MAP;
const GESTURE_EVENT_ALIASES = {
  click: 'tap',
  anyclick: 'anytap',
  dblclick: 'doubletap',
  mousedown: 'pointerdown',
  mousemove: 'pointermove',
  mouseup: 'pointerup',
  mouseover: 'pointerover',
  mouseout: 'pointerout',
  mouseleave: 'pointerleave'
};
exports.GESTURE_EVENT_ALIASES = GESTURE_EVENT_ALIASES;
},{"./utils/hammer":"node_modules/mjolnir.js/dist/esm/utils/hammer.browser.js"}],"node_modules/mjolnir.js/dist/esm/utils/globals.js":[function(require,module,exports) {
var global = arguments[3];
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.window = exports.userAgent = exports.passiveSupported = exports.global = exports.document = void 0;
const userAgent = typeof navigator !== 'undefined' && navigator.userAgent ? navigator.userAgent.toLowerCase() : '';
exports.userAgent = userAgent;
const window_ = typeof window !== 'undefined' ? window : global;
exports.window = window_;
const global_ = typeof global !== 'undefined' ? global : window;
exports.global = global_;
const document_ = typeof document !== 'undefined' ? document : {};
exports.document = document_;
let passiveSupported = false;
exports.passiveSupported = passiveSupported;

try {
  const options = {
    get passive() {
      exports.passiveSupported = passiveSupported = true;
      return true;
    }

  };
  window_.addEventListener('test', options, options);
  window_.removeEventListener('test', options, options);
} catch (err) {}
},{}],"node_modules/mjolnir.js/dist/esm/inputs/wheel-input.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _constants = require("../constants");

var _globals = require("../utils/globals");

const firefox = _globals.userAgent.indexOf('firefox') !== -1;
const {
  WHEEL_EVENTS: WHEEL_EVENTS
} = _constants.INPUT_EVENT_TYPES;
const EVENT_TYPE = 'wheel';
const WHEEL_DELTA_MAGIC_SCALER = 4.000244140625;
const WHEEL_DELTA_PER_LINE = 40;
const SHIFT_MULTIPLIER = 0.25;

class WheelInput {
  constructor(element, callback, options = {}) {
    this.element = element;
    this.callback = callback;
    this.options = Object.assign({
      enable: true
    }, options);
    this.events = WHEEL_EVENTS.concat(options.events || []);
    this.handleEvent = this.handleEvent.bind(this);
    this.events.forEach(event => element.addEventListener(event, this.handleEvent, _globals.passiveSupported ? {
      passive: false
    } : false));
  }

  destroy() {
    this.events.forEach(event => this.element.removeEventListener(event, this.handleEvent));
  }

  enableEventType(eventType, enabled) {
    if (eventType === EVENT_TYPE) {
      this.options.enable = enabled;
    }
  }

  handleEvent(event) {
    if (!this.options.enable) {
      return;
    }

    let value = event.deltaY;

    if (_globals.window.WheelEvent) {
      if (firefox && event.deltaMode === _globals.window.WheelEvent.DOM_DELTA_PIXEL) {
        value /= _globals.window.devicePixelRatio;
      }

      if (event.deltaMode === _globals.window.WheelEvent.DOM_DELTA_LINE) {
        value *= WHEEL_DELTA_PER_LINE;
      }
    }

    const wheelPosition = {
      x: event.clientX,
      y: event.clientY
    };

    if (value !== 0 && value % WHEEL_DELTA_MAGIC_SCALER === 0) {
      value = Math.floor(value / WHEEL_DELTA_MAGIC_SCALER);
    }

    if (event.shiftKey && value) {
      value = value * SHIFT_MULTIPLIER;
    }

    this._onWheel(event, -value, wheelPosition);
  }

  _onWheel(srcEvent, delta, position) {
    this.callback({
      type: EVENT_TYPE,
      center: position,
      delta: delta,
      srcEvent: srcEvent,
      pointerType: 'mouse',
      target: srcEvent.target
    });
  }

}

exports.default = WheelInput;
},{"../constants":"node_modules/mjolnir.js/dist/esm/constants.js","../utils/globals":"node_modules/mjolnir.js/dist/esm/utils/globals.js"}],"node_modules/mjolnir.js/dist/esm/inputs/move-input.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _constants = require("../constants");

const {
  MOUSE_EVENTS: MOUSE_EVENTS
} = _constants.INPUT_EVENT_TYPES;
const MOVE_EVENT_TYPE = 'pointermove';
const OVER_EVENT_TYPE = 'pointerover';
const OUT_EVENT_TYPE = 'pointerout';
const LEAVE_EVENT_TYPE = 'pointerleave';

class MoveInput {
  constructor(element, callback, options = {}) {
    this.element = element;
    this.callback = callback;
    this.pressed = false;
    this.options = Object.assign({
      enable: true
    }, options);
    this.enableMoveEvent = this.options.enable;
    this.enableLeaveEvent = this.options.enable;
    this.enableOutEvent = this.options.enable;
    this.enableOverEvent = this.options.enable;
    this.events = MOUSE_EVENTS.concat(options.events || []);
    this.handleEvent = this.handleEvent.bind(this);
    this.events.forEach(event => element.addEventListener(event, this.handleEvent));
  }

  destroy() {
    this.events.forEach(event => this.element.removeEventListener(event, this.handleEvent));
  }

  enableEventType(eventType, enabled) {
    if (eventType === MOVE_EVENT_TYPE) {
      this.enableMoveEvent = enabled;
    }

    if (eventType === OVER_EVENT_TYPE) {
      this.enableOverEvent = enabled;
    }

    if (eventType === OUT_EVENT_TYPE) {
      this.enableOutEvent = enabled;
    }

    if (eventType === LEAVE_EVENT_TYPE) {
      this.enableLeaveEvent = enabled;
    }
  }

  handleEvent(event) {
    this.handleOverEvent(event);
    this.handleOutEvent(event);
    this.handleLeaveEvent(event);
    this.handleMoveEvent(event);
  }

  handleOverEvent(event) {
    if (this.enableOverEvent) {
      if (event.type === 'mouseover') {
        this.callback({
          type: OVER_EVENT_TYPE,
          srcEvent: event,
          pointerType: 'mouse',
          target: event.target
        });
      }
    }
  }

  handleOutEvent(event) {
    if (this.enableOutEvent) {
      if (event.type === 'mouseout') {
        this.callback({
          type: OUT_EVENT_TYPE,
          srcEvent: event,
          pointerType: 'mouse',
          target: event.target
        });
      }
    }
  }

  handleLeaveEvent(event) {
    if (this.enableLeaveEvent) {
      if (event.type === 'mouseleave') {
        this.callback({
          type: LEAVE_EVENT_TYPE,
          srcEvent: event,
          pointerType: 'mouse',
          target: event.target
        });
      }
    }
  }

  handleMoveEvent(event) {
    if (this.enableMoveEvent) {
      switch (event.type) {
        case 'mousedown':
          if (event.button >= 0) {
            this.pressed = true;
          }

          break;

        case 'mousemove':
          if (event.which === 0) {
            this.pressed = false;
          }

          if (!this.pressed) {
            this.callback({
              type: MOVE_EVENT_TYPE,
              srcEvent: event,
              pointerType: 'mouse',
              target: event.target
            });
          }

          break;

        case 'mouseup':
          this.pressed = false;
          break;

        default:
      }
    }
  }

}

exports.default = MoveInput;
},{"../constants":"node_modules/mjolnir.js/dist/esm/constants.js"}],"node_modules/mjolnir.js/dist/esm/inputs/key-input.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _constants = require("../constants");

const {
  KEY_EVENTS: KEY_EVENTS
} = _constants.INPUT_EVENT_TYPES;
const DOWN_EVENT_TYPE = 'keydown';
const UP_EVENT_TYPE = 'keyup';

class KeyInput {
  constructor(element, callback, options = {}) {
    this.element = element;
    this.callback = callback;
    this.options = Object.assign({
      enable: true
    }, options);
    this.enableDownEvent = this.options.enable;
    this.enableUpEvent = this.options.enable;
    this.events = KEY_EVENTS.concat(options.events || []);
    this.handleEvent = this.handleEvent.bind(this);
    element.tabIndex = options.tabIndex || 0;
    element.style.outline = 'none';
    this.events.forEach(event => element.addEventListener(event, this.handleEvent));
  }

  destroy() {
    this.events.forEach(event => this.element.removeEventListener(event, this.handleEvent));
  }

  enableEventType(eventType, enabled) {
    if (eventType === DOWN_EVENT_TYPE) {
      this.enableDownEvent = enabled;
    }

    if (eventType === UP_EVENT_TYPE) {
      this.enableUpEvent = enabled;
    }
  }

  handleEvent(event) {
    const targetElement = event.target || event.srcElement;

    if (targetElement.tagName === 'INPUT' && targetElement.type === 'text' || targetElement.tagName === 'TEXTAREA') {
      return;
    }

    if (this.enableDownEvent && event.type === 'keydown') {
      this.callback({
        type: DOWN_EVENT_TYPE,
        srcEvent: event,
        key: event.key,
        target: event.target
      });
    }

    if (this.enableUpEvent && event.type === 'keyup') {
      this.callback({
        type: UP_EVENT_TYPE,
        srcEvent: event,
        key: event.key,
        target: event.target
      });
    }
  }

}

exports.default = KeyInput;
},{"../constants":"node_modules/mjolnir.js/dist/esm/constants.js"}],"node_modules/mjolnir.js/dist/esm/inputs/contextmenu-input.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
const EVENT_TYPE = 'contextmenu';

class ContextmenuInput {
  constructor(element, callback, options = {}) {
    this.element = element;
    this.callback = callback;
    this.options = Object.assign({
      enable: true
    }, options);
    this.handleEvent = this.handleEvent.bind(this);
    element.addEventListener('contextmenu', this.handleEvent);
  }

  destroy() {
    this.element.removeEventListener('contextmenu', this.handleEvent);
  }

  enableEventType(eventType, enabled) {
    if (eventType === EVENT_TYPE) {
      this.options.enable = enabled;
    }
  }

  handleEvent(event) {
    if (!this.options.enable) {
      return;
    }

    this.callback({
      type: EVENT_TYPE,
      center: {
        x: event.clientX,
        y: event.clientY
      },
      srcEvent: event,
      pointerType: 'mouse',
      target: event.target
    });
  }

}

exports.default = ContextmenuInput;
},{}],"node_modules/mjolnir.js/dist/esm/utils/event-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getOffsetPosition = getOffsetPosition;
exports.whichButtons = whichButtons;
const DOWN_EVENT = 1;
const MOVE_EVENT = 2;
const UP_EVENT = 4;
const MOUSE_EVENTS = {
  pointerdown: DOWN_EVENT,
  pointermove: MOVE_EVENT,
  pointerup: UP_EVENT,
  mousedown: DOWN_EVENT,
  mousemove: MOVE_EVENT,
  mouseup: UP_EVENT
};
const MOUSE_EVENT_WHICH_LEFT = 1;
const MOUSE_EVENT_WHICH_MIDDLE = 2;
const MOUSE_EVENT_WHICH_RIGHT = 3;
const MOUSE_EVENT_BUTTON_LEFT = 0;
const MOUSE_EVENT_BUTTON_MIDDLE = 1;
const MOUSE_EVENT_BUTTON_RIGHT = 2;
const MOUSE_EVENT_BUTTONS_LEFT_MASK = 1;
const MOUSE_EVENT_BUTTONS_RIGHT_MASK = 2;
const MOUSE_EVENT_BUTTONS_MIDDLE_MASK = 4;

function whichButtons(event) {
  const eventType = MOUSE_EVENTS[event.srcEvent.type];

  if (!eventType) {
    return null;
  }

  const {
    buttons: buttons,
    button: button,
    which: which
  } = event.srcEvent;
  let leftButton = false;
  let middleButton = false;
  let rightButton = false;

  if (eventType === UP_EVENT || eventType === MOVE_EVENT && !Number.isFinite(buttons)) {
    leftButton = which === MOUSE_EVENT_WHICH_LEFT;
    middleButton = which === MOUSE_EVENT_WHICH_MIDDLE;
    rightButton = which === MOUSE_EVENT_WHICH_RIGHT;
  } else if (eventType === MOVE_EVENT) {
    leftButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_LEFT_MASK);
    middleButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_MIDDLE_MASK);
    rightButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_RIGHT_MASK);
  } else if (eventType === DOWN_EVENT) {
    leftButton = button === MOUSE_EVENT_BUTTON_LEFT;
    middleButton = button === MOUSE_EVENT_BUTTON_MIDDLE;
    rightButton = button === MOUSE_EVENT_BUTTON_RIGHT;
  }

  return {
    leftButton: leftButton,
    middleButton: middleButton,
    rightButton: rightButton
  };
}

function getOffsetPosition(event, rootElement) {
  const {
    srcEvent: srcEvent
  } = event;

  if (!event.center && !Number.isFinite(srcEvent.clientX)) {
    return null;
  }

  const center = event.center || {
    x: srcEvent.clientX,
    y: srcEvent.clientY
  };
  const rect = rootElement.getBoundingClientRect();
  const scaleX = rect.width / rootElement.offsetWidth || 1;
  const scaleY = rect.height / rootElement.offsetHeight || 1;
  const offsetCenter = {
    x: (center.x - rect.left - rootElement.clientLeft) / scaleX,
    y: (center.y - rect.top - rootElement.clientTop) / scaleY
  };
  return {
    center: center,
    offsetCenter: offsetCenter
  };
}
},{}],"node_modules/mjolnir.js/dist/esm/utils/event-registrar.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _eventUtils = require("./event-utils");

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

const DEFAULT_OPTIONS = {
  srcElement: 'root',
  priority: 0
};

class EventRegistrar {
  constructor(eventManager) {
    this.eventManager = eventManager;
    this.handlers = [];
    this.handlersByElement = new Map();
    this.handleEvent = this.handleEvent.bind(this);
    this._active = false;
  }

  isEmpty() {
    return !this._active;
  }

  add(type, handler, opts, once = false, passive = false) {
    const {
      handlers: handlers,
      handlersByElement: handlersByElement
    } = this;

    if (opts && (_typeof(opts) !== 'object' || opts.addEventListener)) {
      opts = {
        srcElement: opts
      };
    }

    opts = opts ? Object.assign({}, DEFAULT_OPTIONS, opts) : DEFAULT_OPTIONS;
    let entries = handlersByElement.get(opts.srcElement);

    if (!entries) {
      entries = [];
      handlersByElement.set(opts.srcElement, entries);
    }

    const entry = {
      type: type,
      handler: handler,
      srcElement: opts.srcElement,
      priority: opts.priority
    };

    if (once) {
      entry.once = true;
    }

    if (passive) {
      entry.passive = true;
    }

    handlers.push(entry);
    this._active = this._active || !entry.passive;
    let insertPosition = entries.length - 1;

    while (insertPosition >= 0) {
      if (entries[insertPosition].priority >= entry.priority) {
        break;
      }

      insertPosition--;
    }

    entries.splice(insertPosition + 1, 0, entry);
  }

  remove(type, handler) {
    const {
      handlers: handlers,
      handlersByElement: handlersByElement
    } = this;

    for (let i = handlers.length - 1; i >= 0; i--) {
      const entry = handlers[i];

      if (entry.type === type && entry.handler === handler) {
        handlers.splice(i, 1);
        const entries = handlersByElement.get(entry.srcElement);
        entries.splice(entries.indexOf(entry), 1);

        if (entries.length === 0) {
          handlersByElement.delete(entry.srcElement);
        }
      }
    }

    this._active = handlers.some(entry => !entry.passive);
  }

  handleEvent(event) {
    if (this.isEmpty()) {
      return;
    }

    const mjolnirEvent = this._normalizeEvent(event);

    let target = event.srcEvent.target;

    while (target && target !== mjolnirEvent.rootElement) {
      this._emit(mjolnirEvent, target);

      if (mjolnirEvent.handled) {
        return;
      }

      target = target.parentNode;
    }

    this._emit(mjolnirEvent, 'root');
  }

  _emit(event, srcElement) {
    const entries = this.handlersByElement.get(srcElement);

    if (entries) {
      let immediatePropagationStopped = false;

      const stopPropagation = () => {
        event.handled = true;
      };

      const stopImmediatePropagation = () => {
        event.handled = true;
        immediatePropagationStopped = true;
      };

      const entriesToRemove = [];

      for (let i = 0; i < entries.length; i++) {
        const {
          type: type,
          handler: handler,
          once: once
        } = entries[i];
        handler(Object.assign({}, event, {
          type: type,
          stopPropagation: stopPropagation,
          stopImmediatePropagation: stopImmediatePropagation
        }));

        if (once) {
          entriesToRemove.push(entries[i]);
        }

        if (immediatePropagationStopped) {
          break;
        }
      }

      for (let i = 0; i < entriesToRemove.length; i++) {
        const {
          type: type,
          handler: handler
        } = entriesToRemove[i];
        this.remove(type, handler);
      }
    }
  }

  _normalizeEvent(event) {
    const rootElement = this.eventManager.element;
    return Object.assign({}, event, (0, _eventUtils.whichButtons)(event), (0, _eventUtils.getOffsetPosition)(event, rootElement), {
      handled: false,
      rootElement: rootElement
    });
  }

}

exports.default = EventRegistrar;
},{"./event-utils":"node_modules/mjolnir.js/dist/esm/utils/event-utils.js"}],"node_modules/mjolnir.js/dist/esm/event-manager.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _hammer = require("./utils/hammer");

var _wheelInput = _interopRequireDefault(require("./inputs/wheel-input"));

var _moveInput = _interopRequireDefault(require("./inputs/move-input"));

var _keyInput = _interopRequireDefault(require("./inputs/key-input"));

var _contextmenuInput = _interopRequireDefault(require("./inputs/contextmenu-input"));

var _eventRegistrar = _interopRequireDefault(require("./utils/event-registrar"));

var _constants = require("./constants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const DEFAULT_OPTIONS = {
  events: null,
  recognizers: null,
  recognizerOptions: {},
  Manager: _hammer.Manager,
  touchAction: 'none',
  tabIndex: 0
};

class EventManager {
  constructor(element = null, options = {}) {
    this.options = Object.assign({}, DEFAULT_OPTIONS, options);
    this.events = new Map();
    this._onBasicInput = this._onBasicInput.bind(this);
    this._onOtherEvent = this._onOtherEvent.bind(this);
    this.setElement(element);
    const {
      events: events
    } = options;

    if (events) {
      this.on(events);
    }
  }

  setElement(element) {
    if (this.element) {
      this.destroy();
    }

    this.element = element;

    if (!element) {
      return;
    }

    const {
      options: options
    } = this;
    const ManagerClass = options.Manager;
    this.manager = new ManagerClass(element, {
      touchAction: options.touchAction,
      recognizers: options.recognizers || _constants.RECOGNIZERS
    }).on('hammer.input', this._onBasicInput);

    if (!options.recognizers) {
      Object.keys(_constants.RECOGNIZER_COMPATIBLE_MAP).forEach(name => {
        const recognizer = this.manager.get(name);

        if (recognizer) {
          _constants.RECOGNIZER_COMPATIBLE_MAP[name].forEach(otherName => {
            recognizer.recognizeWith(otherName);
          });
        }
      });
    }

    for (const recognizerName in options.recognizerOptions) {
      const recognizer = this.manager.get(recognizerName);

      if (recognizer) {
        const recognizerOption = options.recognizerOptions[recognizerName];
        delete recognizerOption.enable;
        recognizer.set(recognizerOption);
      }
    }

    this.wheelInput = new _wheelInput.default(element, this._onOtherEvent, {
      enable: false
    });
    this.moveInput = new _moveInput.default(element, this._onOtherEvent, {
      enable: false
    });
    this.keyInput = new _keyInput.default(element, this._onOtherEvent, {
      enable: false,
      tabIndex: options.tabIndex
    });
    this.contextmenuInput = new _contextmenuInput.default(element, this._onOtherEvent, {
      enable: false
    });

    for (const [eventAlias, eventRegistrar] of this.events) {
      if (!eventRegistrar.isEmpty()) {
        this._toggleRecognizer(eventRegistrar.recognizerName, true);

        this.manager.on(eventAlias, eventRegistrar.handleEvent);
      }
    }
  }

  destroy() {
    if (this.element) {
      this.wheelInput.destroy();
      this.moveInput.destroy();
      this.keyInput.destroy();
      this.contextmenuInput.destroy();
      this.manager.destroy();
      this.wheelInput = null;
      this.moveInput = null;
      this.keyInput = null;
      this.contextmenuInput = null;
      this.manager = null;
      this.element = null;
    }
  }

  on(event, handler, opts) {
    this._addEventHandler(event, handler, opts, false);
  }

  once(event, handler, opts) {
    this._addEventHandler(event, handler, opts, true);
  }

  watch(event, handler, opts) {
    this._addEventHandler(event, handler, opts, false, true);
  }

  off(event, handler) {
    this._removeEventHandler(event, handler);
  }

  _toggleRecognizer(name, enabled) {
    const {
      manager: manager
    } = this;

    if (!manager) {
      return;
    }

    const recognizer = manager.get(name);

    if (recognizer && recognizer.options.enable !== enabled) {
      recognizer.set({
        enable: enabled
      });
      const fallbackRecognizers = _constants.RECOGNIZER_FALLBACK_MAP[name];

      if (fallbackRecognizers && !this.options.recognizers) {
        fallbackRecognizers.forEach(otherName => {
          const otherRecognizer = manager.get(otherName);

          if (enabled) {
            otherRecognizer.requireFailure(name);
            recognizer.dropRequireFailure(otherName);
          } else {
            otherRecognizer.dropRequireFailure(name);
          }
        });
      }
    }

    this.wheelInput.enableEventType(name, enabled);
    this.moveInput.enableEventType(name, enabled);
    this.keyInput.enableEventType(name, enabled);
    this.contextmenuInput.enableEventType(name, enabled);
  }

  _addEventHandler(event, handler, opts, once, passive) {
    if (typeof event !== 'string') {
      opts = handler;

      for (const eventName in event) {
        this._addEventHandler(eventName, event[eventName], opts, once, passive);
      }

      return;
    }

    const {
      manager: manager,
      events: events
    } = this;
    const eventAlias = _constants.GESTURE_EVENT_ALIASES[event] || event;
    let eventRegistrar = events.get(eventAlias);

    if (!eventRegistrar) {
      eventRegistrar = new _eventRegistrar.default(this);
      events.set(eventAlias, eventRegistrar);
      eventRegistrar.recognizerName = _constants.EVENT_RECOGNIZER_MAP[eventAlias] || eventAlias;

      if (manager) {
        manager.on(eventAlias, eventRegistrar.handleEvent);
      }
    }

    eventRegistrar.add(event, handler, opts, once, passive);

    if (!eventRegistrar.isEmpty()) {
      this._toggleRecognizer(eventRegistrar.recognizerName, true);
    }
  }

  _removeEventHandler(event, handler) {
    if (typeof event !== 'string') {
      for (const eventName in event) {
        this._removeEventHandler(eventName, event[eventName]);
      }

      return;
    }

    const {
      events: events
    } = this;
    const eventAlias = _constants.GESTURE_EVENT_ALIASES[event] || event;
    const eventRegistrar = events.get(eventAlias);

    if (!eventRegistrar) {
      return;
    }

    eventRegistrar.remove(event, handler);

    if (eventRegistrar.isEmpty()) {
      const {
        recognizerName: recognizerName
      } = eventRegistrar;
      let isRecognizerUsed = false;

      for (const eh of events.values()) {
        if (eh.recognizerName === recognizerName && !eh.isEmpty()) {
          isRecognizerUsed = true;
          break;
        }
      }

      if (!isRecognizerUsed) {
        this._toggleRecognizer(recognizerName, false);
      }
    }
  }

  _onBasicInput(event) {
    const {
      srcEvent: srcEvent
    } = event;
    const alias = _constants.BASIC_EVENT_ALIASES[srcEvent.type];

    if (alias) {
      this.manager.emit(alias, event);
    }
  }

  _onOtherEvent(event) {
    this.manager.emit(event.type, event);
  }

}

exports.default = EventManager;
},{"./utils/hammer":"node_modules/mjolnir.js/dist/esm/utils/hammer.browser.js","./inputs/wheel-input":"node_modules/mjolnir.js/dist/esm/inputs/wheel-input.js","./inputs/move-input":"node_modules/mjolnir.js/dist/esm/inputs/move-input.js","./inputs/key-input":"node_modules/mjolnir.js/dist/esm/inputs/key-input.js","./inputs/contextmenu-input":"node_modules/mjolnir.js/dist/esm/inputs/contextmenu-input.js","./utils/event-registrar":"node_modules/mjolnir.js/dist/esm/utils/event-registrar.js","./constants":"node_modules/mjolnir.js/dist/esm/constants.js"}],"node_modules/mjolnir.js/dist/esm/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "EventManager", {
  enumerable: true,
  get: function () {
    return _eventManager.default;
  }
});

var _eventManager = _interopRequireDefault(require("./event-manager"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./event-manager":"node_modules/mjolnir.js/dist/esm/event-manager.js"}],"node_modules/@deck.gl/core/dist/esm/lib/deck.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _layerManager = _interopRequireDefault(require("./layer-manager"));

var _viewManager = _interopRequireDefault(require("./view-manager"));

var _mapView = _interopRequireDefault(require("../views/map-view"));

var _effectManager = _interopRequireDefault(require("./effect-manager"));

var _effect = _interopRequireDefault(require("./effect"));

var _deckRenderer = _interopRequireDefault(require("./deck-renderer"));

var _deckPicker = _interopRequireDefault(require("./deck-picker"));

var _tooltip = _interopRequireDefault(require("./tooltip"));

var _log = _interopRequireDefault(require("../utils/log"));

var _deepEqual = require("../utils/deep-equal");

var _typedArrayManager = _interopRequireDefault(require("../utils/typed-array-manager"));

var _init = _interopRequireDefault(require("./init"));

var _env = require("@probe.gl/env");

var _core = require("@luma.gl/core");

var _stats = require("@probe.gl/stats");

var _mjolnir = require("mjolnir.js");

var _assert = _interopRequireDefault(require("../utils/assert"));

var _constants = require("./constants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function noop() {}

const getCursor = ({
  isDragging
}) => isDragging ? 'grabbing' : 'grab';

function getPropTypes(PropTypes) {
  return {
    id: PropTypes.string,
    width: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    height: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    layers: PropTypes.oneOfType([PropTypes.object, PropTypes.array]),
    layerFilter: PropTypes.func,
    views: PropTypes.oneOfType([PropTypes.object, PropTypes.array]),
    viewState: PropTypes.object,
    effects: PropTypes.arrayOf(PropTypes.instanceOf(_effect.default)),
    controller: PropTypes.oneOfType([PropTypes.func, PropTypes.bool, PropTypes.object]),
    gl: PropTypes.object,
    glOptions: PropTypes.object,
    parameters: PropTypes.object,
    pickingRadius: PropTypes.number,
    useDevicePixels: PropTypes.oneOfType([PropTypes.bool, PropTypes.number]),
    touchAction: PropTypes.string,
    eventRecognizerOptions: PropTypes.object,
    onWebGLInitialized: PropTypes.func,
    onResize: PropTypes.func,
    onViewStateChange: PropTypes.func,
    onInteractionStateChange: PropTypes.func,
    onBeforeRender: PropTypes.func,
    onAfterRender: PropTypes.func,
    onLoad: PropTypes.func,
    onError: PropTypes.func,
    debug: PropTypes.bool,
    drawPickingColors: PropTypes.bool,
    _framebuffer: PropTypes.object,
    _animate: PropTypes.bool,
    _pickable: PropTypes.bool,
    _typedArrayManagerProps: PropTypes.object
  };
}

const defaultProps = {
  id: '',
  width: '100%',
  height: '100%',
  pickingRadius: 0,
  layerFilter: null,
  glOptions: {},
  gl: null,
  layers: [],
  effects: [],
  views: null,
  controller: null,
  useDevicePixels: true,
  touchAction: 'none',
  eventRecognizerOptions: {},
  _framebuffer: null,
  _animate: false,
  _pickable: true,
  _typedArrayManagerProps: {},
  onWebGLInitialized: noop,
  onResize: noop,
  onViewStateChange: noop,
  onInteractionStateChange: noop,
  onBeforeRender: noop,
  onAfterRender: noop,
  onLoad: noop,
  onError: (error, layer) => _log.default.error(error)(),
  _onMetrics: null,
  getCursor,
  debug: false,
  drawPickingColors: false
};

class Deck {
  constructor(props) {
    props = { ...defaultProps,
      ...props
    };
    this.props = {};
    this.width = 0;
    this.height = 0;
    this.viewManager = null;
    this.layerManager = null;
    this.effectManager = null;
    this.deckRenderer = null;
    this.deckPicker = null;
    this._needsRedraw = true;
    this._pickRequest = {};
    this._lastPointerDownInfo = null;
    this.viewState = null;
    this.interactiveState = {
      isHovering: false,
      isDragging: false
    };
    this._onEvent = this._onEvent.bind(this);
    this._onPointerDown = this._onPointerDown.bind(this);
    this._onPointerMove = this._onPointerMove.bind(this);

    if (props.viewState && props.initialViewState) {
      _log.default.warn('View state tracking is disabled. Use either `initialViewState` for auto update or `viewState` for manual update.')();
    }

    if ((0, _env.getBrowser)() === 'IE') {
      _log.default.warn('IE 11 support will be deprecated in v8.0')();
    }

    if (!props.gl) {
      if (typeof document !== 'undefined') {
        this.canvas = this._createCanvas(props);
      }
    }

    this.animationLoop = this._createAnimationLoop(props);
    this.stats = new _stats.Stats({
      id: 'deck.gl'
    });
    this.metrics = {
      fps: 0,
      setPropsTime: 0,
      updateAttributesTime: 0,
      framesRedrawn: 0,
      pickTime: 0,
      pickCount: 0,
      gpuTime: 0,
      gpuTimePerFrame: 0,
      cpuTime: 0,
      cpuTimePerFrame: 0,
      bufferMemory: 0,
      textureMemory: 0,
      renderbufferMemory: 0,
      gpuMemory: 0
    };
    this._metricsCounter = 0;
    this.setProps(props);

    if (props._typedArrayManagerProps) {
      _typedArrayManager.default.setProps(props._typedArrayManagerProps);
    }

    this.animationLoop.start();
  }

  finalize() {
    this.animationLoop.stop();
    this.animationLoop = null;
    this._lastPointerDownInfo = null;

    if (this.layerManager) {
      this.layerManager.finalize();
      this.layerManager = null;
      this.viewManager.finalize();
      this.viewManager = null;
      this.effectManager.finalize();
      this.effectManager = null;
      this.deckRenderer.finalize();
      this.deckRenderer = null;
      this.deckPicker.finalize();
      this.deckPicker = null;
      this.eventManager.destroy();
      this.eventManager = null;
      this.tooltip.remove();
      this.tooltip = null;
    }

    if (!this.props.canvas && !this.props.gl && this.canvas) {
      this.canvas.parentElement.removeChild(this.canvas);
      this.canvas = null;
    }
  }

  setProps(props) {
    this.stats.get('setProps Time').timeStart();

    if ('onLayerHover' in props) {
      _log.default.removed('onLayerHover', 'onHover')();
    }

    if ('onLayerClick' in props) {
      _log.default.removed('onLayerClick', 'onClick')();
    }

    if (props.initialViewState && !(0, _deepEqual.deepEqual)(this.props.initialViewState, props.initialViewState)) {
      this.viewState = props.initialViewState;
    }

    Object.assign(this.props, props);

    this._setCanvasSize(this.props);

    const resolvedProps = Object.create(this.props);
    Object.assign(resolvedProps, {
      views: this._getViews(),
      width: this.width,
      height: this.height,
      viewState: this._getViewState()
    });
    this.animationLoop.setProps(resolvedProps);

    if (this.layerManager) {
      this.viewManager.setProps(resolvedProps);
      this.layerManager.activateViewport(this.getViewports()[0]);
      this.layerManager.setProps(resolvedProps);
      this.effectManager.setProps(resolvedProps);
      this.deckRenderer.setProps(resolvedProps);
      this.deckPicker.setProps(resolvedProps);
    }

    this.stats.get('setProps Time').timeEnd();
  }

  needsRedraw(opts = {
    clearRedrawFlags: false
  }) {
    if (this.props._animate) {
      return 'Deck._animate';
    }

    let redraw = this._needsRedraw;

    if (opts.clearRedrawFlags) {
      this._needsRedraw = false;
    }

    const viewManagerNeedsRedraw = this.viewManager.needsRedraw(opts);
    const layerManagerNeedsRedraw = this.layerManager.needsRedraw(opts);
    const effectManagerNeedsRedraw = this.effectManager.needsRedraw(opts);
    const deckRendererNeedsRedraw = this.deckRenderer.needsRedraw(opts);
    redraw = redraw || viewManagerNeedsRedraw || layerManagerNeedsRedraw || effectManagerNeedsRedraw || deckRendererNeedsRedraw;
    return redraw;
  }

  redraw(force) {
    if (!this.layerManager) {
      return;
    }

    const redrawReason = force || this.needsRedraw({
      clearRedrawFlags: true
    });

    if (!redrawReason) {
      return;
    }

    this.stats.get('Redraw Count').incrementCount();

    if (this.props._customRender) {
      this.props._customRender(redrawReason);
    } else {
      this._drawLayers(redrawReason);
    }
  }

  getViews() {
    return this.viewManager.views;
  }

  getViewports(rect) {
    return this.viewManager.getViewports(rect);
  }

  pickObject(opts) {
    const infos = this._pick('pickObject', 'pickObject Time', opts).result;

    return infos.length ? infos[0] : null;
  }

  pickMultipleObjects(opts) {
    opts.depth = opts.depth || 10;
    return this._pick('pickObject', 'pickMultipleObjects Time', opts).result;
  }

  pickObjects(opts) {
    return this._pick('pickObjects', 'pickObjects Time', opts);
  }

  _addResources(resources, forceUpdate = false) {
    for (const id in resources) {
      this.layerManager.resourceManager.add({
        resourceId: id,
        data: resources[id],
        forceUpdate
      });
    }
  }

  _removeResources(resourceIds) {
    for (const id of resourceIds) {
      this.layerManager.resourceManager.remove(id);
    }
  }

  _pick(method, statKey, opts) {
    const {
      stats
    } = this;
    stats.get('Pick Count').incrementCount();
    stats.get(statKey).timeStart();
    const infos = this.deckPicker[method]({
      layers: this.layerManager.getLayers(opts),
      views: this.viewManager.getViews(),
      viewports: this.getViewports(opts),
      onViewportActive: this.layerManager.activateViewport,
      effects: this.effectManager.getEffects(),
      ...opts
    });
    stats.get(statKey).timeEnd();
    return infos;
  }

  _createCanvas(props) {
    let canvas = props.canvas;

    if (typeof canvas === 'string') {
      canvas = document.getElementById(canvas);
      (0, _assert.default)(canvas);
    }

    if (!canvas) {
      canvas = document.createElement('canvas');
      canvas.id = props.id || 'deckgl-overlay';
      const parent = props.parent || document.body;
      parent.appendChild(canvas);
    }

    Object.assign(canvas.style, props.style);
    return canvas;
  }

  _setCanvasSize(props) {
    if (!this.canvas) {
      return;
    }

    let {
      width,
      height
    } = props;

    if (width || width === 0) {
      width = Number.isFinite(width) ? "".concat(width, "px") : width;
      this.canvas.style.width = width;
    }

    if (height || height === 0) {
      height = Number.isFinite(height) ? "".concat(height, "px") : height;
      this.canvas.style.position = 'absolute';
      this.canvas.style.height = height;
    }
  }

  _updateCanvasSize() {
    if (this._checkForCanvasSizeChange()) {
      const {
        width,
        height
      } = this;
      this.viewManager.setProps({
        width,
        height
      });
      this.props.onResize({
        width: this.width,
        height: this.height
      });
    }
  }

  _checkForCanvasSizeChange() {
    const {
      canvas
    } = this;

    if (!canvas) {
      return false;
    }

    const newWidth = canvas.clientWidth || canvas.width;
    const newHeight = canvas.clientHeight || canvas.height;

    if (newWidth !== this.width || newHeight !== this.height) {
      this.width = newWidth;
      this.height = newHeight;
      return true;
    }

    return false;
  }

  _createAnimationLoop(props) {
    const {
      width,
      height,
      gl,
      glOptions,
      debug,
      onError,
      onBeforeRender,
      onAfterRender,
      useDevicePixels,
      autoResizeDrawingBuffer
    } = props;
    return new _core.AnimationLoop({
      width,
      height,
      useDevicePixels,
      autoResizeDrawingBuffer,
      autoResizeViewport: false,
      gl,
      onCreateContext: opts => (0, _core.createGLContext)({ ...glOptions,
        ...opts,
        canvas: this.canvas,
        debug,
        onContextLost: () => this._onContextLost()
      }),
      onInitialize: context => this._setGLContext(context.gl),
      onRender: this._onRenderFrame.bind(this),
      onBeforeRender,
      onAfterRender,
      onError
    });
  }

  _getViewState() {
    return this.props.viewState || this.viewState;
  }

  _getViews() {
    let views = this.props.views || [new _mapView.default({
      id: 'default-view'
    })];
    views = Array.isArray(views) ? views : [views];

    if (views.length && this.props.controller) {
      views[0].props.controller = this.props.controller;
    }

    return views;
  }

  _onContextLost() {
    const {
      onError
    } = this.props;

    if (this.animationLoop && onError) {
      onError(new Error("WebGL context is lost"));
    }
  }

  _onPointerMove(event) {
    const {
      _pickRequest
    } = this;

    if (event.type === 'pointerleave') {
      _pickRequest.x = -1;
      _pickRequest.y = -1;
      _pickRequest.radius = 0;
    } else if (event.leftButton || event.rightButton) {
      return;
    } else {
      const pos = event.offsetCenter;

      if (!pos) {
        return;
      }

      _pickRequest.x = pos.x;
      _pickRequest.y = pos.y;
      _pickRequest.radius = this.props.pickingRadius;
    }

    if (this.layerManager) {
      this.layerManager.context.mousePosition = {
        x: _pickRequest.x,
        y: _pickRequest.y
      };
    }

    _pickRequest.event = event;
    _pickRequest.mode = 'hover';
  }

  _pickAndCallback() {
    const {
      _pickRequest
    } = this;

    if (_pickRequest.event) {
      const {
        result,
        emptyInfo
      } = this._pick('pickObject', 'pickObject Time', _pickRequest);

      this.interactiveState.isHovering = result.length > 0;
      let pickedInfo = emptyInfo;
      let handled = false;

      for (const info of result) {
        pickedInfo = info;
        handled = info.layer.onHover(info, _pickRequest.event);
      }

      if (!handled && this.props.onHover) {
        this.props.onHover(pickedInfo, _pickRequest.event);
      }

      if (this.props.getTooltip) {
        const displayInfo = this.props.getTooltip(pickedInfo);
        this.tooltip.setTooltip(displayInfo, pickedInfo.x, pickedInfo.y);
      }

      _pickRequest.event = null;
    }
  }

  _updateCursor() {
    const container = this.props.parent || this.canvas;

    if (container) {
      container.style.cursor = this.props.getCursor(this.interactiveState);
    }
  }

  _setGLContext(gl) {
    if (this.layerManager) {
      return;
    }

    if (!this.canvas) {
      this.canvas = gl.canvas;
      (0, _core.instrumentGLContext)(gl, {
        enable: true,
        copyState: true
      });
    }

    this.tooltip = new _tooltip.default(this.canvas);
    (0, _core.setParameters)(gl, {
      blend: true,
      blendFunc: [770, 771, 1, 771],
      polygonOffsetFill: true,
      depthTest: true,
      depthFunc: 515
    });
    this.props.onWebGLInitialized(gl);
    const timeline = new _core.Timeline();
    timeline.play();
    this.animationLoop.attachTimeline(timeline);
    this.eventManager = new _mjolnir.EventManager(this.props.parent || gl.canvas, {
      touchAction: this.props.touchAction,
      recognizerOptions: this.props.eventRecognizerOptions,
      events: {
        pointerdown: this._onPointerDown,
        pointermove: this._onPointerMove,
        pointerleave: this._onPointerMove
      }
    });

    for (const eventType in _constants.EVENTS) {
      this.eventManager.on(eventType, this._onEvent);
    }

    this.viewManager = new _viewManager.default({
      timeline,
      eventManager: this.eventManager,
      onViewStateChange: this._onViewStateChange.bind(this),
      onInteractionStateChange: this._onInteractionStateChange.bind(this),
      views: this._getViews(),
      viewState: this._getViewState(),
      width: this.width,
      height: this.height
    });
    const viewport = this.viewManager.getViewports()[0];
    this.layerManager = new _layerManager.default(gl, {
      deck: this,
      stats: this.stats,
      viewport,
      timeline
    });
    this.effectManager = new _effectManager.default();
    this.deckRenderer = new _deckRenderer.default(gl);
    this.deckPicker = new _deckPicker.default(gl);
    this.setProps(this.props);

    this._updateCanvasSize();

    this.props.onLoad();
  }

  _drawLayers(redrawReason, renderOptions) {
    const {
      gl
    } = this.layerManager.context;
    (0, _core.setParameters)(gl, this.props.parameters);
    this.props.onBeforeRender({
      gl
    });
    this.deckRenderer.renderLayers({
      target: this.props._framebuffer,
      layers: this.layerManager.getLayers(),
      viewports: this.viewManager.getViewports(),
      onViewportActive: this.layerManager.activateViewport,
      views: this.viewManager.getViews(),
      pass: 'screen',
      redrawReason,
      effects: this.effectManager.getEffects(),
      ...renderOptions
    });
    this.props.onAfterRender({
      gl
    });
  }

  _onRenderFrame(animationProps) {
    this._getFrameStats();

    if (this._metricsCounter++ % 60 === 0) {
      this._getMetrics();

      this.stats.reset();

      _log.default.table(4, this.metrics)();

      if (this.props._onMetrics) {
        this.props._onMetrics(this.metrics);
      }
    }

    this._updateCanvasSize();

    this._updateCursor();

    if (this.tooltip.isVisible && this.viewManager.needsRedraw()) {
      this.tooltip.setTooltip(null);
    }

    this.layerManager.updateLayers();

    this._pickAndCallback();

    this.redraw(false);

    if (this.viewManager) {
      this.viewManager.updateViewStates();
    }
  }

  _onViewStateChange(params) {
    const viewState = this.props.onViewStateChange(params) || params.viewState;

    if (this.viewState) {
      this.viewState = { ...this.viewState,
        [params.viewId]: viewState
      };

      if (!this.props.viewState) {
        if (this.viewManager) {
          this.viewManager.setProps({
            viewState: this.viewState
          });
        }
      }
    }
  }

  _onInteractionStateChange(interactionState) {
    this.interactiveState.isDragging = interactionState.isDragging;
    this.props.onInteractionStateChange(interactionState);
  }

  _onEvent(event) {
    const eventOptions = _constants.EVENTS[event.type];
    const pos = event.offsetCenter;

    if (!eventOptions || !pos) {
      return;
    }

    const layers = this.layerManager.getLayers();
    const info = this.deckPicker.getLastPickedObject({
      x: pos.x,
      y: pos.y,
      layers,
      viewports: this.getViewports(pos)
    }, this._lastPointerDownInfo);
    const {
      layer
    } = info;
    const layerHandler = layer && (layer[eventOptions.handler] || layer.props[eventOptions.handler]);
    const rootHandler = this.props[eventOptions.handler];
    let handled = false;

    if (layerHandler) {
      handled = layerHandler.call(layer, info, event);
    }

    if (!handled && rootHandler) {
      rootHandler(info, event);
    }
  }

  _onPointerDown(event) {
    const pos = event.offsetCenter;

    const pickedInfo = this._pick('pickObject', 'pickObject Time', {
      x: pos.x,
      y: pos.y,
      radius: this.props.pickingRadius
    });

    this._lastPointerDownInfo = pickedInfo.result[0] || pickedInfo.emptyInfo;
  }

  _getFrameStats() {
    const {
      stats
    } = this;
    stats.get('frameRate').timeEnd();
    stats.get('frameRate').timeStart();
    const animationLoopStats = this.animationLoop.stats;
    stats.get('GPU Time').addTime(animationLoopStats.get('GPU Time').lastTiming);
    stats.get('CPU Time').addTime(animationLoopStats.get('CPU Time').lastTiming);
  }

  _getMetrics() {
    const {
      metrics,
      stats
    } = this;
    metrics.fps = stats.get('frameRate').getHz();
    metrics.setPropsTime = stats.get('setProps Time').time;
    metrics.updateAttributesTime = stats.get('Update Attributes').time;
    metrics.framesRedrawn = stats.get('Redraw Count').count;
    metrics.pickTime = stats.get('pickObject Time').time + stats.get('pickMultipleObjects Time').time + stats.get('pickObjects Time').time;
    metrics.pickCount = stats.get('Pick Count').count;
    metrics.gpuTime = stats.get('GPU Time').time;
    metrics.cpuTime = stats.get('CPU Time').time;
    metrics.gpuTimePerFrame = stats.get('GPU Time').getAverageTime();
    metrics.cpuTimePerFrame = stats.get('CPU Time').getAverageTime();

    const memoryStats = _core.lumaStats.get('Memory Usage');

    metrics.bufferMemory = memoryStats.get('Buffer Memory').count;
    metrics.textureMemory = memoryStats.get('Texture Memory').count;
    metrics.renderbufferMemory = memoryStats.get('Renderbuffer Memory').count;
    metrics.gpuMemory = memoryStats.get('GPU Memory').count;
  }

}

exports.default = Deck;
Deck.getPropTypes = getPropTypes;
Deck.defaultProps = defaultProps;
Deck.VERSION = _init.default.VERSION;
},{"./layer-manager":"node_modules/@deck.gl/core/dist/esm/lib/layer-manager.js","./view-manager":"node_modules/@deck.gl/core/dist/esm/lib/view-manager.js","../views/map-view":"node_modules/@deck.gl/core/dist/esm/views/map-view.js","./effect-manager":"node_modules/@deck.gl/core/dist/esm/lib/effect-manager.js","./effect":"node_modules/@deck.gl/core/dist/esm/lib/effect.js","./deck-renderer":"node_modules/@deck.gl/core/dist/esm/lib/deck-renderer.js","./deck-picker":"node_modules/@deck.gl/core/dist/esm/lib/deck-picker.js","./tooltip":"node_modules/@deck.gl/core/dist/esm/lib/tooltip.js","../utils/log":"node_modules/@deck.gl/core/dist/esm/utils/log.js","../utils/deep-equal":"node_modules/@deck.gl/core/dist/esm/utils/deep-equal.js","../utils/typed-array-manager":"node_modules/@deck.gl/core/dist/esm/utils/typed-array-manager.js","./init":"node_modules/@deck.gl/core/dist/esm/lib/init.js","@probe.gl/env":"node_modules/@probe.gl/env/dist/esm/index.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","@probe.gl/stats":"node_modules/@probe.gl/stats/dist/esm/index.js","mjolnir.js":"node_modules/mjolnir.js/dist/esm/index.js","../utils/assert":"node_modules/@deck.gl/core/dist/esm/utils/assert.js","./constants":"node_modules/@deck.gl/core/dist/esm/lib/constants.js"}],"node_modules/@deck.gl/core/dist/esm/lib/attribute/shader-attribute.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

class ShaderAttribute {
  constructor(dataColumn, opts) {
    this.opts = opts;
    this.source = dataColumn;
  }

  get value() {
    return this.source.value;
  }

  getValue() {
    const buffer = this.source.getBuffer();
    const accessor = this.getAccessor();

    if (buffer) {
      return [buffer, accessor];
    }

    const {
      value
    } = this.source;
    const {
      size
    } = accessor;
    let constantValue = value;

    if (value && value.length !== size) {
      constantValue = new Float32Array(size);
      const index = accessor.elementOffset || 0;

      for (let i = 0; i < size; ++i) {
        constantValue[i] = value[index + i];
      }
    }

    return constantValue;
  }

  getAccessor() {
    return { ...this.source.getAccessor(),
      ...this.opts
    };
  }

}

exports.default = ShaderAttribute;
},{}],"node_modules/@deck.gl/core/dist/esm/lib/attribute/gl-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.glArrayFromType = glArrayFromType;

function glArrayFromType(glType) {
  switch (glType) {
    case 5126:
      return Float32Array;

    case 5130:
      return Float64Array;

    case 5123:
    case 33635:
    case 32819:
    case 32820:
      return Uint16Array;

    case 5125:
      return Uint32Array;

    case 5121:
      return Uint8ClampedArray;

    case 5120:
      return Int8Array;

    case 5122:
      return Int16Array;

    case 5124:
      return Int32Array;

    default:
      throw new Error('Unknown GL type');
  }
}
},{}],"node_modules/@deck.gl/core/dist/esm/lib/attribute/data-column.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _core = require("@luma.gl/core");

var _shaderAttribute = _interopRequireDefault(require("./shader-attribute"));

var _glUtils = require("./gl-utils");

var _typedArrayManager = _interopRequireDefault(require("../../utils/typed-array-manager"));

var _mathUtils = require("../../utils/math-utils");

var _log = _interopRequireDefault(require("../../utils/log"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getStride(accessor) {
  return accessor.stride || accessor.size * accessor.bytesPerElement;
}

function resolveShaderAttribute(baseAccessor, shaderAttributeOptions) {
  if (shaderAttributeOptions.offset) {
    _log.default.removed('shaderAttribute.offset', 'vertexOffset, elementOffset')();
  }

  const stride = getStride(baseAccessor);
  const vertexOffset = 'vertexOffset' in shaderAttributeOptions ? shaderAttributeOptions.vertexOffset : baseAccessor.vertexOffset || 0;
  const elementOffset = shaderAttributeOptions.elementOffset || 0;
  const offset = vertexOffset * stride + elementOffset * baseAccessor.bytesPerElement + (baseAccessor.offset || 0);
  return { ...shaderAttributeOptions,
    offset,
    stride
  };
}

function resolveDoublePrecisionShaderAttributes(baseAccessor, shaderAttributeOptions) {
  const resolvedOptions = resolveShaderAttribute(baseAccessor, shaderAttributeOptions);
  return {
    high: resolvedOptions,
    low: { ...resolvedOptions,
      offset: resolvedOptions.offset + baseAccessor.size * 4
    }
  };
}

class DataColumn {
  constructor(gl, opts) {
    this.gl = gl;
    this.id = opts.id;
    this.size = opts.size;
    const logicalType = opts.logicalType || opts.type;
    const doublePrecision = logicalType === 5130;
    let {
      defaultValue
    } = opts;
    defaultValue = Number.isFinite(defaultValue) ? [defaultValue] : defaultValue || new Array(this.size).fill(0);
    opts.defaultValue = defaultValue;
    let bufferType = logicalType;

    if (doublePrecision) {
      bufferType = 5126;
    } else if (!bufferType && opts.isIndexed) {
      bufferType = gl && (0, _core.hasFeature)(gl, _core.FEATURES.ELEMENT_INDEX_UINT32) ? 5125 : 5123;
    } else if (!bufferType) {
      bufferType = 5126;
    }

    opts.logicalType = logicalType;
    opts.type = bufferType;
    let defaultType = (0, _glUtils.glArrayFromType)(logicalType || bufferType || 5126);
    this.shaderAttributes = {};
    this.doublePrecision = doublePrecision;

    if (doublePrecision && opts.fp64 === false) {
      defaultType = Float32Array;
    }

    opts.bytesPerElement = defaultType.BYTES_PER_ELEMENT;
    this.defaultType = defaultType;
    this.value = null;
    this.settings = opts;
    this.state = {
      externalBuffer: null,
      bufferAccessor: opts,
      allocatedValue: null,
      numInstances: 0,
      bounds: null,
      constant: false
    };
    this._buffer = null;
    this.setData(opts);
  }

  get buffer() {
    if (!this._buffer) {
      const {
        isIndexed,
        type
      } = this.settings;
      this._buffer = new _core.Buffer(this.gl, {
        id: this.id,
        target: isIndexed ? 34963 : 34962,
        accessor: {
          type
        }
      });
    }

    return this._buffer;
  }

  get byteOffset() {
    const accessor = this.getAccessor();

    if (accessor.vertexOffset) {
      return accessor.vertexOffset * getStride(accessor);
    }

    return 0;
  }

  get numInstances() {
    return this.state.numInstances;
  }

  set numInstances(n) {
    this.state.numInstances = n;
  }

  delete() {
    if (this._buffer) {
      this._buffer.delete();

      this._buffer = null;
    }

    _typedArrayManager.default.release(this.state.allocatedValue);
  }

  getShaderAttributes(id, options) {
    if (this.doublePrecision) {
      const shaderAttributes = {};
      const isBuffer64Bit = this.value instanceof Float64Array;
      const doubleShaderAttributeDefs = resolveDoublePrecisionShaderAttributes(this.getAccessor(), options || {});
      shaderAttributes[id] = new _shaderAttribute.default(this, doubleShaderAttributeDefs.high);
      shaderAttributes["".concat(id, "64Low")] = isBuffer64Bit ? new _shaderAttribute.default(this, doubleShaderAttributeDefs.low) : new Float32Array(this.size);
      return shaderAttributes;
    }

    if (options) {
      const shaderAttributeDef = resolveShaderAttribute(this.getAccessor(), options);
      return {
        [id]: new _shaderAttribute.default(this, shaderAttributeDef)
      };
    }

    return {
      [id]: this
    };
  }

  getBuffer() {
    if (this.state.constant) {
      return null;
    }

    return this.state.externalBuffer || this._buffer;
  }

  getValue() {
    if (this.state.constant) {
      return this.value;
    }

    return [this.getBuffer(), this.getAccessor()];
  }

  getAccessor() {
    return this.state.bufferAccessor;
  }

  getBounds() {
    if (this.state.bounds) {
      return this.state.bounds;
    }

    let result = null;

    if (this.state.constant) {
      const min = this.value.slice();
      result = [min, min];
    } else {
      const {
        value,
        numInstances,
        size
      } = this;
      const len = numInstances * size;

      if (value && len && value.length >= len) {
        const min = new Array(size).fill(Infinity);
        const max = new Array(size).fill(-Infinity);

        for (let i = 0; i < len;) {
          for (let j = 0; j < size; j++) {
            const v = value[i++];
            if (v < min[j]) min[j] = v;
            if (v > max[j]) max[j] = v;
          }
        }

        result = [min, max];
      }
    }

    this.state.bounds = result;
    return result;
  }

  setData(opts) {
    const {
      state
    } = this;

    if (ArrayBuffer.isView(opts)) {
      opts = {
        value: opts
      };
    } else if (opts instanceof _core.Buffer) {
      opts = {
        buffer: opts
      };
    }

    const accessor = { ...this.settings,
      ...opts
    };
    state.bufferAccessor = accessor;
    state.bounds = null;

    if (opts.constant) {
      let value = opts.value;
      value = this._normalizeValue(value, [], 0);

      if (this.settings.normalized) {
        value = this._normalizeConstant(value);
      }

      const hasChanged = !state.constant || !this._areValuesEqual(value, this.value);

      if (!hasChanged) {
        return false;
      }

      state.externalBuffer = null;
      state.constant = true;
      this.value = value;
    } else if (opts.buffer) {
      const buffer = opts.buffer;
      state.externalBuffer = buffer;
      state.constant = false;
      this.value = opts.value;
      const isBuffer64Bit = opts.value instanceof Float64Array;
      accessor.type = opts.type || buffer.accessor.type;
      accessor.bytesPerElement = buffer.accessor.BYTES_PER_ELEMENT * (isBuffer64Bit ? 2 : 1);
      accessor.stride = getStride(accessor);
    } else if (opts.value) {
      this._checkExternalBuffer(opts);

      let value = opts.value;
      state.externalBuffer = null;
      state.constant = false;
      this.value = value;
      accessor.bytesPerElement = value.BYTES_PER_ELEMENT;
      accessor.stride = getStride(accessor);
      const {
        buffer,
        byteOffset
      } = this;

      if (this.doublePrecision && value instanceof Float64Array) {
        value = (0, _mathUtils.toDoublePrecisionArray)(value, accessor);
      }

      const requiredBufferSize = value.byteLength + byteOffset + accessor.stride * 2;

      if (buffer.byteLength < requiredBufferSize) {
        buffer.reallocate(requiredBufferSize);
      }

      buffer.setAccessor(null);
      buffer.subData({
        data: value,
        offset: byteOffset
      });
      accessor.type = opts.type || buffer.accessor.type;
    }

    return true;
  }

  updateSubBuffer(opts = {}) {
    this.state.bounds = null;
    const {
      value
    } = this;
    const {
      startOffset = 0,
      endOffset
    } = opts;
    this.buffer.subData({
      data: this.doublePrecision && value instanceof Float64Array ? (0, _mathUtils.toDoublePrecisionArray)(value, {
        size: this.size,
        startIndex: startOffset,
        endIndex: endOffset
      }) : value.subarray(startOffset, endOffset),
      offset: startOffset * value.BYTES_PER_ELEMENT + this.byteOffset
    });
  }

  allocate({
    numInstances,
    copy = false
  }) {
    const {
      state
    } = this;
    const oldValue = state.allocatedValue;

    const value = _typedArrayManager.default.allocate(oldValue, numInstances + 1, {
      size: this.size,
      type: this.defaultType,
      copy
    });

    this.value = value;
    const {
      buffer,
      byteOffset
    } = this;

    if (buffer.byteLength < value.byteLength + byteOffset) {
      buffer.reallocate(value.byteLength + byteOffset);

      if (copy && oldValue) {
        buffer.subData({
          data: oldValue instanceof Float64Array ? (0, _mathUtils.toDoublePrecisionArray)(oldValue, this) : oldValue,
          offset: byteOffset
        });
      }
    }

    state.allocatedValue = value;
    state.constant = false;
    state.externalBuffer = null;
    state.bufferAccessor = this.settings;
    return true;
  }

  _checkExternalBuffer(opts) {
    const {
      value
    } = opts;

    if (!opts.constant && value) {
      const ArrayType = this.defaultType;
      let illegalArrayType = false;

      if (this.doublePrecision) {
        illegalArrayType = value.BYTES_PER_ELEMENT < 4;
      }

      if (illegalArrayType) {
        throw new Error("Attribute ".concat(this.id, " does not support ").concat(value.constructor.name));
      }

      if (!(value instanceof ArrayType) && this.settings.normalized && !('normalized' in opts)) {
        _log.default.warn("Attribute ".concat(this.id, " is normalized"))();
      }
    }
  }

  _normalizeConstant(value) {
    switch (this.settings.type) {
      case 5120:
        return new Float32Array(value).map(x => (x + 128) / 255 * 2 - 1);

      case 5122:
        return new Float32Array(value).map(x => (x + 32768) / 65535 * 2 - 1);

      case 5121:
        return new Float32Array(value).map(x => x / 255);

      case 5123:
        return new Float32Array(value).map(x => x / 65535);

      default:
        return value;
    }
  }

  _normalizeValue(value, out, start) {
    const {
      defaultValue,
      size
    } = this.settings;

    if (Number.isFinite(value)) {
      out[start] = value;
      return out;
    }

    if (!value) {
      out[start] = defaultValue[0];
      return out;
    }

    switch (size) {
      case 4:
        out[start + 3] = Number.isFinite(value[3]) ? value[3] : defaultValue[3];

      case 3:
        out[start + 2] = Number.isFinite(value[2]) ? value[2] : defaultValue[2];

      case 2:
        out[start + 1] = Number.isFinite(value[1]) ? value[1] : defaultValue[1];

      case 1:
        out[start + 0] = Number.isFinite(value[0]) ? value[0] : defaultValue[0];
        break;

      default:
        let i = size;

        while (--i >= 0) {
          out[start + i] = Number.isFinite(value[i]) ? value[i] : defaultValue[i];
        }

    }

    return out;
  }

  _areValuesEqual(value1, value2) {
    if (!value1 || !value2) {
      return false;
    }

    const {
      size
    } = this;

    for (let i = 0; i < size; i++) {
      if (value1[i] !== value2[i]) {
        return false;
      }
    }

    return true;
  }

}

exports.default = DataColumn;
},{"@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","./shader-attribute":"node_modules/@deck.gl/core/dist/esm/lib/attribute/shader-attribute.js","./gl-utils":"node_modules/@deck.gl/core/dist/esm/lib/attribute/gl-utils.js","../../utils/typed-array-manager":"node_modules/@deck.gl/core/dist/esm/utils/typed-array-manager.js","../../utils/math-utils":"node_modules/@deck.gl/core/dist/esm/utils/math-utils.js","../../utils/log":"node_modules/@deck.gl/core/dist/esm/utils/log.js"}],"node_modules/@deck.gl/core/dist/esm/utils/iterable-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createIterable = createIterable;
exports.getAccessorFromBuffer = getAccessorFromBuffer;
exports.isAsyncIterable = isAsyncIterable;
const EMPTY_ARRAY = [];
const placeholderArray = [];

function createIterable(data, startRow = 0, endRow = Infinity) {
  let iterable = EMPTY_ARRAY;
  const objectInfo = {
    index: -1,
    data,
    target: []
  };

  if (!data) {
    iterable = EMPTY_ARRAY;
  } else if (typeof data[Symbol.iterator] === 'function') {
    iterable = data;
  } else if (data.length > 0) {
    placeholderArray.length = data.length;
    iterable = placeholderArray;
  }

  if (startRow > 0 || Number.isFinite(endRow)) {
    iterable = (Array.isArray(iterable) ? iterable : Array.from(iterable)).slice(startRow, endRow);
    objectInfo.index = startRow - 1;
  }

  return {
    iterable,
    objectInfo
  };
}

function isAsyncIterable(data) {
  return data && data[Symbol.asyncIterator];
}

function getAccessorFromBuffer(typedArray, options) {
  const {
    size,
    stride,
    offset,
    startIndices,
    nested
  } = options;
  const bytesPerElement = typedArray.BYTES_PER_ELEMENT;
  const elementStride = stride ? stride / bytesPerElement : size;
  const elementOffset = offset ? offset / bytesPerElement : 0;
  const vertexCount = Math.floor((typedArray.length - elementOffset) / elementStride);
  return (_, {
    index,
    target
  }) => {
    if (!startIndices) {
      const sourceIndex = index * elementStride + elementOffset;

      for (let j = 0; j < size; j++) {
        target[j] = typedArray[sourceIndex + j];
      }

      return target;
    }

    const startIndex = startIndices[index];
    const endIndex = startIndices[index + 1] || vertexCount;
    let result;

    if (nested) {
      result = new Array(endIndex - startIndex);

      for (let i = startIndex; i < endIndex; i++) {
        const sourceIndex = i * elementStride + elementOffset;
        target = new Array(size);

        for (let j = 0; j < size; j++) {
          target[j] = typedArray[sourceIndex + j];
        }

        result[i - startIndex] = target;
      }
    } else if (elementStride === size) {
      result = typedArray.subarray(startIndex * size + elementOffset, endIndex * size + elementOffset);
    } else {
      result = new typedArray.constructor((endIndex - startIndex) * size);
      let targetIndex = 0;

      for (let i = startIndex; i < endIndex; i++) {
        const sourceIndex = i * elementStride + elementOffset;

        for (let j = 0; j < size; j++) {
          result[targetIndex++] = typedArray[sourceIndex + j];
        }
      }
    }

    return result;
  };
}
},{}],"node_modules/@deck.gl/core/dist/esm/utils/range.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FULL = exports.EMPTY = void 0;
exports.add = add;
const EMPTY = [];
exports.EMPTY = EMPTY;
const FULL = [[0, Infinity]];
exports.FULL = FULL;

function add(rangeList, range) {
  if (rangeList === FULL) {
    return rangeList;
  }

  if (range[0] < 0) {
    range[0] = 0;
  }

  if (range[0] >= range[1]) {
    return rangeList;
  }

  const newRangeList = [];
  const len = rangeList.length;
  let insertPosition = 0;

  for (let i = 0; i < len; i++) {
    const range0 = rangeList[i];

    if (range0[1] < range[0]) {
      newRangeList.push(range0);
      insertPosition = i + 1;
    } else if (range0[0] > range[1]) {
      newRangeList.push(range0);
    } else {
      range = [Math.min(range0[0], range[0]), Math.max(range0[1], range[1])];
    }
  }

  newRangeList.splice(insertPosition, 0, range);
  return newRangeList;
}
},{}],"node_modules/@deck.gl/core/dist/esm/utils/array-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.padArray = padArray;

function padArrayChunk(options) {
  const {
    source,
    target,
    start = 0,
    size,
    getData
  } = options;
  const end = options.end || target.length;
  const sourceLength = source.length;
  const targetLength = end - start;

  if (sourceLength > targetLength) {
    target.set(source.subarray(0, targetLength), start);
    return;
  }

  target.set(source, start);

  if (!getData) {
    return;
  }

  let i = sourceLength;

  while (i < targetLength) {
    const datum = getData(i, source);

    for (let j = 0; j < size; j++) {
      target[start + i] = datum[j] || 0;
      i++;
    }
  }
}

function padArray({
  source,
  target,
  size,
  getData,
  sourceStartIndices,
  targetStartIndices
}) {
  if (!Array.isArray(targetStartIndices)) {
    padArrayChunk({
      source,
      target,
      size,
      getData
    });
    return target;
  }

  let sourceIndex = 0;
  let targetIndex = 0;

  const getChunkData = getData && ((i, chunk) => getData(i + targetIndex, chunk));

  const n = Math.min(sourceStartIndices.length, targetStartIndices.length);

  for (let i = 1; i < n; i++) {
    const nextSourceIndex = sourceStartIndices[i] * size;
    const nextTargetIndex = targetStartIndices[i] * size;
    padArrayChunk({
      source: source.subarray(sourceIndex, nextSourceIndex),
      target,
      start: targetIndex,
      end: nextTargetIndex,
      size,
      getData: getChunkData
    });
    sourceIndex = nextSourceIndex;
    targetIndex = nextTargetIndex;
  }

  if (targetIndex < target.length) {
    padArrayChunk({
      source: [],
      target,
      start: targetIndex,
      size,
      getData: getChunkData
    });
  }

  return target;
}
},{}],"node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-transition-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cycleBuffers = cycleBuffers;
exports.getAttributeBufferLength = getAttributeBufferLength;
exports.getAttributeTypeFromSize = getAttributeTypeFromSize;
exports.getSourceBufferAttribute = getSourceBufferAttribute;
exports.normalizeTransitionSettings = normalizeTransitionSettings;
exports.padBuffer = padBuffer;

var _arrayUtils = require("../../utils/array-utils");

const DEFAULT_TRANSITION_SETTINGS = {
  interpolation: {
    duration: 0,
    easing: t => t
  },
  spring: {
    stiffness: 0.05,
    damping: 0.5
  }
};

function normalizeTransitionSettings(userSettings, layerSettings) {
  if (!userSettings) {
    return null;
  }

  if (Number.isFinite(userSettings)) {
    userSettings = {
      duration: userSettings
    };
  }

  userSettings.type = userSettings.type || 'interpolation';
  return { ...DEFAULT_TRANSITION_SETTINGS[userSettings.type],
    ...layerSettings,
    ...userSettings
  };
}

function getSourceBufferAttribute(gl, attribute) {
  const buffer = attribute.getBuffer();

  if (buffer) {
    return [attribute.getBuffer(), {
      divisor: 0,
      size: attribute.size,
      normalized: attribute.settings.normalized
    }];
  }

  return attribute.value;
}

function getAttributeTypeFromSize(size) {
  switch (size) {
    case 1:
      return 'float';

    case 2:
      return 'vec2';

    case 3:
      return 'vec3';

    case 4:
      return 'vec4';

    default:
      throw new Error("No defined attribute type for size \"".concat(size, "\""));
  }
}

function cycleBuffers(buffers) {
  buffers.push(buffers.shift());
}

function getAttributeBufferLength(attribute, numInstances) {
  const {
    doublePrecision,
    settings,
    value,
    size
  } = attribute;
  const multiplier = doublePrecision && value instanceof Float64Array ? 2 : 1;
  return (settings.noAlloc ? value.length : numInstances * size) * multiplier;
}

function padBuffer({
  buffer,
  numInstances,
  attribute,
  fromLength,
  fromStartIndices,
  getData = x => x
}) {
  const precisionMultiplier = attribute.doublePrecision && attribute.value instanceof Float64Array ? 2 : 1;
  const size = attribute.size * precisionMultiplier;
  const byteOffset = attribute.byteOffset;
  const toStartIndices = attribute.startIndices;
  const hasStartIndices = fromStartIndices && toStartIndices;
  const toLength = getAttributeBufferLength(attribute, numInstances);
  const isConstant = attribute.state.constant;

  if (!hasStartIndices && fromLength >= toLength) {
    return;
  }

  const toData = isConstant ? attribute.value : attribute.getBuffer().getData({
    srcByteOffset: byteOffset
  });

  if (attribute.settings.normalized && !isConstant) {
    const getter = getData;

    getData = (value, chunk) => attribute._normalizeConstant(getter(value, chunk));
  }

  const getMissingData = isConstant ? (i, chunk) => getData(toData, chunk) : (i, chunk) => getData(toData.subarray(i, i + size), chunk);
  const source = buffer.getData({
    length: fromLength
  });
  const data = new Float32Array(toLength);
  (0, _arrayUtils.padArray)({
    source,
    target: data,
    sourceStartIndices: fromStartIndices,
    targetStartIndices: toStartIndices,
    size,
    getData: getMissingData
  });

  if (buffer.byteLength < data.byteLength + byteOffset) {
    buffer.reallocate(data.byteLength + byteOffset);
  }

  buffer.subData({
    data,
    offset: byteOffset
  });
}
},{"../../utils/array-utils":"node_modules/@deck.gl/core/dist/esm/utils/array-utils.js"}],"node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _dataColumn = _interopRequireDefault(require("./data-column"));

var _assert = _interopRequireDefault(require("../../utils/assert"));

var _iterableUtils = require("../../utils/iterable-utils");

var _flatten = require("../../utils/flatten");

var range = _interopRequireWildcard(require("../../utils/range"));

var _attributeTransitionUtils = require("./attribute-transition-utils");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class Attribute extends _dataColumn.default {
  constructor(gl, opts = {}) {
    super(gl, opts);
    const {
      transition = false,
      noAlloc = false,
      update = null,
      accessor = null,
      transform = null,
      startIndices = null
    } = opts;
    Object.assign(this.settings, {
      transition,
      noAlloc,
      update: update || accessor && this._autoUpdater,
      accessor,
      transform
    });
    Object.assign(this.state, {
      lastExternalBuffer: null,
      binaryValue: null,
      binaryAccessor: null,
      needsUpdate: true,
      needsRedraw: false,
      updateRanges: range.FULL,
      startIndices
    });
    Object.seal(this.settings);
    Object.seal(this.state);

    this._validateAttributeUpdaters();
  }

  get startIndices() {
    return this.state.startIndices;
  }

  set startIndices(layout) {
    this.state.startIndices = layout;
  }

  needsUpdate() {
    return this.state.needsUpdate;
  }

  needsRedraw({
    clearChangedFlags = false
  } = {}) {
    const needsRedraw = this.state.needsRedraw;
    this.state.needsRedraw = needsRedraw && !clearChangedFlags;
    return needsRedraw;
  }

  getUpdateTriggers() {
    const {
      accessor
    } = this.settings;
    return [this.id].concat(typeof accessor !== 'function' && accessor || []);
  }

  supportsTransition() {
    return Boolean(this.settings.transition);
  }

  getTransitionSetting(opts) {
    if (!opts || !this.supportsTransition()) {
      return null;
    }

    const {
      accessor
    } = this.settings;
    const layerSettings = this.settings.transition;
    const userSettings = Array.isArray(accessor) ? opts[accessor.find(a => opts[a])] : opts[accessor];
    return (0, _attributeTransitionUtils.normalizeTransitionSettings)(userSettings, layerSettings);
  }

  setNeedsUpdate(reason = this.id, dataRange) {
    this.state.needsUpdate = this.state.needsUpdate || reason;
    this.setNeedsRedraw(reason);

    if (dataRange) {
      const {
        startRow = 0,
        endRow = Infinity
      } = dataRange;
      this.state.updateRanges = range.add(this.state.updateRanges, [startRow, endRow]);
    } else {
      this.state.updateRanges = range.FULL;
    }
  }

  clearNeedsUpdate() {
    this.state.needsUpdate = false;
    this.state.updateRanges = range.EMPTY;
  }

  setNeedsRedraw(reason = this.id) {
    this.state.needsRedraw = this.state.needsRedraw || reason;
  }

  update(opts) {
    this.setData(opts);
  }

  allocate(numInstances) {
    const {
      state,
      settings
    } = this;

    if (settings.noAlloc) {
      return false;
    }

    if (settings.update) {
      super.allocate({
        numInstances,
        copy: state.updateRanges !== range.FULL
      });
      return true;
    }

    return false;
  }

  updateBuffer({
    numInstances,
    data,
    props,
    context
  }) {
    if (!this.needsUpdate()) {
      return false;
    }

    const {
      state: {
        updateRanges
      },
      settings: {
        update,
        noAlloc
      }
    } = this;
    let updated = true;

    if (update) {
      for (const [startRow, endRow] of updateRanges) {
        update.call(context, this, {
          data,
          startRow,
          endRow,
          props,
          numInstances
        });
      }

      if (!this.value) {} else if (this.constant || this.buffer.byteLength < this.value.byteLength + this.byteOffset) {
        this.setData({
          value: this.value,
          constant: this.constant
        });
        this.constant = false;
      } else {
        for (const [startRow, endRow] of updateRanges) {
          const startOffset = Number.isFinite(startRow) ? this.getVertexOffset(startRow) : 0;
          const endOffset = Number.isFinite(endRow) ? this.getVertexOffset(endRow) : noAlloc || !Number.isFinite(numInstances) ? this.value.length : numInstances * this.size;
          super.updateSubBuffer({
            startOffset,
            endOffset
          });
        }
      }

      this._checkAttributeArray();
    } else {
      updated = false;
    }

    this.clearNeedsUpdate();
    this.setNeedsRedraw();
    return updated;
  }

  setConstantValue(value) {
    if (value === undefined || typeof value === 'function') {
      return false;
    }

    const hasChanged = this.setData({
      constant: true,
      value
    });

    if (hasChanged) {
      this.setNeedsRedraw();
    }

    this.clearNeedsUpdate();
    return true;
  }

  setExternalBuffer(buffer) {
    const {
      state
    } = this;

    if (!buffer) {
      state.lastExternalBuffer = null;
      return false;
    }

    this.clearNeedsUpdate();

    if (state.lastExternalBuffer === buffer) {
      return true;
    }

    state.lastExternalBuffer = buffer;
    this.setNeedsRedraw();
    this.setData(buffer);
    return true;
  }

  setBinaryValue(buffer, startIndices = null) {
    const {
      state,
      settings
    } = this;

    if (!buffer) {
      state.binaryValue = null;
      state.binaryAccessor = null;
      return false;
    }

    if (settings.noAlloc) {
      return false;
    }

    if (state.binaryValue === buffer) {
      this.clearNeedsUpdate();
      return true;
    }

    state.binaryValue = buffer;
    this.setNeedsRedraw();

    if (ArrayBuffer.isView(buffer)) {
      buffer = {
        value: buffer
      };
    }

    const needsUpdate = settings.transform || startIndices !== this.startIndices;

    if (needsUpdate) {
      (0, _assert.default)(ArrayBuffer.isView(buffer.value), "invalid ".concat(settings.accessor));
      const needsNormalize = buffer.size && buffer.size !== this.size;
      state.binaryAccessor = (0, _iterableUtils.getAccessorFromBuffer)(buffer.value, {
        size: buffer.size || this.size,
        stride: buffer.stride,
        offset: buffer.offset,
        startIndices,
        nested: needsNormalize
      });
      return false;
    }

    this.clearNeedsUpdate();
    this.setData(buffer);
    return true;
  }

  getVertexOffset(row) {
    const {
      startIndices
    } = this;
    const vertexIndex = startIndices ? startIndices[row] : row;
    return vertexIndex * this.size;
  }

  getShaderAttributes() {
    const shaderAttributeDefs = this.settings.shaderAttributes || {
      [this.id]: null
    };
    const shaderAttributes = {};

    for (const shaderAttributeName in shaderAttributeDefs) {
      Object.assign(shaderAttributes, super.getShaderAttributes(shaderAttributeName, shaderAttributeDefs[shaderAttributeName]));
    }

    return shaderAttributes;
  }

  _autoUpdater(attribute, {
    data,
    startRow,
    endRow,
    props,
    numInstances
  }) {
    if (attribute.constant) {
      return;
    }

    const {
      settings,
      state,
      value,
      size,
      startIndices
    } = attribute;
    const {
      accessor,
      transform
    } = settings;
    const accessorFunc = state.binaryAccessor || (typeof accessor === 'function' ? accessor : props[accessor]);
    (0, _assert.default)(typeof accessorFunc === 'function', "accessor \"".concat(accessor, "\" is not a function"));
    let i = attribute.getVertexOffset(startRow);
    const {
      iterable,
      objectInfo
    } = (0, _iterableUtils.createIterable)(data, startRow, endRow);

    for (const object of iterable) {
      objectInfo.index++;
      let objectValue = accessorFunc(object, objectInfo);

      if (transform) {
        objectValue = transform.call(this, objectValue);
      }

      if (startIndices) {
        const numVertices = (objectInfo.index < startIndices.length - 1 ? startIndices[objectInfo.index + 1] : numInstances) - startIndices[objectInfo.index];

        if (objectValue && Array.isArray(objectValue[0])) {
          let startIndex = i;

          for (const item of objectValue) {
            attribute._normalizeValue(item, value, startIndex);

            startIndex += size;
          }
        } else if (objectValue && objectValue.length > size) {
          value.set(objectValue, i);
        } else {
          attribute._normalizeValue(objectValue, objectInfo.target, 0);

          (0, _flatten.fillArray)({
            target: value,
            source: objectInfo.target,
            start: i,
            count: numVertices
          });
        }

        i += numVertices * size;
      } else {
        attribute._normalizeValue(objectValue, value, i);

        i += size;
      }
    }
  }

  _validateAttributeUpdaters() {
    const {
      settings
    } = this;
    const hasUpdater = settings.noAlloc || typeof settings.update === 'function';

    if (!hasUpdater) {
      throw new Error("Attribute ".concat(this.id, " missing update or accessor"));
    }
  }

  _checkAttributeArray() {
    const {
      value
    } = this;
    const limit = Math.min(4, this.size);

    if (value && value.length >= limit) {
      let valid = true;

      switch (limit) {
        case 4:
          valid = valid && Number.isFinite(value[3]);

        case 3:
          valid = valid && Number.isFinite(value[2]);

        case 2:
          valid = valid && Number.isFinite(value[1]);

        case 1:
          valid = valid && Number.isFinite(value[0]);
          break;

        default:
          valid = false;
      }

      if (!valid) {
        throw new Error("Illegal attribute generated for ".concat(this.id));
      }
    }
  }

}

exports.default = Attribute;
},{"./data-column":"node_modules/@deck.gl/core/dist/esm/lib/attribute/data-column.js","../../utils/assert":"node_modules/@deck.gl/core/dist/esm/utils/assert.js","../../utils/iterable-utils":"node_modules/@deck.gl/core/dist/esm/utils/iterable-utils.js","../../utils/flatten":"node_modules/@deck.gl/core/dist/esm/utils/flatten.js","../../utils/range":"node_modules/@deck.gl/core/dist/esm/utils/range.js","./attribute-transition-utils":"node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-transition-utils.js"}],"node_modules/@deck.gl/core/dist/esm/transitions/gpu-interpolation-transition.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _core = require("@luma.gl/core");

var _attribute = _interopRequireDefault(require("../lib/attribute/attribute"));

var _attributeTransitionUtils = require("../lib/attribute/attribute-transition-utils");

var _transition = _interopRequireDefault(require("./transition"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class GPUInterpolationTransition {
  constructor({
    gl,
    attribute,
    timeline
  }) {
    this.gl = gl;
    this.type = 'interpolation';
    this.transition = new _transition.default(timeline);
    this.attribute = attribute;
    this.attributeInTransition = new _attribute.default(gl, attribute.settings);
    this.currentStartIndices = attribute.startIndices;
    this.currentLength = 0;
    this.transform = getTransform(gl, attribute);
    const bufferOpts = {
      byteLength: 0,
      usage: 35050
    };
    this.buffers = [new _core.Buffer(gl, bufferOpts), new _core.Buffer(gl, bufferOpts)];
  }

  get inProgress() {
    return this.transition.inProgress;
  }

  start(transitionSettings, numInstances) {
    if (transitionSettings.duration <= 0) {
      this.transition.cancel();
      return;
    }

    const {
      gl,
      buffers,
      attribute
    } = this;
    (0, _attributeTransitionUtils.cycleBuffers)(buffers);
    const padBufferOpts = {
      numInstances,
      attribute,
      fromLength: this.currentLength,
      fromStartIndices: this.currentStartIndices,
      getData: transitionSettings.enter
    };

    for (const buffer of buffers) {
      (0, _attributeTransitionUtils.padBuffer)({
        buffer,
        ...padBufferOpts
      });
    }

    this.currentStartIndices = attribute.startIndices;
    this.currentLength = (0, _attributeTransitionUtils.getAttributeBufferLength)(attribute, numInstances);
    this.attributeInTransition.update({
      buffer: buffers[1],
      value: attribute.value
    });
    this.transition.start(transitionSettings);
    this.transform.update({
      elementCount: Math.floor(this.currentLength / attribute.size),
      sourceBuffers: {
        aFrom: buffers[0],
        aTo: (0, _attributeTransitionUtils.getSourceBufferAttribute)(gl, attribute)
      },
      feedbackBuffers: {
        vCurrent: buffers[1]
      }
    });
  }

  update() {
    const updated = this.transition.update();

    if (updated) {
      const {
        time,
        settings: {
          duration,
          easing
        }
      } = this.transition;
      const t = easing(time / duration);
      this.transform.run({
        uniforms: {
          time: t
        }
      });
    }

    return updated;
  }

  cancel() {
    this.transition.cancel();
    this.transform.delete();

    while (this.buffers.length) {
      this.buffers.pop().delete();
    }
  }

}

exports.default = GPUInterpolationTransition;
const vs = "\n#define SHADER_NAME interpolation-transition-vertex-shader\n\nuniform float time;\nattribute ATTRIBUTE_TYPE aFrom;\nattribute ATTRIBUTE_TYPE aTo;\nvarying ATTRIBUTE_TYPE vCurrent;\n\nvoid main(void) {\n  vCurrent = mix(aFrom, aTo, time);\n  gl_Position = vec4(0.0);\n}\n";

function getTransform(gl, attribute) {
  const attributeType = (0, _attributeTransitionUtils.getAttributeTypeFromSize)(attribute.size);
  return new _core.Transform(gl, {
    vs,
    defines: {
      ATTRIBUTE_TYPE: attributeType
    },
    varyings: ['vCurrent']
  });
}
},{"@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","../lib/attribute/attribute":"node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute.js","../lib/attribute/attribute-transition-utils":"node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-transition-utils.js","./transition":"node_modules/@deck.gl/core/dist/esm/transitions/transition.js"}],"node_modules/@deck.gl/core/dist/esm/transitions/gpu-spring-transition.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _core = require("@luma.gl/core");

var _attributeTransitionUtils = require("../lib/attribute/attribute-transition-utils");

var _attribute = _interopRequireDefault(require("../lib/attribute/attribute"));

var _transition = _interopRequireDefault(require("./transition"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class GPUSpringTransition {
  constructor({
    gl,
    attribute,
    timeline
  }) {
    this.gl = gl;
    this.type = 'spring';
    this.transition = new _transition.default(timeline);
    this.attribute = attribute;
    this.attributeInTransition = new _attribute.default(gl, { ...attribute.settings,
      normalized: false
    });
    this.currentStartIndices = attribute.startIndices;
    this.currentLength = 0;
    this.texture = getTexture(gl);
    this.framebuffer = getFramebuffer(gl, this.texture);
    this.transform = getTransform(gl, attribute, this.framebuffer);
    const bufferOpts = {
      byteLength: 0,
      usage: 35050
    };
    this.buffers = [new _core.Buffer(gl, bufferOpts), new _core.Buffer(gl, bufferOpts), new _core.Buffer(gl, bufferOpts)];
  }

  get inProgress() {
    return this.transition.inProgress;
  }

  start(transitionSettings, numInstances) {
    const {
      gl,
      buffers,
      attribute
    } = this;
    const padBufferOpts = {
      numInstances,
      attribute,
      fromLength: this.currentLength,
      fromStartIndices: this.currentStartIndices,
      getData: transitionSettings.enter
    };

    for (const buffer of buffers) {
      (0, _attributeTransitionUtils.padBuffer)({
        buffer,
        ...padBufferOpts
      });
    }

    this.currentStartIndices = attribute.startIndices;
    this.currentLength = (0, _attributeTransitionUtils.getAttributeBufferLength)(attribute, numInstances);
    this.attributeInTransition.update({
      buffer: buffers[1],
      value: attribute.value
    });
    this.transition.start(transitionSettings);
    this.transform.update({
      elementCount: Math.floor(this.currentLength / attribute.size),
      sourceBuffers: {
        aTo: (0, _attributeTransitionUtils.getSourceBufferAttribute)(gl, attribute)
      }
    });
  }

  update() {
    const {
      buffers,
      transform,
      framebuffer,
      transition
    } = this;
    const updated = transition.update();

    if (!updated) {
      return false;
    }

    transform.update({
      sourceBuffers: {
        aPrev: buffers[0],
        aCur: buffers[1]
      },
      feedbackBuffers: {
        vNext: buffers[2]
      }
    });
    transform.run({
      framebuffer,
      discard: false,
      clearRenderTarget: true,
      uniforms: {
        stiffness: transition.settings.stiffness,
        damping: transition.settings.damping
      },
      parameters: {
        depthTest: false,
        blend: true,
        viewport: [0, 0, 1, 1],
        blendFunc: [1, 1],
        blendEquation: [32776, 32776]
      }
    });
    (0, _attributeTransitionUtils.cycleBuffers)(buffers);
    this.attributeInTransition.update({
      buffer: buffers[1],
      value: this.attribute.value
    });
    const isTransitioning = (0, _core.readPixelsToArray)(framebuffer)[0] > 0;

    if (!isTransitioning) {
      transition.end();
    }

    return true;
  }

  cancel() {
    this.transition.cancel();
    this.transform.delete();

    while (this.buffers.length) {
      this.buffers.pop().delete();
    }

    this.texture.delete();
    this.texture = null;
    this.framebuffer.delete();
    this.framebuffer = null;
  }

}

exports.default = GPUSpringTransition;

function getTransform(gl, attribute, framebuffer) {
  const attributeType = (0, _attributeTransitionUtils.getAttributeTypeFromSize)(attribute.size);
  return new _core.Transform(gl, {
    framebuffer,
    vs: "\n#define SHADER_NAME spring-transition-vertex-shader\n\n#define EPSILON 0.00001\n\nuniform float stiffness;\nuniform float damping;\nattribute ATTRIBUTE_TYPE aPrev;\nattribute ATTRIBUTE_TYPE aCur;\nattribute ATTRIBUTE_TYPE aTo;\nvarying ATTRIBUTE_TYPE vNext;\nvarying float vIsTransitioningFlag;\n\nATTRIBUTE_TYPE getNextValue(ATTRIBUTE_TYPE cur, ATTRIBUTE_TYPE prev, ATTRIBUTE_TYPE dest) {\n  ATTRIBUTE_TYPE velocity = cur - prev;\n  ATTRIBUTE_TYPE delta = dest - cur;\n  ATTRIBUTE_TYPE spring = delta * stiffness;\n  ATTRIBUTE_TYPE damper = velocity * -1.0 * damping;\n  return spring + damper + velocity + cur;\n}\n\nvoid main(void) {\n  bool isTransitioning = length(aCur - aPrev) > EPSILON || length(aTo - aCur) > EPSILON;\n  vIsTransitioningFlag = isTransitioning ? 1.0 : 0.0;\n\n  vNext = getNextValue(aCur, aPrev, aTo);\n  gl_Position = vec4(0, 0, 0, 1);\n  gl_PointSize = 100.0;\n}\n",
    fs: "\n#define SHADER_NAME spring-transition-is-transitioning-fragment-shader\n\nvarying float vIsTransitioningFlag;\n\nvoid main(void) {\n  if (vIsTransitioningFlag == 0.0) {\n    discard;\n  }\n  gl_FragColor = vec4(1.0);\n}",
    defines: {
      ATTRIBUTE_TYPE: attributeType
    },
    varyings: ['vNext']
  });
}

function getTexture(gl) {
  return new _core.Texture2D(gl, {
    data: new Uint8Array(4),
    format: 6408,
    type: 5121,
    border: 0,
    mipmaps: false,
    dataFormat: 6408,
    width: 1,
    height: 1
  });
}

function getFramebuffer(gl, texture) {
  return new _core.Framebuffer(gl, {
    id: 'spring-transition-is-transitioning-framebuffer',
    width: 1,
    height: 1,
    attachments: {
      [36064]: texture
    }
  });
}
},{"@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","../lib/attribute/attribute-transition-utils":"node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-transition-utils.js","../lib/attribute/attribute":"node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute.js","./transition":"node_modules/@deck.gl/core/dist/esm/transitions/transition.js"}],"node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-transition-manager.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _core = require("@luma.gl/core");

var _gpuInterpolationTransition = _interopRequireDefault(require("../../transitions/gpu-interpolation-transition"));

var _gpuSpringTransition = _interopRequireDefault(require("../../transitions/gpu-spring-transition"));

var _log = _interopRequireDefault(require("../../utils/log"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const TRANSITION_TYPES = {
  interpolation: _gpuInterpolationTransition.default,
  spring: _gpuSpringTransition.default
};

class AttributeTransitionManager {
  constructor(gl, {
    id,
    timeline
  }) {
    this.id = id;
    this.gl = gl;
    this.timeline = timeline;
    this.transitions = {};
    this.needsRedraw = false;
    this.numInstances = 1;
    this.isSupported = _core.Transform.isSupported(gl);
  }

  finalize() {
    for (const attributeName in this.transitions) {
      this._removeTransition(attributeName);
    }
  }

  update({
    attributes,
    transitions,
    numInstances
  }) {
    this.numInstances = numInstances || 1;

    for (const attributeName in attributes) {
      const attribute = attributes[attributeName];
      const settings = attribute.getTransitionSetting(transitions);
      if (!settings) continue;

      this._updateAttribute(attributeName, attribute, settings);
    }

    for (const attributeName in this.transitions) {
      const attribute = attributes[attributeName];

      if (!attribute || !attribute.getTransitionSetting(transitions)) {
        this._removeTransition(attributeName);
      }
    }
  }

  hasAttribute(attributeName) {
    const transition = this.transitions[attributeName];
    return transition && transition.inProgress;
  }

  getAttributes() {
    const animatedAttributes = {};

    for (const attributeName in this.transitions) {
      const transition = this.transitions[attributeName];

      if (transition.inProgress) {
        animatedAttributes[attributeName] = transition.attributeInTransition;
      }
    }

    return animatedAttributes;
  }

  run() {
    if (!this.isSupported || this.numInstances === 0) {
      return false;
    }

    for (const attributeName in this.transitions) {
      const updated = this.transitions[attributeName].update();

      if (updated) {
        this.needsRedraw = true;
      }
    }

    const needsRedraw = this.needsRedraw;
    this.needsRedraw = false;
    return needsRedraw;
  }

  _removeTransition(attributeName) {
    this.transitions[attributeName].cancel();
    delete this.transitions[attributeName];
  }

  _updateAttribute(attributeName, attribute, settings) {
    const transition = this.transitions[attributeName];
    let isNew = !transition || transition.type !== settings.type;

    if (isNew) {
      if (!this.isSupported) {
        _log.default.warn("WebGL2 not supported by this browser. Transition for ".concat(attributeName, " is disabled."))();

        return;
      }

      if (transition) {
        this._removeTransition(attributeName);
      }

      const TransitionType = TRANSITION_TYPES[settings.type];

      if (TransitionType) {
        this.transitions[attributeName] = new TransitionType({
          attribute,
          timeline: this.timeline,
          gl: this.gl
        });
      } else {
        _log.default.error("unsupported transition type '".concat(settings.type, "'"))();

        isNew = false;
      }
    }

    if (isNew || attribute.needsRedraw()) {
      this.needsRedraw = true;
      this.transitions[attributeName].start(settings, this.numInstances);
    }
  }

}

exports.default = AttributeTransitionManager;
},{"@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","../../transitions/gpu-interpolation-transition":"node_modules/@deck.gl/core/dist/esm/transitions/gpu-interpolation-transition.js","../../transitions/gpu-spring-transition":"node_modules/@deck.gl/core/dist/esm/transitions/gpu-spring-transition.js","../../utils/log":"node_modules/@deck.gl/core/dist/esm/utils/log.js"}],"node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-manager.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _attribute = _interopRequireDefault(require("./attribute"));

var _log = _interopRequireDefault(require("../../utils/log"));

var _debug = _interopRequireDefault(require("../../debug"));

var _attributeTransitionManager = _interopRequireDefault(require("./attribute-transition-manager"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const TRACE_INVALIDATE = 'attributeManager.invalidate';
const TRACE_UPDATE_START = 'attributeManager.updateStart';
const TRACE_UPDATE_END = 'attributeManager.updateEnd';
const TRACE_ATTRIBUTE_UPDATE_START = 'attribute.updateStart';
const TRACE_ATTRIBUTE_ALLOCATE = 'attribute.allocate';
const TRACE_ATTRIBUTE_UPDATE_END = 'attribute.updateEnd';

class AttributeManager {
  constructor(gl, {
    id = 'attribute-manager',
    stats,
    timeline
  } = {}) {
    this.id = id;
    this.gl = gl;
    this.attributes = {};
    this.updateTriggers = {};
    this.accessors = {};
    this.needsRedraw = true;
    this.userData = {};
    this.stats = stats;
    this.attributeTransitionManager = new _attributeTransitionManager.default(gl, {
      id: "".concat(id, "-transitions"),
      timeline
    });
    Object.seal(this);
  }

  finalize() {
    for (const attributeName in this.attributes) {
      this.attributes[attributeName].delete();
    }

    this.attributeTransitionManager.finalize();
  }

  getNeedsRedraw(opts = {
    clearRedrawFlags: false
  }) {
    const redraw = this.needsRedraw;
    this.needsRedraw = this.needsRedraw && !opts.clearRedrawFlags;
    return redraw && this.id;
  }

  setNeedsRedraw(redraw = true) {
    this.needsRedraw = true;
    return this;
  }

  add(attributes, updaters) {
    this._add(attributes, updaters);
  }

  addInstanced(attributes, updaters) {
    this._add(attributes, updaters, {
      instanced: 1
    });
  }

  remove(attributeNameArray) {
    for (let i = 0; i < attributeNameArray.length; i++) {
      const name = attributeNameArray[i];

      if (this.attributes[name] !== undefined) {
        this.attributes[name].delete();
        delete this.attributes[name];
      }
    }
  }

  invalidate(triggerName, dataRange) {
    const invalidatedAttributes = this._invalidateTrigger(triggerName, dataRange);

    (0, _debug.default)(TRACE_INVALIDATE, this, triggerName, invalidatedAttributes);
  }

  invalidateAll(dataRange) {
    for (const attributeName in this.attributes) {
      this.attributes[attributeName].setNeedsUpdate(attributeName, dataRange);
    }

    (0, _debug.default)(TRACE_INVALIDATE, this, 'all');
  }

  update({
    data,
    numInstances,
    startIndices = null,
    transitions,
    props = {},
    buffers = {},
    context = {}
  } = {}) {
    let updated = false;
    (0, _debug.default)(TRACE_UPDATE_START, this);

    if (this.stats) {
      this.stats.get('Update Attributes').timeStart();
    }

    for (const attributeName in this.attributes) {
      const attribute = this.attributes[attributeName];
      const accessorName = attribute.settings.accessor;
      attribute.startIndices = startIndices;
      attribute.numInstances = numInstances;

      if (props[attributeName]) {
        _log.default.removed("props.".concat(attributeName), "data.attributes.".concat(attributeName))();
      }

      if (attribute.setExternalBuffer(buffers[attributeName])) {} else if (attribute.setBinaryValue(buffers[accessorName], data.startIndices)) {} else if (!buffers[accessorName] && attribute.setConstantValue(props[accessorName])) {} else if (attribute.needsUpdate()) {
        updated = true;

        this._updateAttribute({
          attribute,
          numInstances,
          data,
          props,
          context
        });
      }

      this.needsRedraw |= attribute.needsRedraw();
    }

    if (updated) {
      (0, _debug.default)(TRACE_UPDATE_END, this, numInstances);
    }

    if (this.stats) {
      this.stats.get('Update Attributes').timeEnd();
    }

    this.attributeTransitionManager.update({
      attributes: this.attributes,
      numInstances,
      transitions
    });
  }

  updateTransition() {
    const {
      attributeTransitionManager
    } = this;
    const transitionUpdated = attributeTransitionManager.run();
    this.needsRedraw = this.needsRedraw || transitionUpdated;
    return transitionUpdated;
  }

  getAttributes() {
    return this.attributes;
  }

  getChangedAttributes(opts = {
    clearChangedFlags: false
  }) {
    const {
      attributes,
      attributeTransitionManager
    } = this;
    const changedAttributes = { ...attributeTransitionManager.getAttributes()
    };

    for (const attributeName in attributes) {
      const attribute = attributes[attributeName];

      if (attribute.needsRedraw(opts) && !attributeTransitionManager.hasAttribute(attributeName)) {
        changedAttributes[attributeName] = attribute;
      }
    }

    return changedAttributes;
  }

  getShaderAttributes(attributes, excludeAttributes = {}) {
    if (!attributes) {
      attributes = this.getAttributes();
    }

    const shaderAttributes = {};

    for (const attributeName in attributes) {
      if (!excludeAttributes[attributeName]) {
        Object.assign(shaderAttributes, attributes[attributeName].getShaderAttributes());
      }
    }

    return shaderAttributes;
  }

  getAccessors() {
    return this.updateTriggers;
  }

  _add(attributes, updaters, extraProps = {}) {
    if (updaters) {
      _log.default.warn('AttributeManager.add({updaters}) - updater map no longer supported')();
    }

    for (const attributeName in attributes) {
      const attribute = attributes[attributeName];
      this.attributes[attributeName] = this._createAttribute(attributeName, attribute, extraProps);
    }

    this._mapUpdateTriggersToAttributes();
  }

  _createAttribute(name, attribute, extraProps) {
    const props = { ...attribute,
      id: name,
      isIndexed: attribute.isIndexed || attribute.elements || false,
      constant: attribute.constant || false,
      size: attribute.elements && 1 || attribute.size || 1,
      value: attribute.value || null,
      divisor: attribute.instanced || extraProps.instanced ? 1 : attribute.divisor || 0
    };
    return new _attribute.default(this.gl, props);
  }

  _mapUpdateTriggersToAttributes() {
    const triggers = {};

    for (const attributeName in this.attributes) {
      const attribute = this.attributes[attributeName];
      attribute.getUpdateTriggers().forEach(triggerName => {
        if (!triggers[triggerName]) {
          triggers[triggerName] = [];
        }

        triggers[triggerName].push(attributeName);
      });
    }

    this.updateTriggers = triggers;
  }

  _invalidateTrigger(triggerName, dataRange) {
    const {
      attributes,
      updateTriggers
    } = this;
    const invalidatedAttributes = updateTriggers[triggerName];

    if (invalidatedAttributes) {
      invalidatedAttributes.forEach(name => {
        const attribute = attributes[name];

        if (attribute) {
          attribute.setNeedsUpdate(attribute.id, dataRange);
        }
      });
    }

    return invalidatedAttributes;
  }

  _updateAttribute(opts) {
    const {
      attribute,
      numInstances
    } = opts;
    (0, _debug.default)(TRACE_ATTRIBUTE_UPDATE_START, attribute);

    if (attribute.constant) {
      attribute.setConstantValue(attribute.value);
      return;
    }

    if (attribute.allocate(numInstances)) {
      (0, _debug.default)(TRACE_ATTRIBUTE_ALLOCATE, attribute, numInstances);
    }

    const updated = attribute.updateBuffer(opts);

    if (updated) {
      this.needsRedraw = true;
      (0, _debug.default)(TRACE_ATTRIBUTE_UPDATE_END, attribute, numInstances);
    }
  }

}

exports.default = AttributeManager;
},{"./attribute":"node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute.js","../../utils/log":"node_modules/@deck.gl/core/dist/esm/utils/log.js","../../debug":"node_modules/@deck.gl/core/dist/esm/debug/index.js","./attribute-transition-manager":"node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-transition-manager.js"}],"node_modules/@deck.gl/core/dist/esm/transitions/cpu-interpolation-transition.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _core = require("@math.gl/core");

var _transition = _interopRequireDefault(require("./transition"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class CPUInterpolationTransition extends _transition.default {
  get value() {
    return this._value;
  }

  _onUpdate() {
    const {
      time,
      settings: {
        fromValue,
        toValue,
        duration,
        easing
      }
    } = this;
    const t = easing(time / duration);
    this._value = (0, _core.lerp)(fromValue, toValue, t);
  }

}

exports.default = CPUInterpolationTransition;
},{"@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js","./transition":"node_modules/@deck.gl/core/dist/esm/transitions/transition.js"}],"node_modules/@deck.gl/core/dist/esm/transitions/cpu-spring-transition.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _transition = _interopRequireDefault(require("./transition"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const EPSILON = 1e-5;

function updateSpringElement(prev, cur, dest, damping, stiffness) {
  const velocity = cur - prev;
  const delta = dest - cur;
  const spring = delta * stiffness;
  const damper = -velocity * damping;
  return spring + damper + velocity + cur;
}

function updateSpring(prev, cur, dest, damping, stiffness) {
  if (Array.isArray(dest)) {
    const next = [];

    for (let i = 0; i < dest.length; i++) {
      next[i] = updateSpringElement(prev[i], cur[i], dest[i], damping, stiffness);
    }

    return next;
  }

  return updateSpringElement(prev, cur, dest, damping, stiffness);
}

function distance(value1, value2) {
  if (Array.isArray(value1)) {
    let distanceSquare = 0;

    for (let i = 0; i < value1.length; i++) {
      const d = value1[i] - value2[i];
      distanceSquare += d * d;
    }

    return Math.sqrt(distanceSquare);
  }

  return Math.abs(value1 - value2);
}

class CPUSpringTransition extends _transition.default {
  get value() {
    return this._currValue;
  }

  _onUpdate() {
    const {
      fromValue,
      toValue,
      damping,
      stiffness
    } = this.settings;
    const {
      _prevValue = fromValue,
      _currValue = fromValue
    } = this;
    let nextValue = updateSpring(_prevValue, _currValue, toValue, damping, stiffness);
    const delta = distance(nextValue, toValue);
    const velocity = distance(nextValue, _currValue);

    if (delta < EPSILON && velocity < EPSILON) {
      nextValue = toValue;
      this.end();
    }

    this._prevValue = _currValue;
    this._currValue = nextValue;
  }

}

exports.default = CPUSpringTransition;
},{"./transition":"node_modules/@deck.gl/core/dist/esm/transitions/transition.js"}],"node_modules/@deck.gl/core/dist/esm/lib/uniform-transition-manager.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _attributeTransitionUtils = require("./attribute/attribute-transition-utils");

var _cpuInterpolationTransition = _interopRequireDefault(require("../transitions/cpu-interpolation-transition"));

var _cpuSpringTransition = _interopRequireDefault(require("../transitions/cpu-spring-transition"));

var _log = _interopRequireDefault(require("../utils/log"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const TRANSITION_TYPES = {
  interpolation: _cpuInterpolationTransition.default,
  spring: _cpuSpringTransition.default
};

class UniformTransitionManager {
  constructor(timeline) {
    this.transitions = new Map();
    this.timeline = timeline;
  }

  get active() {
    return this.transitions.size > 0;
  }

  add(key, fromValue, toValue, settings) {
    const {
      transitions
    } = this;

    if (transitions.has(key)) {
      const transition = transitions.get(key);
      const {
        value = transition.settings.fromValue
      } = transition;
      fromValue = value;
      this.remove(key);
    }

    settings = (0, _attributeTransitionUtils.normalizeTransitionSettings)(settings);

    if (!settings) {
      return;
    }

    const TransitionType = TRANSITION_TYPES[settings.type];

    if (!TransitionType) {
      _log.default.error("unsupported transition type '".concat(settings.type, "'"))();

      return;
    }

    const transition = new TransitionType(this.timeline);
    transition.start({ ...settings,
      fromValue,
      toValue
    });
    transitions.set(key, transition);
  }

  remove(key) {
    const {
      transitions
    } = this;

    if (transitions.has(key)) {
      transitions.get(key).cancel();
      transitions.delete(key);
    }
  }

  update() {
    const propsInTransition = {};

    for (const [key, transition] of this.transitions) {
      transition.update();
      propsInTransition[key] = transition.value;

      if (!transition.inProgress) {
        this.remove(key);
      }
    }

    return propsInTransition;
  }

  clear() {
    for (const key of this.transitions.keys()) {
      this.remove(key);
    }
  }

}

exports.default = UniformTransitionManager;
},{"./attribute/attribute-transition-utils":"node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-transition-utils.js","../transitions/cpu-interpolation-transition":"node_modules/@deck.gl/core/dist/esm/transitions/cpu-interpolation-transition.js","../transitions/cpu-spring-transition":"node_modules/@deck.gl/core/dist/esm/transitions/cpu-spring-transition.js","../utils/log":"node_modules/@deck.gl/core/dist/esm/utils/log.js"}],"node_modules/@deck.gl/core/dist/esm/lifecycle/props.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.compareProps = compareProps;
exports.diffProps = diffProps;
exports.validateProps = validateProps;

var _constants = require("./constants");

function validateProps(props) {
  const propTypes = getPropTypes(props);

  for (const propName in propTypes) {
    const propType = propTypes[propName];
    const {
      validate
    } = propType;

    if (validate && !validate(props[propName], propType)) {
      throw new Error("Invalid prop ".concat(propName, ": ").concat(props[propName]));
    }
  }
}

function diffProps(props, oldProps) {
  const propsChangedReason = compareProps({
    newProps: props,
    oldProps,
    propTypes: getPropTypes(props),
    ignoreProps: {
      data: null,
      updateTriggers: null,
      extensions: null,
      transitions: null
    }
  });
  const dataChangedReason = diffDataProps(props, oldProps);
  let updateTriggersChangedReason = false;

  if (!dataChangedReason) {
    updateTriggersChangedReason = diffUpdateTriggers(props, oldProps);
  }

  return {
    dataChanged: dataChangedReason,
    propsChanged: propsChangedReason,
    updateTriggersChanged: updateTriggersChangedReason,
    extensionsChanged: diffExtensions(props, oldProps),
    transitionsChanged: diffTransitions(props, oldProps)
  };
}

function diffTransitions(props, oldProps) {
  if (!props.transitions) {
    return null;
  }

  const result = {};
  const propTypes = getPropTypes(props);

  for (const key in props.transitions) {
    const propType = propTypes[key];
    const type = propType && propType.type;
    const isTransitionable = type === 'number' || type === 'color' || type === 'array';

    if (isTransitionable && comparePropValues(props[key], oldProps[key], propType)) {
      result[key] = true;
    }
  }

  return result;
}

function compareProps({
  newProps,
  oldProps,
  ignoreProps = {},
  propTypes = {},
  triggerName = 'props'
}) {
  if (oldProps === newProps) {
    return null;
  }

  if (typeof newProps !== 'object' || newProps === null) {
    return "".concat(triggerName, " changed shallowly");
  }

  if (typeof oldProps !== 'object' || oldProps === null) {
    return "".concat(triggerName, " changed shallowly");
  }

  for (const key of Object.keys(newProps)) {
    if (!(key in ignoreProps)) {
      if (!(key in oldProps)) {
        return "".concat(triggerName, ".").concat(key, " added");
      }

      const changed = comparePropValues(newProps[key], oldProps[key], propTypes[key]);

      if (changed) {
        return "".concat(triggerName, ".").concat(key, " ").concat(changed);
      }
    }
  }

  for (const key of Object.keys(oldProps)) {
    if (!(key in ignoreProps)) {
      if (!(key in newProps)) {
        return "".concat(triggerName, ".").concat(key, " dropped");
      }

      if (!Object.hasOwnProperty.call(newProps, key)) {
        const changed = comparePropValues(newProps[key], oldProps[key], propTypes[key]);

        if (changed) {
          return "".concat(triggerName, ".").concat(key, " ").concat(changed);
        }
      }
    }
  }

  return null;
}

function comparePropValues(newProp, oldProp, propType) {
  let equal = propType && propType.equal;

  if (equal && !equal(newProp, oldProp, propType)) {
    return 'changed deeply';
  }

  if (!equal) {
    equal = newProp && oldProp && newProp.equals;

    if (equal && !equal.call(newProp, oldProp)) {
      return 'changed deeply';
    }
  }

  if (!equal && oldProp !== newProp) {
    return 'changed shallowly';
  }

  return null;
}

function diffDataProps(props, oldProps) {
  if (oldProps === null) {
    return 'oldProps is null, initial diff';
  }

  let dataChanged = null;
  const {
    dataComparator,
    _dataDiff
  } = props;

  if (dataComparator) {
    if (!dataComparator(props.data, oldProps.data)) {
      dataChanged = 'Data comparator detected a change';
    }
  } else if (props.data !== oldProps.data) {
    dataChanged = 'A new data container was supplied';
  }

  if (dataChanged && _dataDiff) {
    dataChanged = _dataDiff(props.data, oldProps.data) || dataChanged;
  }

  return dataChanged;
}

function diffUpdateTriggers(props, oldProps) {
  if (oldProps === null) {
    return 'oldProps is null, initial diff';
  }

  if ('all' in props.updateTriggers) {
    const diffReason = diffUpdateTrigger(props, oldProps, 'all');

    if (diffReason) {
      return {
        all: true
      };
    }
  }

  const triggerChanged = {};
  let reason = false;

  for (const triggerName in props.updateTriggers) {
    if (triggerName !== 'all') {
      const diffReason = diffUpdateTrigger(props, oldProps, triggerName);

      if (diffReason) {
        triggerChanged[triggerName] = true;
        reason = triggerChanged;
      }
    }
  }

  return reason;
}

function diffExtensions(props, oldProps) {
  if (oldProps === null) {
    return true;
  }

  const oldExtensions = oldProps.extensions;
  const {
    extensions
  } = props;

  if (extensions === oldExtensions) {
    return false;
  }

  if (!oldExtensions || !extensions) {
    return true;
  }

  if (extensions.length !== oldExtensions.length) {
    return true;
  }

  for (let i = 0; i < extensions.length; i++) {
    if (!extensions[i].equals(oldExtensions[i])) {
      return true;
    }
  }

  return false;
}

function diffUpdateTrigger(props, oldProps, triggerName) {
  let newTriggers = props.updateTriggers[triggerName];
  newTriggers = newTriggers === undefined || newTriggers === null ? {} : newTriggers;
  let oldTriggers = oldProps.updateTriggers[triggerName];
  oldTriggers = oldTriggers === undefined || oldTriggers === null ? {} : oldTriggers;
  const diffReason = compareProps({
    oldProps: oldTriggers,
    newProps: newTriggers,
    triggerName
  });
  return diffReason;
}

function getPropTypes(props) {
  const layer = props[_constants.COMPONENT_SYMBOL];
  const LayerType = layer && layer.constructor;
  return LayerType ? LayerType._propTypes : {};
}
},{"./constants":"node_modules/@deck.gl/core/dist/esm/lifecycle/constants.js"}],"node_modules/@deck.gl/core/dist/esm/utils/count.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.count = count;
const ERR_NOT_OBJECT = 'count(): argument not an object';
const ERR_NOT_CONTAINER = 'count(): argument not a container';

function count(container) {
  if (!isObject(container)) {
    throw new Error(ERR_NOT_OBJECT);
  }

  if (typeof container.count === 'function') {
    return container.count();
  }

  if (Number.isFinite(container.size)) {
    return container.size;
  }

  if (Number.isFinite(container.length)) {
    return container.length;
  }

  if (isPlainObject(container)) {
    return Object.keys(container).length;
  }

  throw new Error(ERR_NOT_CONTAINER);
}

function isPlainObject(value) {
  return value !== null && typeof value === 'object' && value.constructor === Object;
}

function isObject(value) {
  return value !== null && typeof value === 'object';
}
},{}],"node_modules/@deck.gl/core/dist/esm/utils/shader.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mergeShaders = mergeShaders;

function mergeShaders(target, source) {
  if (!source) {
    return target;
  }

  const result = { ...target,
    ...source
  };

  if ('defines' in source) {
    result.defines = { ...target.defines,
      ...source.defines
    };
  }

  if ('modules' in source) {
    result.modules = (target.modules || []).concat(source.modules);

    if (source.modules.some(module => module.name === 'project64')) {
      const index = result.modules.findIndex(module => module.name === 'project32');

      if (index >= 0) {
        result.modules.splice(index, 1);
      }
    }
  }

  if ('inject' in source) {
    if (!target.inject) {
      result.inject = source.inject;
    } else {
      const mergedInjection = { ...target.inject
      };

      for (const key in source.inject) {
        mergedInjection[key] = (mergedInjection[key] || '') + source.inject[key];
      }

      result.inject = mergedInjection;
    }
  }

  return result;
}
},{}],"node_modules/@deck.gl/core/dist/esm/utils/texture.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createTexture = createTexture;
exports.destroyTexture = destroyTexture;

var _core = require("@luma.gl/core");

const DEFAULT_TEXTURE_PARAMETERS = {
  [10241]: 9987,
  [10240]: 9729,
  [10242]: 33071,
  [10243]: 33071
};
const internalTextures = {};

function createTexture(layer, image) {
  const gl = layer.context && layer.context.gl;

  if (!gl || !image) {
    return null;
  }

  if (image instanceof _core.Texture2D) {
    return image;
  } else if (image.constructor && image.constructor.name !== 'Object') {
    image = {
      data: image
    };
  }

  let specialTextureParameters = null;

  if (image.compressed) {
    specialTextureParameters = {
      [10241]: image.data.length > 1 ? 9985 : 9729
    };
  }

  const texture = new _core.Texture2D(gl, { ...image,
    parameters: { ...DEFAULT_TEXTURE_PARAMETERS,
      ...specialTextureParameters,
      ...layer.props.textureParameters
    }
  });
  internalTextures[texture.id] = true;
  return texture;
}

function destroyTexture(texture) {
  if (!texture || !(texture instanceof _core.Texture2D)) {
    return;
  }

  if (internalTextures[texture.id]) {
    texture.delete();
    delete internalTextures[texture.id];
  }
}
},{"@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/lifecycle/prop-types.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parsePropTypes = parsePropTypes;

var _texture = require("../utils/texture");

var _deepEqual = require("../utils/deep-equal");

const TYPE_DEFINITIONS = {
  boolean: {
    validate(value, propType) {
      return true;
    },

    equal(value1, value2, propType) {
      return Boolean(value1) === Boolean(value2);
    }

  },
  number: {
    validate(value, propType) {
      return Number.isFinite(value) && (!('max' in propType) || value <= propType.max) && (!('min' in propType) || value >= propType.min);
    }

  },
  color: {
    validate(value, propType) {
      return propType.optional && !value || isArray(value) && (value.length === 3 || value.length === 4);
    },

    equal(value1, value2, propType) {
      return arrayEqual(value1, value2);
    }

  },
  accessor: {
    validate(value, propType) {
      const valueType = getTypeOf(value);
      return valueType === 'function' || valueType === getTypeOf(propType.value);
    },

    equal(value1, value2, propType) {
      if (typeof value2 === 'function') {
        return true;
      }

      return arrayEqual(value1, value2);
    }

  },
  array: {
    validate(value, propType) {
      return propType.optional && !value || isArray(value);
    },

    equal(value1, value2, propType) {
      return propType.compare ? arrayEqual(value1, value2) : value1 === value2;
    }

  },
  object: {
    equal(value1, value2, propType) {
      return propType.compare ? (0, _deepEqual.deepEqual)(value1, value2) : value1 === value2;
    }

  },
  function: {
    validate(value, propType) {
      return propType.optional && !value || typeof value === 'function';
    },

    equal(value1, value2, propType) {
      return !propType.compare || value1 === value2;
    }

  },
  data: {
    transform: (value, propType, component) => {
      const {
        dataTransform
      } = component.props;
      return dataTransform && value ? dataTransform(value) : value;
    }
  },
  image: {
    transform: (value, propType, component) => {
      return (0, _texture.createTexture)(component, value);
    },
    release: value => {
      (0, _texture.destroyTexture)(value);
    }
  }
};

function arrayEqual(array1, array2) {
  if (array1 === array2) {
    return true;
  }

  if (!isArray(array1) || !isArray(array2)) {
    return false;
  }

  const len = array1.length;

  if (len !== array2.length) {
    return false;
  }

  for (let i = 0; i < len; i++) {
    if (array1[i] !== array2[i]) {
      return false;
    }
  }

  return true;
}

function parsePropTypes(propDefs) {
  const propTypes = {};
  const defaultProps = {};
  const deprecatedProps = {};

  for (const [propName, propDef] of Object.entries(propDefs)) {
    const deprecated = propDef === null || propDef === void 0 ? void 0 : propDef.deprecatedFor;

    if (deprecated) {
      deprecatedProps[propName] = Array.isArray(deprecated) ? deprecated : [deprecated];
    } else {
      const propType = parsePropType(propName, propDef);
      propTypes[propName] = propType;
      defaultProps[propName] = propType.value;
    }
  }

  return {
    propTypes,
    defaultProps,
    deprecatedProps
  };
}

function parsePropType(name, propDef) {
  switch (getTypeOf(propDef)) {
    case 'object':
      return normalizePropDefinition(name, propDef);

    case 'array':
      return normalizePropDefinition(name, {
        type: 'array',
        value: propDef,
        compare: false
      });

    case 'boolean':
      return normalizePropDefinition(name, {
        type: 'boolean',
        value: propDef
      });

    case 'number':
      return normalizePropDefinition(name, {
        type: 'number',
        value: propDef
      });

    case 'function':
      return normalizePropDefinition(name, {
        type: 'function',
        value: propDef,
        compare: true
      });

    default:
      return {
        name,
        type: 'unknown',
        value: propDef
      };
  }
}

function normalizePropDefinition(name, propDef) {
  if (!('type' in propDef)) {
    if (!('value' in propDef)) {
      return {
        name,
        type: 'object',
        value: propDef
      };
    }

    return {
      name,
      type: getTypeOf(propDef.value),
      ...propDef
    };
  }

  return {
    name,
    ...TYPE_DEFINITIONS[propDef.type],
    ...propDef
  };
}

function isArray(value) {
  return Array.isArray(value) || ArrayBuffer.isView(value);
}

function getTypeOf(value) {
  if (isArray(value)) {
    return 'array';
  }

  if (value === null) {
    return 'null';
  }

  return typeof value;
}
},{"../utils/texture":"node_modules/@deck.gl/core/dist/esm/utils/texture.js","../utils/deep-equal":"node_modules/@deck.gl/core/dist/esm/utils/deep-equal.js"}],"node_modules/@deck.gl/core/dist/esm/lifecycle/create-props.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createProps = createProps;

var _log = _interopRequireDefault(require("../utils/log"));

var _iterableUtils = require("../utils/iterable-utils");

var _propTypes = require("./prop-types");

var _constants = require("./constants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function createProps(component, propObjects) {
  const propsPrototype = getPropsPrototype(component.constructor);
  const propsInstance = Object.create(propsPrototype);
  propsInstance[_constants.COMPONENT_SYMBOL] = component;
  propsInstance[_constants.ASYNC_ORIGINAL_SYMBOL] = {};
  propsInstance[_constants.ASYNC_RESOLVED_SYMBOL] = {};

  for (let i = 0; i < propObjects.length; ++i) {
    const props = propObjects[i];

    for (const key in props) {
      propsInstance[key] = props[key];
    }
  }

  Object.freeze(propsInstance);
  return propsInstance;
}

function getPropsPrototype(componentClass) {
  const defaultProps = getOwnProperty(componentClass, '_mergedDefaultProps');

  if (!defaultProps) {
    createPropsPrototypeAndTypes(componentClass);
    return componentClass._mergedDefaultProps;
  }

  return defaultProps;
}

function createPropsPrototypeAndTypes(componentClass) {
  const parent = componentClass.prototype;

  if (!parent) {
    return;
  }

  const parentClass = Object.getPrototypeOf(componentClass);
  const parentDefaultProps = getPropsPrototype(parentClass);
  const componentDefaultProps = getOwnProperty(componentClass, 'defaultProps') || {};
  const componentPropDefs = (0, _propTypes.parsePropTypes)(componentDefaultProps);
  const defaultProps = createPropsPrototype(componentPropDefs.defaultProps, parentDefaultProps, componentClass);
  const propTypes = { ...parentClass._propTypes,
    ...componentPropDefs.propTypes
  };
  addAsyncPropsToPropPrototype(defaultProps, propTypes);
  const deprecatedProps = { ...parentClass._deprecatedProps,
    ...componentPropDefs.deprecatedProps
  };
  addDeprecatedPropsToPropPrototype(defaultProps, deprecatedProps);
  componentClass._mergedDefaultProps = defaultProps;
  componentClass._propTypes = propTypes;
  componentClass._deprecatedProps = deprecatedProps;
}

function createPropsPrototype(props, parentProps, componentClass) {
  const defaultProps = Object.create(null);
  Object.assign(defaultProps, parentProps, props);
  const id = getComponentName(componentClass);
  delete props.id;
  Object.defineProperties(defaultProps, {
    id: {
      writable: true,
      value: id
    }
  });
  return defaultProps;
}

function addDeprecatedPropsToPropPrototype(defaultProps, deprecatedProps) {
  for (const propName in deprecatedProps) {
    Object.defineProperty(defaultProps, propName, {
      enumerable: false,

      set(newValue) {
        const nameStr = "".concat(this.id, ": ").concat(propName);

        for (const newPropName of deprecatedProps[propName]) {
          if (!hasOwnProperty(this, newPropName)) {
            this[newPropName] = newValue;
          }
        }

        _log.default.deprecated(nameStr, deprecatedProps[propName].join('/'))();
      }

    });
  }
}

function addAsyncPropsToPropPrototype(defaultProps, propTypes) {
  const defaultValues = {};
  const descriptors = {};

  for (const propName in propTypes) {
    const propType = propTypes[propName];
    const {
      name,
      value
    } = propType;

    if (propType.async) {
      defaultValues[name] = value;
      descriptors[name] = getDescriptorForAsyncProp(name);
    }
  }

  defaultProps[_constants.ASYNC_DEFAULTS_SYMBOL] = defaultValues;
  defaultProps[_constants.ASYNC_ORIGINAL_SYMBOL] = {};
  Object.defineProperties(defaultProps, descriptors);
}

function getDescriptorForAsyncProp(name) {
  return {
    enumerable: true,

    set(newValue) {
      if (typeof newValue === 'string' || newValue instanceof Promise || (0, _iterableUtils.isAsyncIterable)(newValue)) {
        this[_constants.ASYNC_ORIGINAL_SYMBOL][name] = newValue;
      } else {
        this[_constants.ASYNC_RESOLVED_SYMBOL][name] = newValue;
      }
    },

    get() {
      if (this[_constants.ASYNC_RESOLVED_SYMBOL]) {
        if (name in this[_constants.ASYNC_RESOLVED_SYMBOL]) {
          const value = this[_constants.ASYNC_RESOLVED_SYMBOL][name];
          return value || this[_constants.ASYNC_DEFAULTS_SYMBOL][name];
        }

        if (name in this[_constants.ASYNC_ORIGINAL_SYMBOL]) {
          const state = this[_constants.COMPONENT_SYMBOL] && this[_constants.COMPONENT_SYMBOL].internalState;

          if (state && state.hasAsyncProp(name)) {
            return state.getAsyncProp(name) || this[_constants.ASYNC_DEFAULTS_SYMBOL][name];
          }
        }
      }

      return this[_constants.ASYNC_DEFAULTS_SYMBOL][name];
    }

  };
}

function hasOwnProperty(object, prop) {
  return Object.prototype.hasOwnProperty.call(object, prop);
}

function getOwnProperty(object, prop) {
  return hasOwnProperty(object, prop) && object[prop];
}

function getComponentName(componentClass) {
  const componentName = getOwnProperty(componentClass, 'layerName') || getOwnProperty(componentClass, 'componentName');

  if (!componentName) {
    _log.default.once(0, "".concat(componentClass.name, ".componentName not specified"))();
  }

  return componentName || componentClass.name;
}
},{"../utils/log":"node_modules/@deck.gl/core/dist/esm/utils/log.js","../utils/iterable-utils":"node_modules/@deck.gl/core/dist/esm/utils/iterable-utils.js","./prop-types":"node_modules/@deck.gl/core/dist/esm/lifecycle/prop-types.js","./constants":"node_modules/@deck.gl/core/dist/esm/lifecycle/constants.js"}],"node_modules/@deck.gl/core/dist/esm/lifecycle/component-state.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));

var _iterableUtils = require("../utils/iterable-utils");

var _constants = require("./constants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const EMPTY_PROPS = Object.freeze({});

class ComponentState {
  constructor(component) {
    (0, _defineProperty2.default)(this, "component", void 0);
    (0, _defineProperty2.default)(this, "onAsyncPropUpdated", void 0);
    (0, _defineProperty2.default)(this, "asyncProps", void 0);
    (0, _defineProperty2.default)(this, "oldProps", void 0);
    (0, _defineProperty2.default)(this, "oldAsyncProps", void 0);
    this.component = component;
    this.asyncProps = {};

    this.onAsyncPropUpdated = () => {};

    this.oldProps = null;
    this.oldAsyncProps = null;
  }

  finalize() {
    for (const propName in this.asyncProps) {
      const asyncProp = this.asyncProps[propName];

      if (asyncProp && asyncProp.type && asyncProp.type.release) {
        asyncProp.type.release(asyncProp.resolvedValue, asyncProp.type, this.component);
      }
    }
  }

  getOldProps() {
    return this.oldAsyncProps || this.oldProps || EMPTY_PROPS;
  }

  resetOldProps() {
    this.oldAsyncProps = null;
    this.oldProps = this.component.props;
  }

  hasAsyncProp(propName) {
    return propName in this.asyncProps;
  }

  getAsyncProp(propName) {
    const asyncProp = this.asyncProps[propName];
    return asyncProp && asyncProp.resolvedValue;
  }

  isAsyncPropLoading(propName) {
    if (propName) {
      const asyncProp = this.asyncProps[propName];
      return Boolean(asyncProp && asyncProp.pendingLoadCount > 0 && asyncProp.pendingLoadCount !== asyncProp.resolvedLoadCount);
    }

    for (const key in this.asyncProps) {
      if (this.isAsyncPropLoading(key)) {
        return true;
      }
    }

    return false;
  }

  reloadAsyncProp(propName, value) {
    this._watchPromise(propName, Promise.resolve(value));
  }

  setAsyncProps(props) {
    const resolvedValues = props[_constants.ASYNC_RESOLVED_SYMBOL] || {};
    const originalValues = props[_constants.ASYNC_ORIGINAL_SYMBOL] || props;
    const defaultValues = props[_constants.ASYNC_DEFAULTS_SYMBOL] || {};

    for (const propName in resolvedValues) {
      const value = resolvedValues[propName];

      this._createAsyncPropData(propName, defaultValues[propName]);

      this._updateAsyncProp(propName, value);

      resolvedValues[propName] = this.getAsyncProp(propName);
    }

    for (const propName in originalValues) {
      const value = originalValues[propName];

      this._createAsyncPropData(propName, defaultValues[propName]);

      this._updateAsyncProp(propName, value);
    }
  }

  _fetch(propName, url) {
    return url;
  }

  _onResolve(propName, value) {}

  _onError(propName, error) {}

  _updateAsyncProp(propName, value) {
    if (!this._didAsyncInputValueChange(propName, value)) {
      return;
    }

    if (typeof value === 'string') {
      value = this._fetch(propName, value);
    }

    if (value instanceof Promise) {
      this._watchPromise(propName, value);

      return;
    }

    if ((0, _iterableUtils.isAsyncIterable)(value)) {
      this._resolveAsyncIterable(propName, value);

      return;
    }

    this._setPropValue(propName, value);
  }

  _freezeAsyncOldProps() {
    if (!this.oldAsyncProps && this.oldProps) {
      this.oldAsyncProps = Object.create(this.oldProps);

      for (const propName in this.asyncProps) {
        Object.defineProperty(this.oldAsyncProps, propName, {
          enumerable: true,
          value: this.oldProps[propName]
        });
      }
    }
  }

  _didAsyncInputValueChange(propName, value) {
    const asyncProp = this.asyncProps[propName];

    if (value === asyncProp.resolvedValue || value === asyncProp.lastValue) {
      return false;
    }

    asyncProp.lastValue = value;
    return true;
  }

  _setPropValue(propName, value) {
    this._freezeAsyncOldProps();

    const asyncProp = this.asyncProps[propName];

    if (asyncProp) {
      value = this._postProcessValue(asyncProp, value);
      asyncProp.resolvedValue = value;
      asyncProp.pendingLoadCount++;
      asyncProp.resolvedLoadCount = asyncProp.pendingLoadCount;
    }
  }

  _setAsyncPropValue(propName, value, loadCount) {
    const asyncProp = this.asyncProps[propName];

    if (asyncProp && loadCount >= asyncProp.resolvedLoadCount && value !== undefined) {
      this._freezeAsyncOldProps();

      asyncProp.resolvedValue = value;
      asyncProp.resolvedLoadCount = loadCount;
      this.onAsyncPropUpdated(propName, value);
    }
  }

  _watchPromise(propName, promise) {
    const asyncProp = this.asyncProps[propName];

    if (asyncProp) {
      asyncProp.pendingLoadCount++;
      const loadCount = asyncProp.pendingLoadCount;
      promise.then(data => {
        data = this._postProcessValue(asyncProp, data);

        this._setAsyncPropValue(propName, data, loadCount);

        this._onResolve(propName, data);
      }).catch(error => {
        this._onError(propName, error);
      });
    }
  }

  async _resolveAsyncIterable(propName, iterable) {
    if (propName !== 'data') {
      this._setPropValue(propName, iterable);

      return;
    }

    const asyncProp = this.asyncProps[propName];

    if (!asyncProp) {
      return;
    }

    asyncProp.pendingLoadCount++;
    const loadCount = asyncProp.pendingLoadCount;
    let data = [];
    let count = 0;

    for await (const chunk of iterable) {
      const {
        dataTransform
      } = this.component.props;

      if (dataTransform) {
        data = dataTransform(chunk, data);
      } else {
        data = data.concat(chunk);
      }

      Object.defineProperty(data, '__diff', {
        enumerable: false,
        value: [{
          startRow: count,
          endRow: data.length
        }]
      });
      count = data.length;

      this._setAsyncPropValue(propName, data, loadCount);
    }

    this._onResolve(propName, data);
  }

  _postProcessValue(asyncProp, value) {
    const propType = asyncProp.type;

    if (propType) {
      if (propType.release) {
        propType.release(asyncProp.resolvedValue, propType, this.component);
      }

      if (propType.transform) {
        return propType.transform(value, propType, this.component);
      }
    }

    return value;
  }

  _createAsyncPropData(propName, defaultValue) {
    const asyncProp = this.asyncProps[propName];

    if (!asyncProp) {
      const propTypes = this.component && this.component.constructor._propTypes;
      this.asyncProps[propName] = {
        type: propTypes && propTypes[propName],
        lastValue: null,
        resolvedValue: defaultValue,
        pendingLoadCount: 0,
        resolvedLoadCount: 0
      };
    }
  }

}

exports.default = ComponentState;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","../utils/iterable-utils":"node_modules/@deck.gl/core/dist/esm/utils/iterable-utils.js","./constants":"node_modules/@deck.gl/core/dist/esm/lifecycle/constants.js"}],"node_modules/@deck.gl/core/dist/esm/lifecycle/component.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));

var _constants = require("./constants");

var _createProps = require("./create-props");

var _componentState = _interopRequireDefault(require("./component-state"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

let counter = 0;

class Component {
  constructor(...propObjects) {
    (0, _defineProperty2.default)(this, "id", void 0);
    (0, _defineProperty2.default)(this, "props", void 0);
    (0, _defineProperty2.default)(this, "count", void 0);
    (0, _defineProperty2.default)(this, "lifecycle", void 0);
    (0, _defineProperty2.default)(this, "parent", void 0);
    (0, _defineProperty2.default)(this, "context", void 0);
    (0, _defineProperty2.default)(this, "state", void 0);
    (0, _defineProperty2.default)(this, "internalState", void 0);
    this.props = (0, _createProps.createProps)(this, propObjects);
    this.id = this.props.id;
    this.count = counter++;
    this.lifecycle = _constants.LIFECYCLE.NO_STATE;
    this.parent = null;
    this.context = null;
    this.state = null;
    this.internalState = null;
    Object.seal(this);
  }

  get root() {
    let component = this;

    while (component.parent) {
      component = component.parent;
    }

    return component;
  }

  clone(newProps) {
    const {
      props
    } = this;
    const asyncProps = {};

    for (const key in props[_constants.ASYNC_DEFAULTS_SYMBOL]) {
      if (key in props[_constants.ASYNC_RESOLVED_SYMBOL]) {
        asyncProps[key] = props[_constants.ASYNC_RESOLVED_SYMBOL][key];
      } else if (key in props[_constants.ASYNC_ORIGINAL_SYMBOL]) {
        asyncProps[key] = props[_constants.ASYNC_ORIGINAL_SYMBOL][key];
      }
    }

    return new this.constructor({ ...props,
      ...asyncProps,
      ...newProps
    });
  }

  _initState() {
    this.internalState = new _componentState.default(this);
  }

}

exports.default = Component;
(0, _defineProperty2.default)(Component, "componentName", 'Component');
(0, _defineProperty2.default)(Component, "defaultProps", {});
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./constants":"node_modules/@deck.gl/core/dist/esm/lifecycle/constants.js","./create-props":"node_modules/@deck.gl/core/dist/esm/lifecycle/create-props.js","./component-state":"node_modules/@deck.gl/core/dist/esm/lifecycle/component-state.js"}],"node_modules/@deck.gl/core/dist/esm/lib/layer-state.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));

var _componentState = _interopRequireDefault(require("../lifecycle/component-state"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class LayerState extends _componentState.default {
  constructor({
    attributeManager,
    layer
  }) {
    super(layer);
    (0, _defineProperty2.default)(this, "attributeManager", void 0);
    (0, _defineProperty2.default)(this, "needsRedraw", void 0);
    (0, _defineProperty2.default)(this, "subLayers", void 0);
    (0, _defineProperty2.default)(this, "usesPickingColorCache", void 0);
    this.attributeManager = attributeManager;
    this.needsRedraw = true;
    this.subLayers = null;
    this.usesPickingColorCache = false;
  }

  get layer() {
    return this.component;
  }

  set layer(layer) {
    this.component = layer;
  }

  _fetch(propName, url) {
    const fetch = this.component.props.fetch;

    if (fetch) {
      return fetch(url, {
        propName,
        layer: this.layer
      });
    }

    return super._fetch(propName, url);
  }

  _onResolve(propName, value) {
    const onDataLoad = this.component.props.onDataLoad;

    if (propName === 'data' && onDataLoad) {
      onDataLoad(value, {
        propName,
        layer: this.layer
      });
    }
  }

  _onError(propName, error) {
    this.layer.raiseError(error, "loading ".concat(propName, " of ").concat(this.layer));
  }

}

exports.default = LayerState;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","../lifecycle/component-state":"node_modules/@deck.gl/core/dist/esm/lifecycle/component-state.js"}],"node_modules/@deck.gl/core/dist/esm/lib/layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _constants = require("./constants");

var _attributeManager = _interopRequireDefault(require("./attribute/attribute-manager"));

var _uniformTransitionManager = _interopRequireDefault(require("./uniform-transition-manager"));

var _props = require("../lifecycle/props");

var _count = require("../utils/count");

var _log = _interopRequireDefault(require("../utils/log"));

var _debug = _interopRequireDefault(require("../debug"));

var _core = require("@luma.gl/core");

var _assert = _interopRequireDefault(require("../utils/assert"));

var _memoize = _interopRequireDefault(require("../utils/memoize"));

var _shader = require("../utils/shader");

var _projectFunctions = require("../shaderlib/project/project-functions");

var _typedArrayManager = _interopRequireDefault(require("../utils/typed-array-manager"));

var _component = _interopRequireDefault(require("../lifecycle/component"));

var _layerState = _interopRequireDefault(require("./layer-state"));

var _webMercator = require("@math.gl/web-mercator");

var _core2 = require("@loaders.gl/core");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const TRACE_CHANGE_FLAG = 'layer.changeFlag';
const TRACE_INITIALIZE = 'layer.initialize';
const TRACE_UPDATE = 'layer.update';
const TRACE_FINALIZE = 'layer.finalize';
const TRACE_MATCHED = 'layer.matched';
const MAX_PICKING_COLOR_CACHE_SIZE = 2 ** 24 - 1;
const EMPTY_ARRAY = Object.freeze([]);
const areViewportsEqual = (0, _memoize.default)(({
  oldViewport,
  viewport
}) => {
  return oldViewport.equals(viewport);
});
let pickingColorCache = new Uint8ClampedArray(0);
const defaultProps = {
  data: {
    type: 'data',
    value: EMPTY_ARRAY,
    async: true
  },
  dataComparator: {
    type: 'function',
    value: null,
    compare: false,
    optional: true
  },
  _dataDiff: {
    type: 'function',
    value: data => data && data.__diff,
    compare: false,
    optional: true
  },
  dataTransform: {
    type: 'function',
    value: null,
    compare: false,
    optional: true
  },
  onDataLoad: {
    type: 'function',
    value: null,
    compare: false,
    optional: true
  },
  onError: {
    type: 'function',
    value: null,
    compare: false,
    optional: true
  },
  fetch: {
    type: 'function',
    value: (url, {
      propName,
      layer,
      loaders,
      loadOptions,
      signal
    }) => {
      const {
        resourceManager
      } = layer.context;
      loadOptions = loadOptions || layer.getLoadOptions();
      loaders = loaders || layer.props.loaders;

      if (signal) {
        var _loadOptions;

        loadOptions = { ...loadOptions,
          fetch: { ...((_loadOptions = loadOptions) === null || _loadOptions === void 0 ? void 0 : _loadOptions.fetch),
            signal
          }
        };
      }

      let inResourceManager = resourceManager.contains(url);

      if (!inResourceManager && !loadOptions) {
        resourceManager.add({
          resourceId: url,
          data: (0, _core2.load)(url, loaders),
          persistent: false
        });
        inResourceManager = true;
      }

      if (inResourceManager) {
        return resourceManager.subscribe({
          resourceId: url,
          onChange: data => layer.internalState.reloadAsyncProp(propName, data),
          consumerId: layer.id,
          requestId: propName
        });
      }

      return (0, _core2.load)(url, loaders, loadOptions);
    },
    compare: false
  },
  updateTriggers: {},
  visible: true,
  pickable: false,
  opacity: {
    type: 'number',
    min: 0,
    max: 1,
    value: 1
  },
  operation: _constants.OPERATION.DRAW,
  onHover: {
    type: 'function',
    value: null,
    compare: false,
    optional: true
  },
  onClick: {
    type: 'function',
    value: null,
    compare: false,
    optional: true
  },
  onDragStart: {
    type: 'function',
    value: null,
    compare: false,
    optional: true
  },
  onDrag: {
    type: 'function',
    value: null,
    compare: false,
    optional: true
  },
  onDragEnd: {
    type: 'function',
    value: null,
    compare: false,
    optional: true
  },
  coordinateSystem: _constants.COORDINATE_SYSTEM.DEFAULT,
  coordinateOrigin: {
    type: 'array',
    value: [0, 0, 0],
    compare: true
  },
  modelMatrix: {
    type: 'array',
    value: null,
    compare: true,
    optional: true
  },
  wrapLongitude: false,
  positionFormat: 'XYZ',
  colorFormat: 'RGBA',
  parameters: {
    type: 'object',
    value: {},
    optional: true,
    compare: true
  },
  transitions: null,
  extensions: [],
  loaders: {
    type: 'array',
    value: [],
    optional: true,
    compare: true
  },
  getPolygonOffset: {
    type: 'function',
    value: ({
      layerIndex
    }) => [0, -layerIndex * 100],
    compare: false
  },
  highlightedObjectIndex: null,
  autoHighlight: false,
  highlightColor: {
    type: 'accessor',
    value: [0, 0, 128, 128]
  }
};

class Layer extends _component.default {
  toString() {
    const className = this.constructor.layerName || this.constructor.name;
    return "".concat(className, "({id: '").concat(this.props.id, "'})");
  }

  raiseError(error, message) {
    var _this$props$onError, _this$props;

    if (message) {
      error.message = "".concat(message, ": ").concat(error.message);
    }

    if (!((_this$props$onError = (_this$props = this.props).onError) !== null && _this$props$onError !== void 0 && _this$props$onError.call(_this$props, error))) {
      var _this$context, _this$context$onError;

      (_this$context = this.context) === null || _this$context === void 0 ? void 0 : (_this$context$onError = _this$context.onError) === null || _this$context$onError === void 0 ? void 0 : _this$context$onError.call(_this$context, error, this);
    }
  }

  setState(updateObject) {
    this.setChangeFlags({
      stateChanged: true
    });
    Object.assign(this.state, updateObject);
    this.setNeedsRedraw();
  }

  setNeedsRedraw(redraw = true) {
    if (this.internalState) {
      this.internalState.needsRedraw = redraw;
    }
  }

  setNeedsUpdate() {
    this.context.layerManager.setNeedsUpdate(String(this));
    this.internalState.needsUpdate = true;
  }

  getNeedsRedraw(opts = {
    clearRedrawFlags: false
  }) {
    return this._getNeedsRedraw(opts);
  }

  needsUpdate() {
    return this.internalState.needsUpdate || this.hasUniformTransition() || this.shouldUpdateState(this._getUpdateParams());
  }

  hasUniformTransition() {
    return this.internalState.uniformTransitions.active;
  }

  get isLoaded() {
    return this.internalState && !this.internalState.isAsyncPropLoading();
  }

  get wrapLongitude() {
    return this.props.wrapLongitude;
  }

  isPickable() {
    return this.props.pickable && this.props.visible;
  }

  getModels() {
    return this.state && (this.state.models || (this.state.model ? [this.state.model] : []));
  }

  getAttributeManager() {
    return this.internalState && this.internalState.attributeManager;
  }

  getCurrentLayer() {
    return this.internalState && this.internalState.layer;
  }

  getLoadOptions() {
    return this.props.loadOptions;
  }

  project(xyz) {
    const {
      viewport
    } = this.context;
    const worldPosition = (0, _projectFunctions.getWorldPosition)(xyz, {
      viewport,
      modelMatrix: this.props.modelMatrix,
      coordinateOrigin: this.props.coordinateOrigin,
      coordinateSystem: this.props.coordinateSystem
    });
    const [x, y, z] = (0, _webMercator.worldToPixels)(worldPosition, viewport.pixelProjectionMatrix);
    return xyz.length === 2 ? [x, y] : [x, y, z];
  }

  unproject(xy) {
    const {
      viewport
    } = this.context;
    return viewport.unproject(xy);
  }

  projectPosition(xyz, params) {
    return (0, _projectFunctions.projectPosition)(xyz, {
      viewport: this.context.viewport,
      modelMatrix: this.props.modelMatrix,
      coordinateOrigin: this.props.coordinateOrigin,
      coordinateSystem: this.props.coordinateSystem,
      ...params
    });
  }

  use64bitPositions() {
    const {
      coordinateSystem
    } = this.props;
    return coordinateSystem === _constants.COORDINATE_SYSTEM.DEFAULT || coordinateSystem === _constants.COORDINATE_SYSTEM.LNGLAT || coordinateSystem === _constants.COORDINATE_SYSTEM.CARTESIAN;
  }

  onHover(info, pickingEvent) {
    if (this.props.onHover) {
      return this.props.onHover(info, pickingEvent);
    }

    return false;
  }

  onClick(info, pickingEvent) {
    if (this.props.onClick) {
      return this.props.onClick(info, pickingEvent);
    }

    return false;
  }

  nullPickingColor() {
    return [0, 0, 0];
  }

  encodePickingColor(i, target = []) {
    target[0] = i + 1 & 255;
    target[1] = i + 1 >> 8 & 255;
    target[2] = i + 1 >> 8 >> 8 & 255;
    return target;
  }

  decodePickingColor(color) {
    (0, _assert.default)(color instanceof Uint8Array);
    const [i1, i2, i3] = color;
    const index = i1 + i2 * 256 + i3 * 65536 - 1;
    return index;
  }

  initializeState() {
    throw new Error("Layer ".concat(this, " has not defined initializeState"));
  }

  getShaders(shaders) {
    for (const extension of this.props.extensions) {
      shaders = (0, _shader.mergeShaders)(shaders, extension.getShaders.call(this, extension));
    }

    return shaders;
  }

  getBounds() {
    var _ref;

    const attributeManager = this.getAttributeManager();
    if (!attributeManager) return null;
    const {
      positions,
      instancePositions
    } = attributeManager.attributes;
    return (_ref = positions || instancePositions) === null || _ref === void 0 ? void 0 : _ref.getBounds();
  }

  shouldUpdateState({
    oldProps,
    props,
    context,
    changeFlags
  }) {
    return changeFlags.propsOrDataChanged;
  }

  updateState({
    oldProps,
    props,
    context,
    changeFlags
  }) {
    const attributeManager = this.getAttributeManager();

    if (changeFlags.dataChanged && attributeManager) {
      const {
        dataChanged
      } = changeFlags;

      if (Array.isArray(dataChanged)) {
        for (const dataRange of dataChanged) {
          attributeManager.invalidateAll(dataRange);
        }
      } else {
        attributeManager.invalidateAll();
      }
    }

    const neededPickingBuffer = Number.isInteger(oldProps.highlightedObjectIndex) || oldProps.pickable;
    const needPickingBuffer = Number.isInteger(props.highlightedObjectIndex) || props.pickable;

    if (neededPickingBuffer !== needPickingBuffer && attributeManager) {
      const {
        pickingColors,
        instancePickingColors
      } = attributeManager.attributes;
      const pickingColorsAttribute = pickingColors || instancePickingColors;

      if (pickingColorsAttribute) {
        if (needPickingBuffer && pickingColorsAttribute.constant) {
          pickingColorsAttribute.constant = false;
          attributeManager.invalidate(pickingColorsAttribute.id);
        }

        if (!pickingColorsAttribute.value && !needPickingBuffer) {
          pickingColorsAttribute.constant = true;
          pickingColorsAttribute.value = [0, 0, 0];
        }
      }
    }
  }

  finalizeState() {
    for (const model of this.getModels()) {
      model.delete();
    }

    const attributeManager = this.getAttributeManager();

    if (attributeManager) {
      attributeManager.finalize();
    }

    this.context.resourceManager.unsubscribe({
      consumerId: this.id
    });
    this.internalState.uniformTransitions.clear();
    this.internalState.finalize();
  }

  draw(opts) {
    for (const model of this.getModels()) {
      model.draw(opts);
    }
  }

  getPickingInfo({
    info,
    mode
  }) {
    const {
      index
    } = info;

    if (index >= 0) {
      if (Array.isArray(this.props.data)) {
        info.object = this.props.data[index];
      }
    }

    return info;
  }

  activateViewport(viewport) {
    const oldViewport = this.internalState.viewport;
    this.internalState.viewport = viewport;

    if (!oldViewport || !areViewportsEqual({
      oldViewport,
      viewport
    })) {
      this.setChangeFlags({
        viewportChanged: true
      });

      if (this.isComposite) {
        if (this.needsUpdate()) {
          this.setNeedsUpdate();
        }
      } else {
        this._update();
      }
    }
  }

  invalidateAttribute(name = 'all', diffReason = '') {
    const attributeManager = this.getAttributeManager();

    if (!attributeManager) {
      return;
    }

    if (name === 'all') {
      attributeManager.invalidateAll();
    } else {
      attributeManager.invalidate(name);
    }
  }

  updateAttributes(changedAttributes) {
    for (const model of this.getModels()) {
      this._setModelAttributes(model, changedAttributes);
    }
  }

  _updateAttributes(props) {
    const attributeManager = this.getAttributeManager();

    if (!attributeManager) {
      return;
    }

    const numInstances = this.getNumInstances(props);
    const startIndices = this.getStartIndices(props);
    attributeManager.update({
      data: props.data,
      numInstances,
      startIndices,
      props,
      transitions: props.transitions,
      buffers: props.data.attributes,
      context: this,
      ignoreUnknownAttributes: true
    });
    const changedAttributes = attributeManager.getChangedAttributes({
      clearChangedFlags: true
    });
    this.updateAttributes(changedAttributes);
  }

  _updateAttributeTransition() {
    const attributeManager = this.getAttributeManager();

    if (attributeManager) {
      attributeManager.updateTransition();
    }
  }

  _updateUniformTransition() {
    const {
      uniformTransitions
    } = this.internalState;

    if (uniformTransitions.active) {
      const propsInTransition = uniformTransitions.update();
      const props = Object.create(this.props);

      for (const key in propsInTransition) {
        Object.defineProperty(props, key, {
          value: propsInTransition[key]
        });
      }

      return props;
    }

    return this.props;
  }

  calculateInstancePickingColors(attribute, {
    numInstances
  }) {
    if (attribute.constant) {
      return;
    }

    const cacheSize = Math.floor(pickingColorCache.length / 3);
    this.internalState.usesPickingColorCache = true;

    if (cacheSize < numInstances) {
      if (numInstances > MAX_PICKING_COLOR_CACHE_SIZE) {
        _log.default.warn('Layer has too many data objects. Picking might not be able to distinguish all objects.')();
      }

      pickingColorCache = _typedArrayManager.default.allocate(pickingColorCache, numInstances, {
        size: 3,
        copy: true,
        maxCount: Math.max(numInstances, MAX_PICKING_COLOR_CACHE_SIZE)
      });
      const newCacheSize = Math.floor(pickingColorCache.length / 3);
      const pickingColor = [];

      for (let i = cacheSize; i < newCacheSize; i++) {
        this.encodePickingColor(i, pickingColor);
        pickingColorCache[i * 3 + 0] = pickingColor[0];
        pickingColorCache[i * 3 + 1] = pickingColor[1];
        pickingColorCache[i * 3 + 2] = pickingColor[2];
      }
    }

    attribute.value = pickingColorCache.subarray(0, numInstances * 3);
  }

  _setModelAttributes(model, changedAttributes) {
    const attributeManager = this.getAttributeManager();
    const excludeAttributes = model.userData.excludeAttributes || {};
    const shaderAttributes = attributeManager.getShaderAttributes(changedAttributes, excludeAttributes);
    model.setAttributes(shaderAttributes);
  }

  disablePickingIndex(objectIndex) {
    this._disablePickingIndex(objectIndex);
  }

  _disablePickingIndex(objectIndex) {
    const {
      pickingColors,
      instancePickingColors
    } = this.getAttributeManager().attributes;
    const colors = pickingColors || instancePickingColors;
    const start = colors.getVertexOffset(objectIndex);
    const end = colors.getVertexOffset(objectIndex + 1);
    colors.buffer.subData({
      data: new Uint8Array(end - start),
      offset: start
    });
  }

  restorePickingColors() {
    const {
      pickingColors,
      instancePickingColors
    } = this.getAttributeManager().attributes;
    const colors = pickingColors || instancePickingColors;

    if (this.internalState.usesPickingColorCache && colors.value.buffer !== pickingColorCache.buffer) {
      colors.value = pickingColorCache.subarray(0, colors.value.length);
    }

    colors.updateSubBuffer({
      startOffset: 0
    });
  }

  getNumInstances(props) {
    props = props || this.props;

    if (props.numInstances !== undefined) {
      return props.numInstances;
    }

    if (this.state && this.state.numInstances !== undefined) {
      return this.state.numInstances;
    }

    return (0, _count.count)(props.data);
  }

  getStartIndices(props) {
    props = props || this.props;

    if (props.startIndices !== undefined) {
      return props.startIndices;
    }

    if (this.state && this.state.startIndices) {
      return this.state.startIndices;
    }

    return null;
  }

  _initialize() {
    (0, _debug.default)(TRACE_INITIALIZE, this);

    this._initState();

    this.initializeState(this.context);

    for (const extension of this.props.extensions) {
      extension.initializeState.call(this, this.context, extension);
    }

    this.setChangeFlags({
      dataChanged: true,
      propsChanged: true,
      viewportChanged: true,
      extensionsChanged: true
    });

    this._updateState();
  }

  _update() {
    const stateNeedsUpdate = this.needsUpdate();
    (0, _debug.default)(TRACE_UPDATE, this, stateNeedsUpdate);

    if (stateNeedsUpdate) {
      this._updateState();
    }
  }

  _updateState() {
    const currentProps = this.props;
    const currentViewport = this.context.viewport;

    const propsInTransition = this._updateUniformTransition();

    this.internalState.propsInTransition = propsInTransition;
    this.context.viewport = this.internalState.viewport || currentViewport;
    this.props = propsInTransition;

    try {
      const updateParams = this._getUpdateParams();

      const oldModels = this.getModels();

      if (this.context.gl) {
        this.updateState(updateParams);
      } else {
        try {
          this.updateState(updateParams);
        } catch (error) {}
      }

      for (const extension of this.props.extensions) {
        extension.updateState.call(this, updateParams, extension);
      }

      const modelChanged = this.getModels()[0] !== oldModels[0];

      this._updateModules(updateParams, modelChanged);

      if (this.isComposite) {
        this._renderLayers(updateParams);
      } else {
        this.setNeedsRedraw();

        this._updateAttributes(this.props);

        if (this.state.model) {
          this.state.model.setInstanceCount(this.getNumInstances());
        }
      }
    } finally {
      this.context.viewport = currentViewport;
      this.props = currentProps;
      this.clearChangeFlags();
      this.internalState.needsUpdate = false;
      this.internalState.resetOldProps();
    }
  }

  _finalize() {
    (0, _debug.default)(TRACE_FINALIZE, this);
    this.finalizeState(this.context);

    for (const extension of this.props.extensions) {
      extension.finalizeState.call(this, extension);
    }
  }

  drawLayer({
    moduleParameters = null,
    uniforms = {},
    parameters = {}
  }) {
    this._updateAttributeTransition();

    const currentProps = this.props;
    this.props = this.internalState.propsInTransition || currentProps;
    const {
      opacity
    } = this.props;
    uniforms.opacity = Math.pow(opacity, 1 / 2.2);

    try {
      if (moduleParameters) {
        this.setModuleParameters(moduleParameters);
      }

      const {
        getPolygonOffset
      } = this.props;
      const offsets = getPolygonOffset && getPolygonOffset(uniforms) || [0, 0];
      (0, _core.setParameters)(this.context.gl, {
        polygonOffset: offsets
      });
      (0, _core.withParameters)(this.context.gl, parameters, () => {
        const opts = {
          moduleParameters,
          uniforms,
          parameters,
          context: this.context
        };

        for (const extension of this.props.extensions) {
          extension.draw.call(this, opts, extension);
        }

        this.draw(opts);
      });
    } finally {
      this.props = currentProps;
    }
  }

  getChangeFlags() {
    return this.internalState.changeFlags;
  }

  setChangeFlags(flags) {
    const {
      changeFlags
    } = this.internalState;

    for (const key in flags) {
      if (flags[key]) {
        let flagChanged = false;

        switch (key) {
          case 'dataChanged':
            if (Array.isArray(changeFlags[key])) {
              changeFlags[key] = Array.isArray(flags[key]) ? changeFlags[key].concat(flags[key]) : flags[key];
              flagChanged = true;
            }

          default:
            if (!changeFlags[key]) {
              changeFlags[key] = flags[key];
              flagChanged = true;
            }

        }

        if (flagChanged) {
          (0, _debug.default)(TRACE_CHANGE_FLAG, this, key, flags);
        }
      }
    }

    const propsOrDataChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged || changeFlags.propsChanged || changeFlags.extensionsChanged;
    changeFlags.propsOrDataChanged = propsOrDataChanged;
    changeFlags.somethingChanged = propsOrDataChanged || flags.viewportChanged || flags.stateChanged;
  }

  clearChangeFlags() {
    this.internalState.changeFlags = {
      dataChanged: false,
      propsChanged: false,
      updateTriggersChanged: false,
      viewportChanged: false,
      stateChanged: false,
      extensionsChanged: false,
      propsOrDataChanged: false,
      somethingChanged: false
    };
  }

  diffProps(newProps, oldProps) {
    const changeFlags = (0, _props.diffProps)(newProps, oldProps);

    if (changeFlags.updateTriggersChanged) {
      for (const key in changeFlags.updateTriggersChanged) {
        if (changeFlags.updateTriggersChanged[key]) {
          this.invalidateAttribute(key);
        }
      }
    }

    if (changeFlags.transitionsChanged) {
      for (const key in changeFlags.transitionsChanged) {
        this.internalState.uniformTransitions.add(key, oldProps[key], newProps[key], newProps.transitions[key]);
      }
    }

    return this.setChangeFlags(changeFlags);
  }

  validateProps() {
    (0, _props.validateProps)(this.props);
  }

  setModuleParameters(moduleParameters) {
    for (const model of this.getModels()) {
      model.updateModuleSettings(moduleParameters);
    }
  }

  updateAutoHighlight(info) {
    if (this.props.autoHighlight && !Number.isInteger(this.props.highlightedObjectIndex)) {
      this._updateAutoHighlight(info);
    }
  }

  _updateAutoHighlight(info) {
    const pickingModuleParameters = {
      pickingSelectedColor: info.picked ? info.color : null
    };
    const {
      highlightColor
    } = this.props;

    if (info.picked && typeof highlightColor === 'function') {
      pickingModuleParameters.pickingHighlightColor = highlightColor(info);
    }

    this.setModuleParameters(pickingModuleParameters);
    this.setNeedsRedraw();
  }

  _updateModules({
    props,
    oldProps
  }, forceUpdate) {
    const {
      autoHighlight,
      highlightedObjectIndex,
      highlightColor
    } = props;

    if (forceUpdate || oldProps.autoHighlight !== autoHighlight || oldProps.highlightedObjectIndex !== highlightedObjectIndex || oldProps.highlightColor !== highlightColor) {
      const parameters = {};

      if (!autoHighlight) {
        parameters.pickingSelectedColor = null;
      }

      if (Array.isArray(highlightColor)) {
        parameters.pickingHighlightColor = highlightColor;
      }

      if (Number.isInteger(highlightedObjectIndex)) {
        parameters.pickingSelectedColor = highlightedObjectIndex >= 0 ? this.encodePickingColor(highlightedObjectIndex) : null;
      }

      this.setModuleParameters(parameters);
    }
  }

  _getUpdateParams() {
    return {
      props: this.props,
      oldProps: this.internalState.getOldProps(),
      context: this.context,
      changeFlags: this.internalState.changeFlags
    };
  }

  _getNeedsRedraw(opts) {
    if (!this.internalState) {
      return false;
    }

    let redraw = false;
    redraw = redraw || this.internalState.needsRedraw && this.id;
    this.internalState.needsRedraw = this.internalState.needsRedraw && !opts.clearRedrawFlags;
    const attributeManager = this.getAttributeManager();
    const attributeManagerNeedsRedraw = attributeManager && attributeManager.getNeedsRedraw(opts);
    redraw = redraw || attributeManagerNeedsRedraw;
    return redraw;
  }

  _getAttributeManager() {
    return new _attributeManager.default(this.context.gl, {
      id: this.props.id,
      stats: this.context.stats,
      timeline: this.context.timeline
    });
  }

  _initState() {
    (0, _assert.default)(!this.internalState && !this.state);
    (0, _assert.default)(isFinite(this.props.coordinateSystem));

    const attributeManager = this._getAttributeManager();

    if (attributeManager) {
      attributeManager.addInstanced({
        instancePickingColors: {
          type: 5121,
          size: 3,
          noAlloc: true,
          update: this.calculateInstancePickingColors
        }
      });
    }

    this.internalState = new _layerState.default({
      attributeManager,
      layer: this
    });
    this.clearChangeFlags();
    this.state = {};
    Object.defineProperty(this.state, 'attributeManager', {
      get: () => {
        _log.default.deprecated('layer.state.attributeManager', 'layer.getAttributeManager()');

        return attributeManager;
      }
    });
    this.internalState.layer = this;
    this.internalState.uniformTransitions = new _uniformTransitionManager.default(this.context.timeline);
    this.internalState.onAsyncPropUpdated = this._onAsyncPropUpdated.bind(this);
    this.internalState.setAsyncProps(this.props);
  }

  _transferState(oldLayer) {
    (0, _debug.default)(TRACE_MATCHED, this, this === oldLayer);
    const {
      state,
      internalState
    } = oldLayer;

    if (this === oldLayer) {
      return;
    }

    this.internalState = internalState;
    this.internalState.layer = this;
    this.state = state;
    this.internalState.setAsyncProps(this.props);
    this.diffProps(this.props, this.internalState.getOldProps());
  }

  _onAsyncPropUpdated() {
    this.diffProps(this.props, this.internalState.getOldProps());
    this.setNeedsUpdate();
  }

}

exports.default = Layer;
Layer.layerName = 'Layer';
Layer.defaultProps = defaultProps;
},{"./constants":"node_modules/@deck.gl/core/dist/esm/lib/constants.js","./attribute/attribute-manager":"node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-manager.js","./uniform-transition-manager":"node_modules/@deck.gl/core/dist/esm/lib/uniform-transition-manager.js","../lifecycle/props":"node_modules/@deck.gl/core/dist/esm/lifecycle/props.js","../utils/count":"node_modules/@deck.gl/core/dist/esm/utils/count.js","../utils/log":"node_modules/@deck.gl/core/dist/esm/utils/log.js","../debug":"node_modules/@deck.gl/core/dist/esm/debug/index.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","../utils/assert":"node_modules/@deck.gl/core/dist/esm/utils/assert.js","../utils/memoize":"node_modules/@deck.gl/core/dist/esm/utils/memoize.js","../utils/shader":"node_modules/@deck.gl/core/dist/esm/utils/shader.js","../shaderlib/project/project-functions":"node_modules/@deck.gl/core/dist/esm/shaderlib/project/project-functions.js","../utils/typed-array-manager":"node_modules/@deck.gl/core/dist/esm/utils/typed-array-manager.js","../lifecycle/component":"node_modules/@deck.gl/core/dist/esm/lifecycle/component.js","./layer-state":"node_modules/@deck.gl/core/dist/esm/lib/layer-state.js","@math.gl/web-mercator":"node_modules/@math.gl/web-mercator/dist/esm/index.js","@loaders.gl/core":"node_modules/@loaders.gl/core/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/lib/composite-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _layer = _interopRequireDefault(require("./layer"));

var _debug = _interopRequireDefault(require("../debug"));

var _flatten = require("../utils/flatten");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const TRACE_RENDER_LAYERS = 'compositeLayer.renderLayers';

class CompositeLayer extends _layer.default {
  get isComposite() {
    return true;
  }

  get isLoaded() {
    return super.isLoaded && this.getSubLayers().every(layer => layer.isLoaded);
  }

  getSubLayers() {
    return this.internalState && this.internalState.subLayers || [];
  }

  initializeState() {}

  setState(updateObject) {
    super.setState(updateObject);
    this.setNeedsUpdate();
  }

  getPickingInfo({
    info
  }) {
    const {
      object
    } = info;
    const isDataWrapped = object && object.__source && object.__source.parent && object.__source.parent.id === this.id;

    if (!isDataWrapped) {
      return info;
    }

    info.object = object.__source.object;
    info.index = object.__source.index;
    return info;
  }

  renderLayers() {
    return null;
  }

  filterSubLayer(context) {
    return true;
  }

  shouldRenderSubLayer(id, data) {
    return data && data.length;
  }

  getSubLayerClass(id, DefaultLayerClass) {
    const {
      _subLayerProps: overridingProps
    } = this.props;
    return overridingProps && overridingProps[id] && overridingProps[id].type || DefaultLayerClass;
  }

  getSubLayerRow(row, sourceObject, sourceObjectIndex) {
    row.__source = {
      parent: this,
      object: sourceObject,
      index: sourceObjectIndex
    };
    return row;
  }

  getSubLayerAccessor(accessor) {
    if (typeof accessor === 'function') {
      const objectInfo = {
        data: this.props.data,
        target: []
      };
      return (x, i) => {
        if (x && x.__source) {
          objectInfo.index = x.__source.index;
          return accessor(x.__source.object, objectInfo);
        }

        return accessor(x, i);
      };
    }

    return accessor;
  }

  getSubLayerProps(sublayerProps = {}) {
    const {
      opacity,
      pickable,
      visible,
      parameters,
      getPolygonOffset,
      highlightedObjectIndex,
      autoHighlight,
      highlightColor,
      coordinateSystem,
      coordinateOrigin,
      wrapLongitude,
      positionFormat,
      modelMatrix,
      extensions,
      fetch,
      operation,
      _subLayerProps: overridingProps
    } = this.props;
    const newProps = {
      opacity,
      pickable,
      visible,
      parameters,
      getPolygonOffset,
      highlightedObjectIndex,
      autoHighlight,
      highlightColor,
      coordinateSystem,
      coordinateOrigin,
      wrapLongitude,
      positionFormat,
      modelMatrix,
      extensions,
      fetch,
      operation
    };
    const overridingSublayerProps = overridingProps && overridingProps[sublayerProps.id];
    const overridingSublayerTriggers = overridingSublayerProps && overridingSublayerProps.updateTriggers;
    const sublayerId = sublayerProps.id || 'sublayer';

    if (overridingSublayerProps) {
      const propTypes = this.constructor._propTypes;
      const subLayerPropTypes = sublayerProps.type ? sublayerProps.type._propTypes : {};

      for (const key in overridingSublayerProps) {
        const propType = subLayerPropTypes[key] || propTypes[key];

        if (propType && propType.type === 'accessor') {
          overridingSublayerProps[key] = this.getSubLayerAccessor(overridingSublayerProps[key]);
        }
      }
    }

    Object.assign(newProps, sublayerProps, overridingSublayerProps);
    newProps.id = "".concat(this.props.id, "-").concat(sublayerId);
    newProps.updateTriggers = {
      all: this.props.updateTriggers.all,
      ...sublayerProps.updateTriggers,
      ...overridingSublayerTriggers
    };

    for (const extension of extensions) {
      const passThroughProps = extension.getSubLayerProps.call(this, extension);

      if (passThroughProps) {
        Object.assign(newProps, passThroughProps, {
          updateTriggers: Object.assign(newProps.updateTriggers, passThroughProps.updateTriggers)
        });
      }
    }

    return newProps;
  }

  _updateAutoHighlight(info) {
    for (const layer of this.getSubLayers()) {
      layer.updateAutoHighlight(info);
    }
  }

  _getAttributeManager() {
    return null;
  }

  _renderLayers() {
    let {
      subLayers
    } = this.internalState;
    const shouldUpdate = !subLayers || this.needsUpdate();

    if (shouldUpdate) {
      subLayers = this.renderLayers();
      subLayers = (0, _flatten.flatten)(subLayers, Boolean);
      this.internalState.subLayers = subLayers;
    }

    (0, _debug.default)(TRACE_RENDER_LAYERS, this, shouldUpdate, subLayers);

    for (const layer of subLayers) {
      layer.parent = this;
    }
  }

}

exports.default = CompositeLayer;
CompositeLayer.layerName = 'CompositeLayer';
},{"./layer":"node_modules/@deck.gl/core/dist/esm/lib/layer.js","../debug":"node_modules/@deck.gl/core/dist/esm/debug/index.js","../utils/flatten":"node_modules/@deck.gl/core/dist/esm/utils/flatten.js"}],"node_modules/@deck.gl/core/dist/esm/lib/layer-extension.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));

var _deepEqual = require("../utils/deep-equal");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class LayerExtension {
  constructor(opts = {}) {
    (0, _defineProperty2.default)(this, "props", void 0);
    this.opts = opts;
  }

  equals(extension) {
    if (this === extension) {
      return true;
    }

    return this.constructor === extension.constructor && (0, _deepEqual.deepEqual)(this.opts, extension.opts);
  }

  getShaders(extension) {
    return null;
  }

  getSubLayerProps(extension) {
    const {
      defaultProps = {}
    } = extension.constructor;
    const newProps = {
      updateTriggers: {}
    };

    for (const key in defaultProps) {
      if (key in this.props) {
        const propDef = defaultProps[key];
        const propValue = this.props[key];
        newProps[key] = propValue;

        if (propDef && propDef.type === 'accessor') {
          newProps.updateTriggers[key] = this.props.updateTriggers[key];

          if (typeof propValue === 'function') {
            newProps[key] = this.getSubLayerAccessor(propValue, true);
          }
        }
      }
    }

    return newProps;
  }

  initializeState(context, extension) {}

  updateState(params, extension) {}

  draw(params, extension) {}

  finalizeState(extension) {}

}

exports.default = LayerExtension;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","../utils/deep-equal":"node_modules/@deck.gl/core/dist/esm/utils/deep-equal.js"}],"node_modules/@deck.gl/core/dist/esm/lib/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "AttributeManager", {
  enumerable: true,
  get: function () {
    return _attributeManager.default;
  }
});
Object.defineProperty(exports, "COORDINATE_SYSTEM", {
  enumerable: true,
  get: function () {
    return _constants.COORDINATE_SYSTEM;
  }
});
Object.defineProperty(exports, "CompositeLayer", {
  enumerable: true,
  get: function () {
    return _compositeLayer.default;
  }
});
Object.defineProperty(exports, "Deck", {
  enumerable: true,
  get: function () {
    return _deck.default;
  }
});
Object.defineProperty(exports, "DeckRenderer", {
  enumerable: true,
  get: function () {
    return _deckRenderer.default;
  }
});
Object.defineProperty(exports, "Effect", {
  enumerable: true,
  get: function () {
    return _effect.default;
  }
});
Object.defineProperty(exports, "Layer", {
  enumerable: true,
  get: function () {
    return _layer.default;
  }
});
Object.defineProperty(exports, "LayerExtension", {
  enumerable: true,
  get: function () {
    return _layerExtension.default;
  }
});
Object.defineProperty(exports, "LayerManager", {
  enumerable: true,
  get: function () {
    return _layerManager.default;
  }
});

var _constants = require("./constants");

var _deck = _interopRequireDefault(require("./deck"));

var _deckRenderer = _interopRequireDefault(require("./deck-renderer"));

var _effect = _interopRequireDefault(require("./effect"));

var _layer = _interopRequireDefault(require("./layer"));

var _compositeLayer = _interopRequireDefault(require("./composite-layer"));

var _layerExtension = _interopRequireDefault(require("./layer-extension"));

var _attributeManager = _interopRequireDefault(require("./attribute/attribute-manager"));

var _layerManager = _interopRequireDefault(require("./layer-manager"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./constants":"node_modules/@deck.gl/core/dist/esm/lib/constants.js","./deck":"node_modules/@deck.gl/core/dist/esm/lib/deck.js","./deck-renderer":"node_modules/@deck.gl/core/dist/esm/lib/deck-renderer.js","./effect":"node_modules/@deck.gl/core/dist/esm/lib/effect.js","./layer":"node_modules/@deck.gl/core/dist/esm/lib/layer.js","./composite-layer":"node_modules/@deck.gl/core/dist/esm/lib/composite-layer.js","./layer-extension":"node_modules/@deck.gl/core/dist/esm/lib/layer-extension.js","./attribute/attribute-manager":"node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-manager.js","./layer-manager":"node_modules/@deck.gl/core/dist/esm/lib/layer-manager.js"}],"node_modules/@deck.gl/core/dist/esm/effects/lighting/point-light.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PointLight = void 0;

var _projectFunctions = require("../../shaderlib/project/project-functions");

var _lib = require("../../lib");

const DEFAULT_LIGHT_COLOR = [255, 255, 255];
const DEFAULT_LIGHT_INTENSITY = 1.0;
const DEFAULT_ATTENUATION = [0, 0, 1];
const DEFAULT_LIGHT_POSITION = [0.0, 0.0, 1.0];
let idCount = 0;

class PointLight {
  constructor(props = {}) {
    const {
      color = DEFAULT_LIGHT_COLOR
    } = props;
    const {
      intensity = DEFAULT_LIGHT_INTENSITY
    } = props;
    const {
      position = DEFAULT_LIGHT_POSITION
    } = props;
    this.id = props.id || "point-".concat(idCount++);
    this.color = color;
    this.intensity = intensity;
    this.type = 'point';
    this.position = position;
    this.attenuation = getAttenuation(props);
    this.projectedLight = { ...this
    };
  }

  getProjectedLight({
    layer
  }) {
    const {
      projectedLight
    } = this;
    const viewport = layer.context.viewport;
    const {
      coordinateSystem,
      coordinateOrigin
    } = layer.props;
    const position = (0, _projectFunctions.projectPosition)(this.position, {
      viewport,
      coordinateSystem,
      coordinateOrigin,
      fromCoordinateSystem: viewport.isGeospatial ? _lib.COORDINATE_SYSTEM.LNGLAT : _lib.COORDINATE_SYSTEM.CARTESIAN,
      fromCoordinateOrigin: [0, 0, 0]
    });
    projectedLight.color = this.color;
    projectedLight.intensity = this.intensity;
    projectedLight.position = position;
    return projectedLight;
  }

}

exports.PointLight = PointLight;

function getAttenuation(props) {
  if ('attenuation' in props) {
    return props.attenuation;
  }

  if ('intensity' in props) {
    return [0, 0, props.intensity];
  }

  return DEFAULT_ATTENUATION;
}
},{"../../shaderlib/project/project-functions":"node_modules/@deck.gl/core/dist/esm/shaderlib/project/project-functions.js","../../lib":"node_modules/@deck.gl/core/dist/esm/lib/index.js"}],"node_modules/@deck.gl/core/dist/esm/effects/lighting/camera-light.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _pointLight = require("./point-light");

var _viewportUniforms = require("../../shaderlib/project/viewport-uniforms");

class CameraLight extends _pointLight.PointLight {
  getProjectedLight({
    layer
  }) {
    const {
      projectedLight
    } = this;
    const viewport = layer.context.viewport;
    const {
      coordinateSystem,
      coordinateOrigin,
      modelMatrix
    } = layer.props;
    const {
      project_uCameraPosition
    } = (0, _viewportUniforms.getUniformsFromViewport)({
      viewport,
      modelMatrix,
      coordinateSystem,
      coordinateOrigin
    });
    projectedLight.color = this.color;
    projectedLight.intensity = this.intensity;
    projectedLight.position = project_uCameraPosition;
    return projectedLight;
  }

}

exports.default = CameraLight;
},{"./point-light":"node_modules/@deck.gl/core/dist/esm/effects/lighting/point-light.js","../../shaderlib/project/viewport-uniforms":"node_modules/@deck.gl/core/dist/esm/shaderlib/project/viewport-uniforms.js"}],"node_modules/@deck.gl/core/dist/esm/effects/lighting/suncalc.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSolarPosition = getSolarPosition;
exports.getSunlightDirection = getSunlightDirection;
const DEGREES_TO_RADIANS = Math.PI / 180;
const DAY_IN_MS = 1000 * 60 * 60 * 24;
const JD1970 = 2440588;
const JD2000 = 2451545;
const e = DEGREES_TO_RADIANS * 23.4397;
const M0 = 357.5291;
const M1 = 0.98560028;
const THETA0 = 280.147;
const THETA1 = 360.9856235;

function getSolarPosition(timestamp, latitude, longitude) {
  const longitudeWestInRadians = DEGREES_TO_RADIANS * -longitude;
  const phi = DEGREES_TO_RADIANS * latitude;
  const d = toDays(timestamp);
  const c = getSunCoords(d);
  const H = getSiderealTime(d, longitudeWestInRadians) - c.rightAscension;
  return {
    azimuth: getAzimuth(H, phi, c.declination),
    altitude: getAltitude(H, phi, c.declination)
  };
}

function getSunlightDirection(timestamp, latitude, longitude) {
  const {
    azimuth,
    altitude
  } = getSolarPosition(timestamp, latitude, longitude);
  return [Math.sin(azimuth) * Math.cos(altitude), Math.cos(azimuth) * Math.cos(altitude), -Math.sin(altitude)];
}

function toJulianDay(timestamp) {
  return timestamp / DAY_IN_MS - 0.5 + JD1970;
}

function toDays(timestamp) {
  return toJulianDay(timestamp) - JD2000;
}

function getRightAscension(eclipticLongitude, b) {
  const lambda = eclipticLongitude;
  return Math.atan2(Math.sin(lambda) * Math.cos(e) - Math.tan(b) * Math.sin(e), Math.cos(lambda));
}

function getDeclination(eclipticLongitude, b) {
  const lambda = eclipticLongitude;
  return Math.asin(Math.sin(b) * Math.cos(e) + Math.cos(b) * Math.sin(e) * Math.sin(lambda));
}

function getAzimuth(hourAngle, latitudeInRadians, declination) {
  const H = hourAngle;
  const phi = latitudeInRadians;
  const delta = declination;
  return Math.atan2(Math.sin(H), Math.cos(H) * Math.sin(phi) - Math.tan(delta) * Math.cos(phi));
}

function getAltitude(hourAngle, latitudeInRadians, declination) {
  const H = hourAngle;
  const phi = latitudeInRadians;
  const delta = declination;
  return Math.asin(Math.sin(phi) * Math.sin(delta) + Math.cos(phi) * Math.cos(delta) * Math.cos(H));
}

function getSiderealTime(dates, longitudeWestInRadians) {
  return DEGREES_TO_RADIANS * (THETA0 + THETA1 * dates) - longitudeWestInRadians;
}

function getSolarMeanAnomaly(days) {
  return DEGREES_TO_RADIANS * (M0 + M1 * days);
}

function getEclipticLongitude(meanAnomaly) {
  const M = meanAnomaly;
  const C = DEGREES_TO_RADIANS * (1.9148 * Math.sin(M) + 0.02 * Math.sin(2 * M) + 0.0003 * Math.sin(3 * M));
  const P = DEGREES_TO_RADIANS * 102.9372;
  return M + C + P + Math.PI;
}

function getSunCoords(dates) {
  const M = getSolarMeanAnomaly(dates);
  const L = getEclipticLongitude(M);
  return {
    declination: getDeclination(L, 0),
    rightAscension: getRightAscension(L, 0)
  };
}
},{}],"node_modules/@deck.gl/core/dist/esm/effects/lighting/sun-light.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _directionalLight = require("./directional-light");

var _suncalc = require("./suncalc");

class SunLight extends _directionalLight.DirectionalLight {
  constructor({
    timestamp,
    ...others
  }) {
    super(others);
    this.timestamp = timestamp;
  }

  getProjectedLight({
    layer
  }) {
    const {
      viewport
    } = layer.context;
    const isGlobe = viewport.resolution > 0;

    if (isGlobe) {
      const [x, y, z] = (0, _suncalc.getSunlightDirection)(this.timestamp, 0, 0);
      this.direction = [x, -z, y];
    } else {
      const {
        latitude,
        longitude
      } = viewport;
      this.direction = (0, _suncalc.getSunlightDirection)(this.timestamp, latitude, longitude);
    }

    return this;
  }

}

exports.default = SunLight;
},{"./directional-light":"node_modules/@deck.gl/core/dist/esm/effects/lighting/directional-light.js","./suncalc":"node_modules/@deck.gl/core/dist/esm/effects/lighting/suncalc.js"}],"node_modules/@deck.gl/core/dist/esm/passes/screen-pass.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));

var _core = require("@luma.gl/core");

var _pass = _interopRequireDefault(require("./pass"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class ScreenPass extends _pass.default {
  constructor(gl, props) {
    super(gl, props);
    (0, _defineProperty2.default)(this, "model", void 0);
    const {
      module,
      fs,
      id
    } = props;
    this.model = new _core.ClipSpace(gl, {
      id,
      fs,
      modules: [module]
    });
  }

  render(params) {
    const gl = this.gl;
    (0, _core.setParameters)(gl, {
      viewport: [0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight]
    });
    (0, _core.withParameters)(gl, {
      framebuffer: params.outputBuffer,
      clearColor: [0, 0, 0, 0]
    }, () => this._renderPass(gl, params));
  }

  delete() {
    this.model.delete();
    this.model = null;
  }

  _renderPass(gl, options) {
    const {
      inputBuffer
    } = options;
    (0, _core.clear)(gl, {
      color: true
    });
    this.model.draw({
      moduleSettings: this.props.moduleSettings,
      uniforms: {
        texture: inputBuffer,
        texSize: [inputBuffer.width, inputBuffer.height]
      },
      parameters: {
        depthWrite: false,
        depthTest: false
      }
    });
  }

}

exports.default = ScreenPass;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","./pass":"node_modules/@deck.gl/core/dist/esm/passes/pass.js"}],"node_modules/@deck.gl/core/dist/esm/effects/post-process-effect.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _effect = _interopRequireDefault(require("../lib/effect"));

var _screenPass = _interopRequireDefault(require("../passes/screen-pass"));

var _core = require("@luma.gl/core");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class PostProcessEffect extends _effect.default {
  constructor(module, props = {}) {
    super(props);
    this.id = "".concat(module.name, "-pass");
    (0, _core.normalizeShaderModule)(module);
    this.module = module;
  }

  postRender(gl, params) {
    if (!this.passes) {
      this.passes = createPasses(gl, this.module, this.id, this.props);
    }

    const {
      target
    } = params;
    let inputBuffer = params.inputBuffer;
    let outputBuffer = params.swapBuffer;

    for (let index = 0; index < this.passes.length; index++) {
      if (target && index === this.passes.length - 1) {
        outputBuffer = target;
      }

      this.passes[index].render({
        inputBuffer,
        outputBuffer
      });
      const switchBuffer = outputBuffer;
      outputBuffer = inputBuffer;
      inputBuffer = switchBuffer;
    }

    return inputBuffer;
  }

  cleanup() {
    if (this.passes) {
      for (const pass of this.passes) {
        pass.delete();
      }

      this.passes = null;
    }
  }

}

exports.default = PostProcessEffect;

function createPasses(gl, module, id, moduleSettings) {
  if (module.filter || module.sampler) {
    const fs = getFragmentShaderForRenderPass(module);
    const pass = new _screenPass.default(gl, {
      id,
      module,
      fs,
      moduleSettings
    });
    return [pass];
  }

  const passes = module.passes || [];
  return passes.map((pass, index) => {
    const fs = getFragmentShaderForRenderPass(module, pass);
    const idn = "".concat(id, "-").concat(index);
    return new _screenPass.default(gl, {
      id: idn,
      module,
      fs,
      moduleSettings
    });
  });
}

const FILTER_FS_TEMPLATE = func => "uniform sampler2D texture;\nuniform vec2 texSize;\n\nvarying vec2 position;\nvarying vec2 coordinate;\nvarying vec2 uv;\n\nvoid main() {\n  vec2 texCoord = coordinate;\n\n  gl_FragColor = texture2D(texture, texCoord);\n  gl_FragColor = ".concat(func, "(gl_FragColor, texSize, texCoord);\n}\n");

const SAMPLER_FS_TEMPLATE = func => "uniform sampler2D texture;\nuniform vec2 texSize;\n\nvarying vec2 position;\nvarying vec2 coordinate;\nvarying vec2 uv;\n\nvoid main() {\n  vec2 texCoord = coordinate;\n\n  gl_FragColor = ".concat(func, "(texture, texSize, texCoord);\n}\n");

function getFragmentShaderForRenderPass(module, pass = module) {
  if (pass.filter) {
    const func = typeof pass.filter === 'string' ? pass.filter : "".concat(module.name, "_filterColor");
    return FILTER_FS_TEMPLATE(func);
  }

  if (pass.sampler) {
    const func = typeof pass.sampler === 'string' ? pass.sampler : "".concat(module.name, "_sampleColor");
    return SAMPLER_FS_TEMPLATE(func);
  }

  return null;
}
},{"../lib/effect":"node_modules/@deck.gl/core/dist/esm/lib/effect.js","../passes/screen-pass":"node_modules/@deck.gl/core/dist/esm/passes/screen-pass.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/viewports/globe-viewport.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _core = require("@math.gl/core");

var _viewport = _interopRequireDefault(require("./viewport"));

var _constants = require("../lib/constants");

var vec3 = _interopRequireWildcard(require("gl-matrix/vec3"));

var vec4 = _interopRequireWildcard(require("gl-matrix/vec4"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const DEGREES_TO_RADIANS = Math.PI / 180;
const RADIANS_TO_DEGREES = 180 / Math.PI;
const EARTH_RADIUS = 6370972;
const GLOBE_RADIUS = 256;

function getDistanceScales() {
  const unitsPerMeter = GLOBE_RADIUS / EARTH_RADIUS;
  const unitsPerDegree = Math.PI / 180 * GLOBE_RADIUS;
  return {
    unitsPerMeter: [unitsPerMeter, unitsPerMeter, unitsPerMeter],
    unitsPerMeter2: [0, 0, 0],
    metersPerUnit: [1 / unitsPerMeter, 1 / unitsPerMeter, 1 / unitsPerMeter],
    unitsPerDegree: [unitsPerDegree, unitsPerDegree, unitsPerMeter],
    unitsPerDegree2: [0, 0, 0],
    degreesPerUnit: [1 / unitsPerDegree, 1 / unitsPerDegree, 1 / unitsPerMeter]
  };
}

class GlobeViewport extends _viewport.default {
  constructor(opts = {}) {
    const {
      latitude = 0,
      longitude = 0,
      zoom = 11,
      nearZMultiplier = 0.1,
      farZMultiplier = 2,
      resolution = 10
    } = opts;
    let {
      width,
      height,
      altitude = 1.5
    } = opts;
    width = width || 1;
    height = height || 1;
    altitude = Math.max(0.75, altitude);
    const viewMatrix = new _core.Matrix4().lookAt({
      eye: [0, -altitude, 0],
      up: [0, 0, 1]
    });
    const scale = Math.pow(2, zoom);
    viewMatrix.rotateX(latitude * DEGREES_TO_RADIANS);
    viewMatrix.rotateZ(-longitude * DEGREES_TO_RADIANS);
    viewMatrix.scale(scale / height);
    const halfFov = Math.atan(0.5 / altitude);
    const relativeScale = GLOBE_RADIUS * 2 * scale / height;
    super({ ...opts,
      width,
      height,
      viewMatrix,
      longitude,
      latitude,
      zoom,
      fovyRadians: halfFov * 2,
      aspect: width / height,
      focalDistance: altitude,
      near: nearZMultiplier,
      far: Math.min(2, 1 / relativeScale + 1) * altitude * farZMultiplier
    });
    this.resolution = resolution;
    this.distanceScales = getDistanceScales();
  }

  get projectionMode() {
    return _constants.PROJECTION_MODE.GLOBE;
  }

  getDistanceScales() {
    return this.distanceScales;
  }

  getBounds(options = {}) {
    const unprojectOption = {
      targetZ: options.z || 0
    };
    const left = this.unproject([0, this.height / 2], unprojectOption);
    const top = this.unproject([this.width / 2, 0], unprojectOption);
    const right = this.unproject([this.width, this.height / 2], unprojectOption);
    const bottom = this.unproject([this.width / 2, this.height], unprojectOption);
    if (right[0] < this.longitude) right[0] += 360;
    if (left[0] > this.longitude) left[0] -= 360;
    return [Math.min(left[0], right[0], top[0], bottom[0]), Math.min(left[1], right[1], top[1], bottom[1]), Math.max(left[0], right[0], top[0], bottom[0]), Math.max(left[1], right[1], top[1], bottom[1])];
  }

  unproject(xyz, {
    topLeft = true,
    targetZ
  } = {}) {
    const [x, y, z] = xyz;
    const y2 = topLeft ? y : this.height - y;
    const {
      pixelUnprojectionMatrix
    } = this;
    let coord;

    if (Number.isFinite(z)) {
      coord = transformVector(pixelUnprojectionMatrix, [x, y2, z, 1]);
    } else {
      const coord0 = transformVector(pixelUnprojectionMatrix, [x, y2, -1, 1]);
      const coord1 = transformVector(pixelUnprojectionMatrix, [x, y2, 1, 1]);
      const lt = ((targetZ || 0) / EARTH_RADIUS + 1) * GLOBE_RADIUS;
      const lSqr = vec3.sqrLen(vec3.sub([], coord0, coord1));
      const l0Sqr = vec3.sqrLen(coord0);
      const l1Sqr = vec3.sqrLen(coord1);
      const sSqr = (4 * l0Sqr * l1Sqr - (lSqr - l0Sqr - l1Sqr) ** 2) / 16;
      const dSqr = 4 * sSqr / lSqr;
      const r0 = Math.sqrt(l0Sqr - dSqr);
      const dr = Math.sqrt(Math.max(0, lt * lt - dSqr));
      const t = (r0 - dr) / Math.sqrt(lSqr);
      coord = vec3.lerp([], coord0, coord1, t);
    }

    const [X, Y, Z] = this.unprojectPosition(coord);

    if (Number.isFinite(z)) {
      return [X, Y, Z];
    }

    return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];
  }

  projectPosition(xyz) {
    const [lng, lat, Z = 0] = xyz;
    const lambda = lng * DEGREES_TO_RADIANS;
    const phi = lat * DEGREES_TO_RADIANS;
    const cosPhi = Math.cos(phi);
    const D = (Z / EARTH_RADIUS + 1) * GLOBE_RADIUS;
    return [Math.sin(lambda) * cosPhi * D, -Math.cos(lambda) * cosPhi * D, Math.sin(phi) * D];
  }

  unprojectPosition(xyz) {
    const [x, y, z] = xyz;
    const D = vec3.len(xyz);
    const phi = Math.asin(z / D);
    const lambda = Math.atan2(x, -y);
    const lng = lambda * RADIANS_TO_DEGREES;
    const lat = phi * RADIANS_TO_DEGREES;
    const Z = (D / GLOBE_RADIUS - 1) * EARTH_RADIUS;
    return [lng, lat, Z];
  }

  projectFlat(xyz) {
    return xyz;
  }

  unprojectFlat(xyz) {
    return xyz;
  }

  panByPosition(coords, pixel) {
    const fromPosition = this.unproject(pixel);
    return {
      longitude: coords[0] - fromPosition[0] + this.longitude,
      latitude: coords[1] - fromPosition[1] + this.latitude
    };
  }

}

exports.default = GlobeViewport;

function transformVector(matrix, vector) {
  const result = vec4.transformMat4([], vector, matrix);
  vec4.scale(result, result, 1 / result[3]);
  return result;
}
},{"@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js","./viewport":"node_modules/@deck.gl/core/dist/esm/viewports/viewport.js","../lib/constants":"node_modules/@deck.gl/core/dist/esm/lib/constants.js","gl-matrix/vec3":"node_modules/gl-matrix/esm/vec3.js","gl-matrix/vec4":"node_modules/gl-matrix/esm/vec4.js"}],"node_modules/@deck.gl/core/dist/esm/controllers/first-person-controller.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _controller = _interopRequireDefault(require("./controller"));

var _viewState = _interopRequireDefault(require("./view-state"));

var _mathUtils = require("../utils/math-utils");

var _core = require("@math.gl/core");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const MOVEMENT_SPEED = 20;
const DEFAULT_STATE = {
  position: [0, 0, 0],
  pitch: 0,
  bearing: 0,
  maxPitch: 90,
  minPitch: -90
};

class FirstPersonState extends _viewState.default {
  constructor({
    width,
    height,
    position = DEFAULT_STATE.position,
    bearing = DEFAULT_STATE.bearing,
    pitch = DEFAULT_STATE.pitch,
    longitude,
    latitude,
    maxPitch = DEFAULT_STATE.maxPitch,
    minPitch = DEFAULT_STATE.minPitch,
    startRotatePos,
    startBearing,
    startPitch,
    startZoomPosition,
    startZoom
  }) {
    super({
      width,
      height,
      position,
      bearing,
      pitch,
      longitude,
      latitude,
      maxPitch,
      minPitch
    });
    this._state = {
      startRotatePos,
      startBearing,
      startPitch,
      startZoomPosition,
      startZoom
    };
  }

  getDirection(use2D = false) {
    const spherical = new _core._SphericalCoordinates({
      bearing: this._viewportProps.bearing,
      pitch: use2D ? 90 : 90 + this._viewportProps.pitch
    });
    const direction = spherical.toVector3().normalize();
    return direction;
  }

  panStart() {
    return this;
  }

  pan() {
    return this;
  }

  panEnd() {
    return this;
  }

  rotateStart({
    pos
  }) {
    return this._getUpdatedState({
      startRotatePos: pos,
      startBearing: this._viewportProps.bearing,
      startPitch: this._viewportProps.pitch
    });
  }

  rotate({
    pos,
    deltaAngleX = 0,
    deltaAngleY = 0
  }) {
    const {
      startRotatePos,
      startBearing,
      startPitch
    } = this._state;
    const {
      width,
      height
    } = this._viewportProps;

    if (!startRotatePos || !Number.isFinite(startBearing) || !Number.isFinite(startPitch)) {
      return this;
    }

    let newRotation;

    if (pos) {
      const deltaScaleX = (pos[0] - startRotatePos[0]) / width;
      const deltaScaleY = (pos[1] - startRotatePos[1]) / height;
      newRotation = {
        bearing: startBearing - deltaScaleX * 180,
        pitch: startPitch - deltaScaleY * 90
      };
    } else {
      newRotation = {
        bearing: startBearing - deltaAngleX,
        pitch: startPitch - deltaAngleY
      };
    }

    return this._getUpdatedState(newRotation);
  }

  rotateEnd() {
    return this._getUpdatedState({
      startRotatePos: null,
      startBearing: null,
      startPitch: null
    });
  }

  zoomStart() {
    return this._getUpdatedState({
      startZoomPosition: this._viewportProps.position,
      startZoom: this._viewportProps.zoom
    });
  }

  zoom({
    scale
  }) {
    let {
      startZoomPosition
    } = this._state;

    if (!startZoomPosition) {
      startZoomPosition = this._viewportProps.position;
    }

    const direction = this.getDirection();
    return this._move(direction, Math.log2(scale) * MOVEMENT_SPEED, startZoomPosition);
  }

  zoomEnd() {
    return this._getUpdatedState({
      startZoomPosition: null,
      startZoom: null
    });
  }

  moveLeft(speed = MOVEMENT_SPEED) {
    const direction = this.getDirection(true);
    return this._move(direction.rotateZ({
      radians: Math.PI / 2
    }), speed);
  }

  moveRight(speed = MOVEMENT_SPEED) {
    const direction = this.getDirection(true);
    return this._move(direction.rotateZ({
      radians: -Math.PI / 2
    }), speed);
  }

  moveUp(speed = MOVEMENT_SPEED) {
    const direction = this.getDirection(true);
    return this._move(direction, speed);
  }

  moveDown(speed = MOVEMENT_SPEED) {
    const direction = this.getDirection(true);
    return this._move(direction.negate(), speed);
  }

  rotateLeft(speed = 15) {
    return this._getUpdatedState({
      bearing: this._viewportProps.bearing - speed
    });
  }

  rotateRight(speed = 15) {
    return this._getUpdatedState({
      bearing: this._viewportProps.bearing + speed
    });
  }

  rotateUp(speed = 10) {
    return this._getUpdatedState({
      pitch: this._viewportProps.pitch + speed
    });
  }

  rotateDown(speed = 10) {
    return this._getUpdatedState({
      pitch: this._viewportProps.pitch - speed
    });
  }

  zoomIn(speed = 2) {
    return this.zoom({
      scale: speed
    });
  }

  zoomOut(speed = 2) {
    return this.zoom({
      scale: 1 / speed
    });
  }

  shortestPathFrom(viewState) {
    const fromProps = viewState.getViewportProps();
    const props = { ...this._viewportProps
    };
    const {
      bearing,
      longitude
    } = props;

    if (Math.abs(bearing - fromProps.bearing) > 180) {
      props.bearing = bearing < 0 ? bearing + 360 : bearing - 360;
    }

    if (Math.abs(longitude - fromProps.longitude) > 180) {
      props.longitude = longitude < 0 ? longitude + 360 : longitude - 360;
    }

    return props;
  }

  _move(direction, speed, fromPosition = this._viewportProps.position) {
    const delta = direction.scale(speed);
    return this._getUpdatedState({
      position: new _core.Vector3(fromPosition).add(delta)
    });
  }

  _getUpdatedState(newProps) {
    return new FirstPersonState({ ...this._viewportProps,
      ...this._state,
      ...newProps
    });
  }

  _applyConstraints(props) {
    const {
      pitch,
      maxPitch,
      minPitch,
      longitude,
      bearing
    } = props;
    props.pitch = (0, _core.clamp)(pitch, minPitch, maxPitch);

    if (longitude < -180 || longitude > 180) {
      props.longitude = (0, _mathUtils.mod)(longitude + 180, 360) - 180;
    }

    if (bearing < -180 || bearing > 180) {
      props.bearing = (0, _mathUtils.mod)(bearing + 180, 360) - 180;
    }

    return props;
  }

}

class FirstPersonController extends _controller.default {
  constructor(props) {
    super(FirstPersonState, props);
  }

  get linearTransitionProps() {
    return ['position', 'pitch', 'bearing'];
  }

}

exports.default = FirstPersonController;
},{"./controller":"node_modules/@deck.gl/core/dist/esm/controllers/controller.js","./view-state":"node_modules/@deck.gl/core/dist/esm/controllers/view-state.js","../utils/math-utils":"node_modules/@deck.gl/core/dist/esm/utils/math-utils.js","@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/views/first-person-view.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _view = _interopRequireDefault(require("./view"));

var _viewport = _interopRequireDefault(require("../viewports/viewport"));

var _webMercator = require("@math.gl/web-mercator");

var _core = require("@math.gl/core");

var _firstPersonController = _interopRequireDefault(require("../controllers/first-person-controller"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getDirectionFromBearingAndPitch({
  bearing,
  pitch
}) {
  const spherical = new _core._SphericalCoordinates({
    bearing,
    pitch
  });
  const direction = spherical.toVector3().normalize();
  return direction;
}

class FirstPersonViewport extends _viewport.default {
  constructor(props) {
    const {
      modelMatrix = null,
      bearing = 0,
      pitch = 0,
      up = [0, 0, 1]
    } = props;
    const dir = getDirectionFromBearingAndPitch({
      bearing,
      pitch: pitch === -90 ? 0.0001 : 90 + pitch
    });
    const center = modelMatrix ? modelMatrix.transformDirection(dir) : dir;
    const zoom = (0, _webMercator.getMeterZoom)(props);
    const scale = Math.pow(2, zoom);
    const viewMatrix = new _core.Matrix4().lookAt({
      eye: [0, 0, 0],
      center,
      up
    }).scale(scale);
    super({ ...props,
      zoom,
      viewMatrix
    });
  }

}

class FirstPersonView extends _view.default {
  constructor(props) {
    super({ ...props,
      type: FirstPersonViewport
    });
  }

  get controller() {
    return this._getControllerProps({
      type: _firstPersonController.default
    });
  }

}

exports.default = FirstPersonView;
FirstPersonView.displayName = 'FirstPersonView';
},{"./view":"node_modules/@deck.gl/core/dist/esm/views/view.js","../viewports/viewport":"node_modules/@deck.gl/core/dist/esm/viewports/viewport.js","@math.gl/web-mercator":"node_modules/@math.gl/web-mercator/dist/esm/index.js","@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js","../controllers/first-person-controller":"node_modules/@deck.gl/core/dist/esm/controllers/first-person-controller.js"}],"node_modules/@deck.gl/core/dist/esm/views/orbit-view.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/esm/defineProperty"));

var _view = _interopRequireDefault(require("./view"));

var _viewport = _interopRequireDefault(require("../viewports/viewport"));

var _core = require("@math.gl/core");

var _webMercator = require("@math.gl/web-mercator");

var _orbitController = _interopRequireDefault(require("../controllers/orbit-controller"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const DEGREES_TO_RADIANS = Math.PI / 180;

function getViewMatrix({
  height,
  focalDistance,
  orbitAxis,
  rotationX,
  rotationOrbit,
  zoom
}) {
  const up = orbitAxis === 'Z' ? [0, 0, 1] : [0, 1, 0];
  const eye = orbitAxis === 'Z' ? [0, -focalDistance, 0] : [0, 0, focalDistance];
  const viewMatrix = new _core.Matrix4().lookAt({
    eye,
    up
  });
  viewMatrix.rotateX(rotationX * DEGREES_TO_RADIANS);

  if (orbitAxis === 'Z') {
    viewMatrix.rotateZ(rotationOrbit * DEGREES_TO_RADIANS);
  } else {
    viewMatrix.rotateY(rotationOrbit * DEGREES_TO_RADIANS);
  }

  const projectionScale = Math.pow(2, zoom) / (height || 1);
  viewMatrix.scale(projectionScale);
  return viewMatrix;
}

class OrbitViewport extends _viewport.default {
  constructor(props) {
    const {
      height,
      projectionMatrix,
      fovy = 50,
      orbitAxis,
      target = [0, 0, 0],
      rotationX = 0,
      rotationOrbit = 0,
      zoom = 0
    } = props;
    const focalDistance = projectionMatrix ? projectionMatrix[5] / 2 : (0, _webMercator.fovyToAltitude)(fovy);
    super({ ...props,
      longitude: null,
      viewMatrix: getViewMatrix({
        height,
        focalDistance,
        orbitAxis,
        rotationX,
        rotationOrbit,
        zoom
      }),
      fovy,
      focalDistance,
      position: target,
      zoom
    });
    (0, _defineProperty2.default)(this, "projectedCenter", void 0);
    this.projectedCenter = this.project(this.center);
  }

  unproject(xyz, {
    topLeft = true
  } = {}) {
    const [x, y, z = this.projectedCenter[2]] = xyz;
    const y2 = topLeft ? y : this.height - y;
    const [X, Y, Z] = (0, _webMercator.pixelsToWorld)([x, y2, z], this.pixelUnprojectionMatrix);
    return [X, Y, Z];
  }

  panByPosition(coords, pixel) {
    const p0 = this.project(coords);
    const nextCenter = [this.width / 2 + p0[0] - pixel[0], this.height / 2 + p0[1] - pixel[1], this.projectedCenter[2]];
    return {
      target: this.unproject(nextCenter)
    };
  }

}

(0, _defineProperty2.default)(OrbitViewport, "displayName", 'OrbitView');

class OrbitView extends _view.default {
  constructor(props = {}) {
    const {
      orbitAxis = 'Z'
    } = props;
    super({ ...props,
      orbitAxis,
      type: OrbitViewport
    });
  }

  get controller() {
    return this._getControllerProps({
      type: _orbitController.default
    });
  }

}

exports.default = OrbitView;
},{"@babel/runtime/helpers/esm/defineProperty":"node_modules/@babel/runtime/helpers/esm/defineProperty.js","./view":"node_modules/@deck.gl/core/dist/esm/views/view.js","../viewports/viewport":"node_modules/@deck.gl/core/dist/esm/viewports/viewport.js","@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js","@math.gl/web-mercator":"node_modules/@math.gl/web-mercator/dist/esm/index.js","../controllers/orbit-controller":"node_modules/@deck.gl/core/dist/esm/controllers/orbit-controller.js"}],"node_modules/@deck.gl/core/dist/esm/controllers/globe-controller.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _core = require("@math.gl/core");

var _controller = _interopRequireDefault(require("./controller"));

var _mapController = require("./map-controller");

var _mathUtils = require("../utils/math-utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class GlobeState extends _mapController.MapState {
  _applyConstraints(props) {
    const {
      maxZoom,
      minZoom,
      zoom
    } = props;
    props.zoom = (0, _core.clamp)(zoom, minZoom, maxZoom);
    const {
      longitude,
      latitude
    } = props;

    if (longitude < -180 || longitude > 180) {
      props.longitude = (0, _mathUtils.mod)(longitude + 180, 360) - 180;
    }

    props.latitude = (0, _core.clamp)(latitude, -89, 89);
    return props;
  }

}

class GlobeController extends _controller.default {
  constructor(props) {
    props.dragMode = props.dragMode || 'pan';
    super(GlobeState, props);
  }

  setProps(props) {
    super.setProps(props);
    this.dragRotate = false;
    this.touchRotate = false;
  }

  get linearTransitionProps() {
    return ['longitude', 'latitude', 'zoom'];
  }

}

exports.default = GlobeController;
},{"@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js","./controller":"node_modules/@deck.gl/core/dist/esm/controllers/controller.js","./map-controller":"node_modules/@deck.gl/core/dist/esm/controllers/map-controller.js","../utils/math-utils":"node_modules/@deck.gl/core/dist/esm/utils/math-utils.js"}],"node_modules/@deck.gl/core/dist/esm/views/globe-view.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _view = _interopRequireDefault(require("./view"));

var _globeViewport = _interopRequireDefault(require("../viewports/globe-viewport"));

var _globeController = _interopRequireDefault(require("../controllers/globe-controller"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class GlobeView extends _view.default {
  constructor(props) {
    super({ ...props,
      type: _globeViewport.default
    });
  }

  get controller() {
    return this._getControllerProps({
      type: _globeController.default
    });
  }

}

exports.default = GlobeView;
GlobeView.displayName = 'GlobeView';
},{"./view":"node_modules/@deck.gl/core/dist/esm/views/view.js","../viewports/globe-viewport":"node_modules/@deck.gl/core/dist/esm/viewports/globe-viewport.js","../controllers/globe-controller":"node_modules/@deck.gl/core/dist/esm/controllers/globe-controller.js"}],"node_modules/@deck.gl/core/dist/esm/transitions/viewport-fly-to-interpolator.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _transitionInterpolator = _interopRequireDefault(require("./transition-interpolator"));

var _core = require("@math.gl/core");

var _webMercator = require("@math.gl/web-mercator");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const LINEARLY_INTERPOLATED_PROPS = ['bearing', 'pitch'];
const DEFAULT_OPTS = {
  speed: 1.2,
  curve: 1.414
};

class FlyToInterpolator extends _transitionInterpolator.default {
  constructor(props = {}) {
    super({
      compare: ['longitude', 'latitude', 'zoom', 'bearing', 'pitch'],
      extract: ['width', 'height', 'longitude', 'latitude', 'zoom', 'bearing', 'pitch'],
      required: ['width', 'height', 'latitude', 'longitude', 'zoom']
    });
    this.props = { ...DEFAULT_OPTS,
      ...props
    };
  }

  interpolateProps(startProps, endProps, t) {
    const viewport = (0, _webMercator.flyToViewport)(startProps, endProps, t, this.props);

    for (const key of LINEARLY_INTERPOLATED_PROPS) {
      viewport[key] = (0, _core.lerp)(startProps[key] || 0, endProps[key] || 0, t);
    }

    return viewport;
  }

  getDuration(startProps, endProps) {
    let {
      transitionDuration
    } = endProps;

    if (transitionDuration === 'auto') {
      transitionDuration = (0, _webMercator.getFlyToDuration)(startProps, endProps, this.props);
    }

    return transitionDuration;
  }

}

exports.default = FlyToInterpolator;
},{"./transition-interpolator":"node_modules/@deck.gl/core/dist/esm/transitions/transition-interpolator.js","@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js","@math.gl/web-mercator":"node_modules/@math.gl/web-mercator/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/utils/tesselator.js":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _iterableUtils = require("./iterable-utils");

var _typedArrayManager = _interopRequireDefault(require("./typed-array-manager"));

var _assert = _interopRequireDefault(require("./assert"));

var _core = require("@luma.gl/core");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class Tesselator {
  constructor(opts = {}) {
    const {
      attributes = {}
    } = opts;
    this.typedArrayManager = _typedArrayManager.default;
    this.indexStarts = null;
    this.vertexStarts = null;
    this.vertexCount = 0;
    this.instanceCount = 0;
    this.attributes = {};
    this._attributeDefs = attributes;
    this.opts = opts;
    this.updateGeometry(opts);
    Object.seal(this);
  }

  updateGeometry(opts) {
    Object.assign(this.opts, opts);
    const {
      data,
      buffers = {},
      getGeometry,
      geometryBuffer,
      positionFormat,
      dataChanged,
      normalize = true
    } = this.opts;
    this.data = data;
    this.getGeometry = getGeometry;
    this.positionSize = geometryBuffer && geometryBuffer.size || (positionFormat === 'XY' ? 2 : 3);
    this.buffers = buffers;
    this.normalize = normalize;

    if (geometryBuffer) {
      (0, _assert.default)(data.startIndices);
      this.getGeometry = this.getGeometryFromBuffer(geometryBuffer);

      if (!normalize) {
        buffers.positions = geometryBuffer;
      }
    }

    this.geometryBuffer = buffers.positions;

    if (Array.isArray(dataChanged)) {
      for (const dataRange of dataChanged) {
        this._rebuildGeometry(dataRange);
      }
    } else {
      this._rebuildGeometry();
    }
  }

  updatePartialGeometry({
    startRow,
    endRow
  }) {
    this._rebuildGeometry({
      startRow,
      endRow
    });
  }

  normalizeGeometry(geometry) {
    return geometry;
  }

  updateGeometryAttributes(geometry, startIndex, size) {
    throw new Error('Not implemented');
  }

  getGeometrySize(geometry) {
    throw new Error('Not implemented');
  }

  getGeometryFromBuffer(geometryBuffer) {
    const value = geometryBuffer.value || geometryBuffer;
    (0, _assert.default)(ArrayBuffer.isView(value));
    return (0, _iterableUtils.getAccessorFromBuffer)(value, {
      size: this.positionSize,
      offset: geometryBuffer.offset,
      stride: geometryBuffer.stride,
      startIndices: this.data.startIndices
    });
  }

  _allocate(instanceCount, copy) {
    const {
      attributes,
      buffers,
      _attributeDefs,
      typedArrayManager
    } = this;

    for (const name in _attributeDefs) {
      if (name in buffers) {
        typedArrayManager.release(attributes[name]);
        attributes[name] = null;
      } else {
        const def = _attributeDefs[name];
        def.copy = copy;
        attributes[name] = typedArrayManager.allocate(attributes[name], instanceCount, def);
      }
    }
  }

  _forEachGeometry(visitor, startRow, endRow) {
    const {
      data,
      getGeometry
    } = this;
    const {
      iterable,
      objectInfo
    } = (0, _iterableUtils.createIterable)(data, startRow, endRow);

    for (const object of iterable) {
      objectInfo.index++;
      const geometry = getGeometry(object, objectInfo);
      visitor(geometry, objectInfo.index);
    }
  }

  _rebuildGeometry(dataRange) {
    if (!this.data || !this.getGeometry) {
      return;
    }

    let {
      indexStarts,
      vertexStarts,
      instanceCount
    } = this;
    const {
      data,
      geometryBuffer
    } = this;
    const {
      startRow = 0,
      endRow = Infinity
    } = dataRange || {};
    const normalizedData = {};

    if (!dataRange) {
      indexStarts = [0];
      vertexStarts = [0];
    }

    if (this.normalize || !geometryBuffer) {
      this._forEachGeometry((geometry, dataIndex) => {
        geometry = this.normalizeGeometry(geometry);
        normalizedData[dataIndex] = geometry;
        vertexStarts[dataIndex + 1] = vertexStarts[dataIndex] + this.getGeometrySize(geometry);
      }, startRow, endRow);

      instanceCount = vertexStarts[vertexStarts.length - 1];
    } else if (geometryBuffer.buffer instanceof _core.Buffer) {
      const byteStride = geometryBuffer.stride || this.positionSize * 4;
      vertexStarts = data.startIndices;
      instanceCount = vertexStarts[data.length] || geometryBuffer.buffer.byteLength / byteStride;
    } else {
      const bufferValue = geometryBuffer.value || geometryBuffer;
      const elementStride = geometryBuffer.stride / bufferValue.BYTES_PER_ELEMENT || this.positionSize;
      vertexStarts = data.startIndices;
      instanceCount = vertexStarts[data.length] || bufferValue.length / elementStride;
    }

    this._allocate(instanceCount, Boolean(dataRange));

    this.indexStarts = indexStarts;
    this.vertexStarts = vertexStarts;
    this.instanceCount = instanceCount;
    const context = {};

    this._forEachGeometry((geometry, dataIndex) => {
      geometry = normalizedData[dataIndex] || geometry;
      context.vertexStart = vertexStarts[dataIndex];
      context.indexStart = indexStarts[dataIndex];
      const vertexEnd = dataIndex < vertexStarts.length - 1 ? vertexStarts[dataIndex + 1] : instanceCount;
      context.geometrySize = vertexEnd - vertexStarts[dataIndex];
      context.geometryIndex = dataIndex;
      this.updateGeometryAttributes(geometry, context);
    }, startRow, endRow);

    this.vertexCount = indexStarts[indexStarts.length - 1];
  }

}

exports.default = Tesselator;
},{"./iterable-utils":"node_modules/@deck.gl/core/dist/esm/utils/iterable-utils.js","./typed-array-manager":"node_modules/@deck.gl/core/dist/esm/utils/typed-array-manager.js","./assert":"node_modules/@deck.gl/core/dist/esm/utils/assert.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js"}],"node_modules/@deck.gl/core/dist/esm/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "AmbientLight", {
  enumerable: true,
  get: function () {
    return _ambientLight.AmbientLight;
  }
});
Object.defineProperty(exports, "AttributeManager", {
  enumerable: true,
  get: function () {
    return _attributeManager.default;
  }
});
Object.defineProperty(exports, "COORDINATE_SYSTEM", {
  enumerable: true,
  get: function () {
    return _constants.COORDINATE_SYSTEM;
  }
});
Object.defineProperty(exports, "CompositeLayer", {
  enumerable: true,
  get: function () {
    return _compositeLayer.default;
  }
});
Object.defineProperty(exports, "Controller", {
  enumerable: true,
  get: function () {
    return _controller.default;
  }
});
Object.defineProperty(exports, "Deck", {
  enumerable: true,
  get: function () {
    return _deck.default;
  }
});
Object.defineProperty(exports, "DeckRenderer", {
  enumerable: true,
  get: function () {
    return _deckRenderer.default;
  }
});
Object.defineProperty(exports, "DirectionalLight", {
  enumerable: true,
  get: function () {
    return _directionalLight.DirectionalLight;
  }
});
Object.defineProperty(exports, "Effect", {
  enumerable: true,
  get: function () {
    return _effect.default;
  }
});
Object.defineProperty(exports, "FirstPersonController", {
  enumerable: true,
  get: function () {
    return _firstPersonController.default;
  }
});
Object.defineProperty(exports, "FirstPersonView", {
  enumerable: true,
  get: function () {
    return _firstPersonView.default;
  }
});
Object.defineProperty(exports, "FlyToInterpolator", {
  enumerable: true,
  get: function () {
    return _viewportFlyToInterpolator.default;
  }
});
Object.defineProperty(exports, "Layer", {
  enumerable: true,
  get: function () {
    return _layer.default;
  }
});
Object.defineProperty(exports, "LayerExtension", {
  enumerable: true,
  get: function () {
    return _layerExtension.default;
  }
});
Object.defineProperty(exports, "LayerManager", {
  enumerable: true,
  get: function () {
    return _layerManager.default;
  }
});
Object.defineProperty(exports, "LightingEffect", {
  enumerable: true,
  get: function () {
    return _lightingEffect.default;
  }
});
Object.defineProperty(exports, "LinearInterpolator", {
  enumerable: true,
  get: function () {
    return _linearInterpolator.default;
  }
});
Object.defineProperty(exports, "MapController", {
  enumerable: true,
  get: function () {
    return _mapController.default;
  }
});
Object.defineProperty(exports, "MapView", {
  enumerable: true,
  get: function () {
    return _mapView.default;
  }
});
Object.defineProperty(exports, "OPERATION", {
  enumerable: true,
  get: function () {
    return _constants.OPERATION;
  }
});
Object.defineProperty(exports, "OrbitController", {
  enumerable: true,
  get: function () {
    return _orbitController.default;
  }
});
Object.defineProperty(exports, "OrbitView", {
  enumerable: true,
  get: function () {
    return _orbitView.default;
  }
});
Object.defineProperty(exports, "OrthographicController", {
  enumerable: true,
  get: function () {
    return _orthographicController.default;
  }
});
Object.defineProperty(exports, "OrthographicView", {
  enumerable: true,
  get: function () {
    return _orthographicView.default;
  }
});
Object.defineProperty(exports, "PointLight", {
  enumerable: true,
  get: function () {
    return _pointLight.PointLight;
  }
});
Object.defineProperty(exports, "PostProcessEffect", {
  enumerable: true,
  get: function () {
    return _postProcessEffect.default;
  }
});
Object.defineProperty(exports, "TRANSITION_EVENTS", {
  enumerable: true,
  get: function () {
    return _transitionManager.TRANSITION_EVENTS;
  }
});
Object.defineProperty(exports, "Tesselator", {
  enumerable: true,
  get: function () {
    return _tesselator.default;
  }
});
Object.defineProperty(exports, "TransitionInterpolator", {
  enumerable: true,
  get: function () {
    return _transitionInterpolator.default;
  }
});
Object.defineProperty(exports, "UNIT", {
  enumerable: true,
  get: function () {
    return _constants.UNIT;
  }
});
Object.defineProperty(exports, "View", {
  enumerable: true,
  get: function () {
    return _view.default;
  }
});
Object.defineProperty(exports, "Viewport", {
  enumerable: true,
  get: function () {
    return _viewport.default;
  }
});
Object.defineProperty(exports, "WebMercatorViewport", {
  enumerable: true,
  get: function () {
    return _webMercatorViewport.default;
  }
});
Object.defineProperty(exports, "_CameraLight", {
  enumerable: true,
  get: function () {
    return _cameraLight.default;
  }
});
Object.defineProperty(exports, "_GlobeController", {
  enumerable: true,
  get: function () {
    return _globeController.default;
  }
});
Object.defineProperty(exports, "_GlobeView", {
  enumerable: true,
  get: function () {
    return _globeView.default;
  }
});
Object.defineProperty(exports, "_GlobeViewport", {
  enumerable: true,
  get: function () {
    return _globeViewport.default;
  }
});
Object.defineProperty(exports, "_LayersPass", {
  enumerable: true,
  get: function () {
    return _layersPass.default;
  }
});
Object.defineProperty(exports, "_SunLight", {
  enumerable: true,
  get: function () {
    return _sunLight.default;
  }
});
Object.defineProperty(exports, "_compareProps", {
  enumerable: true,
  get: function () {
    return _props.compareProps;
  }
});
Object.defineProperty(exports, "_count", {
  enumerable: true,
  get: function () {
    return _count.count;
  }
});
Object.defineProperty(exports, "_fillArray", {
  enumerable: true,
  get: function () {
    return _flatten.fillArray;
  }
});
Object.defineProperty(exports, "_flatten", {
  enumerable: true,
  get: function () {
    return _flatten.flatten;
  }
});
Object.defineProperty(exports, "_memoize", {
  enumerable: true,
  get: function () {
    return _memoize.default;
  }
});
Object.defineProperty(exports, "_mergeShaders", {
  enumerable: true,
  get: function () {
    return _shader.mergeShaders;
  }
});
Object.defineProperty(exports, "createIterable", {
  enumerable: true,
  get: function () {
    return _iterableUtils.createIterable;
  }
});
Object.defineProperty(exports, "fp64LowPart", {
  enumerable: true,
  get: function () {
    return _mathUtils.fp64LowPart;
  }
});
Object.defineProperty(exports, "gouraudLighting", {
  enumerable: true,
  get: function () {
    return _shaderlib.gouraudLighting;
  }
});
Object.defineProperty(exports, "log", {
  enumerable: true,
  get: function () {
    return _log.default;
  }
});
Object.defineProperty(exports, "phongLighting", {
  enumerable: true,
  get: function () {
    return _shaderlib.phongLighting;
  }
});
Object.defineProperty(exports, "picking", {
  enumerable: true,
  get: function () {
    return _shaderlib.picking;
  }
});
Object.defineProperty(exports, "project", {
  enumerable: true,
  get: function () {
    return _shaderlib.project;
  }
});
Object.defineProperty(exports, "project32", {
  enumerable: true,
  get: function () {
    return _shaderlib.project32;
  }
});
Object.defineProperty(exports, "shadow", {
  enumerable: true,
  get: function () {
    return _shaderlib.shadow;
  }
});

require("./lib/init");

var _shaderlib = require("./shaderlib");

var _constants = require("./lib/constants");

var _lightingEffect = _interopRequireDefault(require("./effects/lighting/lighting-effect"));

var _ambientLight = require("./effects/lighting/ambient-light");

var _directionalLight = require("./effects/lighting/directional-light");

var _pointLight = require("./effects/lighting/point-light");

var _cameraLight = _interopRequireDefault(require("./effects/lighting/camera-light"));

var _sunLight = _interopRequireDefault(require("./effects/lighting/sun-light"));

var _postProcessEffect = _interopRequireDefault(require("./effects/post-process-effect"));

var _layersPass = _interopRequireDefault(require("./passes/layers-pass"));

var _deck = _interopRequireDefault(require("./lib/deck"));

var _layerManager = _interopRequireDefault(require("./lib/layer-manager"));

var _attributeManager = _interopRequireDefault(require("./lib/attribute/attribute-manager"));

var _layer = _interopRequireDefault(require("./lib/layer"));

var _compositeLayer = _interopRequireDefault(require("./lib/composite-layer"));

var _deckRenderer = _interopRequireDefault(require("./lib/deck-renderer"));

var _viewport = _interopRequireDefault(require("./viewports/viewport"));

var _webMercatorViewport = _interopRequireDefault(require("./viewports/web-mercator-viewport"));

var _globeViewport = _interopRequireDefault(require("./viewports/globe-viewport"));

var _view = _interopRequireDefault(require("./views/view"));

var _mapView = _interopRequireDefault(require("./views/map-view"));

var _firstPersonView = _interopRequireDefault(require("./views/first-person-view"));

var _orbitView = _interopRequireDefault(require("./views/orbit-view"));

var _orthographicView = _interopRequireDefault(require("./views/orthographic-view"));

var _globeView = _interopRequireDefault(require("./views/globe-view"));

var _controller = _interopRequireDefault(require("./controllers/controller"));

var _mapController = _interopRequireDefault(require("./controllers/map-controller"));

var _globeController = _interopRequireDefault(require("./controllers/globe-controller"));

var _firstPersonController = _interopRequireDefault(require("./controllers/first-person-controller"));

var _orbitController = _interopRequireDefault(require("./controllers/orbit-controller"));

var _orthographicController = _interopRequireDefault(require("./controllers/orthographic-controller"));

var _effect = _interopRequireDefault(require("./lib/effect"));

var _layerExtension = _interopRequireDefault(require("./lib/layer-extension"));

var _transitionManager = require("./controllers/transition-manager");

var _transitionInterpolator = _interopRequireDefault(require("./transitions/transition-interpolator"));

var _linearInterpolator = _interopRequireDefault(require("./transitions/linear-interpolator"));

var _viewportFlyToInterpolator = _interopRequireDefault(require("./transitions/viewport-fly-to-interpolator"));

var _log = _interopRequireDefault(require("./utils/log"));

var _iterableUtils = require("./utils/iterable-utils");

var _mathUtils = require("./utils/math-utils");

var _tesselator = _interopRequireDefault(require("./utils/tesselator"));

var _flatten = require("./utils/flatten");

var _count = require("./utils/count");

var _memoize = _interopRequireDefault(require("./utils/memoize"));

var _shader = require("./utils/shader");

var _props = require("./lifecycle/props");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./lib/init":"node_modules/@deck.gl/core/dist/esm/lib/init.js","./shaderlib":"node_modules/@deck.gl/core/dist/esm/shaderlib/index.js","./lib/constants":"node_modules/@deck.gl/core/dist/esm/lib/constants.js","./effects/lighting/lighting-effect":"node_modules/@deck.gl/core/dist/esm/effects/lighting/lighting-effect.js","./effects/lighting/ambient-light":"node_modules/@deck.gl/core/dist/esm/effects/lighting/ambient-light.js","./effects/lighting/directional-light":"node_modules/@deck.gl/core/dist/esm/effects/lighting/directional-light.js","./effects/lighting/point-light":"node_modules/@deck.gl/core/dist/esm/effects/lighting/point-light.js","./effects/lighting/camera-light":"node_modules/@deck.gl/core/dist/esm/effects/lighting/camera-light.js","./effects/lighting/sun-light":"node_modules/@deck.gl/core/dist/esm/effects/lighting/sun-light.js","./effects/post-process-effect":"node_modules/@deck.gl/core/dist/esm/effects/post-process-effect.js","./passes/layers-pass":"node_modules/@deck.gl/core/dist/esm/passes/layers-pass.js","./lib/deck":"node_modules/@deck.gl/core/dist/esm/lib/deck.js","./lib/layer-manager":"node_modules/@deck.gl/core/dist/esm/lib/layer-manager.js","./lib/attribute/attribute-manager":"node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-manager.js","./lib/layer":"node_modules/@deck.gl/core/dist/esm/lib/layer.js","./lib/composite-layer":"node_modules/@deck.gl/core/dist/esm/lib/composite-layer.js","./lib/deck-renderer":"node_modules/@deck.gl/core/dist/esm/lib/deck-renderer.js","./viewports/viewport":"node_modules/@deck.gl/core/dist/esm/viewports/viewport.js","./viewports/web-mercator-viewport":"node_modules/@deck.gl/core/dist/esm/viewports/web-mercator-viewport.js","./viewports/globe-viewport":"node_modules/@deck.gl/core/dist/esm/viewports/globe-viewport.js","./views/view":"node_modules/@deck.gl/core/dist/esm/views/view.js","./views/map-view":"node_modules/@deck.gl/core/dist/esm/views/map-view.js","./views/first-person-view":"node_modules/@deck.gl/core/dist/esm/views/first-person-view.js","./views/orbit-view":"node_modules/@deck.gl/core/dist/esm/views/orbit-view.js","./views/orthographic-view":"node_modules/@deck.gl/core/dist/esm/views/orthographic-view.js","./views/globe-view":"node_modules/@deck.gl/core/dist/esm/views/globe-view.js","./controllers/controller":"node_modules/@deck.gl/core/dist/esm/controllers/controller.js","./controllers/map-controller":"node_modules/@deck.gl/core/dist/esm/controllers/map-controller.js","./controllers/globe-controller":"node_modules/@deck.gl/core/dist/esm/controllers/globe-controller.js","./controllers/first-person-controller":"node_modules/@deck.gl/core/dist/esm/controllers/first-person-controller.js","./controllers/orbit-controller":"node_modules/@deck.gl/core/dist/esm/controllers/orbit-controller.js","./controllers/orthographic-controller":"node_modules/@deck.gl/core/dist/esm/controllers/orthographic-controller.js","./lib/effect":"node_modules/@deck.gl/core/dist/esm/lib/effect.js","./lib/layer-extension":"node_modules/@deck.gl/core/dist/esm/lib/layer-extension.js","./controllers/transition-manager":"node_modules/@deck.gl/core/dist/esm/controllers/transition-manager.js","./transitions/transition-interpolator":"node_modules/@deck.gl/core/dist/esm/transitions/transition-interpolator.js","./transitions/linear-interpolator":"node_modules/@deck.gl/core/dist/esm/transitions/linear-interpolator.js","./transitions/viewport-fly-to-interpolator":"node_modules/@deck.gl/core/dist/esm/transitions/viewport-fly-to-interpolator.js","./utils/log":"node_modules/@deck.gl/core/dist/esm/utils/log.js","./utils/iterable-utils":"node_modules/@deck.gl/core/dist/esm/utils/iterable-utils.js","./utils/math-utils":"node_modules/@deck.gl/core/dist/esm/utils/math-utils.js","./utils/tesselator":"node_modules/@deck.gl/core/dist/esm/utils/tesselator.js","./utils/flatten":"node_modules/@deck.gl/core/dist/esm/utils/flatten.js","./utils/count":"node_modules/@deck.gl/core/dist/esm/utils/count.js","./utils/memoize":"node_modules/@deck.gl/core/dist/esm/utils/memoize.js","./utils/shader":"node_modules/@deck.gl/core/dist/esm/utils/shader.js","./lifecycle/props":"node_modules/@deck.gl/core/dist/esm/lifecycle/props.js"}],"node_modules/@deck.gl/layers/dist/esm/arc-layer/arc-layer-vertex.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME arc-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec4 instanceSourceColors;\nattribute vec4 instanceTargetColors;\nattribute vec3 instanceSourcePositions;\nattribute vec3 instanceSourcePositions64Low;\nattribute vec3 instanceTargetPositions;\nattribute vec3 instanceTargetPositions64Low;\nattribute vec3 instancePickingColors;\nattribute float instanceWidths;\nattribute float instanceHeights;\nattribute float instanceTilts;\n\nuniform bool greatCircle;\nuniform bool useShortestPath;\nuniform float numSegments;\nuniform float opacity;\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform int widthUnits;\n\nvarying vec4 vColor;\nvarying vec2 uv;\nvarying float isValid;\n\nfloat paraboloid(float distance, float sourceZ, float targetZ, float ratio) {\n\n  float deltaZ = targetZ - sourceZ;\n  float dh = distance * instanceHeights;\n  if (dh == 0.0) {\n    return sourceZ + deltaZ * ratio;\n  }\n  float unitZ = deltaZ / dh;\n  float p2 = unitZ * unitZ + 1.0;\n  float dir = step(deltaZ, 0.0);\n  float z0 = mix(sourceZ, targetZ, dir);\n  float r = mix(ratio, 1.0 - ratio, dir);\n  return sqrt(r * (p2 - r)) * dh + z0;\n}\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {\n  vec2 dir_screenspace = normalize(line_clipspace * project_uViewportSize);\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n\n  return dir_screenspace * offset_direction * width / 2.0;\n}\n\nfloat getSegmentRatio(float index) {\n  return smoothstep(0.0, 1.0, index / (numSegments - 1.0));\n}\n\nvec3 interpolateFlat(vec3 source, vec3 target, float segmentRatio) {\n  float distance = length(source.xy - target.xy);\n  float z = paraboloid(distance, source.z, target.z, segmentRatio);\n\n  float tiltAngle = radians(instanceTilts);\n  vec2 tiltDirection = normalize(target.xy - source.xy);\n  vec2 tilt = vec2(-tiltDirection.y, tiltDirection.x) * z * sin(tiltAngle);\n\n  return vec3(\n    mix(source.xy, target.xy, segmentRatio) + tilt,\n    z * cos(tiltAngle)\n  );\n}\nfloat getAngularDist (vec2 source, vec2 target) {\n  vec2 sourceRadians = radians(source);\n  vec2 targetRadians = radians(target);\n  vec2 sin_half_delta = sin((sourceRadians - targetRadians) / 2.0);\n  vec2 shd_sq = sin_half_delta * sin_half_delta;\n\n  float a = shd_sq.y + cos(sourceRadians.y) * cos(targetRadians.y) * shd_sq.x;\n  return 2.0 * asin(sqrt(a));\n}\n\nvec3 interpolateGreatCircle(vec3 source, vec3 target, vec3 source3D, vec3 target3D, float angularDist, float t) {\n  vec2 lngLat;\n  if(abs(angularDist - PI) < 0.001) {\n    lngLat = (1.0 - t) * source.xy + t * target.xy;\n  } else {\n    float a = sin((1.0 - t) * angularDist);\n    float b = sin(t * angularDist);\n    vec3 p = source3D.yxz * a + target3D.yxz * b;\n    lngLat = degrees(vec2(atan(p.y, -p.x), atan(p.z, length(p.xy))));\n  }\n\n  float z = paraboloid(angularDist * EARTH_RADIUS, source.z, target.z, t);\n\n  return vec3(lngLat, z);\n}\n\nvoid main(void) {\n  geometry.worldPosition = instanceSourcePositions;\n  geometry.worldPositionAlt = instanceTargetPositions;\n\n  float segmentIndex = positions.x;\n  float segmentRatio = getSegmentRatio(segmentIndex);\n  float prevSegmentRatio = getSegmentRatio(max(0.0, segmentIndex - 1.0));\n  float nextSegmentRatio = getSegmentRatio(min(numSegments - 1.0, segmentIndex + 1.0));\n  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\n  isValid = 1.0;\n\n  uv = vec2(segmentRatio, positions.y);\n  geometry.uv = uv;\n  geometry.pickingColor = instancePickingColors;\n\n  vec4 curr;\n  vec4 next;\n  vec3 source;\n  vec3 target;\n\n  if ((greatCircle || project_uProjectionMode == PROJECTION_MODE_GLOBE) && project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n    source = project_globe_(vec3(instanceSourcePositions.xy, 0.0));\n    target = project_globe_(vec3(instanceTargetPositions.xy, 0.0));\n    float angularDist = getAngularDist(instanceSourcePositions.xy, instanceTargetPositions.xy);\n\n    vec3 prevPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, prevSegmentRatio);\n    vec3 currPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, segmentRatio);\n    vec3 nextPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, nextSegmentRatio);\n\n    if (abs(currPos.x - prevPos.x) > 180.0) {\n      indexDir = -1.0;\n      isValid = 0.0;\n    } else if (abs(currPos.x - nextPos.x) > 180.0) {\n      indexDir = 1.0;\n      isValid = 0.0;\n    }\n    nextPos = indexDir < 0.0 ? prevPos : nextPos;\n    nextSegmentRatio = indexDir < 0.0 ? prevSegmentRatio : nextSegmentRatio;\n\n    if (isValid == 0.0) {\n      nextPos.x += nextPos.x > 0.0 ? -360.0 : 360.0;\n      float t = ((currPos.x > 0.0 ? 180.0 : -180.0) - currPos.x) / (nextPos.x - currPos.x);\n      currPos = mix(currPos, nextPos, t);\n      segmentRatio = mix(segmentRatio, nextSegmentRatio, t);\n    }\n\n    vec3 currPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, segmentRatio);\n    vec3 nextPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, nextSegmentRatio);\n  \n    curr = project_position_to_clipspace(currPos, currPos64Low, vec3(0.0), geometry.position);\n    next = project_position_to_clipspace(nextPos, nextPos64Low, vec3(0.0));\n  \n  } else {\n    vec3 source_world = instanceSourcePositions;\n    vec3 target_world = instanceTargetPositions;\n    if (useShortestPath) {\n      source_world.x = mod(source_world.x + 180., 360.0) - 180.;\n      target_world.x = mod(target_world.x + 180., 360.0) - 180.;\n\n      float deltaLng = target_world.x - source_world.x;\n      if (deltaLng > 180.) target_world.x -= 360.;\n      if (deltaLng < -180.) source_world.x -= 360.;\n    }\n    source = project_position(source_world, instanceSourcePositions64Low);\n    target = project_position(target_world, instanceTargetPositions64Low);\n    float antiMeridianX = 0.0;\n\n    if (useShortestPath) {\n      if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {\n        antiMeridianX = -(project_uCoordinateOrigin.x + 180.) / 360. * TILE_SIZE;\n      }\n      float thresholdRatio = (antiMeridianX - source.x) / (target.x - source.x);\n\n      if (prevSegmentRatio <= thresholdRatio && nextSegmentRatio > thresholdRatio) {\n        isValid = 0.0;\n        indexDir = sign(segmentRatio - thresholdRatio);\n        segmentRatio = thresholdRatio;\n      }\n    }\n\n    nextSegmentRatio = indexDir < 0.0 ? prevSegmentRatio : nextSegmentRatio;\n    vec3 currPos = interpolateFlat(source, target, segmentRatio);\n    vec3 nextPos = interpolateFlat(source, target, nextSegmentRatio);\n\n    if (useShortestPath) {\n      if (nextPos.x < antiMeridianX) {\n        currPos.x += TILE_SIZE;\n        nextPos.x += TILE_SIZE;\n      }\n    }\n\n    curr = project_common_position_to_clipspace(vec4(currPos, 1.0));\n    next = project_common_position_to_clipspace(vec4(nextPos, 1.0));\n    geometry.position = vec4(currPos, 1.0);\n  }\n  float widthPixels = clamp(\n    project_size_to_pixel(instanceWidths * widthScale, widthUnits),\n    widthMinPixels, widthMaxPixels\n  );\n  vec3 offset = vec3(\n    getExtrusionOffset((next.xy - curr.xy) * indexDir, positions.y, widthPixels),\n    0.0);\n  DECKGL_FILTER_SIZE(offset, geometry);\n  gl_Position = curr + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  vec4 color = mix(instanceSourceColors, instanceTargetColors, segmentRatio);\n  vColor = vec4(color.rgb, color.a * opacity);\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/arc-layer/arc-layer-fragment.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME arc-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\nvarying vec2 uv;\nvarying float isValid;\n\nvoid main(void) {\n  if (isValid == 0.0) {\n    discard;\n  }\n\n  gl_FragColor = vColor;\n  geometry.uv = uv;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/arc-layer/arc-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _core = require("@deck.gl/core");

var _core2 = require("@luma.gl/core");

var _arcLayerVertex = _interopRequireDefault(require("./arc-layer-vertex.glsl"));

var _arcLayerFragment = _interopRequireDefault(require("./arc-layer-fragment.glsl"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const DEFAULT_COLOR = [0, 0, 0, 255];
const defaultProps = {
  getSourcePosition: {
    type: 'accessor',
    value: x => x.sourcePosition
  },
  getTargetPosition: {
    type: 'accessor',
    value: x => x.targetPosition
  },
  getSourceColor: {
    type: 'accessor',
    value: DEFAULT_COLOR
  },
  getTargetColor: {
    type: 'accessor',
    value: DEFAULT_COLOR
  },
  getWidth: {
    type: 'accessor',
    value: 1
  },
  getHeight: {
    type: 'accessor',
    value: 1
  },
  getTilt: {
    type: 'accessor',
    value: 0
  },
  greatCircle: false,
  widthUnits: 'pixels',
  widthScale: {
    type: 'number',
    value: 1,
    min: 0
  },
  widthMinPixels: {
    type: 'number',
    value: 0,
    min: 0
  },
  widthMaxPixels: {
    type: 'number',
    value: Number.MAX_SAFE_INTEGER,
    min: 0
  }
};

class ArcLayer extends _core.Layer {
  getShaders() {
    return super.getShaders({
      vs: _arcLayerVertex.default,
      fs: _arcLayerFragment.default,
      modules: [_core.project32, _core.picking]
    });
  }

  get wrapLongitude() {
    return false;
  }

  initializeState() {
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instanceSourcePositions: {
        size: 3,
        type: 5130,
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: 'getSourcePosition'
      },
      instanceTargetPositions: {
        size: 3,
        type: 5130,
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: 'getTargetPosition'
      },
      instanceSourceColors: {
        size: this.props.colorFormat.length,
        type: 5121,
        normalized: true,
        transition: true,
        accessor: 'getSourceColor',
        defaultValue: DEFAULT_COLOR
      },
      instanceTargetColors: {
        size: this.props.colorFormat.length,
        type: 5121,
        normalized: true,
        transition: true,
        accessor: 'getTargetColor',
        defaultValue: DEFAULT_COLOR
      },
      instanceWidths: {
        size: 1,
        transition: true,
        accessor: 'getWidth',
        defaultValue: 1
      },
      instanceHeights: {
        size: 1,
        transition: true,
        accessor: 'getHeight',
        defaultValue: 1
      },
      instanceTilts: {
        size: 1,
        transition: true,
        accessor: 'getTilt',
        defaultValue: 0
      }
    });
  }

  updateState({
    props,
    oldProps,
    changeFlags
  }) {
    super.updateState({
      props,
      oldProps,
      changeFlags
    });

    if (changeFlags.extensionsChanged) {
      var _this$state$model;

      const {
        gl
      } = this.context;
      (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();
      this.state.model = this._getModel(gl);
      this.getAttributeManager().invalidateAll();
    }
  }

  draw({
    uniforms
  }) {
    const {
      widthUnits,
      widthScale,
      widthMinPixels,
      widthMaxPixels,
      greatCircle,
      wrapLongitude
    } = this.props;
    this.state.model.setUniforms(uniforms).setUniforms({
      greatCircle,
      widthUnits: _core.UNIT[widthUnits],
      widthScale,
      widthMinPixels,
      widthMaxPixels,
      useShortestPath: wrapLongitude
    }).draw();
  }

  _getModel(gl) {
    let positions = [];
    const NUM_SEGMENTS = 50;

    for (let i = 0; i < NUM_SEGMENTS; i++) {
      positions = positions.concat([i, 1, 0, i, -1, 0]);
    }

    const model = new _core2.Model(gl, { ...this.getShaders(),
      id: this.props.id,
      geometry: new _core2.Geometry({
        drawMode: 5,
        attributes: {
          positions: new Float32Array(positions)
        }
      }),
      isInstanced: true
    });
    model.setUniforms({
      numSegments: NUM_SEGMENTS
    });
    return model;
  }

}

exports.default = ArcLayer;
ArcLayer.layerName = 'ArcLayer';
ArcLayer.defaultProps = defaultProps;
},{"@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","./arc-layer-vertex.glsl":"node_modules/@deck.gl/layers/dist/esm/arc-layer/arc-layer-vertex.glsl.js","./arc-layer-fragment.glsl":"node_modules/@deck.gl/layers/dist/esm/arc-layer/arc-layer-fragment.glsl.js"}],"node_modules/@deck.gl/layers/dist/esm/bitmap-layer/create-mesh.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createMesh;

var _core = require("@math.gl/core");

const DEFAULT_INDICES = new Uint16Array([0, 2, 1, 0, 3, 2]);
const DEFAULT_TEX_COORDS = new Float32Array([0, 1, 0, 0, 1, 0, 1, 1]);

function createMesh(bounds, resolution) {
  if (!resolution) {
    return createQuad(bounds);
  }

  const maxXSpan = Math.max(Math.abs(bounds[0][0] - bounds[3][0]), Math.abs(bounds[1][0] - bounds[2][0]));
  const maxYSpan = Math.max(Math.abs(bounds[1][1] - bounds[0][1]), Math.abs(bounds[2][1] - bounds[3][1]));
  const uCount = Math.ceil(maxXSpan / resolution) + 1;
  const vCount = Math.ceil(maxYSpan / resolution) + 1;
  const vertexCount = (uCount - 1) * (vCount - 1) * 6;
  const indices = new Uint32Array(vertexCount);
  const texCoords = new Float32Array(uCount * vCount * 2);
  const positions = new Float64Array(uCount * vCount * 3);
  let vertex = 0;
  let index = 0;

  for (let u = 0; u < uCount; u++) {
    const ut = u / (uCount - 1);

    for (let v = 0; v < vCount; v++) {
      const vt = v / (vCount - 1);
      const p = interpolateQuad(bounds, ut, vt);
      positions[vertex * 3 + 0] = p[0];
      positions[vertex * 3 + 1] = p[1];
      positions[vertex * 3 + 2] = p[2] || 0;
      texCoords[vertex * 2 + 0] = ut;
      texCoords[vertex * 2 + 1] = 1 - vt;

      if (u > 0 && v > 0) {
        indices[index++] = vertex - vCount;
        indices[index++] = vertex - vCount - 1;
        indices[index++] = vertex - 1;
        indices[index++] = vertex - vCount;
        indices[index++] = vertex - 1;
        indices[index++] = vertex;
      }

      vertex++;
    }
  }

  return {
    vertexCount,
    positions,
    indices,
    texCoords
  };
}

function createQuad(bounds) {
  const positions = new Float64Array(12);

  for (let i = 0; i < bounds.length; i++) {
    positions[i * 3 + 0] = bounds[i][0];
    positions[i * 3 + 1] = bounds[i][1];
    positions[i * 3 + 2] = bounds[i][2] || 0;
  }

  return {
    vertexCount: 6,
    positions,
    indices: DEFAULT_INDICES,
    texCoords: DEFAULT_TEX_COORDS
  };
}

function interpolateQuad(quad, ut, vt) {
  return (0, _core.lerp)((0, _core.lerp)(quad[0], quad[1], vt), (0, _core.lerp)(quad[3], quad[2], vt), ut);
}
},{"@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js"}],"node_modules/@deck.gl/layers/dist/esm/bitmap-layer/bitmap-layer-vertex.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "\n#define SHADER_NAME bitmap-layer-vertex-shader\n\nattribute vec2 texCoords;\nattribute vec3 positions;\nattribute vec3 positions64Low;\n\nvarying vec2 vTexCoord;\nvarying vec2 vTexPos;\n\nuniform float coordinateConversion;\n\nconst vec3 pickingColor = vec3(1.0, 0.0, 0.0);\n\nvoid main(void) {\n  geometry.worldPosition = positions;\n  geometry.uv = texCoords;\n  geometry.pickingColor = pickingColor;\n\n  gl_Position = project_position_to_clipspace(positions, positions64Low, vec3(0.0), geometry.position);\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  vTexCoord = texCoords;\n\n  if (coordinateConversion < -0.5) {\n    vTexPos = geometry.position.xy + project_uCommonOrigin.xy;\n  } else if (coordinateConversion > 0.5) {\n    vTexPos = geometry.worldPosition.xy;\n  }\n\n  vec4 color = vec4(0.0);\n  DECKGL_FILTER_COLOR(color, geometry);\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/bitmap-layer/bitmap-layer-fragment.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
const packUVsIntoRGB = "\nvec3 packUVsIntoRGB(vec2 uv) {\n  // Extract the top 8 bits. We want values to be truncated down so we can add a fraction\n  vec2 uv8bit = floor(uv * 256.);\n\n  // Calculate the normalized remainders of u and v parts that do not fit into 8 bits\n  // Scale and clamp to 0-1 range\n  vec2 uvFraction = fract(uv * 256.);\n  vec2 uvFraction4bit = floor(uvFraction * 16.);\n\n  // Remainder can be encoded in blue channel, encode as 4 bits for pixel coordinates\n  float fractions = uvFraction4bit.x + uvFraction4bit.y * 16.;\n\n  return vec3(uv8bit, fractions) / 255.;\n}\n";

var _default = "\n#define SHADER_NAME bitmap-layer-fragment-shader\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform sampler2D bitmapTexture;\n\nvarying vec2 vTexCoord;\nvarying vec2 vTexPos;\n\nuniform float desaturate;\nuniform vec4 transparentColor;\nuniform vec3 tintColor;\nuniform float opacity;\n\nuniform float coordinateConversion;\nuniform vec4 bounds;\n\n/* projection utils */\nconst float TILE_SIZE = 512.0;\nconst float PI = 3.1415926536;\nconst float WORLD_SCALE = TILE_SIZE / PI / 2.0;\n\n// from degrees to Web Mercator\nvec2 lnglat_to_mercator(vec2 lnglat) {\n  float x = lnglat.x;\n  float y = clamp(lnglat.y, -89.9, 89.9);\n  return vec2(\n    radians(x) + PI,\n    PI + log(tan(PI * 0.25 + radians(y) * 0.5))\n  ) * WORLD_SCALE;\n}\n\n// from Web Mercator to degrees\nvec2 mercator_to_lnglat(vec2 xy) {\n  xy /= WORLD_SCALE;\n  return degrees(vec2(\n    xy.x - PI,\n    atan(exp(xy.y - PI)) * 2.0 - PI * 0.5\n  ));\n}\n/* End projection utils */\n\n// apply desaturation\nvec3 color_desaturate(vec3 color) {\n  float luminance = (color.r + color.g + color.b) * 0.333333333;\n  return mix(color, vec3(luminance), desaturate);\n}\n\n// apply tint\nvec3 color_tint(vec3 color) {\n  return color * tintColor;\n}\n\n// blend with background color\nvec4 apply_opacity(vec3 color, float alpha) {\n  return mix(transparentColor, vec4(color, 1.0), alpha);\n}\n\nvec2 getUV(vec2 pos) {\n  return vec2(\n    (pos.x - bounds[0]) / (bounds[2] - bounds[0]),\n    (pos.y - bounds[3]) / (bounds[1] - bounds[3])\n  );\n}\n\n".concat(packUVsIntoRGB, "\n\nvoid main(void) {\n  vec2 uv = vTexCoord;\n  if (coordinateConversion < -0.5) {\n    vec2 lnglat = mercator_to_lnglat(vTexPos);\n    uv = getUV(lnglat);\n  } else if (coordinateConversion > 0.5) {\n    vec2 commonPos = lnglat_to_mercator(vTexPos);\n    uv = getUV(commonPos);\n  }\n  vec4 bitmapColor = texture2D(bitmapTexture, uv);\n\n  gl_FragColor = apply_opacity(color_tint(color_desaturate(bitmapColor.rgb)), bitmapColor.a * opacity);\n\n  geometry.uv = uv;\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n\n  if (picking_uActive) {\n    // Since instance information is not used, we can use picking color for pixel index\n    gl_FragColor.rgb = packUVsIntoRGB(uv);\n  }\n}\n");

exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/bitmap-layer/bitmap-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _core = require("@deck.gl/core");

var _core2 = require("@luma.gl/core");

var _webMercator = require("@math.gl/web-mercator");

var _createMesh = _interopRequireDefault(require("./create-mesh"));

var _bitmapLayerVertex = _interopRequireDefault(require("./bitmap-layer-vertex"));

var _bitmapLayerFragment = _interopRequireDefault(require("./bitmap-layer-fragment"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const defaultProps = {
  image: {
    type: 'image',
    value: null,
    async: true
  },
  bounds: {
    type: 'array',
    value: [1, 0, 0, 1],
    compare: true
  },
  _imageCoordinateSystem: _core.COORDINATE_SYSTEM.DEFAULT,
  desaturate: {
    type: 'number',
    min: 0,
    max: 1,
    value: 0
  },
  transparentColor: {
    type: 'color',
    value: [0, 0, 0, 0]
  },
  tintColor: {
    type: 'color',
    value: [255, 255, 255]
  }
};

class BitmapLayer extends _core.Layer {
  getShaders() {
    return super.getShaders({
      vs: _bitmapLayerVertex.default,
      fs: _bitmapLayerFragment.default,
      modules: [_core.project32, _core.picking]
    });
  }

  initializeState() {
    const attributeManager = this.getAttributeManager();
    attributeManager.remove(['instancePickingColors']);
    const noAlloc = true;
    attributeManager.add({
      indices: {
        size: 1,
        isIndexed: true,
        update: attribute => attribute.value = this.state.mesh.indices,
        noAlloc
      },
      positions: {
        size: 3,
        type: 5130,
        fp64: this.use64bitPositions(),
        update: attribute => attribute.value = this.state.mesh.positions,
        noAlloc
      },
      texCoords: {
        size: 2,
        update: attribute => attribute.value = this.state.mesh.texCoords,
        noAlloc
      }
    });
  }

  updateState({
    props,
    oldProps,
    changeFlags
  }) {
    if (changeFlags.extensionsChanged) {
      var _this$state$model;

      const {
        gl
      } = this.context;
      (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();
      this.state.model = this._getModel(gl);
      this.getAttributeManager().invalidateAll();
    }

    const attributeManager = this.getAttributeManager();

    if (props.bounds !== oldProps.bounds) {
      const oldMesh = this.state.mesh;

      const mesh = this._createMesh();

      this.state.model.setVertexCount(mesh.vertexCount);

      for (const key in mesh) {
        if (oldMesh && oldMesh[key] !== mesh[key]) {
          attributeManager.invalidate(key);
        }
      }

      this.setState({
        mesh,
        ...this._getCoordinateUniforms()
      });
    } else if (props._imageCoordinateSystem !== oldProps._imageCoordinateSystem) {
      this.setState(this._getCoordinateUniforms());
    }
  }

  getPickingInfo({
    info
  }) {
    const {
      image
    } = this.props;

    if (!info.color || !image) {
      info.bitmap = null;
      return info;
    }

    const {
      width,
      height
    } = image;
    info.index = 0;
    const uv = unpackUVsFromRGB(info.color);
    const pixel = [Math.floor(uv[0] * width), Math.floor(uv[1] * height)];
    info.bitmap = {
      size: {
        width,
        height
      },
      uv,
      pixel
    };
    return info;
  }

  disablePickingIndex() {
    this.setState({
      disablePicking: true
    });
  }

  restorePickingColors() {
    this.setState({
      disablePicking: false
    });
  }

  _updateAutoHighlight(info) {
    super._updateAutoHighlight({ ...info,
      color: this.encodePickingColor(0)
    });
  }

  _createMesh() {
    const {
      bounds
    } = this.props;
    let normalizedBounds = bounds;

    if (Number.isFinite(bounds[0])) {
      normalizedBounds = [[bounds[0], bounds[1]], [bounds[0], bounds[3]], [bounds[2], bounds[3]], [bounds[2], bounds[1]]];
    }

    return (0, _createMesh.default)(normalizedBounds, this.context.viewport.resolution);
  }

  _getModel(gl) {
    if (!gl) {
      return null;
    }

    return new _core2.Model(gl, { ...this.getShaders(),
      id: this.props.id,
      geometry: new _core2.Geometry({
        drawMode: 4,
        vertexCount: 6
      }),
      isInstanced: false
    });
  }

  draw(opts) {
    const {
      uniforms,
      moduleParameters
    } = opts;
    const {
      model,
      coordinateConversion,
      bounds,
      disablePicking
    } = this.state;
    const {
      image,
      desaturate,
      transparentColor,
      tintColor
    } = this.props;

    if (moduleParameters.pickingActive && disablePicking) {
      return;
    }

    if (image && model) {
      model.setUniforms(uniforms).setUniforms({
        bitmapTexture: image,
        desaturate,
        transparentColor: transparentColor.map(x => x / 255),
        tintColor: tintColor.slice(0, 3).map(x => x / 255),
        coordinateConversion,
        bounds
      }).draw();
    }
  }

  _getCoordinateUniforms() {
    const {
      LNGLAT,
      CARTESIAN,
      DEFAULT
    } = _core.COORDINATE_SYSTEM;
    let {
      _imageCoordinateSystem: imageCoordinateSystem
    } = this.props;

    if (imageCoordinateSystem !== DEFAULT) {
      const {
        bounds
      } = this.props;

      if (!Number.isFinite(bounds[0])) {
        throw new Error('_imageCoordinateSystem only supports rectangular bounds');
      }

      const defaultImageCoordinateSystem = this.context.viewport.resolution ? LNGLAT : CARTESIAN;
      imageCoordinateSystem = imageCoordinateSystem === LNGLAT ? LNGLAT : CARTESIAN;

      if (imageCoordinateSystem === LNGLAT && defaultImageCoordinateSystem === CARTESIAN) {
        return {
          coordinateConversion: -1,
          bounds
        };
      }

      if (imageCoordinateSystem === CARTESIAN && defaultImageCoordinateSystem === LNGLAT) {
        const bottomLeft = (0, _webMercator.lngLatToWorld)([bounds[0], bounds[1]]);
        const topRight = (0, _webMercator.lngLatToWorld)([bounds[2], bounds[3]]);
        return {
          coordinateConversion: 1,
          bounds: [bottomLeft[0], bottomLeft[1], topRight[0], topRight[1]]
        };
      }
    }

    return {
      coordinateConversion: 0,
      bounds: [0, 0, 0, 0]
    };
  }

}

exports.default = BitmapLayer;
BitmapLayer.layerName = 'BitmapLayer';
BitmapLayer.defaultProps = defaultProps;

function unpackUVsFromRGB(color) {
  const [u, v, fracUV] = color;
  const vFrac = (fracUV & 0xf0) / 256;
  const uFrac = (fracUV & 0x0f) / 16;
  return [(u + uFrac) / 256, (v + vFrac) / 256];
}
},{"@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","@math.gl/web-mercator":"node_modules/@math.gl/web-mercator/dist/esm/index.js","./create-mesh":"node_modules/@deck.gl/layers/dist/esm/bitmap-layer/create-mesh.js","./bitmap-layer-vertex":"node_modules/@deck.gl/layers/dist/esm/bitmap-layer/bitmap-layer-vertex.js","./bitmap-layer-fragment":"node_modules/@deck.gl/layers/dist/esm/bitmap-layer/bitmap-layer-fragment.js"}],"node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-layer-vertex.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME icon-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute float instanceSizes;\nattribute float instanceAngles;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\nattribute vec4 instanceIconFrames;\nattribute float instanceColorModes;\nattribute vec2 instanceOffsets;\nattribute vec2 instancePixelOffset;\n\nuniform float sizeScale;\nuniform vec2 iconsTextureDim;\nuniform float sizeMinPixels;\nuniform float sizeMaxPixels;\nuniform bool billboard;\nuniform int sizeUnits;\n\nvarying float vColorMode;\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvec2 rotate_by_angle(vec2 vertex, float angle) {\n  float angle_radian = angle * PI / 180.0;\n  float cos_angle = cos(angle_radian);\n  float sin_angle = sin(angle_radian);\n  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\n  return rotationMatrix * vertex;\n}\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.uv = positions;\n  geometry.pickingColor = instancePickingColors;\n  uv = positions;\n\n  vec2 iconSize = instanceIconFrames.zw;\n  float sizePixels = clamp(\n    project_size_to_pixel(instanceSizes * sizeScale, sizeUnits), \n    sizeMinPixels, sizeMaxPixels\n  );\n  float instanceScale = iconSize.y == 0.0 ? 0.0 : sizePixels / iconSize.y;\n  vec2 pixelOffset = positions / 2.0 * iconSize + instanceOffsets;\n  pixelOffset = rotate_by_angle(pixelOffset, instanceAngles) * instanceScale;\n  pixelOffset += instancePixelOffset;\n  pixelOffset.y *= -1.0;\n\n  if (billboard)  {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    vec3 offset = vec3(pixelOffset, 0.0);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n\n  } else {\n    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);\n    DECKGL_FILTER_SIZE(offset_common, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position); \n  }\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  vTextureCoords = mix(\n    instanceIconFrames.xy,\n    instanceIconFrames.xy + iconSize,\n    (positions.xy + 1.0) / 2.0\n  ) / iconsTextureDim;\n\n  vColor = instanceColors;\n  DECKGL_FILTER_COLOR(vColor, geometry);\n\n  vColorMode = instanceColorModes;\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-layer-fragment.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME icon-layer-fragment-shader\n\nprecision highp float;\n\nuniform float opacity;\nuniform sampler2D iconsTexture;\nuniform float alphaCutoff;\n\nvarying float vColorMode;\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  vec4 texColor = texture2D(iconsTexture, vTextureCoords);\n  vec3 color = mix(texColor.rgb, vColor.rgb, vColorMode);\n  float a = texColor.a * opacity * vColor.a;\n\n  if (a < alphaCutoff) {\n    discard;\n  }\n\n  gl_FragColor = vec4(color, a);\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-manager.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildMapping = buildMapping;
exports.default = void 0;
exports.getDiffIcons = getDiffIcons;

var _core = require("@luma.gl/core");

var _images = require("@loaders.gl/images");

var _core2 = require("@loaders.gl/core");

var _core3 = require("@deck.gl/core");

const DEFAULT_CANVAS_WIDTH = 1024;
const DEFAULT_BUFFER = 4;

const noop = () => {};

const DEFAULT_TEXTURE_PARAMETERS = {
  [10241]: 9987,
  [10240]: 9729,
  [10242]: 33071,
  [10243]: 33071
};

function nextPowOfTwo(number) {
  return Math.pow(2, Math.ceil(Math.log2(number)));
}

function resizeImage(ctx, imageData, width, height) {
  if (width === imageData.width && height === imageData.height) {
    return imageData;
  }

  ctx.canvas.height = height;
  ctx.canvas.width = width;
  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
  ctx.drawImage(imageData, 0, 0, imageData.width, imageData.height, 0, 0, width, height);
  return ctx.canvas;
}

function getIconId(icon) {
  return icon && (icon.id || icon.url);
}

function resizeTexture(gl, texture, width, height) {
  const oldWidth = texture.width;
  const oldHeight = texture.height;
  const newTexture = (0, _core.cloneTextureFrom)(texture, {
    width,
    height
  });
  (0, _core.copyToTexture)(texture, newTexture, {
    targetY: 0,
    width: oldWidth,
    height: oldHeight
  });
  texture.delete();
  return newTexture;
}

function buildRowMapping(mapping, columns, yOffset) {
  for (let i = 0; i < columns.length; i++) {
    const {
      icon,
      xOffset
    } = columns[i];
    const id = getIconId(icon);
    mapping[id] = { ...icon,
      x: xOffset,
      y: yOffset
    };
  }
}

function buildMapping({
  icons,
  buffer,
  mapping = {},
  xOffset = 0,
  yOffset = 0,
  rowHeight = 0,
  canvasWidth
}) {
  let columns = [];

  for (let i = 0; i < icons.length; i++) {
    const icon = icons[i];
    const id = getIconId(icon);

    if (!mapping[id]) {
      const {
        height,
        width
      } = icon;

      if (xOffset + width + buffer > canvasWidth) {
        buildRowMapping(mapping, columns, yOffset);
        xOffset = 0;
        yOffset = rowHeight + yOffset + buffer;
        rowHeight = 0;
        columns = [];
      }

      columns.push({
        icon,
        xOffset
      });
      xOffset = xOffset + width + buffer;
      rowHeight = Math.max(rowHeight, height);
    }
  }

  if (columns.length > 0) {
    buildRowMapping(mapping, columns, yOffset);
  }

  return {
    mapping,
    rowHeight,
    xOffset,
    yOffset,
    canvasWidth,
    canvasHeight: nextPowOfTwo(rowHeight + yOffset + buffer)
  };
}

function getDiffIcons(data, getIcon, cachedIcons) {
  if (!data || !getIcon) {
    return null;
  }

  cachedIcons = cachedIcons || {};
  const icons = {};
  const {
    iterable,
    objectInfo
  } = (0, _core3.createIterable)(data);

  for (const object of iterable) {
    objectInfo.index++;
    const icon = getIcon(object, objectInfo);
    const id = getIconId(icon);

    if (!icon) {
      throw new Error('Icon is missing.');
    }

    if (!icon.url) {
      throw new Error('Icon url is missing.');
    }

    if (!icons[id] && (!cachedIcons[id] || icon.url !== cachedIcons[id].url)) {
      icons[id] = { ...icon,
        source: object,
        sourceIndex: objectInfo.index
      };
    }
  }

  return icons;
}

class IconManager {
  constructor(gl, {
    onUpdate = noop,
    onError = noop
  }) {
    this.gl = gl;
    this.onUpdate = onUpdate;
    this.onError = onError;
    this._loadOptions = null;
    this._getIcon = null;
    this._texture = null;
    this._externalTexture = null;
    this._mapping = {};
    this._pendingCount = 0;
    this._autoPacking = false;
    this._xOffset = 0;
    this._yOffset = 0;
    this._rowHeight = 0;
    this._buffer = DEFAULT_BUFFER;
    this._canvasWidth = DEFAULT_CANVAS_WIDTH;
    this._canvasHeight = 0;
    this._canvas = null;
  }

  finalize() {
    var _this$_texture;

    (_this$_texture = this._texture) === null || _this$_texture === void 0 ? void 0 : _this$_texture.delete();
  }

  getTexture() {
    return this._texture || this._externalTexture;
  }

  getIconMapping(icon) {
    const id = this._autoPacking ? getIconId(icon) : icon;
    return this._mapping[id] || {};
  }

  setProps({
    loadOptions,
    autoPacking,
    iconAtlas,
    iconMapping,
    data,
    getIcon
  }) {
    if (loadOptions) {
      this._loadOptions = loadOptions;
    }

    if (autoPacking !== undefined) {
      this._autoPacking = autoPacking;
    }

    if (getIcon) {
      this._getIcon = getIcon;
    }

    if (iconMapping) {
      this._mapping = iconMapping;
    }

    if (iconAtlas) {
      this._updateIconAtlas(iconAtlas);
    }

    if (this._autoPacking && (data || getIcon) && typeof document !== 'undefined') {
      this._canvas = this._canvas || document.createElement('canvas');

      this._updateAutoPacking(data);
    }
  }

  get isLoaded() {
    return this._pendingCount === 0;
  }

  _updateIconAtlas(iconAtlas) {
    var _this$_texture2;

    (_this$_texture2 = this._texture) === null || _this$_texture2 === void 0 ? void 0 : _this$_texture2.delete();
    this._texture = null;
    this._externalTexture = iconAtlas;
    this.onUpdate();
  }

  _updateAutoPacking(data) {
    const icons = Object.values(getDiffIcons(data, this._getIcon, this._mapping) || {});

    if (icons.length > 0) {
      const {
        mapping,
        xOffset,
        yOffset,
        rowHeight,
        canvasHeight
      } = buildMapping({
        icons,
        buffer: this._buffer,
        canvasWidth: this._canvasWidth,
        mapping: this._mapping,
        rowHeight: this._rowHeight,
        xOffset: this._xOffset,
        yOffset: this._yOffset
      });
      this._rowHeight = rowHeight;
      this._mapping = mapping;
      this._xOffset = xOffset;
      this._yOffset = yOffset;
      this._canvasHeight = canvasHeight;

      if (!this._texture) {
        this._texture = new _core.Texture2D(this.gl, {
          width: this._canvasWidth,
          height: this._canvasHeight,
          parameters: DEFAULT_TEXTURE_PARAMETERS
        });
      }

      if (this._texture.height !== this._canvasHeight) {
        this._texture = resizeTexture(this.gl, this._texture, this._canvasWidth, this._canvasHeight);
      }

      this.onUpdate();

      this._loadIcons(icons);
    }
  }

  _loadIcons(icons) {
    const ctx = this._canvas.getContext('2d');

    for (const icon of icons) {
      this._pendingCount++;
      (0, _core2.load)(icon.url, _images.ImageLoader, this._loadOptions).then(imageData => {
        const id = getIconId(icon);
        const {
          x,
          y,
          width,
          height
        } = this._mapping[id];
        const data = resizeImage(ctx, imageData, width, height);

        this._texture.setSubImageData({
          data,
          x,
          y,
          width,
          height
        });

        this._texture.generateMipmap();

        this.onUpdate();
      }).catch(error => {
        this.onError({
          url: icon.url,
          source: icon.source,
          sourceIndex: icon.sourceIndex,
          loadOptions: this._loadOptions,
          error
        });
      }).finally(() => {
        this._pendingCount--;
      });
    }
  }

}

exports.default = IconManager;
},{"@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","@loaders.gl/images":"node_modules/@loaders.gl/images/dist/esm/index.js","@loaders.gl/core":"node_modules/@loaders.gl/core/dist/esm/index.js","@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js"}],"node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _core = require("@deck.gl/core");

var _core2 = require("@luma.gl/core");

var _iconLayerVertex = _interopRequireDefault(require("./icon-layer-vertex.glsl"));

var _iconLayerFragment = _interopRequireDefault(require("./icon-layer-fragment.glsl"));

var _iconManager = _interopRequireDefault(require("./icon-manager"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const DEFAULT_COLOR = [0, 0, 0, 255];
const defaultProps = {
  iconAtlas: {
    type: 'image',
    value: null,
    async: true
  },
  iconMapping: {
    type: 'object',
    value: {},
    async: true
  },
  sizeScale: {
    type: 'number',
    value: 1,
    min: 0
  },
  billboard: true,
  sizeUnits: 'pixels',
  sizeMinPixels: {
    type: 'number',
    min: 0,
    value: 0
  },
  sizeMaxPixels: {
    type: 'number',
    min: 0,
    value: Number.MAX_SAFE_INTEGER
  },
  alphaCutoff: {
    type: 'number',
    value: 0.05,
    min: 0,
    max: 1
  },
  getPosition: {
    type: 'accessor',
    value: x => x.position
  },
  getIcon: {
    type: 'accessor',
    value: x => x.icon
  },
  getColor: {
    type: 'accessor',
    value: DEFAULT_COLOR
  },
  getSize: {
    type: 'accessor',
    value: 1
  },
  getAngle: {
    type: 'accessor',
    value: 0
  },
  getPixelOffset: {
    type: 'accessor',
    value: [0, 0]
  },
  onIconError: {
    type: 'function',
    value: null,
    compare: false,
    optional: true
  }
};

class IconLayer extends _core.Layer {
  getShaders() {
    return super.getShaders({
      vs: _iconLayerVertex.default,
      fs: _iconLayerFragment.default,
      modules: [_core.project32, _core.picking]
    });
  }

  initializeState() {
    this.state = {
      iconManager: new _iconManager.default(this.context.gl, {
        onUpdate: this._onUpdate.bind(this),
        onError: this._onError.bind(this)
      })
    };
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instancePositions: {
        size: 3,
        type: 5130,
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: 'getPosition'
      },
      instanceSizes: {
        size: 1,
        transition: true,
        accessor: 'getSize',
        defaultValue: 1
      },
      instanceOffsets: {
        size: 2,
        accessor: 'getIcon',
        transform: this.getInstanceOffset
      },
      instanceIconFrames: {
        size: 4,
        accessor: 'getIcon',
        transform: this.getInstanceIconFrame
      },
      instanceColorModes: {
        size: 1,
        type: 5121,
        accessor: 'getIcon',
        transform: this.getInstanceColorMode
      },
      instanceColors: {
        size: this.props.colorFormat.length,
        type: 5121,
        normalized: true,
        transition: true,
        accessor: 'getColor',
        defaultValue: DEFAULT_COLOR
      },
      instanceAngles: {
        size: 1,
        transition: true,
        accessor: 'getAngle'
      },
      instancePixelOffset: {
        size: 2,
        transition: true,
        accessor: 'getPixelOffset'
      }
    });
  }

  updateState({
    oldProps,
    props,
    changeFlags
  }) {
    super.updateState({
      props,
      oldProps,
      changeFlags
    });
    const attributeManager = this.getAttributeManager();
    const {
      iconAtlas,
      iconMapping,
      data,
      getIcon
    } = props;
    const {
      iconManager
    } = this.state;
    iconManager.setProps({
      loadOptions: props.loadOptions
    });
    let iconMappingChanged = false;
    const prePacked = iconAtlas || this.internalState.isAsyncPropLoading('iconAtlas');

    if (prePacked) {
      if (oldProps.iconAtlas !== props.iconAtlas) {
        iconManager.setProps({
          iconAtlas,
          autoPacking: false
        });
      }

      if (oldProps.iconMapping !== props.iconMapping) {
        iconManager.setProps({
          iconMapping
        });
        iconMappingChanged = true;
      }
    } else {
      iconManager.setProps({
        autoPacking: true
      });
    }

    if (changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getIcon)) {
      iconManager.setProps({
        data,
        getIcon
      });
    }

    if (iconMappingChanged) {
      attributeManager.invalidate('instanceOffsets');
      attributeManager.invalidate('instanceIconFrames');
      attributeManager.invalidate('instanceColorModes');
    }

    if (changeFlags.extensionsChanged) {
      var _this$state$model;

      const {
        gl
      } = this.context;
      (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();
      this.state.model = this._getModel(gl);
      attributeManager.invalidateAll();
    }
  }

  get isLoaded() {
    return super.isLoaded && this.state.iconManager.isLoaded;
  }

  finalizeState() {
    super.finalizeState();
    this.state.iconManager.finalize();
  }

  draw({
    uniforms
  }) {
    const {
      sizeScale,
      sizeMinPixels,
      sizeMaxPixels,
      sizeUnits,
      billboard,
      alphaCutoff
    } = this.props;
    const {
      iconManager
    } = this.state;
    const iconsTexture = iconManager.getTexture();

    if (iconsTexture) {
      this.state.model.setUniforms(uniforms).setUniforms({
        iconsTexture,
        iconsTextureDim: [iconsTexture.width, iconsTexture.height],
        sizeUnits: _core.UNIT[sizeUnits],
        sizeScale,
        sizeMinPixels,
        sizeMaxPixels,
        billboard,
        alphaCutoff
      }).draw();
    }
  }

  _getModel(gl) {
    const positions = [-1, -1, -1, 1, 1, 1, 1, -1];
    return new _core2.Model(gl, { ...this.getShaders(),
      id: this.props.id,
      geometry: new _core2.Geometry({
        drawMode: 6,
        attributes: {
          positions: {
            size: 2,
            value: new Float32Array(positions)
          }
        }
      }),
      isInstanced: true
    });
  }

  _onUpdate() {
    this.setNeedsRedraw();
  }

  _onError(evt) {
    const {
      onIconError
    } = this.getCurrentLayer().props;

    if (onIconError) {
      onIconError(evt);
    } else {
      _core.log.error(evt.error)();
    }
  }

  getInstanceOffset(icon) {
    const rect = this.state.iconManager.getIconMapping(icon);
    return [rect.width / 2 - rect.anchorX || 0, rect.height / 2 - rect.anchorY || 0];
  }

  getInstanceColorMode(icon) {
    const mapping = this.state.iconManager.getIconMapping(icon);
    return mapping.mask ? 1 : 0;
  }

  getInstanceIconFrame(icon) {
    const rect = this.state.iconManager.getIconMapping(icon);
    return [rect.x || 0, rect.y || 0, rect.width || 0, rect.height || 0];
  }

}

exports.default = IconLayer;
IconLayer.layerName = 'IconLayer';
IconLayer.defaultProps = defaultProps;
},{"@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","./icon-layer-vertex.glsl":"node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-layer-vertex.glsl.js","./icon-layer-fragment.glsl":"node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-layer-fragment.glsl.js","./icon-manager":"node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-manager.js"}],"node_modules/@deck.gl/layers/dist/esm/line-layer/line-layer-vertex.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME line-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 instanceSourcePositions;\nattribute vec3 instanceTargetPositions;\nattribute vec3 instanceSourcePositions64Low;\nattribute vec3 instanceTargetPositions64Low;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\nattribute float instanceWidths;\n\nuniform float opacity;\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform float useShortestPath;\nuniform int widthUnits;\n\nvarying vec4 vColor;\nvarying vec2 uv;\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {\n  vec2 dir_screenspace = normalize(line_clipspace * project_uViewportSize);\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n\n  return dir_screenspace * offset_direction * width / 2.0;\n}\n\nvec3 splitLine(vec3 a, vec3 b, float x) {\n  float t = (x - a.x) / (b.x - a.x);\n  return vec3(x, mix(a.yz, b.yz, t));\n}\n\nvoid main(void) {\n  geometry.worldPosition = instanceSourcePositions;\n  geometry.worldPositionAlt = instanceTargetPositions;\n\n  vec3 source_world = instanceSourcePositions;\n  vec3 target_world = instanceTargetPositions;\n  vec3 source_world_64low = instanceSourcePositions64Low;\n  vec3 target_world_64low = instanceTargetPositions64Low;\n\n  if (useShortestPath > 0.5 || useShortestPath < -0.5) {\n    source_world.x = mod(source_world.x + 180., 360.0) - 180.;\n    target_world.x = mod(target_world.x + 180., 360.0) - 180.;\n    float deltaLng = target_world.x - source_world.x;\n\n    if (deltaLng * useShortestPath > 180.) {\n      source_world.x += 360. * useShortestPath;\n      source_world = splitLine(source_world, target_world, 180. * useShortestPath);\n      source_world_64low = vec3(0.0);\n    } else if (deltaLng * useShortestPath < -180.) {\n      target_world.x += 360. * useShortestPath;\n      target_world = splitLine(source_world, target_world, 180. * useShortestPath);\n      target_world_64low = vec3(0.0);\n    } else if (useShortestPath < 0.) {\n      gl_Position = vec4(0.);\n      return;\n    }\n  }\n  vec4 source_commonspace;\n  vec4 target_commonspace;\n  vec4 source = project_position_to_clipspace(source_world, source_world_64low, vec3(0.), source_commonspace);\n  vec4 target = project_position_to_clipspace(target_world, target_world_64low, vec3(0.), target_commonspace);\n  float segmentIndex = positions.x;\n  vec4 p = mix(source, target, segmentIndex);\n  geometry.position = mix(source_commonspace, target_commonspace, segmentIndex);\n  uv = positions.xy;\n  geometry.uv = uv;\n  geometry.pickingColor = instancePickingColors;\n  float widthPixels = clamp(\n    project_size_to_pixel(instanceWidths * widthScale, widthUnits),\n    widthMinPixels, widthMaxPixels\n  );\n  vec3 offset = vec3(\n    getExtrusionOffset(target.xy - source.xy, positions.y, widthPixels),\n    0.0);\n  DECKGL_FILTER_SIZE(offset, geometry);\n  gl_Position = p + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/line-layer/line-layer-fragment.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME line-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\nvarying vec2 uv;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/line-layer/line-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _core = require("@deck.gl/core");

var _core2 = require("@luma.gl/core");

var _lineLayerVertex = _interopRequireDefault(require("./line-layer-vertex.glsl"));

var _lineLayerFragment = _interopRequireDefault(require("./line-layer-fragment.glsl"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const DEFAULT_COLOR = [0, 0, 0, 255];
const defaultProps = {
  getSourcePosition: {
    type: 'accessor',
    value: x => x.sourcePosition
  },
  getTargetPosition: {
    type: 'accessor',
    value: x => x.targetPosition
  },
  getColor: {
    type: 'accessor',
    value: DEFAULT_COLOR
  },
  getWidth: {
    type: 'accessor',
    value: 1
  },
  widthUnits: 'pixels',
  widthScale: {
    type: 'number',
    value: 1,
    min: 0
  },
  widthMinPixels: {
    type: 'number',
    value: 0,
    min: 0
  },
  widthMaxPixels: {
    type: 'number',
    value: Number.MAX_SAFE_INTEGER,
    min: 0
  }
};

class LineLayer extends _core.Layer {
  getShaders() {
    return super.getShaders({
      vs: _lineLayerVertex.default,
      fs: _lineLayerFragment.default,
      modules: [_core.project32, _core.picking]
    });
  }

  get wrapLongitude() {
    return false;
  }

  initializeState() {
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instanceSourcePositions: {
        size: 3,
        type: 5130,
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: 'getSourcePosition'
      },
      instanceTargetPositions: {
        size: 3,
        type: 5130,
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: 'getTargetPosition'
      },
      instanceColors: {
        size: this.props.colorFormat.length,
        type: 5121,
        normalized: true,
        transition: true,
        accessor: 'getColor',
        defaultValue: [0, 0, 0, 255]
      },
      instanceWidths: {
        size: 1,
        transition: true,
        accessor: 'getWidth',
        defaultValue: 1
      }
    });
  }

  updateState({
    props,
    oldProps,
    changeFlags
  }) {
    super.updateState({
      props,
      oldProps,
      changeFlags
    });

    if (changeFlags.extensionsChanged) {
      var _this$state$model;

      const {
        gl
      } = this.context;
      (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();
      this.state.model = this._getModel(gl);
      this.getAttributeManager().invalidateAll();
    }
  }

  draw({
    uniforms
  }) {
    const {
      widthUnits,
      widthScale,
      widthMinPixels,
      widthMaxPixels,
      wrapLongitude
    } = this.props;
    this.state.model.setUniforms(uniforms).setUniforms({
      widthUnits: _core.UNIT[widthUnits],
      widthScale,
      widthMinPixels,
      widthMaxPixels,
      useShortestPath: wrapLongitude ? 1 : 0
    }).draw();

    if (wrapLongitude) {
      this.state.model.setUniforms({
        useShortestPath: -1
      }).draw();
    }
  }

  _getModel(gl) {
    const positions = [0, -1, 0, 0, 1, 0, 1, -1, 0, 1, 1, 0];
    return new _core2.Model(gl, { ...this.getShaders(),
      id: this.props.id,
      geometry: new _core2.Geometry({
        drawMode: 5,
        attributes: {
          positions: new Float32Array(positions)
        }
      }),
      isInstanced: true
    });
  }

}

exports.default = LineLayer;
LineLayer.layerName = 'LineLayer';
LineLayer.defaultProps = defaultProps;
},{"@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","./line-layer-vertex.glsl":"node_modules/@deck.gl/layers/dist/esm/line-layer/line-layer-vertex.glsl.js","./line-layer-fragment.glsl":"node_modules/@deck.gl/layers/dist/esm/line-layer/line-layer-fragment.glsl.js"}],"node_modules/@deck.gl/layers/dist/esm/point-cloud-layer/point-cloud-layer-vertex.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME point-cloud-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 instanceNormals;\nattribute vec4 instanceColors;\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute vec3 instancePickingColors;\n\nuniform float opacity;\nuniform float radiusPixels;\nuniform int sizeUnits;\n\nvarying vec4 vColor;\nvarying vec2 unitPosition;\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.normal = project_normal(instanceNormals);\n  unitPosition = positions.xy;\n  geometry.uv = unitPosition;\n  geometry.pickingColor = instancePickingColors;\n  vec3 offset = vec3(positions.xy * project_size_to_pixel(radiusPixels, sizeUnits), 0.0);\n  DECKGL_FILTER_SIZE(offset, geometry);\n\n  gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.), geometry.position);\n  gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  vec3 lightColor = lighting_getLightColor(instanceColors.rgb, project_uCameraPosition, geometry.position.xyz, geometry.normal);\n  vColor = vec4(lightColor, instanceColors.a * opacity);\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/point-cloud-layer/point-cloud-layer-fragment.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME point-cloud-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\nvarying vec2 unitPosition;\n\nvoid main(void) {\n  geometry.uv = unitPosition;\n\n  float distToCenter = length(unitPosition);\n\n  if (distToCenter > 1.0) {\n    discard;\n  }\n\n  gl_FragColor = vColor;\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/point-cloud-layer/point-cloud-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _core = require("@deck.gl/core");

var _core2 = require("@luma.gl/core");

var _pointCloudLayerVertex = _interopRequireDefault(require("./point-cloud-layer-vertex.glsl"));

var _pointCloudLayerFragment = _interopRequireDefault(require("./point-cloud-layer-fragment.glsl"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const DEFAULT_COLOR = [0, 0, 0, 255];
const DEFAULT_NORMAL = [0, 0, 1];
const defaultProps = {
  sizeUnits: 'pixels',
  pointSize: {
    type: 'number',
    min: 0,
    value: 10
  },
  getPosition: {
    type: 'accessor',
    value: x => x.position
  },
  getNormal: {
    type: 'accessor',
    value: DEFAULT_NORMAL
  },
  getColor: {
    type: 'accessor',
    value: DEFAULT_COLOR
  },
  material: true,
  radiusPixels: {
    deprecatedFor: 'pointSize'
  }
};

function normalizeData(data) {
  const {
    header,
    attributes
  } = data;

  if (!header || !attributes) {
    return;
  }

  data.length = header.vertexCount;

  if (attributes.POSITION) {
    attributes.instancePositions = attributes.POSITION;
  }

  if (attributes.NORMAL) {
    attributes.instanceNormals = attributes.NORMAL;
  }

  if (attributes.COLOR_0) {
    attributes.instanceColors = attributes.COLOR_0;
  }
}

class PointCloudLayer extends _core.Layer {
  getShaders() {
    return super.getShaders({
      vs: _pointCloudLayerVertex.default,
      fs: _pointCloudLayerFragment.default,
      modules: [_core.project32, _core.gouraudLighting, _core.picking]
    });
  }

  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        size: 3,
        type: 5130,
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: 'getPosition'
      },
      instanceNormals: {
        size: 3,
        transition: true,
        accessor: 'getNormal',
        defaultValue: DEFAULT_NORMAL
      },
      instanceColors: {
        size: this.props.colorFormat.length,
        type: 5121,
        normalized: true,
        transition: true,
        accessor: 'getColor',
        defaultValue: DEFAULT_COLOR
      }
    });
  }

  updateState({
    props,
    oldProps,
    changeFlags
  }) {
    super.updateState({
      props,
      oldProps,
      changeFlags
    });

    if (changeFlags.extensionsChanged) {
      var _this$state$model;

      const {
        gl
      } = this.context;
      (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();
      this.state.model = this._getModel(gl);
      this.getAttributeManager().invalidateAll();
    }

    if (changeFlags.dataChanged) {
      normalizeData(props.data);
    }
  }

  draw({
    uniforms
  }) {
    const {
      pointSize,
      sizeUnits
    } = this.props;
    this.state.model.setUniforms(uniforms).setUniforms({
      sizeUnits: _core.UNIT[sizeUnits],
      radiusPixels: pointSize
    }).draw();
  }

  _getModel(gl) {
    const positions = [];

    for (let i = 0; i < 3; i++) {
      const angle = i / 3 * Math.PI * 2;
      positions.push(Math.cos(angle) * 2, Math.sin(angle) * 2, 0);
    }

    return new _core2.Model(gl, { ...this.getShaders(),
      id: this.props.id,
      geometry: new _core2.Geometry({
        drawMode: 4,
        attributes: {
          positions: new Float32Array(positions)
        }
      }),
      isInstanced: true
    });
  }

}

exports.default = PointCloudLayer;
PointCloudLayer.layerName = 'PointCloudLayer';
PointCloudLayer.defaultProps = defaultProps;
},{"@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","./point-cloud-layer-vertex.glsl":"node_modules/@deck.gl/layers/dist/esm/point-cloud-layer/point-cloud-layer-vertex.glsl.js","./point-cloud-layer-fragment.glsl":"node_modules/@deck.gl/layers/dist/esm/point-cloud-layer/point-cloud-layer-fragment.glsl.js"}],"node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer-vertex.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME scatterplot-layer-vertex-shader\n\nattribute vec3 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute float instanceRadius;\nattribute float instanceLineWidths;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\nuniform float opacity;\nuniform float radiusScale;\nuniform float radiusMinPixels;\nuniform float radiusMaxPixels;\nuniform float lineWidthScale;\nuniform float lineWidthMinPixels;\nuniform float lineWidthMaxPixels;\nuniform float stroked;\nuniform bool filled;\nuniform bool antialiasing;\nuniform bool billboard;\nuniform int radiusUnits;\nuniform int lineWidthUnits;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying vec2 unitPosition;\nvarying float innerUnitRadius;\nvarying float outerRadiusPixels;\n\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  outerRadiusPixels = clamp(\n    project_size_to_pixel(radiusScale * instanceRadius, radiusUnits),\n    radiusMinPixels, radiusMaxPixels\n  );\n  float lineWidthPixels = clamp(\n    project_size_to_pixel(lineWidthScale * instanceLineWidths, lineWidthUnits),\n    lineWidthMinPixels, lineWidthMaxPixels\n  );\n  outerRadiusPixels += stroked * lineWidthPixels / 2.0;\n  float edgePadding = antialiasing ? (outerRadiusPixels + SMOOTH_EDGE_RADIUS) / outerRadiusPixels : 1.0;\n  unitPosition = edgePadding * positions.xy;\n  geometry.uv = unitPosition;\n  geometry.pickingColor = instancePickingColors;\n\n  innerUnitRadius = 1.0 - stroked * lineWidthPixels / outerRadiusPixels;\n  \n  if (billboard) {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    vec3 offset = edgePadding * positions * outerRadiusPixels;\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n  } else {\n    vec3 offset = edgePadding * positions * project_pixel_size(outerRadiusPixels);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset, geometry.position);\n  }\n\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);\n  DECKGL_FILTER_COLOR(vFillColor, geometry);\n  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);\n  DECKGL_FILTER_COLOR(vLineColor, geometry);\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer-fragment.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME scatterplot-layer-fragment-shader\n\nprecision highp float;\n\nuniform bool filled;\nuniform float stroked;\nuniform bool antialiasing;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying vec2 unitPosition;\nvarying float innerUnitRadius;\nvarying float outerRadiusPixels;\n\nvoid main(void) {\n  geometry.uv = unitPosition;\n\n  float distToCenter = length(unitPosition) * outerRadiusPixels;\n  float inCircle = antialiasing ? \n    smoothedge(distToCenter, outerRadiusPixels) : \n    step(distToCenter, outerRadiusPixels);\n\n  if (inCircle == 0.0) {\n    discard;\n  }\n\n  if (stroked > 0.5) {\n    float isLine = antialiasing ? \n      smoothedge(innerUnitRadius * outerRadiusPixels, distToCenter) :\n      step(innerUnitRadius * outerRadiusPixels, distToCenter);\n\n    if (filled) {\n      gl_FragColor = mix(vFillColor, vLineColor, isLine);\n    } else {\n      if (isLine == 0.0) {\n        discard;\n      }\n      gl_FragColor = vec4(vLineColor.rgb, vLineColor.a * isLine);\n    }\n  } else if (filled) {\n    gl_FragColor = vFillColor;\n  } else {\n    discard;\n  }\n\n  gl_FragColor.a *= inCircle;\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _core = require("@deck.gl/core");

var _core2 = require("@luma.gl/core");

var _scatterplotLayerVertex = _interopRequireDefault(require("./scatterplot-layer-vertex.glsl"));

var _scatterplotLayerFragment = _interopRequireDefault(require("./scatterplot-layer-fragment.glsl"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const DEFAULT_COLOR = [0, 0, 0, 255];
const defaultProps = {
  radiusUnits: 'meters',
  radiusScale: {
    type: 'number',
    min: 0,
    value: 1
  },
  radiusMinPixels: {
    type: 'number',
    min: 0,
    value: 0
  },
  radiusMaxPixels: {
    type: 'number',
    min: 0,
    value: Number.MAX_SAFE_INTEGER
  },
  lineWidthUnits: 'meters',
  lineWidthScale: {
    type: 'number',
    min: 0,
    value: 1
  },
  lineWidthMinPixels: {
    type: 'number',
    min: 0,
    value: 0
  },
  lineWidthMaxPixels: {
    type: 'number',
    min: 0,
    value: Number.MAX_SAFE_INTEGER
  },
  stroked: false,
  filled: true,
  billboard: false,
  antialiasing: true,
  getPosition: {
    type: 'accessor',
    value: x => x.position
  },
  getRadius: {
    type: 'accessor',
    value: 1
  },
  getFillColor: {
    type: 'accessor',
    value: DEFAULT_COLOR
  },
  getLineColor: {
    type: 'accessor',
    value: DEFAULT_COLOR
  },
  getLineWidth: {
    type: 'accessor',
    value: 1
  },
  strokeWidth: {
    deprecatedFor: 'getLineWidth'
  },
  outline: {
    deprecatedFor: 'stroked'
  },
  getColor: {
    deprecatedFor: ['getFillColor', 'getLineColor']
  }
};

class ScatterplotLayer extends _core.Layer {
  getShaders() {
    return super.getShaders({
      vs: _scatterplotLayerVertex.default,
      fs: _scatterplotLayerFragment.default,
      modules: [_core.project32, _core.picking]
    });
  }

  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        size: 3,
        type: 5130,
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: 'getPosition'
      },
      instanceRadius: {
        size: 1,
        transition: true,
        accessor: 'getRadius',
        defaultValue: 1
      },
      instanceFillColors: {
        size: this.props.colorFormat.length,
        transition: true,
        normalized: true,
        type: 5121,
        accessor: 'getFillColor',
        defaultValue: [0, 0, 0, 255]
      },
      instanceLineColors: {
        size: this.props.colorFormat.length,
        transition: true,
        normalized: true,
        type: 5121,
        accessor: 'getLineColor',
        defaultValue: [0, 0, 0, 255]
      },
      instanceLineWidths: {
        size: 1,
        transition: true,
        accessor: 'getLineWidth',
        defaultValue: 1
      }
    });
  }

  updateState({
    props,
    oldProps,
    changeFlags
  }) {
    super.updateState({
      props,
      oldProps,
      changeFlags
    });

    if (changeFlags.extensionsChanged) {
      var _this$state$model;

      const {
        gl
      } = this.context;
      (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();
      this.state.model = this._getModel(gl);
      this.getAttributeManager().invalidateAll();
    }
  }

  draw({
    uniforms
  }) {
    const {
      radiusUnits,
      radiusScale,
      radiusMinPixels,
      radiusMaxPixels,
      stroked,
      filled,
      billboard,
      antialiasing,
      lineWidthUnits,
      lineWidthScale,
      lineWidthMinPixels,
      lineWidthMaxPixels
    } = this.props;
    this.state.model.setUniforms(uniforms).setUniforms({
      stroked: stroked ? 1 : 0,
      filled,
      billboard,
      antialiasing,
      radiusUnits: _core.UNIT[radiusUnits],
      radiusScale,
      radiusMinPixels,
      radiusMaxPixels,
      lineWidthUnits: _core.UNIT[lineWidthUnits],
      lineWidthScale,
      lineWidthMinPixels,
      lineWidthMaxPixels
    }).draw();
  }

  _getModel(gl) {
    const positions = [-1, -1, 0, 1, -1, 0, 1, 1, 0, -1, 1, 0];
    return new _core2.Model(gl, { ...this.getShaders(),
      id: this.props.id,
      geometry: new _core2.Geometry({
        drawMode: 6,
        vertexCount: 4,
        attributes: {
          positions: {
            size: 3,
            value: new Float32Array(positions)
          }
        }
      }),
      isInstanced: true
    });
  }

}

exports.default = ScatterplotLayer;
ScatterplotLayer.layerName = 'ScatterplotLayer';
ScatterplotLayer.defaultProps = defaultProps;
},{"@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","./scatterplot-layer-vertex.glsl":"node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer-vertex.glsl.js","./scatterplot-layer-fragment.glsl":"node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer-fragment.glsl.js"}],"node_modules/@math.gl/polygon/dist/esm/polygon-utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WINDING = void 0;
exports.forEachSegmentInPolygon = forEachSegmentInPolygon;
exports.forEachSegmentInPolygonPoints = forEachSegmentInPolygonPoints;
exports.getPolygonSignedArea = getPolygonSignedArea;
exports.getPolygonSignedAreaPoints = getPolygonSignedAreaPoints;
exports.getPolygonWindingDirection = getPolygonWindingDirection;
exports.getPolygonWindingDirectionPoints = getPolygonWindingDirectionPoints;
exports.modifyPolygonWindingDirection = modifyPolygonWindingDirection;
exports.modifyPolygonWindingDirectionPoints = modifyPolygonWindingDirectionPoints;

var _core = require("@math.gl/core");

const WINDING = {
  CLOCKWISE: 1,
  COUNTER_CLOCKWISE: -1
};
exports.WINDING = WINDING;

function modifyPolygonWindingDirection(points, direction, options = {}) {
  const windingDirection = getPolygonWindingDirection(points, options);

  if (windingDirection !== direction) {
    reversePolygon(points, options);
    return true;
  }

  return false;
}

function getPolygonWindingDirection(points, options = {}) {
  return Math.sign(getPolygonSignedArea(points, options));
}

function getPolygonSignedArea(points, options = {}) {
  const {
    start = 0,
    end = points.length
  } = options;
  const dim = options.size || 2;
  let area = 0;

  for (let i = start, j = end - dim; i < end; i += dim) {
    area += (points[i] - points[j]) * (points[i + 1] + points[j + 1]);
    j = i;
  }

  return area / 2;
}

function forEachSegmentInPolygon(points, visitor, options = {}) {
  const {
    start = 0,
    end = points.length,
    size = 2,
    isClosed
  } = options;
  const numPoints = (end - start) / size;

  for (let i = 0; i < numPoints - 1; ++i) {
    visitor(points[start + i * size], points[start + i * size + 1], points[start + (i + 1) * size], points[start + (i + 1) * size + 1], i, i + 1);
  }

  const endPointIndex = start + (numPoints - 1) * size;
  const isClosedEx = isClosed || (0, _core.equals)(points[start], points[endPointIndex]) && (0, _core.equals)(points[start + 1], points[endPointIndex + 1]);

  if (!isClosedEx) {
    visitor(points[endPointIndex], points[endPointIndex + 1], points[start], points[start + 1], numPoints - 1, 0);
  }
}

function reversePolygon(points, options) {
  const {
    start = 0,
    end = points.length,
    size = 2
  } = options;
  const numPoints = (end - start) / size;
  const numSwaps = Math.floor(numPoints / 2);

  for (let i = 0; i < numSwaps; ++i) {
    const b1 = start + i * size;
    const b2 = start + (numPoints - 1 - i) * size;

    for (let j = 0; j < size; ++j) {
      const tmp = points[b1 + j];
      points[b1 + j] = points[b2 + j];
      points[b2 + j] = tmp;
    }
  }
}

function modifyPolygonWindingDirectionPoints(points, direction, options = {}) {
  const currentDirection = getPolygonWindingDirectionPoints(points, options);

  if (currentDirection !== direction) {
    points.reverse();
    return true;
  }

  return false;
}

function getPolygonWindingDirectionPoints(points, options = {}) {
  return Math.sign(getPolygonSignedAreaPoints(points, options));
}

function getPolygonSignedAreaPoints(points, options = {}) {
  const {
    start = 0,
    end = points.length
  } = options;
  let area = 0;

  for (let i = start, j = end - 1; i < end; ++i) {
    area += (points[i][0] - points[j][0]) * (points[i][1] + points[j][1]);
    j = i;
  }

  return area / 2;
}

function forEachSegmentInPolygonPoints(points, visitor, options = {}) {
  const {
    start = 0,
    end = points.length,
    isClosed
  } = options;

  for (let i = start; i < end - 1; ++i) {
    visitor(points[i], points[i + 1], i, i + 1);
  }

  const isClosedEx = isClosed || (0, _core.equals)(points[end - 1], points[0]);

  if (!isClosedEx) {
    visitor(points[end - 1], points[0], end - 1, 0);
  }
}
},{"@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js"}],"node_modules/@math.gl/polygon/dist/esm/polygon.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _core = require("@math.gl/core");

var _polygonUtils = require("./polygon-utils");

class Polygon {
  constructor(points, options = {}) {
    this.points = points;
    this.isFlatArray = !(0, _core.isArray)(points[0]);
    this.options = {
      start: options.start || 0,
      end: options.end || points.length,
      size: options.size || 2,
      isClosed: options.isClosed
    };
    Object.freeze(this);
  }

  getSignedArea() {
    if (this.isFlatArray) return (0, _polygonUtils.getPolygonSignedArea)(this.points, this.options);
    return (0, _polygonUtils.getPolygonSignedAreaPoints)(this.points, this.options);
  }

  getArea() {
    return Math.abs(this.getSignedArea());
  }

  getWindingDirection() {
    return Math.sign(this.getSignedArea());
  }

  forEachSegment(visitor) {
    if (this.isFlatArray) {
      (0, _polygonUtils.forEachSegmentInPolygon)(this.points, (x1, y1, x2, y2, i1, i2) => {
        visitor([x1, y1], [x2, y2], i1, i2);
      }, this.options);
    } else {
      (0, _polygonUtils.forEachSegmentInPolygonPoints)(this.points, visitor, this.options);
    }
  }

  modifyWindingDirection(direction) {
    if (this.isFlatArray) {
      return (0, _polygonUtils.modifyPolygonWindingDirection)(this.points, direction, this.options);
    }

    return (0, _polygonUtils.modifyPolygonWindingDirectionPoints)(this.points, direction, this.options);
  }

}

exports.default = Polygon;
},{"@math.gl/core":"node_modules/@math.gl/core/dist/esm/index.js","./polygon-utils":"node_modules/@math.gl/polygon/dist/esm/polygon-utils.js"}],"node_modules/@math.gl/polygon/dist/esm/earcut.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.earcut = earcut;

var _polygonUtils = require("./polygon-utils");

function earcut(data, holeIndices, dim, areas) {
  dim = dim || 2;
  const hasHoles = holeIndices && holeIndices.length;
  const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
  let outerNode = linkedList(data, 0, outerLen, dim, true, areas && areas[0]);
  const triangles = [];
  if (!outerNode || outerNode.next === outerNode.prev) return triangles;
  let invSize;
  let maxX;
  let maxY;
  let minX;
  let minY;
  let x;
  let y;
  if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim, areas);

  if (data.length > 80 * dim) {
    minX = maxX = data[0];
    minY = maxY = data[1];

    for (let i = dim; i < outerLen; i += dim) {
      x = data[i];
      y = data[i + 1];
      if (x < minX) minX = x;
      if (y < minY) minY = y;
      if (x > maxX) maxX = x;
      if (y > maxY) maxY = y;
    }

    invSize = Math.max(maxX - minX, maxY - minY);
    invSize = invSize !== 0 ? 1 / invSize : 0;
  }

  earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
  return triangles;
}

function linkedList(data, start, end, dim, clockwise, area) {
  let i;
  let last;

  if (area === undefined) {
    area = (0, _polygonUtils.getPolygonSignedArea)(data, {
      start,
      end,
      size: dim
    });
  }

  if (clockwise === area < 0) {
    for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
  } else {
    for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
  }

  if (last && equals(last, last.next)) {
    removeNode(last);
    last = last.next;
  }

  return last;
}

function filterPoints(start, end) {
  if (!start) return start;
  if (!end) end = start;
  let p = start;
  let again;

  do {
    again = false;

    if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
      removeNode(p);
      p = end = p.prev;
      if (p === p.next) break;
      again = true;
    } else {
      p = p.next;
    }
  } while (again || p !== end);

  return end;
}

function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
  if (!ear) return;
  if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
  let stop = ear;
  let prev;
  let next;

  while (ear.prev !== ear.next) {
    prev = ear.prev;
    next = ear.next;

    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      triangles.push(prev.i / dim);
      triangles.push(ear.i / dim);
      triangles.push(next.i / dim);
      removeNode(ear);
      ear = next.next;
      stop = next.next;
      continue;
    }

    ear = next;

    if (ear === stop) {
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
      } else if (pass === 1) {
        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }

      break;
    }
  }
}

function isEar(ear) {
  const a = ear.prev;
  const b = ear;
  const c = ear.next;
  if (area(a, b, c) >= 0) return false;
  let p = ear.next.next;

  while (p !== ear.prev) {
    if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.next;
  }

  return true;
}

function isEarHashed(ear, minX, minY, invSize) {
  const a = ear.prev;
  const b = ear;
  const c = ear.next;
  if (area(a, b, c) >= 0) return false;
  const minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x;
  const minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y;
  const maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x;
  const maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;
  const minZ = zOrder(minTX, minTY, minX, minY, invSize);
  const maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
  let p = ear.prevZ;
  let n = ear.nextZ;

  while (p && p.z >= minZ && n && n.z <= maxZ) {
    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.prevZ;
    if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
    n = n.nextZ;
  }

  while (p && p.z >= minZ) {
    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.prevZ;
  }

  while (n && n.z <= maxZ) {
    if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
    n = n.nextZ;
  }

  return true;
}

function cureLocalIntersections(start, triangles, dim) {
  let p = start;

  do {
    const a = p.prev;
    const b = p.next.next;

    if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
      triangles.push(a.i / dim);
      triangles.push(p.i / dim);
      triangles.push(b.i / dim);
      removeNode(p);
      removeNode(p.next);
      p = start = b;
    }

    p = p.next;
  } while (p !== start);

  return filterPoints(p);
}

function splitEarcut(start, triangles, dim, minX, minY, invSize) {
  let a = start;

  do {
    let b = a.next.next;

    while (b !== a.prev) {
      if (a.i !== b.i && isValidDiagonal(a, b)) {
        let c = splitPolygon(a, b);
        a = filterPoints(a, a.next);
        c = filterPoints(c, c.next);
        earcutLinked(a, triangles, dim, minX, minY, invSize);
        earcutLinked(c, triangles, dim, minX, minY, invSize);
        return;
      }

      b = b.next;
    }

    a = a.next;
  } while (a !== start);
}

function eliminateHoles(data, holeIndices, outerNode, dim, areas) {
  const queue = [];
  let i;
  let len;
  let start;
  let end;
  let list;

  for (i = 0, len = holeIndices.length; i < len; i++) {
    start = holeIndices[i] * dim;
    end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
    list = linkedList(data, start, end, dim, false, areas && areas[i + 1]);
    if (list === list.next) list.steiner = true;
    queue.push(getLeftmost(list));
  }

  queue.sort(compareX);

  for (i = 0; i < queue.length; i++) {
    eliminateHole(queue[i], outerNode);
    outerNode = filterPoints(outerNode, outerNode.next);
  }

  return outerNode;
}

function compareX(a, b) {
  return a.x - b.x;
}

function eliminateHole(hole, outerNode) {
  outerNode = findHoleBridge(hole, outerNode);

  if (outerNode) {
    const b = splitPolygon(outerNode, hole);
    filterPoints(outerNode, outerNode.next);
    filterPoints(b, b.next);
  }
}

function findHoleBridge(hole, outerNode) {
  let p = outerNode;
  const hx = hole.x;
  const hy = hole.y;
  let qx = -Infinity;
  let m;

  do {
    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
      const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);

      if (x <= hx && x > qx) {
        qx = x;

        if (x === hx) {
          if (hy === p.y) return p;
          if (hy === p.next.y) return p.next;
        }

        m = p.x < p.next.x ? p : p.next;
      }
    }

    p = p.next;
  } while (p !== outerNode);

  if (!m) return null;
  if (hx === qx) return m;
  const stop = m;
  const mx = m.x;
  const my = m.y;
  let tanMin = Infinity;
  let tan;
  p = m;

  do {
    if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
      tan = Math.abs(hy - p.y) / (hx - p.x);

      if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
        m = p;
        tanMin = tan;
      }
    }

    p = p.next;
  } while (p !== stop);

  return m;
}

function sectorContainsSector(m, p) {
  return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}

function indexCurve(start, minX, minY, invSize) {
  let p = start;

  do {
    if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
    p.prevZ = p.prev;
    p.nextZ = p.next;
    p = p.next;
  } while (p !== start);

  p.prevZ.nextZ = null;
  p.prevZ = null;
  sortLinked(p);
}

function sortLinked(list) {
  let e;
  let i;
  let inSize = 1;
  let numMerges;
  let p;
  let pSize;
  let q;
  let qSize;
  let tail;

  do {
    p = list;
    list = null;
    tail = null;
    numMerges = 0;

    while (p) {
      numMerges++;
      q = p;
      pSize = 0;

      for (i = 0; i < inSize; i++) {
        pSize++;
        q = q.nextZ;
        if (!q) break;
      }

      qSize = inSize;

      while (pSize > 0 || qSize > 0 && q) {
        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
          e = p;
          p = p.nextZ;
          pSize--;
        } else {
          e = q;
          q = q.nextZ;
          qSize--;
        }

        if (tail) tail.nextZ = e;else list = e;
        e.prevZ = tail;
        tail = e;
      }

      p = q;
    }

    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);

  return list;
}

function zOrder(x, y, minX, minY, invSize) {
  x = 32767 * (x - minX) * invSize;
  y = 32767 * (y - minY) * invSize;
  x = (x | x << 8) & 0x00ff00ff;
  x = (x | x << 4) & 0x0f0f0f0f;
  x = (x | x << 2) & 0x33333333;
  x = (x | x << 1) & 0x55555555;
  y = (y | y << 8) & 0x00ff00ff;
  y = (y | y << 4) & 0x0f0f0f0f;
  y = (y | y << 2) & 0x33333333;
  y = (y | y << 1) & 0x55555555;
  return x | y << 1;
}

function getLeftmost(start) {
  let p = start;
  let leftmost = start;

  do {
    if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;
    p = p.next;
  } while (p !== start);

  return leftmost;
}

function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
  return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
}

function isValidDiagonal(a, b) {
  return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && (area(a.prev, a, b.prev) || area(a, b.prev, b)) || equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0);
}

function area(p, q, r) {
  return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

function equals(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
}

function intersects(p1, q1, p2, q2) {
  const o1 = sign(area(p1, q1, p2));
  const o2 = sign(area(p1, q1, q2));
  const o3 = sign(area(p2, q2, p1));
  const o4 = sign(area(p2, q2, q1));
  if (o1 !== o2 && o3 !== o4) return true;
  if (o1 === 0 && onSegment(p1, p2, q1)) return true;
  if (o2 === 0 && onSegment(p1, q2, q1)) return true;
  if (o3 === 0 && onSegment(p2, p1, q2)) return true;
  if (o4 === 0 && onSegment(p2, q1, q2)) return true;
  return false;
}

function onSegment(p, q, r) {
  return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}

function sign(num) {
  return num > 0 ? 1 : num < 0 ? -1 : 0;
}

function intersectsPolygon(a, b) {
  let p = a;

  do {
    if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
    p = p.next;
  } while (p !== a);

  return false;
}

function locallyInside(a, b) {
  return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

function middleInside(a, b) {
  let p = a;
  let inside = false;
  const px = (a.x + b.x) / 2;
  const py = (a.y + b.y) / 2;

  do {
    if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;
    p = p.next;
  } while (p !== a);

  return inside;
}

function splitPolygon(a, b) {
  const a2 = new Node(a.i, a.x, a.y);
  const b2 = new Node(b.i, b.x, b.y);
  const an = a.next;
  const bp = b.prev;
  a.next = b;
  b.prev = a;
  a2.next = an;
  an.prev = a2;
  b2.next = a2;
  a2.prev = b2;
  bp.next = b2;
  b2.prev = bp;
  return b2;
}

function insertNode(i, x, y, last) {
  const p = new Node(i, x, y);

  if (!last) {
    p.prev = p;
    p.next = p;
  } else {
    p.next = last.next;
    p.prev = last;
    last.next.prev = p;
    last.next = p;
  }

  return p;
}

function removeNode(p) {
  p.next.prev = p.prev;
  p.prev.next = p.next;
  if (p.prevZ) p.prevZ.nextZ = p.nextZ;
  if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node(i, x, y) {
  this.i = i;
  this.x = x;
  this.y = y;
  this.prev = null;
  this.next = null;
  this.z = null;
  this.prevZ = null;
  this.nextZ = null;
  this.steiner = false;
}
},{"./polygon-utils":"node_modules/@math.gl/polygon/dist/esm/polygon-utils.js"}],"node_modules/@math.gl/polygon/dist/esm/utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.copy = copy;
exports.getPointAtIndex = getPointAtIndex;
exports.push = push;

function push(target, source) {
  const size = source.length;
  const startIndex = target.length;

  if (startIndex > 0) {
    let isDuplicate = true;

    for (let i = 0; i < size; i++) {
      if (target[startIndex - size + i] !== source[i]) {
        isDuplicate = false;
        break;
      }
    }

    if (isDuplicate) {
      return false;
    }
  }

  for (let i = 0; i < size; i++) {
    target[startIndex + i] = source[i];
  }

  return true;
}

function copy(target, source) {
  const size = source.length;

  for (let i = 0; i < size; i++) {
    target[i] = source[i];
  }
}

function getPointAtIndex(positions, index, size, offset, out = []) {
  const startI = offset + index * size;

  for (let i = 0; i < size; i++) {
    out[i] = positions[startI + i];
  }

  return out;
}
},{}],"node_modules/@math.gl/polygon/dist/esm/lineclip.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.bitCode = bitCode;
exports.clipPolygon = clipPolygon;
exports.clipPolyline = clipPolyline;
exports.intersect = intersect;

var _utils = require("./utils");

function clipPolyline(positions, bbox, options = {}) {
  const {
    size = 2,
    startIndex = 0,
    endIndex = positions.length
  } = options;
  const numPoints = (endIndex - startIndex) / size;
  const result = [];
  let part = [];
  let a;
  let b;
  let codeA = -1;
  let codeB;
  let lastCode;

  for (let i = 1; i < numPoints; i++) {
    a = (0, _utils.getPointAtIndex)(positions, i - 1, size, startIndex, a);
    b = (0, _utils.getPointAtIndex)(positions, i, size, startIndex, b);

    if (codeA < 0) {
      codeA = bitCode(a, bbox);
    }

    codeB = lastCode = bitCode(b, bbox);

    while (true) {
      if (!(codeA | codeB)) {
        (0, _utils.push)(part, a);

        if (codeB !== lastCode) {
          (0, _utils.push)(part, b);

          if (i < numPoints - 1) {
            result.push(part);
            part = [];
          }
        } else if (i === numPoints - 1) {
          (0, _utils.push)(part, b);
        }

        break;
      } else if (codeA & codeB) {
        break;
      } else if (codeA) {
        intersect(a, b, codeA, bbox, a);
        codeA = bitCode(a, bbox);
      } else {
        intersect(a, b, codeB, bbox, b);
        codeB = bitCode(b, bbox);
      }
    }

    codeA = lastCode;
  }

  if (part.length) result.push(part);
  return result;
}

function clipPolygon(positions, bbox, options = {}) {
  const {
    size = 2,
    endIndex = positions.length
  } = options;
  let {
    startIndex = 0
  } = options;
  let numPoints = (endIndex - startIndex) / size;
  let result;
  let p;
  let prev;
  let inside;
  let prevInside;

  for (let edge = 1; edge <= 8; edge *= 2) {
    result = [];
    prev = (0, _utils.getPointAtIndex)(positions, numPoints - 1, size, startIndex, prev);
    prevInside = !(bitCode(prev, bbox) & edge);

    for (let i = 0; i < numPoints; i++) {
      p = (0, _utils.getPointAtIndex)(positions, i, size, startIndex, p);
      inside = !(bitCode(p, bbox) & edge);
      if (inside !== prevInside) (0, _utils.push)(result, intersect(prev, p, edge, bbox));
      if (inside) (0, _utils.push)(result, p);
      (0, _utils.copy)(prev, p);
      prevInside = inside;
    }

    positions = result;
    startIndex = 0;
    numPoints = result.length / size;
    if (!numPoints) break;
  }

  return result;
}

function intersect(a, b, edge, bbox, out = []) {
  let t;
  let snap;

  if (edge & 8) {
    t = (bbox[3] - a[1]) / (b[1] - a[1]);
    snap = 3;
  } else if (edge & 4) {
    t = (bbox[1] - a[1]) / (b[1] - a[1]);
    snap = 1;
  } else if (edge & 2) {
    t = (bbox[2] - a[0]) / (b[0] - a[0]);
    snap = 2;
  } else if (edge & 1) {
    t = (bbox[0] - a[0]) / (b[0] - a[0]);
    snap = 0;
  } else {
    return null;
  }

  for (let i = 0; i < a.length; i++) {
    out[i] = (snap & 1) === i ? bbox[snap] : t * (b[i] - a[i]) + a[i];
  }

  return out;
}

function bitCode(p, bbox) {
  let code = 0;
  if (p[0] < bbox[0]) code |= 1;else if (p[0] > bbox[2]) code |= 2;
  if (p[1] < bbox[1]) code |= 4;else if (p[1] > bbox[3]) code |= 8;
  return code;
}
},{"./utils":"node_modules/@math.gl/polygon/dist/esm/utils.js"}],"node_modules/@math.gl/polygon/dist/esm/cut-by-grid.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cutPolygonByGrid = cutPolygonByGrid;
exports.cutPolylineByGrid = cutPolylineByGrid;

var _lineclip = require("./lineclip");

var _utils = require("./utils");

function cutPolylineByGrid(positions, options = {}) {
  const {
    size = 2,
    broken = false,
    gridResolution = 10,
    gridOffset = [0, 0],
    startIndex = 0,
    endIndex = positions.length
  } = options;
  const numPoints = (endIndex - startIndex) / size;
  let part = [];
  const result = [part];
  const a = (0, _utils.getPointAtIndex)(positions, 0, size, startIndex);
  let b;
  let codeB;
  const cell = getGridCell(a, gridResolution, gridOffset, []);
  const scratchPoint = [];
  (0, _utils.push)(part, a);

  for (let i = 1; i < numPoints; i++) {
    b = (0, _utils.getPointAtIndex)(positions, i, size, startIndex, b);
    codeB = (0, _lineclip.bitCode)(b, cell);

    while (codeB) {
      (0, _lineclip.intersect)(a, b, codeB, cell, scratchPoint);
      const codeAlt = (0, _lineclip.bitCode)(scratchPoint, cell);

      if (codeAlt) {
        (0, _lineclip.intersect)(a, scratchPoint, codeAlt, cell, scratchPoint);
        codeB = codeAlt;
      }

      (0, _utils.push)(part, scratchPoint);
      (0, _utils.copy)(a, scratchPoint);
      moveToNeighborCell(cell, gridResolution, codeB);

      if (broken && part.length > size) {
        part = [];
        result.push(part);
        (0, _utils.push)(part, a);
      }

      codeB = (0, _lineclip.bitCode)(b, cell);
    }

    (0, _utils.push)(part, b);
    (0, _utils.copy)(a, b);
  }

  return broken ? result : result[0];
}

const TYPE_INSIDE = 0;
const TYPE_BORDER = 1;

function concatInPlace(arr1, arr2) {
  for (let i = 0; i < arr2.length; i++) {
    arr1.push(arr2[i]);
  }

  return arr1;
}

function cutPolygonByGrid(positions, holeIndices, options = {}) {
  if (!positions.length) {
    return [];
  }

  const {
    size = 2,
    gridResolution = 10,
    gridOffset = [0, 0],
    edgeTypes = false
  } = options;
  const result = [];
  const queue = [{
    pos: positions,
    types: edgeTypes && new Array(positions.length / size).fill(TYPE_BORDER),
    holes: holeIndices || []
  }];
  const bbox = [[], []];
  let cell = [];

  while (queue.length) {
    const {
      pos,
      types,
      holes
    } = queue.shift();
    getBoundingBox(pos, size, holes[0] || pos.length, bbox);
    cell = getGridCell(bbox[0], gridResolution, gridOffset, cell);
    const code = (0, _lineclip.bitCode)(bbox[1], cell);

    if (code) {
      let parts = bisectPolygon(pos, types, size, 0, holes[0] || pos.length, cell, code);
      const polygonLow = {
        pos: parts[0].pos,
        types: parts[0].types,
        holes: []
      };
      const polygonHigh = {
        pos: parts[1].pos,
        types: parts[1].types,
        holes: []
      };
      queue.push(polygonLow, polygonHigh);

      for (let i = 0; i < holes.length; i++) {
        parts = bisectPolygon(pos, types, size, holes[i], holes[i + 1] || pos.length, cell, code);

        if (parts[0]) {
          polygonLow.holes.push(polygonLow.pos.length);
          polygonLow.pos = concatInPlace(polygonLow.pos, parts[0].pos);

          if (edgeTypes) {
            polygonLow.types = concatInPlace(polygonLow.types, parts[0].types);
          }
        }

        if (parts[1]) {
          polygonHigh.holes.push(polygonHigh.pos.length);
          polygonHigh.pos = concatInPlace(polygonHigh.pos, parts[1].pos);

          if (edgeTypes) {
            polygonHigh.types = concatInPlace(polygonHigh.types, parts[1].types);
          }
        }
      }
    } else {
      const polygon = {
        positions: pos
      };

      if (edgeTypes) {
        polygon.edgeTypes = types;
      }

      if (holes.length) {
        polygon.holeIndices = holes;
      }

      result.push(polygon);
    }
  }

  return result;
}

function bisectPolygon(positions, edgeTypes, size, startIndex, endIndex, bbox, edge) {
  const numPoints = (endIndex - startIndex) / size;
  const resultLow = [];
  const resultHigh = [];
  const typesLow = [];
  const typesHigh = [];
  const scratchPoint = [];
  let p;
  let side;
  let type;
  const prev = (0, _utils.getPointAtIndex)(positions, numPoints - 1, size, startIndex);
  let prevSide = Math.sign(edge & 8 ? prev[1] - bbox[3] : prev[0] - bbox[2]);
  let prevType = edgeTypes && edgeTypes[numPoints - 1];
  let lowPointCount = 0;
  let highPointCount = 0;

  for (let i = 0; i < numPoints; i++) {
    p = (0, _utils.getPointAtIndex)(positions, i, size, startIndex, p);
    side = Math.sign(edge & 8 ? p[1] - bbox[3] : p[0] - bbox[2]);
    type = edgeTypes && edgeTypes[startIndex / size + i];

    if (side && prevSide && prevSide !== side) {
      (0, _lineclip.intersect)(prev, p, edge, bbox, scratchPoint);
      (0, _utils.push)(resultLow, scratchPoint) && typesLow.push(prevType);
      (0, _utils.push)(resultHigh, scratchPoint) && typesHigh.push(prevType);
    }

    if (side <= 0) {
      (0, _utils.push)(resultLow, p) && typesLow.push(type);
      lowPointCount -= side;
    } else if (typesLow.length) {
      typesLow[typesLow.length - 1] = TYPE_INSIDE;
    }

    if (side >= 0) {
      (0, _utils.push)(resultHigh, p) && typesHigh.push(type);
      highPointCount += side;
    } else if (typesHigh.length) {
      typesHigh[typesHigh.length - 1] = TYPE_INSIDE;
    }

    (0, _utils.copy)(prev, p);
    prevSide = side;
    prevType = type;
  }

  return [lowPointCount ? {
    pos: resultLow,
    types: edgeTypes && typesLow
  } : null, highPointCount ? {
    pos: resultHigh,
    types: edgeTypes && typesHigh
  } : null];
}

function getGridCell(p, gridResolution, gridOffset, out) {
  const left = Math.floor((p[0] - gridOffset[0]) / gridResolution) * gridResolution + gridOffset[0];
  const bottom = Math.floor((p[1] - gridOffset[1]) / gridResolution) * gridResolution + gridOffset[1];
  out[0] = left;
  out[1] = bottom;
  out[2] = left + gridResolution;
  out[3] = bottom + gridResolution;
  return out;
}

function moveToNeighborCell(cell, gridResolution, edge) {
  if (edge & 8) {
    cell[1] += gridResolution;
    cell[3] += gridResolution;
  } else if (edge & 4) {
    cell[1] -= gridResolution;
    cell[3] -= gridResolution;
  } else if (edge & 2) {
    cell[0] += gridResolution;
    cell[2] += gridResolution;
  } else if (edge & 1) {
    cell[0] -= gridResolution;
    cell[2] -= gridResolution;
  }
}

function getBoundingBox(positions, size, endIndex, out) {
  let minX = Infinity;
  let maxX = -Infinity;
  let minY = Infinity;
  let maxY = -Infinity;

  for (let i = 0; i < endIndex; i += size) {
    const x = positions[i];
    const y = positions[i + 1];
    minX = x < minX ? x : minX;
    maxX = x > maxX ? x : maxX;
    minY = y < minY ? y : minY;
    maxY = y > maxY ? y : maxY;
  }

  out[0][0] = minX;
  out[0][1] = minY;
  out[1][0] = maxX;
  out[1][1] = maxY;
  return out;
}
},{"./lineclip":"node_modules/@math.gl/polygon/dist/esm/lineclip.js","./utils":"node_modules/@math.gl/polygon/dist/esm/utils.js"}],"node_modules/@math.gl/polygon/dist/esm/cut-by-mercator-bounds.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cutPolygonByMercatorBounds = cutPolygonByMercatorBounds;
exports.cutPolylineByMercatorBounds = cutPolylineByMercatorBounds;

var _cutByGrid = require("./cut-by-grid");

var _utils = require("./utils");

const DEFAULT_MAX_LATITUDE = 85.051129;

function cutPolylineByMercatorBounds(positions, options = {}) {
  const {
    size = 2,
    startIndex = 0,
    endIndex = positions.length,
    normalize = true
  } = options;
  const newPositions = positions.slice(startIndex, endIndex);
  wrapLongitudesForShortestPath(newPositions, size, 0, endIndex - startIndex);
  const parts = (0, _cutByGrid.cutPolylineByGrid)(newPositions, {
    size,
    broken: true,
    gridResolution: 360,
    gridOffset: [-180, -180]
  });

  if (normalize) {
    for (const part of parts) {
      shiftLongitudesIntoRange(part, size);
    }
  }

  return parts;
}

function cutPolygonByMercatorBounds(positions, holeIndices, options = {}) {
  const {
    size = 2,
    normalize = true,
    edgeTypes = false
  } = options;
  holeIndices = holeIndices || [];
  const newPositions = [];
  const newHoleIndices = [];
  let srcStartIndex = 0;
  let targetIndex = 0;

  for (let ringIndex = 0; ringIndex <= holeIndices.length; ringIndex++) {
    const srcEndIndex = holeIndices[ringIndex] || positions.length;
    const targetStartIndex = targetIndex;
    const splitIndex = findSplitIndex(positions, size, srcStartIndex, srcEndIndex);

    for (let i = splitIndex; i < srcEndIndex; i++) {
      newPositions[targetIndex++] = positions[i];
    }

    for (let i = srcStartIndex; i < splitIndex; i++) {
      newPositions[targetIndex++] = positions[i];
    }

    wrapLongitudesForShortestPath(newPositions, size, targetStartIndex, targetIndex);
    insertPoleVertices(newPositions, size, targetStartIndex, targetIndex, options.maxLatitude);
    srcStartIndex = srcEndIndex;
    newHoleIndices[ringIndex] = targetIndex;
  }

  newHoleIndices.pop();
  const parts = (0, _cutByGrid.cutPolygonByGrid)(newPositions, newHoleIndices, {
    size,
    gridResolution: 360,
    gridOffset: [-180, -180],
    edgeTypes
  });

  if (normalize) {
    for (const part of parts) {
      shiftLongitudesIntoRange(part.positions, size);
    }
  }

  return parts;
}

function findSplitIndex(positions, size, startIndex, endIndex) {
  let maxLat = -1;
  let pointIndex = -1;

  for (let i = startIndex + 1; i < endIndex; i += size) {
    const lat = Math.abs(positions[i]);

    if (lat > maxLat) {
      maxLat = lat;
      pointIndex = i - 1;
    }
  }

  return pointIndex;
}

function insertPoleVertices(positions, size, startIndex, endIndex, maxLatitude = DEFAULT_MAX_LATITUDE) {
  const firstLng = positions[startIndex];
  const lastLng = positions[endIndex - size];

  if (Math.abs(firstLng - lastLng) > 180) {
    const p = (0, _utils.getPointAtIndex)(positions, 0, size, startIndex);
    p[0] += Math.round((lastLng - firstLng) / 360) * 360;
    (0, _utils.push)(positions, p);
    p[1] = Math.sign(p[1]) * maxLatitude;
    (0, _utils.push)(positions, p);
    p[0] = firstLng;
    (0, _utils.push)(positions, p);
  }
}

function wrapLongitudesForShortestPath(positions, size, startIndex, endIndex) {
  let prevLng = positions[0];
  let lng;

  for (let i = startIndex; i < endIndex; i += size) {
    lng = positions[i];
    const delta = lng - prevLng;

    if (delta > 180 || delta < -180) {
      lng -= Math.round(delta / 360) * 360;
    }

    positions[i] = prevLng = lng;
  }
}

function shiftLongitudesIntoRange(positions, size) {
  let refLng;
  const pointCount = positions.length / size;

  for (let i = 0; i < pointCount; i++) {
    refLng = positions[i * size];

    if ((refLng + 180) % 360 !== 0) {
      break;
    }
  }

  const delta = -Math.round(refLng / 360) * 360;

  if (delta === 0) {
    return;
  }

  for (let i = 0; i < pointCount; i++) {
    positions[i * size] += delta;
  }
}
},{"./cut-by-grid":"node_modules/@math.gl/polygon/dist/esm/cut-by-grid.js","./utils":"node_modules/@math.gl/polygon/dist/esm/utils.js"}],"node_modules/@math.gl/polygon/dist/esm/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Polygon", {
  enumerable: true,
  get: function () {
    return _polygon.default;
  }
});
Object.defineProperty(exports, "WINDING", {
  enumerable: true,
  get: function () {
    return _polygonUtils.WINDING;
  }
});
Object.defineProperty(exports, "_Polygon", {
  enumerable: true,
  get: function () {
    return _polygon.default;
  }
});
Object.defineProperty(exports, "clipPolygon", {
  enumerable: true,
  get: function () {
    return _lineclip.clipPolygon;
  }
});
Object.defineProperty(exports, "clipPolyline", {
  enumerable: true,
  get: function () {
    return _lineclip.clipPolyline;
  }
});
Object.defineProperty(exports, "cutPolygonByGrid", {
  enumerable: true,
  get: function () {
    return _cutByGrid.cutPolygonByGrid;
  }
});
Object.defineProperty(exports, "cutPolygonByMercatorBounds", {
  enumerable: true,
  get: function () {
    return _cutByMercatorBounds.cutPolygonByMercatorBounds;
  }
});
Object.defineProperty(exports, "cutPolylineByGrid", {
  enumerable: true,
  get: function () {
    return _cutByGrid.cutPolylineByGrid;
  }
});
Object.defineProperty(exports, "cutPolylineByMercatorBounds", {
  enumerable: true,
  get: function () {
    return _cutByMercatorBounds.cutPolylineByMercatorBounds;
  }
});
Object.defineProperty(exports, "earcut", {
  enumerable: true,
  get: function () {
    return _earcut.earcut;
  }
});
Object.defineProperty(exports, "forEachSegmentInPolygon", {
  enumerable: true,
  get: function () {
    return _polygonUtils.forEachSegmentInPolygon;
  }
});
Object.defineProperty(exports, "getPolygonSignedArea", {
  enumerable: true,
  get: function () {
    return _polygonUtils.getPolygonSignedArea;
  }
});
Object.defineProperty(exports, "getPolygonWindingDirection", {
  enumerable: true,
  get: function () {
    return _polygonUtils.getPolygonWindingDirection;
  }
});
Object.defineProperty(exports, "modifyPolygonWindingDirection", {
  enumerable: true,
  get: function () {
    return _polygonUtils.modifyPolygonWindingDirection;
  }
});

var _polygon = _interopRequireDefault(require("./polygon"));

var _polygonUtils = require("./polygon-utils");

var _earcut = require("./earcut");

var _lineclip = require("./lineclip");

var _cutByGrid = require("./cut-by-grid");

var _cutByMercatorBounds = require("./cut-by-mercator-bounds");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./polygon":"node_modules/@math.gl/polygon/dist/esm/polygon.js","./polygon-utils":"node_modules/@math.gl/polygon/dist/esm/polygon-utils.js","./earcut":"node_modules/@math.gl/polygon/dist/esm/earcut.js","./lineclip":"node_modules/@math.gl/polygon/dist/esm/lineclip.js","./cut-by-grid":"node_modules/@math.gl/polygon/dist/esm/cut-by-grid.js","./cut-by-mercator-bounds":"node_modules/@math.gl/polygon/dist/esm/cut-by-mercator-bounds.js"}],"node_modules/@deck.gl/layers/dist/esm/column-layer/column-geometry.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _core = require("@deck.gl/core");

var _core2 = require("@luma.gl/core");

var _polygon = require("@math.gl/polygon");

class ColumnGeometry extends _core2.Geometry {
  constructor(props = {}) {
    const {
      id = (0, _core2.uid)('column-geometry')
    } = props;
    const {
      indices,
      attributes
    } = tesselateColumn(props);
    super({ ...props,
      id,
      indices,
      attributes
    });
  }

}

exports.default = ColumnGeometry;

function tesselateColumn(props) {
  const {
    radius,
    height = 1,
    nradial = 10
  } = props;
  let {
    vertices
  } = props;

  if (vertices) {
    _core.log.assert(vertices.length >= nradial);

    vertices = vertices.flatMap(v => [v[0], v[1]]);
    (0, _polygon.modifyPolygonWindingDirection)(vertices, _polygon.WINDING.COUNTER_CLOCKWISE);
  }

  const isExtruded = height > 0;
  const vertsAroundEdge = nradial + 1;
  const numVertices = isExtruded ? vertsAroundEdge * 3 + 1 : nradial;
  const stepAngle = Math.PI * 2 / nradial;
  const indices = new Uint16Array(isExtruded ? nradial * 3 * 2 : 0);
  const positions = new Float32Array(numVertices * 3);
  const normals = new Float32Array(numVertices * 3);
  let i = 0;

  if (isExtruded) {
    for (let j = 0; j < vertsAroundEdge; j++) {
      const a = j * stepAngle;
      const vertexIndex = j % nradial;
      const sin = Math.sin(a);
      const cos = Math.cos(a);

      for (let k = 0; k < 2; k++) {
        positions[i + 0] = vertices ? vertices[vertexIndex * 2] : cos * radius;
        positions[i + 1] = vertices ? vertices[vertexIndex * 2 + 1] : sin * radius;
        positions[i + 2] = (1 / 2 - k) * height;
        normals[i + 0] = vertices ? vertices[vertexIndex * 2] : cos;
        normals[i + 1] = vertices ? vertices[vertexIndex * 2 + 1] : sin;
        i += 3;
      }
    }

    positions[i + 0] = positions[i - 3];
    positions[i + 1] = positions[i - 2];
    positions[i + 2] = positions[i - 1];
    i += 3;
  }

  for (let j = isExtruded ? 0 : 1; j < vertsAroundEdge; j++) {
    const v = Math.floor(j / 2) * Math.sign(0.5 - j % 2);
    const a = v * stepAngle;
    const vertexIndex = (v + nradial) % nradial;
    const sin = Math.sin(a);
    const cos = Math.cos(a);
    positions[i + 0] = vertices ? vertices[vertexIndex * 2] : cos * radius;
    positions[i + 1] = vertices ? vertices[vertexIndex * 2 + 1] : sin * radius;
    positions[i + 2] = height / 2;
    normals[i + 2] = 1;
    i += 3;
  }

  if (isExtruded) {
    let index = 0;

    for (let j = 0; j < nradial; j++) {
      indices[index++] = j * 2 + 0;
      indices[index++] = j * 2 + 2;
      indices[index++] = j * 2 + 0;
      indices[index++] = j * 2 + 1;
      indices[index++] = j * 2 + 1;
      indices[index++] = j * 2 + 3;
    }
  }

  return {
    indices,
    attributes: {
      POSITION: {
        size: 3,
        value: positions
      },
      NORMAL: {
        size: 3,
        value: normals
      }
    }
  };
}
},{"@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","@math.gl/polygon":"node_modules/@math.gl/polygon/dist/esm/index.js"}],"node_modules/@deck.gl/layers/dist/esm/column-layer/column-layer-vertex.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#version 300 es\n\n#define SHADER_NAME column-layer-vertex-shader\n\nin vec3 positions;\nin vec3 normals;\n\nin vec3 instancePositions;\nin float instanceElevations;\nin vec3 instancePositions64Low;\nin vec4 instanceFillColors;\nin vec4 instanceLineColors;\nin float instanceStrokeWidths;\n\nin vec3 instancePickingColors;\nuniform float opacity;\nuniform float radius;\nuniform float angle;\nuniform vec2 offset;\nuniform bool extruded;\nuniform bool isStroke;\nuniform float coverage;\nuniform float elevationScale;\nuniform float edgeDistance;\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform int radiusUnits;\nuniform int widthUnits;\nout vec4 vColor;\n#ifdef FLAT_SHADING\nout vec4 position_commonspace;\n#endif\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n\n  vec4 color = isStroke ? instanceLineColors : instanceFillColors;\n  mat2 rotationMatrix = mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n  float elevation = 0.0;\n  float strokeOffsetRatio = 1.0;\n\n  if (extruded) {\n    elevation = instanceElevations * (positions.z + 1.0) / 2.0 * elevationScale;\n  } else if (isStroke) {\n    float widthPixels = clamp(\n      project_size_to_pixel(instanceStrokeWidths * widthScale, widthUnits),\n      widthMinPixels, widthMaxPixels) / 2.0;\n    strokeOffsetRatio -= sign(positions.z) * project_pixel_size(widthPixels) / project_size(edgeDistance * coverage * radius);\n  }\n  float shouldRender = float(color.a > 0.0 && instanceElevations >= 0.0);\n  float dotRadius = radius * coverage * shouldRender;\n\n  geometry.pickingColor = instancePickingColors;\n  vec3 centroidPosition = vec3(instancePositions.xy, instancePositions.z + elevation);\n  vec3 centroidPosition64Low = instancePositions64Low;\n  vec2 offset = (rotationMatrix * positions.xy * strokeOffsetRatio + offset) * dotRadius;\n  if (radiusUnits == UNIT_METERS) {\n    offset = project_size(offset);\n  }\n  vec3 pos = vec3(offset, 0.);\n  DECKGL_FILTER_SIZE(pos, geometry);\n\n  gl_Position = project_position_to_clipspace(centroidPosition, centroidPosition64Low, pos, geometry.position);\n  geometry.normal = project_normal(vec3(rotationMatrix * normals.xy, normals.z));\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  if (extruded && !isStroke) {\n#ifdef FLAT_SHADING\n    position_commonspace = geometry.position;\n    vColor = vec4(color.rgb, color.a * opacity);\n#else\n    vec3 lightColor = lighting_getLightColor(color.rgb, project_uCameraPosition, geometry.position.xyz, geometry.normal);\n    vColor = vec4(lightColor, color.a * opacity);\n#endif\n  } else {\n    vColor = vec4(color.rgb, color.a * opacity);\n  }\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/column-layer/column-layer-fragment.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#version 300 es\n#define SHADER_NAME column-layer-fragment-shader\n\nprecision highp float;\n\nuniform vec3 project_uCameraPosition;\nuniform bool extruded;\nuniform bool isStroke;\n\nout vec4 fragColor;\n\nin vec4 vColor;\n#ifdef FLAT_SHADING\nin vec4 position_commonspace;\n#endif\n\nvoid main(void) {\n  fragColor = vColor;\n#ifdef FLAT_SHADING\n  if (extruded && !isStroke && !picking_uActive) {\n    vec3 normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));\n    fragColor.rgb = lighting_getLightColor(vColor.rgb, project_uCameraPosition, position_commonspace.xyz, normal);\n  }\n#endif\n  DECKGL_FILTER_COLOR(fragColor, geometry);\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/column-layer/column-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _core = require("@deck.gl/core");

var _core2 = require("@luma.gl/core");

var _columnGeometry = _interopRequireDefault(require("./column-geometry"));

var _columnLayerVertex = _interopRequireDefault(require("./column-layer-vertex.glsl"));

var _columnLayerFragment = _interopRequireDefault(require("./column-layer-fragment.glsl"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const DEFAULT_COLOR = [0, 0, 0, 255];
const defaultProps = {
  diskResolution: {
    type: 'number',
    min: 4,
    value: 20
  },
  vertices: null,
  radius: {
    type: 'number',
    min: 0,
    value: 1000
  },
  angle: {
    type: 'number',
    value: 0
  },
  offset: {
    type: 'array',
    value: [0, 0]
  },
  coverage: {
    type: 'number',
    min: 0,
    max: 1,
    value: 1
  },
  elevationScale: {
    type: 'number',
    min: 0,
    value: 1
  },
  radiusUnits: 'meters',
  lineWidthUnits: 'meters',
  lineWidthScale: 1,
  lineWidthMinPixels: 0,
  lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,
  extruded: true,
  wireframe: false,
  filled: true,
  stroked: false,
  getPosition: {
    type: 'accessor',
    value: x => x.position
  },
  getFillColor: {
    type: 'accessor',
    value: DEFAULT_COLOR
  },
  getLineColor: {
    type: 'accessor',
    value: DEFAULT_COLOR
  },
  getLineWidth: {
    type: 'accessor',
    value: 1
  },
  getElevation: {
    type: 'accessor',
    value: 1000
  },
  material: true,
  getColor: {
    deprecatedFor: ['getFillColor', 'getLineColor']
  }
};

class ColumnLayer extends _core.Layer {
  getShaders() {
    const {
      gl
    } = this.context;
    const transpileToGLSL100 = !(0, _core2.isWebGL2)(gl);
    const defines = {};
    const useDerivatives = this.props.flatShading && (0, _core2.hasFeature)(gl, _core2.FEATURES.GLSL_DERIVATIVES);

    if (useDerivatives) {
      defines.FLAT_SHADING = 1;
    }

    return super.getShaders({
      vs: _columnLayerVertex.default,
      fs: _columnLayerFragment.default,
      defines,
      transpileToGLSL100,
      modules: [_core.project32, useDerivatives ? _core.phongLighting : _core.gouraudLighting, _core.picking]
    });
  }

  initializeState() {
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instancePositions: {
        size: 3,
        type: 5130,
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: 'getPosition'
      },
      instanceElevations: {
        size: 1,
        transition: true,
        accessor: 'getElevation'
      },
      instanceFillColors: {
        size: this.props.colorFormat.length,
        type: 5121,
        normalized: true,
        transition: true,
        accessor: 'getFillColor',
        defaultValue: DEFAULT_COLOR
      },
      instanceLineColors: {
        size: this.props.colorFormat.length,
        type: 5121,
        normalized: true,
        transition: true,
        accessor: 'getLineColor',
        defaultValue: DEFAULT_COLOR
      },
      instanceStrokeWidths: {
        size: 1,
        accessor: 'getLineWidth',
        transition: true
      }
    });
  }

  updateState({
    props,
    oldProps,
    changeFlags
  }) {
    super.updateState({
      props,
      oldProps,
      changeFlags
    });
    const regenerateModels = changeFlags.extensionsChanged || props.flatShading !== oldProps.flatShading;

    if (regenerateModels) {
      var _this$state$model;

      const {
        gl
      } = this.context;
      (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();
      this.state.model = this._getModel(gl);
      this.getAttributeManager().invalidateAll();
    }

    if (regenerateModels || props.diskResolution !== oldProps.diskResolution || props.vertices !== oldProps.vertices || (props.extruded || props.stroked) !== (oldProps.extruded || oldProps.stroked)) {
      this._updateGeometry(props);
    }
  }

  getGeometry(diskResolution, vertices, hasThinkness) {
    const geometry = new _columnGeometry.default({
      radius: 1,
      height: hasThinkness ? 2 : 0,
      vertices,
      nradial: diskResolution
    });
    let meanVertexDistance = 0;

    if (vertices) {
      for (let i = 0; i < diskResolution; i++) {
        const p = vertices[i];
        const d = Math.sqrt(p[0] * p[0] + p[1] * p[1]);
        meanVertexDistance += d / diskResolution;
      }
    } else {
      meanVertexDistance = 1;
    }

    this.setState({
      edgeDistance: Math.cos(Math.PI / diskResolution) * meanVertexDistance
    });
    return geometry;
  }

  _getModel(gl) {
    return new _core2.Model(gl, { ...this.getShaders(),
      id: this.props.id,
      isInstanced: true
    });
  }

  _updateGeometry({
    diskResolution,
    vertices,
    extruded,
    stroked
  }) {
    const geometry = this.getGeometry(diskResolution, vertices, extruded || stroked);
    this.setState({
      fillVertexCount: geometry.attributes.POSITION.value.length / 3,
      wireframeVertexCount: geometry.indices.value.length
    });
    this.state.model.setProps({
      geometry
    });
  }

  draw({
    uniforms
  }) {
    const {
      lineWidthUnits,
      lineWidthScale,
      lineWidthMinPixels,
      lineWidthMaxPixels,
      radiusUnits,
      elevationScale,
      extruded,
      filled,
      stroked,
      wireframe,
      offset,
      coverage,
      radius,
      angle
    } = this.props;
    const {
      model,
      fillVertexCount,
      wireframeVertexCount,
      edgeDistance
    } = this.state;
    model.setUniforms(uniforms).setUniforms({
      radius,
      angle: angle / 180 * Math.PI,
      offset,
      extruded,
      coverage,
      elevationScale,
      edgeDistance,
      radiusUnits: _core.UNIT[radiusUnits],
      widthUnits: _core.UNIT[lineWidthUnits],
      widthScale: lineWidthScale,
      widthMinPixels: lineWidthMinPixels,
      widthMaxPixels: lineWidthMaxPixels
    });

    if (extruded && wireframe) {
      model.setProps({
        isIndexed: true
      });
      model.setVertexCount(wireframeVertexCount).setDrawMode(1).setUniforms({
        isStroke: true
      }).draw();
    }

    if (filled) {
      model.setProps({
        isIndexed: false
      });
      model.setVertexCount(fillVertexCount).setDrawMode(5).setUniforms({
        isStroke: false
      }).draw();
    }

    if (!extruded && stroked) {
      model.setProps({
        isIndexed: false
      });
      model.setVertexCount(fillVertexCount * 2 / 3).setDrawMode(5).setUniforms({
        isStroke: true
      }).draw();
    }
  }

}

exports.default = ColumnLayer;
ColumnLayer.layerName = 'ColumnLayer';
ColumnLayer.defaultProps = defaultProps;
},{"@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","./column-geometry":"node_modules/@deck.gl/layers/dist/esm/column-layer/column-geometry.js","./column-layer-vertex.glsl":"node_modules/@deck.gl/layers/dist/esm/column-layer/column-layer-vertex.glsl.js","./column-layer-fragment.glsl":"node_modules/@deck.gl/layers/dist/esm/column-layer/column-layer-fragment.glsl.js"}],"node_modules/@deck.gl/layers/dist/esm/column-layer/grid-cell-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _core = require("@luma.gl/core");

var _core2 = require("@deck.gl/core");

var _columnLayer = _interopRequireDefault(require("./column-layer"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const defaultProps = {
  cellSize: {
    type: 'number',
    min: 0,
    value: 1000
  },
  offset: {
    type: 'array',
    min: 0,
    value: [1, 1]
  }
};

class GridCellLayer extends _columnLayer.default {
  getGeometry(diskResolution) {
    return new _core.CubeGeometry();
  }

  draw({
    uniforms
  }) {
    const {
      elevationScale,
      extruded,
      offset,
      coverage,
      cellSize,
      angle,
      radiusUnits
    } = this.props;
    this.state.model.setUniforms(uniforms).setUniforms({
      radius: cellSize / 2,
      radiusUnits: _core2.UNIT[radiusUnits],
      angle,
      offset,
      extruded,
      coverage,
      elevationScale,
      edgeDistance: 1,
      isWireframe: false
    }).draw();
  }

}

exports.default = GridCellLayer;
GridCellLayer.layerName = 'GridCellLayer';
GridCellLayer.defaultProps = defaultProps;
},{"@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","./column-layer":"node_modules/@deck.gl/layers/dist/esm/column-layer/column-layer.js"}],"node_modules/@deck.gl/layers/dist/esm/path-layer/path.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.normalizePath = normalizePath;

var _polygon = require("@math.gl/polygon");

function normalizePath(path, size, gridResolution, wrapLongitude) {
  let flatPath = path;

  if (Array.isArray(path[0])) {
    const length = path.length * size;
    flatPath = new Array(length);

    for (let i = 0; i < path.length; i++) {
      for (let j = 0; j < size; j++) {
        flatPath[i * size + j] = path[i][j] || 0;
      }
    }
  }

  if (gridResolution) {
    return (0, _polygon.cutPolylineByGrid)(flatPath, {
      size,
      gridResolution
    });
  }

  if (wrapLongitude) {
    return (0, _polygon.cutPolylineByMercatorBounds)(flatPath, {
      size
    });
  }

  return flatPath;
}
},{"@math.gl/polygon":"node_modules/@math.gl/polygon/dist/esm/index.js"}],"node_modules/@deck.gl/layers/dist/esm/path-layer/path-tesselator.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _core = require("@deck.gl/core");

var _path = require("./path");

const START_CAP = 1;
const END_CAP = 2;
const INVALID = 4;

class PathTesselator extends _core.Tesselator {
  constructor(opts) {
    super({ ...opts,
      attributes: {
        positions: {
          size: 3,
          padding: 18,
          initialize: true,
          type: opts.fp64 ? Float64Array : Float32Array
        },
        segmentTypes: {
          size: 1,
          type: Uint8ClampedArray
        }
      }
    });
  }

  getGeometryFromBuffer(buffer) {
    if (this.normalize) {
      return super.getGeometryFromBuffer(buffer);
    }

    return () => null;
  }

  normalizeGeometry(path) {
    if (this.normalize) {
      return (0, _path.normalizePath)(path, this.positionSize, this.opts.resolution, this.opts.wrapLongitude);
    }

    return path;
  }

  get(attributeName) {
    return this.attributes[attributeName];
  }

  getGeometrySize(path) {
    if (Array.isArray(path[0])) {
      let size = 0;

      for (const subPath of path) {
        size += this.getGeometrySize(subPath);
      }

      return size;
    }

    const numPoints = this.getPathLength(path);

    if (numPoints < 2) {
      return 0;
    }

    if (this.isClosed(path)) {
      return numPoints < 3 ? 0 : numPoints + 2;
    }

    return numPoints;
  }

  updateGeometryAttributes(path, context) {
    if (context.geometrySize === 0) {
      return;
    }

    if (path && Array.isArray(path[0])) {
      for (const subPath of path) {
        const geometrySize = this.getGeometrySize(subPath);
        context.geometrySize = geometrySize;
        this.updateGeometryAttributes(subPath, context);
        context.vertexStart += geometrySize;
      }
    } else {
      this._updateSegmentTypes(path, context);

      this._updatePositions(path, context);
    }
  }

  _updateSegmentTypes(path, context) {
    const {
      segmentTypes
    } = this.attributes;
    const isPathClosed = this.isClosed(path);
    const {
      vertexStart,
      geometrySize
    } = context;
    segmentTypes.fill(0, vertexStart, vertexStart + geometrySize);

    if (isPathClosed) {
      segmentTypes[vertexStart] = INVALID;
      segmentTypes[vertexStart + geometrySize - 2] = INVALID;
    } else {
      segmentTypes[vertexStart] += START_CAP;
      segmentTypes[vertexStart + geometrySize - 2] += END_CAP;
    }

    segmentTypes[vertexStart + geometrySize - 1] = INVALID;
  }

  _updatePositions(path, context) {
    const {
      positions
    } = this.attributes;

    if (!positions) {
      return;
    }

    const {
      vertexStart,
      geometrySize
    } = context;
    const p = new Array(3);

    for (let i = vertexStart, ptIndex = 0; ptIndex < geometrySize; i++, ptIndex++) {
      this.getPointOnPath(path, ptIndex, p);
      positions[i * 3] = p[0];
      positions[i * 3 + 1] = p[1];
      positions[i * 3 + 2] = p[2];
    }
  }

  getPathLength(path) {
    return path.length / this.positionSize;
  }

  getPointOnPath(path, index, target = []) {
    const {
      positionSize
    } = this;

    if (index * positionSize >= path.length) {
      index += 1 - path.length / positionSize;
    }

    const i = index * positionSize;
    target[0] = path[i];
    target[1] = path[i + 1];
    target[2] = positionSize === 3 && path[i + 2] || 0;
    return target;
  }

  isClosed(path) {
    if (!this.normalize) {
      return this.opts.loop;
    }

    const {
      positionSize
    } = this;
    const lastPointIndex = path.length - positionSize;
    return path[0] === path[lastPointIndex] && path[1] === path[lastPointIndex + 1] && (positionSize === 2 || path[2] === path[lastPointIndex + 2]);
  }

}

exports.default = PathTesselator;
},{"@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","./path":"node_modules/@deck.gl/layers/dist/esm/path-layer/path.js"}],"node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer-vertex.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME path-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute float instanceTypes;\nattribute vec3 instanceStartPositions;\nattribute vec3 instanceEndPositions;\nattribute vec3 instanceLeftPositions;\nattribute vec3 instanceRightPositions;\nattribute vec3 instanceLeftPositions64Low;\nattribute vec3 instanceStartPositions64Low;\nattribute vec3 instanceEndPositions64Low;\nattribute vec3 instanceRightPositions64Low;\nattribute float instanceStrokeWidths;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform float jointType;\nuniform float capType;\nuniform float miterLimit;\nuniform bool billboard;\nuniform int widthUnits;\n\nuniform float opacity;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\nvarying float vJointType;\n\nconst float EPSILON = 0.001;\nconst vec3 ZERO_OFFSET = vec3(0.0);\n\nfloat flipIfTrue(bool flag) {\n  return -(float(flag) * 2. - 1.);\n}\nvec3 lineJoin(\n  vec3 prevPoint, vec3 currPoint, vec3 nextPoint,\n  vec2 width\n) {\n  bool isEnd = positions.x > 0.0;\n  float sideOfPath = positions.y;\n  float isJoint = float(sideOfPath == 0.0);\n\n  vec3 deltaA3 = (currPoint - prevPoint);\n  vec3 deltaB3 = (nextPoint - currPoint);\n\n  mat3 rotationMatrix;\n  bool needsRotation = !billboard && project_needs_rotation(currPoint, rotationMatrix);\n  if (needsRotation) {\n    deltaA3 = deltaA3 * rotationMatrix;\n    deltaB3 = deltaB3 * rotationMatrix;\n  }\n  vec2 deltaA = deltaA3.xy / width;\n  vec2 deltaB = deltaB3.xy / width;\n\n  float lenA = length(deltaA);\n  float lenB = length(deltaB);\n\n  vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);\n  vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);\n\n  vec2 perpA = vec2(-dirA.y, dirA.x);\n  vec2 perpB = vec2(-dirB.y, dirB.x);\n  vec2 tangent = dirA + dirB;\n  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;\n  vec2 miterVec = vec2(-tangent.y, tangent.x);\n  vec2 dir = isEnd ? dirA : dirB;\n  vec2 perp = isEnd ? perpA : perpB;\n  float L = isEnd ? lenA : lenB;\n  float sinHalfA = abs(dot(miterVec, perp));\n  float cosHalfA = abs(dot(dirA, miterVec));\n  float turnDirection = flipIfTrue(dirA.x * dirB.y >= dirA.y * dirB.x);\n  float cornerPosition = sideOfPath * turnDirection;\n\n  float miterSize = 1.0 / max(sinHalfA, EPSILON);\n  miterSize = mix(\n    min(miterSize, max(lenA, lenB) / max(cosHalfA, EPSILON)),\n    miterSize,\n    step(0.0, cornerPosition)\n  );\n\n  vec2 offsetVec = mix(miterVec * miterSize, perp, step(0.5, cornerPosition))\n    * (sideOfPath + isJoint * turnDirection);\n  bool isStartCap = lenA == 0.0 || (!isEnd && (instanceTypes == 1.0 || instanceTypes == 3.0));\n  bool isEndCap = lenB == 0.0 || (isEnd && (instanceTypes == 2.0 || instanceTypes == 3.0));\n  bool isCap = isStartCap || isEndCap;\n  if (isCap) {\n    offsetVec = mix(perp * sideOfPath, dir * capType * 4.0 * flipIfTrue(isStartCap), isJoint);\n    vJointType = capType;\n  } else {\n    vJointType = jointType;\n  }\n  vPathLength = L;\n  vCornerOffset = offsetVec;\n  vMiterLength = dot(vCornerOffset, miterVec * turnDirection);\n  vMiterLength = isCap ? isJoint : vMiterLength;\n\n  vec2 offsetFromStartOfPath = vCornerOffset + deltaA * float(isEnd);\n  vPathPosition = vec2(\n    dot(offsetFromStartOfPath, perp),\n    dot(offsetFromStartOfPath, dir)\n  );\n  geometry.uv = vPathPosition;\n\n  float isValid = step(instanceTypes, 3.5);\n  vec3 offset = vec3(offsetVec * width * isValid, 0.0);\n\n  if (needsRotation) {\n    offset = rotationMatrix * offset;\n  }\n  return currPoint + offset;\n}\nvoid clipLine(inout vec4 position, vec4 refPosition) {\n  if (position.w < EPSILON) {\n    float r = (EPSILON - refPosition.w) / (position.w - refPosition.w);\n    position = refPosition + (position - refPosition) * r;\n  }\n}\n\nvoid main() {\n  geometry.pickingColor = instancePickingColors;\n\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);\n\n  float isEnd = positions.x;\n\n  vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);\n  vec3 prevPosition64Low = mix(instanceLeftPositions64Low, instanceStartPositions64Low, isEnd);\n\n  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\n  vec3 currPosition64Low = mix(instanceStartPositions64Low, instanceEndPositions64Low, isEnd);\n\n  vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);\n  vec3 nextPosition64Low = mix(instanceEndPositions64Low, instanceRightPositions64Low, isEnd);\n\n  geometry.worldPosition = currPosition;\n  vec2 widthPixels = vec2(clamp(\n    project_size_to_pixel(instanceStrokeWidths * widthScale, widthUnits),\n    widthMinPixels, widthMaxPixels) / 2.0);\n  vec3 width;\n\n  if (billboard) {\n    vec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64Low, ZERO_OFFSET);\n    vec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64Low, ZERO_OFFSET, geometry.position);\n    vec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64Low, ZERO_OFFSET);\n\n    clipLine(prevPositionScreen, currPositionScreen);\n    clipLine(nextPositionScreen, currPositionScreen);\n    clipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));\n\n    width = vec3(widthPixels, 0.0);\n    DECKGL_FILTER_SIZE(width, geometry);\n\n    vec3 pos = lineJoin(\n      prevPositionScreen.xyz / prevPositionScreen.w,\n      currPositionScreen.xyz / currPositionScreen.w,\n      nextPositionScreen.xyz / nextPositionScreen.w,\n      project_pixel_size_to_clipspace(width.xy)\n    );\n\n    gl_Position = vec4(pos * currPositionScreen.w, currPositionScreen.w);\n  } else {\n    prevPosition = project_position(prevPosition, prevPosition64Low);\n    currPosition = project_position(currPosition, currPosition64Low);\n    nextPosition = project_position(nextPosition, nextPosition64Low);\n\n    width = vec3(project_pixel_size(widthPixels), 0.0);\n    DECKGL_FILTER_SIZE(width, geometry);\n\n    vec4 pos = vec4(\n      lineJoin(prevPosition, currPosition, nextPosition, width.xy),\n      1.0);\n    geometry.position = pos;\n    gl_Position = project_common_position_to_clipspace(pos);\n  }\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer-fragment.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME path-layer-fragment-shader\n\nprecision highp float;\n\nuniform float miterLimit;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\nvarying float vJointType;\n\nvoid main(void) {\n  geometry.uv = vPathPosition;\n\n  if (vPathPosition.y < 0.0 || vPathPosition.y > vPathLength) {\n    if (vJointType > 0.5 && length(vCornerOffset) > 1.0) {\n      discard;\n    }\n    if (vJointType < 0.5 && vMiterLength > miterLimit + 1.0) {\n      discard;\n    }\n  }\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _core = require("@deck.gl/core");

var _core2 = require("@luma.gl/core");

var _pathTesselator = _interopRequireDefault(require("./path-tesselator"));

var _pathLayerVertex = _interopRequireDefault(require("./path-layer-vertex.glsl"));

var _pathLayerFragment = _interopRequireDefault(require("./path-layer-fragment.glsl"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const DEFAULT_COLOR = [0, 0, 0, 255];
const defaultProps = {
  widthUnits: 'meters',
  widthScale: {
    type: 'number',
    min: 0,
    value: 1
  },
  widthMinPixels: {
    type: 'number',
    min: 0,
    value: 0
  },
  widthMaxPixels: {
    type: 'number',
    min: 0,
    value: Number.MAX_SAFE_INTEGER
  },
  jointRounded: false,
  capRounded: false,
  miterLimit: {
    type: 'number',
    min: 0,
    value: 4
  },
  billboard: false,
  _pathType: null,
  getPath: {
    type: 'accessor',
    value: object => object.path
  },
  getColor: {
    type: 'accessor',
    value: DEFAULT_COLOR
  },
  getWidth: {
    type: 'accessor',
    value: 1
  },
  rounded: {
    deprecatedFor: ['jointRounded', 'capRounded']
  }
};
const ATTRIBUTE_TRANSITION = {
  enter: (value, chunk) => {
    return chunk.length ? chunk.subarray(chunk.length - value.length) : value;
  }
};

class PathLayer extends _core.Layer {
  getShaders() {
    return super.getShaders({
      vs: _pathLayerVertex.default,
      fs: _pathLayerFragment.default,
      modules: [_core.project32, _core.picking]
    });
  }

  get wrapLongitude() {
    return false;
  }

  initializeState() {
    const noAlloc = true;
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      positions: {
        size: 3,
        vertexOffset: 1,
        type: 5130,
        fp64: this.use64bitPositions(),
        transition: ATTRIBUTE_TRANSITION,
        accessor: 'getPath',
        update: this.calculatePositions,
        noAlloc,
        shaderAttributes: {
          instanceLeftPositions: {
            vertexOffset: 0
          },
          instanceStartPositions: {
            vertexOffset: 1
          },
          instanceEndPositions: {
            vertexOffset: 2
          },
          instanceRightPositions: {
            vertexOffset: 3
          }
        }
      },
      instanceTypes: {
        size: 1,
        type: 5121,
        update: this.calculateSegmentTypes,
        noAlloc
      },
      instanceStrokeWidths: {
        size: 1,
        accessor: 'getWidth',
        transition: ATTRIBUTE_TRANSITION,
        defaultValue: 1
      },
      instanceColors: {
        size: this.props.colorFormat.length,
        type: 5121,
        normalized: true,
        accessor: 'getColor',
        transition: ATTRIBUTE_TRANSITION,
        defaultValue: DEFAULT_COLOR
      },
      instancePickingColors: {
        size: 3,
        type: 5121,
        accessor: (object, {
          index,
          target: value
        }) => this.encodePickingColor(object && object.__source ? object.__source.index : index, value)
      }
    });
    this.setState({
      pathTesselator: new _pathTesselator.default({
        fp64: this.use64bitPositions()
      })
    });

    if (this.props.getDashArray && !this.props.extensions.length) {
      _core.log.removed('getDashArray', 'PathStyleExtension')();
    }
  }

  updateState({
    oldProps,
    props,
    changeFlags
  }) {
    super.updateState({
      props,
      oldProps,
      changeFlags
    });
    const attributeManager = this.getAttributeManager();
    const geometryChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPath);

    if (geometryChanged) {
      const {
        pathTesselator
      } = this.state;
      const buffers = props.data.attributes || {};
      pathTesselator.updateGeometry({
        data: props.data,
        geometryBuffer: buffers.getPath,
        buffers,
        normalize: !props._pathType,
        loop: props._pathType === 'loop',
        getGeometry: props.getPath,
        positionFormat: props.positionFormat,
        wrapLongitude: props.wrapLongitude,
        resolution: this.context.viewport.resolution,
        dataChanged: changeFlags.dataChanged
      });
      this.setState({
        numInstances: pathTesselator.instanceCount,
        startIndices: pathTesselator.vertexStarts
      });

      if (!changeFlags.dataChanged) {
        attributeManager.invalidateAll();
      }
    }

    if (changeFlags.extensionsChanged) {
      var _this$state$model;

      const {
        gl
      } = this.context;
      (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();
      this.state.model = this._getModel(gl);
      attributeManager.invalidateAll();
    }
  }

  getPickingInfo(params) {
    const info = super.getPickingInfo(params);
    const {
      index
    } = info;
    const {
      data
    } = this.props;

    if (data[0] && data[0].__source) {
      info.object = data.find(d => d.__source.index === index);
    }

    return info;
  }

  disablePickingIndex(objectIndex) {
    const {
      data
    } = this.props;

    if (data[0] && data[0].__source) {
      for (let i = 0; i < data.length; i++) {
        if (data[i].__source.index === objectIndex) {
          this._disablePickingIndex(i);
        }
      }
    } else {
      this._disablePickingIndex(objectIndex);
    }
  }

  draw({
    uniforms
  }) {
    const {
      jointRounded,
      capRounded,
      billboard,
      miterLimit,
      widthUnits,
      widthScale,
      widthMinPixels,
      widthMaxPixels
    } = this.props;
    this.state.model.setUniforms(uniforms).setUniforms({
      jointType: Number(jointRounded),
      capType: Number(capRounded),
      billboard,
      widthUnits: _core.UNIT[widthUnits],
      widthScale,
      miterLimit,
      widthMinPixels,
      widthMaxPixels
    }).draw();
  }

  _getModel(gl) {
    const SEGMENT_INDICES = [0, 1, 2, 1, 4, 2, 1, 3, 4, 3, 5, 4];
    const SEGMENT_POSITIONS = [0, 0, 0, -1, 0, 1, 1, -1, 1, 1, 1, 0];
    return new _core2.Model(gl, { ...this.getShaders(),
      id: this.props.id,
      geometry: new _core2.Geometry({
        drawMode: 4,
        attributes: {
          indices: new Uint16Array(SEGMENT_INDICES),
          positions: {
            value: new Float32Array(SEGMENT_POSITIONS),
            size: 2
          }
        }
      }),
      isInstanced: true
    });
  }

  calculatePositions(attribute) {
    const {
      pathTesselator
    } = this.state;
    attribute.startIndices = pathTesselator.vertexStarts;
    attribute.value = pathTesselator.get('positions');
  }

  calculateSegmentTypes(attribute) {
    const {
      pathTesselator
    } = this.state;
    attribute.startIndices = pathTesselator.vertexStarts;
    attribute.value = pathTesselator.get('segmentTypes');
  }

}

exports.default = PathLayer;
PathLayer.layerName = 'PathLayer';
PathLayer.defaultProps = defaultProps;
},{"@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","./path-tesselator":"node_modules/@deck.gl/layers/dist/esm/path-layer/path-tesselator.js","./path-layer-vertex.glsl":"node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer-vertex.glsl.js","./path-layer-fragment.glsl":"node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer-fragment.glsl.js"}],"node_modules/earcut/src/earcut.js":[function(require,module,exports) {
'use strict';

module.exports = earcut;
module.exports.default = earcut;

function earcut(data, holeIndices, dim) {

    dim = dim || 2;

    var hasHoles = holeIndices && holeIndices.length,
        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
        outerNode = linkedList(data, 0, outerLen, dim, true),
        triangles = [];

    if (!outerNode || outerNode.next === outerNode.prev) return triangles;

    var minX, minY, maxX, maxY, x, y, invSize;

    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];

        for (var i = dim; i < outerLen; i += dim) {
            x = data[i];
            y = data[i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
        }

        // minX, minY and invSize are later used to transform coords into integers for z-order calculation
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 1 / invSize : 0;
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);

    return triangles;
}

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    var i, last;

    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
    } else {
        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
    }

    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }

    return last;
}

// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;

    var p = start,
        again;
    do {
        again = false;

        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) break;
            again = true;

        } else {
            p = p.next;
        }
    } while (again || p !== end);

    return end;
}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) return;

    // interlink polygon nodes in z-order
    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);

    var stop = ear,
        prev, next;

    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;

        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);

            removeNode(ear);

            // skipping the next vertex leads to less sliver triangles
            ear = next.next;
            stop = next.next;

            continue;
        }

        ear = next;

        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);

            // if this didn't work, try curing all small self-intersections locally
            } else if (pass === 1) {
                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);

            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }

            break;
        }
    }
}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear
    var p = ear.next.next;

    while (p !== ear.prev) {
        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }

    return true;
}

function isEarHashed(ear, minX, minY, invSize) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // triangle bbox; min & max are calculated like this for speed
    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),
        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),
        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),
        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);

    // z-order range for the current triangle bbox;
    var minZ = zOrder(minTX, minTY, minX, minY, invSize),
        maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);

    var p = ear.prevZ,
        n = ear.nextZ;

    // look for points inside the triangle in both directions
    while (p && p.z >= minZ && n && n.z <= maxZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;

        if (n !== ear.prev && n !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
            area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    // look for remaining points in decreasing z-order
    while (p && p.z >= minZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }

    // look for remaining points in increasing z-order
    while (n && n.z <= maxZ) {
        if (n !== ear.prev && n !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
            area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    return true;
}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev,
            b = p.next.next;

        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

            triangles.push(a.i / dim);
            triangles.push(p.i / dim);
            triangles.push(b.i / dim);

            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);

            p = start = b;
        }
        p = p.next;
    } while (p !== start);

    return filterPoints(p);
}

// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);

                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);

                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, invSize);
                earcutLinked(c, triangles, dim, minX, minY, invSize);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [],
        i, len, start, end, list;

    for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }

    queue.sort(compareX);

    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
        outerNode = eliminateHole(queue[i], outerNode);
        outerNode = filterPoints(outerNode, outerNode.next);
    }

    return outerNode;
}

function compareX(a, b) {
    return a.x - b.x;
}

// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    var bridge = findHoleBridge(hole, outerNode);
    if (!bridge) {
        return outerNode;
    }

    var bridgeReverse = splitPolygon(bridge, hole);

    // filter collinear points around the cuts
    var filteredBridge = filterPoints(bridge, bridge.next);
    filterPoints(bridgeReverse, bridgeReverse.next);

    // Check if input node was removed by the filtering
    return outerNode === bridge ? filteredBridge : outerNode;
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    var p = outerNode,
        hx = hole.x,
        hy = hole.y,
        qx = -Infinity,
        m;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                if (x === hx) {
                    if (hy === p.y) return p;
                    if (hy === p.next.y) return p.next;
                }
                m = p.x < p.next.x ? p : p.next;
            }
        }
        p = p.next;
    } while (p !== outerNode);

    if (!m) return null;

    if (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint

    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    var stop = m,
        mx = m.x,
        my = m.y,
        tanMin = Infinity,
        tan;

    p = m;

    do {
        if (hx >= p.x && p.x >= mx && hx !== p.x &&
                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

            if (locallyInside(p, hole) &&
                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {
                m = p;
                tanMin = tan;
            }
        }

        p = p.next;
    } while (p !== stop);

    return m;
}

// whether sector in vertex m contains sector in vertex p in the same coordinates
function sectorContainsSector(m, p) {
    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}

// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, invSize) {
    var p = start;
    do {
        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    } while (p !== start);

    p.prevZ.nextZ = null;
    p.prevZ = null;

    sortLinked(p);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize,
        inSize = 1;

    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;

        while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }
            qSize = inSize;

            while (pSize > 0 || (qSize > 0 && q)) {

                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }

                if (tail) tail.nextZ = e;
                else list = e;

                e.prevZ = tail;
                tail = e;
            }

            p = q;
        }

        tail.nextZ = null;
        inSize *= 2;

    } while (numMerges > 1);

    return list;
}

// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x, y, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x = 32767 * (x - minX) * invSize;
    y = 32767 * (y - minY) * invSize;

    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    return x | (y << 1);
}

// find the leftmost node of a polygon ring
function getLeftmost(start) {
    var p = start,
        leftmost = start;
    do {
        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;
        p = p.next;
    } while (p !== start);

    return leftmost;
}

// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
           (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
           (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
}

// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    var o1 = sign(area(p1, q1, p2));
    var o2 = sign(area(p1, q1, q2));
    var o3 = sign(area(p2, q2, p1));
    var o4 = sign(area(p2, q2, q1));

    if (o1 !== o2 && o3 !== o4) return true; // general case

    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

    return false;
}

// for collinear points p, q, r, check if point q lies on segment pr
function onSegment(p, q, r) {
    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}

function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    var p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                intersects(p, p.next, a, b)) return true;
        p = p.next;
    } while (p !== a);

    return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ?
        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    var p = a,
        inside = false,
        px = (a.x + b.x) / 2,
        py = (a.y + b.y) / 2;
    do {
        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
            inside = !inside;
        p = p.next;
    } while (p !== a);

    return inside;
}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y),
        b2 = new Node(b.i, b.x, b.y),
        an = a.next,
        bp = b.prev;

    a.next = b;
    b.prev = a;

    a2.next = an;
    an.prev = a2;

    b2.next = a2;
    a2.prev = b2;

    bp.next = b2;
    b2.prev = bp;

    return b2;
}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);

    if (!last) {
        p.prev = p;
        p.next = p;

    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}

function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;

    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node(i, x, y) {
    // vertex index in coordinates array
    this.i = i;

    // vertex coordinates
    this.x = x;
    this.y = y;

    // previous and next vertex nodes in a polygon ring
    this.prev = null;
    this.next = null;

    // z-order curve value
    this.z = null;

    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;

    // indicates whether this is a steiner point
    this.steiner = false;
}

// return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
earcut.deviation = function (data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;

    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
    if (hasHoles) {
        for (var i = 0, len = holeIndices.length; i < len; i++) {
            var start = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
    }

    var trianglesArea = 0;
    for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs(
            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
    }

    return polygonArea === 0 && trianglesArea === 0 ? 0 :
        Math.abs((trianglesArea - polygonArea) / polygonArea);
};

function signedArea(data, start, end, dim) {
    var sum = 0;
    for (var i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}

// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
earcut.flatten = function (data) {
    var dim = data[0][0].length,
        result = {vertices: [], holes: [], dimensions: dim},
        holeIndex = 0;

    for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
        }
    }
    return result;
};

},{}],"node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/polygon.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSurfaceIndices = getSurfaceIndices;
exports.normalize = normalize;

var _earcut = _interopRequireDefault(require("earcut"));

var _polygon = require("@math.gl/polygon");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const OUTER_POLYGON_WINDING = _polygon.WINDING.CLOCKWISE;
const HOLE_POLYGON_WINDING = _polygon.WINDING.COUNTER_CLOCKWISE;
const windingOptions = {
  isClosed: true
};

function validate(polygon) {
  polygon = polygon && polygon.positions || polygon;

  if (!Array.isArray(polygon) && !ArrayBuffer.isView(polygon)) {
    throw new Error('invalid polygon');
  }
}

function isSimple(polygon) {
  return polygon.length >= 1 && polygon[0].length >= 2 && Number.isFinite(polygon[0][0]);
}

function isNestedRingClosed(simplePolygon) {
  const p0 = simplePolygon[0];
  const p1 = simplePolygon[simplePolygon.length - 1];
  return p0[0] === p1[0] && p0[1] === p1[1] && p0[2] === p1[2];
}

function isFlatRingClosed(positions, size, startIndex, endIndex) {
  for (let i = 0; i < size; i++) {
    if (positions[startIndex + i] !== positions[endIndex - size + i]) {
      return false;
    }
  }

  return true;
}

function copyNestedRing(target, targetStartIndex, simplePolygon, size, windingDirection) {
  let targetIndex = targetStartIndex;
  const len = simplePolygon.length;

  for (let i = 0; i < len; i++) {
    for (let j = 0; j < size; j++) {
      target[targetIndex++] = simplePolygon[i][j] || 0;
    }
  }

  if (!isNestedRingClosed(simplePolygon)) {
    for (let j = 0; j < size; j++) {
      target[targetIndex++] = simplePolygon[0][j] || 0;
    }
  }

  windingOptions.start = targetStartIndex;
  windingOptions.end = targetIndex;
  windingOptions.size = size;
  (0, _polygon.modifyPolygonWindingDirection)(target, windingDirection, windingOptions);
  return targetIndex;
}

function copyFlatRing(target, targetStartIndex, positions, size, srcStartIndex = 0, srcEndIndex, windingDirection) {
  srcEndIndex = srcEndIndex || positions.length;
  const srcLength = srcEndIndex - srcStartIndex;

  if (srcLength <= 0) {
    return targetStartIndex;
  }

  let targetIndex = targetStartIndex;

  for (let i = 0; i < srcLength; i++) {
    target[targetIndex++] = positions[srcStartIndex + i];
  }

  if (!isFlatRingClosed(positions, size, srcStartIndex, srcEndIndex)) {
    for (let i = 0; i < size; i++) {
      target[targetIndex++] = positions[srcStartIndex + i];
    }
  }

  windingOptions.start = targetStartIndex;
  windingOptions.end = targetIndex;
  windingOptions.size = size;
  (0, _polygon.modifyPolygonWindingDirection)(target, windingDirection, windingOptions);
  return targetIndex;
}

function normalize(polygon, positionSize) {
  validate(polygon);
  const positions = [];
  const holeIndices = [];

  if (polygon.positions) {
    const {
      positions: srcPositions,
      holeIndices: srcHoleIndices
    } = polygon;

    if (srcHoleIndices) {
      let targetIndex = 0;

      for (let i = 0; i <= srcHoleIndices.length; i++) {
        targetIndex = copyFlatRing(positions, targetIndex, srcPositions, positionSize, srcHoleIndices[i - 1], srcHoleIndices[i], i === 0 ? OUTER_POLYGON_WINDING : HOLE_POLYGON_WINDING);
        holeIndices.push(targetIndex);
      }

      holeIndices.pop();
      return {
        positions,
        holeIndices
      };
    }

    polygon = srcPositions;
  }

  if (Number.isFinite(polygon[0])) {
    copyFlatRing(positions, 0, polygon, positionSize, 0, positions.length, OUTER_POLYGON_WINDING);
    return positions;
  }

  if (!isSimple(polygon)) {
    let targetIndex = 0;

    for (const [polygonIndex, simplePolygon] of polygon.entries()) {
      targetIndex = copyNestedRing(positions, targetIndex, simplePolygon, positionSize, polygonIndex === 0 ? OUTER_POLYGON_WINDING : HOLE_POLYGON_WINDING);
      holeIndices.push(targetIndex);
    }

    holeIndices.pop();
    return {
      positions,
      holeIndices
    };
  }

  copyNestedRing(positions, 0, polygon, positionSize, OUTER_POLYGON_WINDING);
  return positions;
}

function getSurfaceIndices(normalizedPolygon, positionSize, preproject) {
  let holeIndices = null;

  if (normalizedPolygon.holeIndices) {
    holeIndices = normalizedPolygon.holeIndices.map(positionIndex => positionIndex / positionSize);
  }

  let positions = normalizedPolygon.positions || normalizedPolygon;

  if (preproject) {
    const n = positions.length;
    positions = positions.slice();
    const p = [];

    for (let i = 0; i < n; i += positionSize) {
      p[0] = positions[i];
      p[1] = positions[i + 1];
      const xy = preproject(p);
      positions[i] = xy[0];
      positions[i + 1] = xy[1];
    }
  }

  return (0, _earcut.default)(positions, holeIndices, positionSize);
}
},{"earcut":"node_modules/earcut/src/earcut.js","@math.gl/polygon":"node_modules/@math.gl/polygon/dist/esm/index.js"}],"node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/polygon-tesselator.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var Polygon = _interopRequireWildcard(require("./polygon"));

var _core = require("@deck.gl/core");

var _polygon2 = require("@math.gl/polygon");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

class PolygonTesselator extends _core.Tesselator {
  constructor(opts) {
    const {
      fp64,
      IndexType = Uint32Array
    } = opts;
    super({ ...opts,
      attributes: {
        positions: {
          size: 3,
          type: fp64 ? Float64Array : Float32Array
        },
        vertexValid: {
          type: Uint8ClampedArray,
          size: 1
        },
        indices: {
          type: IndexType,
          size: 1
        }
      }
    });
  }

  get(attributeName) {
    const {
      attributes
    } = this;

    if (attributeName === 'indices') {
      return attributes.indices && attributes.indices.subarray(0, this.vertexCount);
    }

    return attributes[attributeName];
  }

  updateGeometry(opts) {
    super.updateGeometry(opts);
    const externalIndices = this.buffers.indices;

    if (externalIndices) {
      this.vertexCount = (externalIndices.value || externalIndices).length;
    }
  }

  normalizeGeometry(polygon) {
    if (this.normalize) {
      polygon = Polygon.normalize(polygon, this.positionSize);

      if (this.opts.resolution) {
        return (0, _polygon2.cutPolygonByGrid)(polygon.positions || polygon, polygon.holeIndices, {
          size: this.positionSize,
          gridResolution: this.opts.resolution,
          edgeTypes: true
        });
      }

      if (this.opts.wrapLongitude) {
        return (0, _polygon2.cutPolygonByMercatorBounds)(polygon.positions || polygon, polygon.holeIndices, {
          size: this.positionSize,
          maxLatitude: 86,
          edgeTypes: true
        });
      }
    }

    return polygon;
  }

  getGeometrySize(polygon) {
    if (Array.isArray(polygon) && !Number.isFinite(polygon[0])) {
      let size = 0;

      for (const subPolygon of polygon) {
        size += this.getGeometrySize(subPolygon);
      }

      return size;
    }

    return (polygon.positions || polygon).length / this.positionSize;
  }

  getGeometryFromBuffer(buffer) {
    if (this.normalize || !this.buffers.indices) {
      return super.getGeometryFromBuffer(buffer);
    }

    return () => null;
  }

  updateGeometryAttributes(polygon, context) {
    if (Array.isArray(polygon) && !Number.isFinite(polygon[0])) {
      for (const subPolygon of polygon) {
        const geometrySize = this.getGeometrySize(subPolygon);
        context.geometrySize = geometrySize;
        this.updateGeometryAttributes(subPolygon, context);
        context.vertexStart += geometrySize;
        context.indexStart = this.indexStarts[context.geometryIndex + 1];
      }
    } else {
      this._updateIndices(polygon, context);

      this._updatePositions(polygon, context);

      this._updateVertexValid(polygon, context);
    }
  }

  _updateIndices(polygon, {
    geometryIndex,
    vertexStart: offset,
    indexStart
  }) {
    const {
      attributes,
      indexStarts,
      typedArrayManager
    } = this;
    let target = attributes.indices;

    if (!target) {
      return;
    }

    let i = indexStart;
    const indices = Polygon.getSurfaceIndices(polygon, this.positionSize, this.opts.preproject);
    target = typedArrayManager.allocate(target, indexStart + indices.length, {
      copy: true
    });

    for (let j = 0; j < indices.length; j++) {
      target[i++] = indices[j] + offset;
    }

    indexStarts[geometryIndex + 1] = indexStart + indices.length;
    attributes.indices = target;
  }

  _updatePositions(polygon, {
    vertexStart,
    geometrySize
  }) {
    const {
      attributes: {
        positions
      },
      positionSize
    } = this;

    if (!positions) {
      return;
    }

    const polygonPositions = polygon.positions || polygon;

    for (let i = vertexStart, j = 0; j < geometrySize; i++, j++) {
      const x = polygonPositions[j * positionSize];
      const y = polygonPositions[j * positionSize + 1];
      const z = positionSize > 2 ? polygonPositions[j * positionSize + 2] : 0;
      positions[i * 3] = x;
      positions[i * 3 + 1] = y;
      positions[i * 3 + 2] = z;
    }
  }

  _updateVertexValid(polygon, {
    vertexStart,
    geometrySize
  }) {
    const {
      attributes: {
        vertexValid
      },
      positionSize
    } = this;
    const holeIndices = polygon && polygon.holeIndices;

    if (polygon && polygon.edgeTypes) {
      vertexValid.set(polygon.edgeTypes, vertexStart);
    } else {
      vertexValid.fill(1, vertexStart, vertexStart + geometrySize);
    }

    if (holeIndices) {
      for (let j = 0; j < holeIndices.length; j++) {
        vertexValid[vertexStart + holeIndices[j] / positionSize - 1] = 0;
      }
    }

    vertexValid[vertexStart + geometrySize - 1] = 0;
  }

}

exports.default = PolygonTesselator;
},{"./polygon":"node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/polygon.js","@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","@math.gl/polygon":"node_modules/@math.gl/polygon/dist/esm/index.js"}],"node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-main.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "\nattribute vec2 vertexPositions;\nattribute float vertexValid;\n\nuniform bool extruded;\nuniform bool isWireframe;\nuniform float elevationScale;\nuniform float opacity;\n\nvarying vec4 vColor;\n\nstruct PolygonProps {\n  vec4 fillColors;\n  vec4 lineColors;\n  vec3 positions;\n  vec3 nextPositions;\n  vec3 pickingColors;\n  vec3 positions64Low;\n  vec3 nextPositions64Low;\n  float elevations;\n};\n\nvec3 project_offset_normal(vec3 vector) {\n  if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS) {\n    return normalize(vector * project_uCommonUnitsPerWorldUnit);\n  }\n  return project_normal(vector);\n}\n\nvoid calculatePosition(PolygonProps props) {\n#ifdef IS_SIDE_VERTEX\n  if(vertexValid < 0.5){\n    gl_Position = vec4(0.);\n    return;\n  }\n#endif\n\n  vec3 pos;\n  vec3 pos64Low;\n  vec3 normal;\n  vec4 colors = isWireframe ? props.lineColors : props.fillColors;\n\n  geometry.worldPosition = props.positions;\n  geometry.worldPositionAlt = props.nextPositions;\n  geometry.pickingColor = props.pickingColors;\n\n#ifdef IS_SIDE_VERTEX\n  pos = mix(props.positions, props.nextPositions, vertexPositions.x);\n  pos64Low = mix(props.positions64Low, props.nextPositions64Low, vertexPositions.x);\n#else\n  pos = props.positions;\n  pos64Low = props.positions64Low;\n#endif\n\n  if (extruded) {\n    pos.z += props.elevations * vertexPositions.y * elevationScale;\n  }\n  gl_Position = project_position_to_clipspace(pos, pos64Low, vec3(0.), geometry.position);\n\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  if (extruded) {\n  #ifdef IS_SIDE_VERTEX\n    normal = vec3(\n      props.positions.y - props.nextPositions.y + (props.positions64Low.y - props.nextPositions64Low.y),\n      props.nextPositions.x - props.positions.x + (props.nextPositions64Low.x - props.positions64Low.x),\n      0.0);\n    normal = project_offset_normal(normal);\n  #else\n    normal = project_normal(vec3(0.0, 0.0, 1.0));\n  #endif\n    geometry.normal = normal;\n    vec3 lightColor = lighting_getLightColor(colors.rgb, project_uCameraPosition, geometry.position.xyz, normal);\n    vColor = vec4(lightColor, colors.a * opacity);\n  } else {\n    vColor = vec4(colors.rgb, colors.a * opacity);\n  }\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-top.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _solidPolygonLayerVertexMain = _interopRequireDefault(require("./solid-polygon-layer-vertex-main.glsl"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = "#define SHADER_NAME solid-polygon-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 positions64Low;\nattribute float elevations;\nattribute vec4 fillColors;\nattribute vec4 lineColors;\nattribute vec3 pickingColors;\n\n".concat(_solidPolygonLayerVertexMain.default, "\n\nvoid main(void) {\n  PolygonProps props;\n\n  props.positions = positions;\n  props.positions64Low = positions64Low;\n  props.elevations = elevations;\n  props.fillColors = fillColors;\n  props.lineColors = lineColors;\n  props.pickingColors = pickingColors;\n\n  calculatePosition(props);\n}\n");

exports.default = _default;
},{"./solid-polygon-layer-vertex-main.glsl":"node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-main.glsl.js"}],"node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-side.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _solidPolygonLayerVertexMain = _interopRequireDefault(require("./solid-polygon-layer-vertex-main.glsl"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = "#define SHADER_NAME solid-polygon-layer-vertex-shader-side\n#define IS_SIDE_VERTEX\n\n\nattribute vec3 instancePositions;\nattribute vec3 nextPositions;\nattribute vec3 instancePositions64Low;\nattribute vec3 nextPositions64Low;\nattribute float instanceElevations;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\n".concat(_solidPolygonLayerVertexMain.default, "\n\nvoid main(void) {\n  PolygonProps props;\n\n  #if RING_WINDING_ORDER_CW == 1\n    props.positions = instancePositions;\n    props.positions64Low = instancePositions64Low;\n    props.nextPositions = nextPositions;\n    props.nextPositions64Low = nextPositions64Low;\n  #else\n    props.positions = nextPositions;\n    props.positions64Low = nextPositions64Low;\n    props.nextPositions = instancePositions;\n    props.nextPositions64Low = instancePositions64Low;\n  #endif\n  props.elevations = instanceElevations;\n  props.fillColors = instanceFillColors;\n  props.lineColors = instanceLineColors;\n  props.pickingColors = instancePickingColors;\n\n  calculatePosition(props);\n}\n");

exports.default = _default;
},{"./solid-polygon-layer-vertex-main.glsl":"node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-main.glsl.js"}],"node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-fragment.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME solid-polygon-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\n\nvoid main(void) {\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _core = require("@deck.gl/core");

var _core2 = require("@luma.gl/core");

var _polygonTesselator = _interopRequireDefault(require("./polygon-tesselator"));

var _solidPolygonLayerVertexTop = _interopRequireDefault(require("./solid-polygon-layer-vertex-top.glsl"));

var _solidPolygonLayerVertexSide = _interopRequireDefault(require("./solid-polygon-layer-vertex-side.glsl"));

var _solidPolygonLayerFragment = _interopRequireDefault(require("./solid-polygon-layer-fragment.glsl"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const DEFAULT_COLOR = [0, 0, 0, 255];
const defaultProps = {
  filled: true,
  extruded: false,
  wireframe: false,
  _normalize: true,
  _windingOrder: 'CW',
  elevationScale: {
    type: 'number',
    min: 0,
    value: 1
  },
  getPolygon: {
    type: 'accessor',
    value: f => f.polygon
  },
  getElevation: {
    type: 'accessor',
    value: 1000
  },
  getFillColor: {
    type: 'accessor',
    value: DEFAULT_COLOR
  },
  getLineColor: {
    type: 'accessor',
    value: DEFAULT_COLOR
  },
  material: true
};
const ATTRIBUTE_TRANSITION = {
  enter: (value, chunk) => {
    return chunk.length ? chunk.subarray(chunk.length - value.length) : value;
  }
};

class SolidPolygonLayer extends _core.Layer {
  getShaders(type) {
    return super.getShaders({
      vs: type === 'top' ? _solidPolygonLayerVertexTop.default : _solidPolygonLayerVertexSide.default,
      fs: _solidPolygonLayerFragment.default,
      defines: {
        RING_WINDING_ORDER_CW: !this.props._normalize && this.props._windingOrder === 'CCW' ? 0 : 1
      },
      modules: [_core.project32, _core.gouraudLighting, _core.picking]
    });
  }

  get wrapLongitude() {
    return false;
  }

  initializeState() {
    const {
      gl,
      viewport
    } = this.context;
    let {
      coordinateSystem
    } = this.props;

    if (viewport.isGeospatial && coordinateSystem === _core.COORDINATE_SYSTEM.DEFAULT) {
      coordinateSystem = _core.COORDINATE_SYSTEM.LNGLAT;
    }

    this.setState({
      numInstances: 0,
      polygonTesselator: new _polygonTesselator.default({
        preproject: coordinateSystem === _core.COORDINATE_SYSTEM.LNGLAT && viewport.projectFlat,
        fp64: this.use64bitPositions(),
        IndexType: !gl || (0, _core2.hasFeatures)(gl, _core2.FEATURES.ELEMENT_INDEX_UINT32) ? Uint32Array : Uint16Array
      })
    });
    const attributeManager = this.getAttributeManager();
    const noAlloc = true;
    attributeManager.remove(['instancePickingColors']);
    attributeManager.add({
      indices: {
        size: 1,
        isIndexed: true,
        update: this.calculateIndices,
        noAlloc
      },
      positions: {
        size: 3,
        type: 5130,
        fp64: this.use64bitPositions(),
        transition: ATTRIBUTE_TRANSITION,
        accessor: 'getPolygon',
        update: this.calculatePositions,
        noAlloc,
        shaderAttributes: {
          positions: {
            vertexOffset: 0,
            divisor: 0
          },
          instancePositions: {
            vertexOffset: 0,
            divisor: 1
          },
          nextPositions: {
            vertexOffset: 1,
            divisor: 1
          }
        }
      },
      vertexValid: {
        size: 1,
        divisor: 1,
        type: 5121,
        update: this.calculateVertexValid,
        noAlloc
      },
      elevations: {
        size: 1,
        transition: ATTRIBUTE_TRANSITION,
        accessor: 'getElevation',
        shaderAttributes: {
          elevations: {
            divisor: 0
          },
          instanceElevations: {
            divisor: 1
          }
        }
      },
      fillColors: {
        alias: 'colors',
        size: this.props.colorFormat.length,
        type: 5121,
        normalized: true,
        transition: ATTRIBUTE_TRANSITION,
        accessor: 'getFillColor',
        defaultValue: DEFAULT_COLOR,
        shaderAttributes: {
          fillColors: {
            divisor: 0
          },
          instanceFillColors: {
            divisor: 1
          }
        }
      },
      lineColors: {
        alias: 'colors',
        size: this.props.colorFormat.length,
        type: 5121,
        normalized: true,
        transition: ATTRIBUTE_TRANSITION,
        accessor: 'getLineColor',
        defaultValue: DEFAULT_COLOR,
        shaderAttributes: {
          lineColors: {
            divisor: 0
          },
          instanceLineColors: {
            divisor: 1
          }
        }
      },
      pickingColors: {
        size: 3,
        type: 5121,
        accessor: (object, {
          index,
          target: value
        }) => this.encodePickingColor(object && object.__source ? object.__source.index : index, value),
        shaderAttributes: {
          pickingColors: {
            divisor: 0
          },
          instancePickingColors: {
            divisor: 1
          }
        }
      }
    });
  }

  getPickingInfo(params) {
    const info = super.getPickingInfo(params);
    const {
      index
    } = info;
    const {
      data
    } = this.props;

    if (data[0] && data[0].__source) {
      info.object = data.find(d => d.__source.index === index);
    }

    return info;
  }

  disablePickingIndex(objectIndex) {
    const {
      data
    } = this.props;

    if (data[0] && data[0].__source) {
      for (let i = 0; i < data.length; i++) {
        if (data[i].__source.index === objectIndex) {
          this._disablePickingIndex(i);
        }
      }
    } else {
      this._disablePickingIndex(objectIndex);
    }
  }

  draw({
    uniforms
  }) {
    const {
      extruded,
      filled,
      wireframe,
      elevationScale
    } = this.props;
    const {
      topModel,
      sideModel,
      polygonTesselator
    } = this.state;
    const renderUniforms = { ...uniforms,
      extruded: Boolean(extruded),
      elevationScale
    };

    if (sideModel) {
      sideModel.setInstanceCount(polygonTesselator.instanceCount - 1);
      sideModel.setUniforms(renderUniforms);

      if (wireframe) {
        sideModel.setDrawMode(3);
        sideModel.setUniforms({
          isWireframe: true
        }).draw();
      }

      if (filled) {
        sideModel.setDrawMode(6);
        sideModel.setUniforms({
          isWireframe: false
        }).draw();
      }
    }

    if (topModel) {
      topModel.setVertexCount(polygonTesselator.vertexCount);
      topModel.setUniforms(renderUniforms).draw();
    }
  }

  updateState(updateParams) {
    super.updateState(updateParams);
    this.updateGeometry(updateParams);
    const {
      props,
      oldProps,
      changeFlags
    } = updateParams;
    const attributeManager = this.getAttributeManager();
    const regenerateModels = changeFlags.extensionsChanged || props.filled !== oldProps.filled || props.extruded !== oldProps.extruded;

    if (regenerateModels) {
      var _this$state$models;

      (_this$state$models = this.state.models) === null || _this$state$models === void 0 ? void 0 : _this$state$models.forEach(model => model.delete());
      this.setState(this._getModels(this.context.gl));
      attributeManager.invalidateAll();
    }
  }

  updateGeometry({
    props,
    oldProps,
    changeFlags
  }) {
    const geometryConfigChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon);

    if (geometryConfigChanged) {
      const {
        polygonTesselator
      } = this.state;
      const buffers = props.data.attributes || {};
      polygonTesselator.updateGeometry({
        data: props.data,
        normalize: props._normalize,
        geometryBuffer: buffers.getPolygon,
        buffers,
        getGeometry: props.getPolygon,
        positionFormat: props.positionFormat,
        wrapLongitude: props.wrapLongitude,
        resolution: this.context.viewport.resolution,
        fp64: this.use64bitPositions(),
        dataChanged: changeFlags.dataChanged
      });
      this.setState({
        numInstances: polygonTesselator.instanceCount,
        startIndices: polygonTesselator.vertexStarts
      });

      if (!changeFlags.dataChanged) {
        this.getAttributeManager().invalidateAll();
      }
    }
  }

  _getModels(gl) {
    const {
      id,
      filled,
      extruded
    } = this.props;
    let topModel;
    let sideModel;

    if (filled) {
      const shaders = this.getShaders('top');
      shaders.defines.NON_INSTANCED_MODEL = 1;
      topModel = new _core2.Model(gl, { ...shaders,
        id: "".concat(id, "-top"),
        drawMode: 4,
        attributes: {
          vertexPositions: new Float32Array([0, 1])
        },
        uniforms: {
          isWireframe: false,
          isSideVertex: false
        },
        vertexCount: 0,
        isIndexed: true
      });
    }

    if (extruded) {
      sideModel = new _core2.Model(gl, { ...this.getShaders('side'),
        id: "".concat(id, "-side"),
        geometry: new _core2.Geometry({
          drawMode: 1,
          vertexCount: 4,
          attributes: {
            vertexPositions: {
              size: 2,
              value: new Float32Array([1, 0, 0, 0, 0, 1, 1, 1])
            }
          }
        }),
        instanceCount: 0,
        isInstanced: 1
      });
      sideModel.userData.excludeAttributes = {
        indices: true
      };
    }

    return {
      models: [sideModel, topModel].filter(Boolean),
      topModel,
      sideModel
    };
  }

  calculateIndices(attribute) {
    const {
      polygonTesselator
    } = this.state;
    attribute.startIndices = polygonTesselator.indexStarts;
    attribute.value = polygonTesselator.get('indices');
  }

  calculatePositions(attribute) {
    const {
      polygonTesselator
    } = this.state;
    attribute.startIndices = polygonTesselator.vertexStarts;
    attribute.value = polygonTesselator.get('positions');
  }

  calculateVertexValid(attribute) {
    attribute.value = this.state.polygonTesselator.get('vertexValid');
  }

}

exports.default = SolidPolygonLayer;
SolidPolygonLayer.layerName = 'SolidPolygonLayer';
SolidPolygonLayer.defaultProps = defaultProps;
},{"@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","./polygon-tesselator":"node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/polygon-tesselator.js","./solid-polygon-layer-vertex-top.glsl":"node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-top.glsl.js","./solid-polygon-layer-vertex-side.glsl":"node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-side.glsl.js","./solid-polygon-layer-fragment.glsl":"node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-fragment.glsl.js"}],"node_modules/@deck.gl/layers/dist/esm/utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.replaceInRange = replaceInRange;

function replaceInRange({
  data,
  getIndex,
  dataRange,
  replace
}) {
  const {
    startRow = 0,
    endRow = Infinity
  } = dataRange;
  const count = data.length;
  let replaceStart = count;
  let replaceEnd = count;

  for (let i = 0; i < count; i++) {
    const row = getIndex(data[i]);

    if (replaceStart > i && row >= startRow) {
      replaceStart = i;
    }

    if (row >= endRow) {
      replaceEnd = i;
      break;
    }
  }

  let index = replaceStart;
  const dataLengthChanged = replaceEnd - replaceStart !== replace.length;
  const endChunk = dataLengthChanged && data.slice(replaceEnd);

  for (let i = 0; i < replace.length; i++) {
    data[index++] = replace[i];
  }

  if (dataLengthChanged) {
    for (let i = 0; i < endChunk.length; i++) {
      data[index++] = endChunk[i];
    }

    data.length = index;
  }

  return {
    startRow: replaceStart,
    endRow: replaceStart + replace.length
  };
}
},{}],"node_modules/@deck.gl/layers/dist/esm/polygon-layer/polygon-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _core = require("@deck.gl/core");

var _solidPolygonLayer = _interopRequireDefault(require("../solid-polygon-layer/solid-polygon-layer"));

var _pathLayer = _interopRequireDefault(require("../path-layer/path-layer"));

var Polygon = _interopRequireWildcard(require("../solid-polygon-layer/polygon"));

var _utils = require("../utils");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const defaultLineColor = [0, 0, 0, 255];
const defaultFillColor = [0, 0, 0, 255];
const defaultProps = {
  stroked: true,
  filled: true,
  extruded: false,
  elevationScale: 1,
  wireframe: false,
  _normalize: true,
  _windingOrder: 'CW',
  lineWidthUnits: 'meters',
  lineWidthScale: 1,
  lineWidthMinPixels: 0,
  lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,
  lineJointRounded: false,
  lineMiterLimit: 4,
  getPolygon: {
    type: 'accessor',
    value: f => f.polygon
  },
  getFillColor: {
    type: 'accessor',
    value: defaultFillColor
  },
  getLineColor: {
    type: 'accessor',
    value: defaultLineColor
  },
  getLineWidth: {
    type: 'accessor',
    value: 1
  },
  getElevation: {
    type: 'accessor',
    value: 1000
  },
  material: true
};

class PolygonLayer extends _core.CompositeLayer {
  initializeState() {
    this.state = {
      paths: []
    };

    if (this.props.getLineDashArray) {
      _core.log.removed('getLineDashArray', 'PathStyleExtension')();
    }
  }

  updateState({
    oldProps,
    props,
    changeFlags
  }) {
    const geometryChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon);

    if (geometryChanged && Array.isArray(changeFlags.dataChanged)) {
      const paths = this.state.paths.slice();
      const pathsDiff = changeFlags.dataChanged.map(dataRange => (0, _utils.replaceInRange)({
        data: paths,
        getIndex: p => p.__source.index,
        dataRange,
        replace: this._getPaths(dataRange)
      }));
      this.setState({
        paths,
        pathsDiff
      });
    } else if (geometryChanged) {
      this.setState({
        paths: this._getPaths(),
        pathsDiff: null
      });
    }
  }

  _getPaths(dataRange = {}) {
    const {
      data,
      getPolygon,
      positionFormat,
      _normalize
    } = this.props;
    const paths = [];
    const positionSize = positionFormat === 'XY' ? 2 : 3;
    const {
      startRow,
      endRow
    } = dataRange;
    const {
      iterable,
      objectInfo
    } = (0, _core.createIterable)(data, startRow, endRow);

    for (const object of iterable) {
      objectInfo.index++;
      let polygon = getPolygon(object, objectInfo);

      if (_normalize) {
        polygon = Polygon.normalize(polygon, positionSize);
      }

      const {
        holeIndices
      } = polygon;
      const positions = polygon.positions || polygon;

      if (holeIndices) {
        for (let i = 0; i <= holeIndices.length; i++) {
          const path = positions.slice(holeIndices[i - 1] || 0, holeIndices[i] || positions.length);
          paths.push(this.getSubLayerRow({
            path
          }, object, objectInfo.index));
        }
      } else {
        paths.push(this.getSubLayerRow({
          path: positions
        }, object, objectInfo.index));
      }
    }

    return paths;
  }

  renderLayers() {
    const {
      data,
      _dataDiff,
      stroked,
      filled,
      extruded,
      wireframe,
      _normalize,
      _windingOrder,
      elevationScale,
      transitions,
      positionFormat
    } = this.props;
    const {
      lineWidthUnits,
      lineWidthScale,
      lineWidthMinPixels,
      lineWidthMaxPixels,
      lineJointRounded,
      lineMiterLimit,
      lineDashJustified
    } = this.props;
    const {
      getFillColor,
      getLineColor,
      getLineWidth,
      getLineDashArray,
      getElevation,
      getPolygon,
      updateTriggers,
      material
    } = this.props;
    const {
      paths,
      pathsDiff
    } = this.state;
    const FillLayer = this.getSubLayerClass('fill', _solidPolygonLayer.default);
    const StrokeLayer = this.getSubLayerClass('stroke', _pathLayer.default);
    const polygonLayer = this.shouldRenderSubLayer('fill', paths) && new FillLayer({
      _dataDiff,
      extruded,
      elevationScale,
      filled,
      wireframe,
      _normalize,
      _windingOrder,
      getElevation,
      getFillColor,
      getLineColor: extruded && wireframe ? getLineColor : defaultLineColor,
      material,
      transitions
    }, this.getSubLayerProps({
      id: 'fill',
      updateTriggers: {
        getPolygon: updateTriggers.getPolygon,
        getElevation: updateTriggers.getElevation,
        getFillColor: updateTriggers.getFillColor,
        lineColors: extruded && wireframe,
        getLineColor: updateTriggers.getLineColor
      }
    }), {
      data,
      positionFormat,
      getPolygon
    });
    const polygonLineLayer = !extruded && stroked && this.shouldRenderSubLayer('stroke', paths) && new StrokeLayer({
      _dataDiff: pathsDiff && (() => pathsDiff),
      widthUnits: lineWidthUnits,
      widthScale: lineWidthScale,
      widthMinPixels: lineWidthMinPixels,
      widthMaxPixels: lineWidthMaxPixels,
      jointRounded: lineJointRounded,
      miterLimit: lineMiterLimit,
      dashJustified: lineDashJustified,
      _pathType: 'loop',
      transitions: transitions && {
        getWidth: transitions.getLineWidth,
        getColor: transitions.getLineColor,
        getPath: transitions.getPolygon
      },
      getColor: this.getSubLayerAccessor(getLineColor),
      getWidth: this.getSubLayerAccessor(getLineWidth),
      getDashArray: this.getSubLayerAccessor(getLineDashArray)
    }, this.getSubLayerProps({
      id: 'stroke',
      updateTriggers: {
        getWidth: updateTriggers.getLineWidth,
        getColor: updateTriggers.getLineColor,
        getDashArray: updateTriggers.getLineDashArray
      }
    }), {
      data: paths,
      positionFormat,
      getPath: x => x.path
    });
    return [!extruded && polygonLayer, polygonLineLayer, extruded && polygonLayer];
  }

}

exports.default = PolygonLayer;
PolygonLayer.layerName = 'PolygonLayer';
PolygonLayer.defaultProps = defaultProps;
},{"@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","../solid-polygon-layer/solid-polygon-layer":"node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer.js","../path-layer/path-layer":"node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer.js","../solid-polygon-layer/polygon":"node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/polygon.js","../utils":"node_modules/@deck.gl/layers/dist/esm/utils.js"}],"node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson-binary.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.binaryToFeatureForAccesor = binaryToFeatureForAccesor;
exports.calculatePickingColors = calculatePickingColors;

function binaryToFeatureForAccesor(data, index) {
  if (!data) {
    return null;
  }

  const featureIndex = 'startIndices' in data ? data.startIndices[index] : index;
  const geometryIndex = data.featureIds.value[featureIndex];

  if (featureIndex !== -1) {
    return getPropertiesForIndex(data, geometryIndex, featureIndex);
  }

  return null;
}

function getPropertiesForIndex(data, propertiesIndex, numericPropsIndex) {
  const feature = {
    properties: { ...data.properties[propertiesIndex]
    }
  };

  for (const prop in data.numericProps) {
    feature.properties[prop] = data.numericProps[prop].value[numericPropsIndex];
  }

  return feature;
}

function calculatePickingColors(geojsonBinary, encodePickingColor) {
  const pickingColors = {
    points: null,
    lines: null,
    polygons: null
  };

  for (const key in pickingColors) {
    const featureIds = geojsonBinary[key].globalFeatureIds.value;
    pickingColors[key] = new Uint8ClampedArray(featureIds.length * 3);
    const pickingColor = [];

    for (let i = 0; i < featureIds.length; i++) {
      encodePickingColor(featureIds[i], pickingColor);
      pickingColors[key][i * 3 + 0] = pickingColor[0];
      pickingColors[key][i * 3 + 1] = pickingColor[1];
      pickingColors[key][i * 3 + 2] = pickingColor[2];
    }
  }

  return pickingColors;
}
},{}],"node_modules/@deck.gl/layers/dist/esm/text-layer/multi-icon-layer/multi-icon-layer-fragment.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME multi-icon-layer-fragment-shader\n\nprecision highp float;\n\nuniform float opacity;\nuniform sampler2D iconsTexture;\nuniform float gamma;\nuniform bool sdf;\nuniform float alphaCutoff;\nuniform float buffer;\nuniform float outlineBuffer;\nuniform vec4 outlineColor;\n\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  if (!picking_uActive) {\n    float alpha = texture2D(iconsTexture, vTextureCoords).a;\n    vec4 color = vColor;\n    if (sdf) {\n      float distance = alpha;\n      alpha = smoothstep(buffer - gamma, buffer + gamma, distance);\n\n      if (outlineBuffer > 0.0) {\n        float inFill = alpha;\n        float inBorder = smoothstep(outlineBuffer - gamma, outlineBuffer + gamma, distance);\n        color = mix(outlineColor, vColor, inFill);\n        alpha = inBorder;\n      }\n    }\n    float a = alpha * color.a;\n    \n    if (a < alphaCutoff) {\n      discard;\n    }\n\n    gl_FragColor = vec4(color.rgb, a * opacity);\n  }\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/text-layer/multi-icon-layer/multi-icon-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _core = require("@deck.gl/core");

var _iconLayer = _interopRequireDefault(require("../../icon-layer/icon-layer"));

var _multiIconLayerFragment = _interopRequireDefault(require("./multi-icon-layer-fragment.glsl"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const DEFAULT_BUFFER = 192.0 / 256;
const EMPTY_ARRAY = [];
const defaultProps = {
  getIconOffsets: {
    type: 'accessor',
    value: x => x.offsets
  },
  alphaCutoff: 0.001,
  smoothing: 0.1,
  outlineWidth: 0,
  outlineColor: {
    type: 'color',
    value: [0, 0, 0, 255]
  }
};

class MultiIconLayer extends _iconLayer.default {
  getShaders() {
    return { ...super.getShaders(),
      fs: _multiIconLayerFragment.default
    };
  }

  initializeState() {
    super.initializeState();
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instanceOffsets: {
        size: 2,
        accessor: 'getIconOffsets'
      },
      instancePickingColors: {
        type: 5121,
        size: 3,
        accessor: (object, {
          index,
          target: value
        }) => this.encodePickingColor(index, value)
      }
    });
  }

  updateState(params) {
    super.updateState(params);
    const {
      props,
      oldProps
    } = params;
    let {
      outlineColor
    } = props;

    if (outlineColor !== oldProps.outlineColor) {
      outlineColor = outlineColor.map(x => x / 255);
      outlineColor[3] = Number.isFinite(outlineColor[3]) ? outlineColor[3] : 1;
      this.setState({
        outlineColor
      });
    }

    if (!props.sdf && props.outlineWidth) {
      _core.log.warn("".concat(this.id, ": fontSettings.sdf is required to render outline"))();
    }
  }

  draw(params) {
    const {
      sdf,
      smoothing,
      outlineWidth
    } = this.props;
    const {
      outlineColor
    } = this.state;
    params.uniforms = { ...params.uniforms,
      buffer: DEFAULT_BUFFER,
      outlineBuffer: outlineWidth ? Math.max(smoothing, DEFAULT_BUFFER * (1 - outlineWidth)) : -1,
      gamma: smoothing,
      sdf: Boolean(sdf),
      outlineColor
    };
    super.draw(params);
  }

  getInstanceOffset(icons) {
    return icons ? Array.from(icons).map(icon => super.getInstanceOffset(icon)) : EMPTY_ARRAY;
  }

  getInstanceColorMode(icons) {
    return 1;
  }

  getInstanceIconFrame(icons) {
    return icons ? Array.from(icons).map(icon => super.getInstanceIconFrame(icon)) : EMPTY_ARRAY;
  }

}

exports.default = MultiIconLayer;
MultiIconLayer.layerName = 'MultiIconLayer';
MultiIconLayer.defaultProps = defaultProps;
},{"@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","../../icon-layer/icon-layer":"node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-layer.js","./multi-icon-layer-fragment.glsl":"node_modules/@deck.gl/layers/dist/esm/text-layer/multi-icon-layer/multi-icon-layer-fragment.glsl.js"}],"node_modules/@mapbox/tiny-sdf/index.js":[function(require,module,exports) {
'use strict';

module.exports = TinySDF;
module.exports.default = TinySDF;

var INF = 1e20;

function TinySDF(fontSize, buffer, radius, cutoff, fontFamily, fontWeight) {
    this.fontSize = fontSize || 24;
    this.buffer = buffer === undefined ? 3 : buffer;
    this.cutoff = cutoff || 0.25;
    this.fontFamily = fontFamily || 'sans-serif';
    this.fontWeight = fontWeight || 'normal';
    this.radius = radius || 8;

    // For backwards compatibility, we honor the implicit contract that the
    // size of the returned bitmap will be fontSize + buffer * 2
    var size = this.size = this.fontSize + this.buffer * 2;
    // Glyphs may be slightly larger than their fontSize. The canvas already
    // has buffer space, but create extra buffer space in the output grid for the
    // "halo" to extend into (if metric extraction is enabled)
    var gridSize = size + this.buffer * 2;

    this.canvas = document.createElement('canvas');
    this.canvas.width = this.canvas.height = size;

    this.ctx = this.canvas.getContext('2d');
    this.ctx.font = this.fontWeight + ' ' + this.fontSize + 'px ' + this.fontFamily;

    this.ctx.textAlign = 'left'; // Necessary so that RTL text doesn't have different alignment
    this.ctx.fillStyle = 'black';

    // temporary arrays for the distance transform
    this.gridOuter = new Float64Array(gridSize * gridSize);
    this.gridInner = new Float64Array(gridSize * gridSize);
    this.f = new Float64Array(gridSize);
    this.z = new Float64Array(gridSize + 1);
    this.v = new Uint16Array(gridSize);

    this.useMetrics = this.ctx.measureText('A').actualBoundingBoxLeft !== undefined;

    // hack around https://bugzilla.mozilla.org/show_bug.cgi?id=737852
    this.middle = Math.round((size / 2) * (navigator.userAgent.indexOf('Gecko/') >= 0 ? 1.2 : 1));
}

function prepareGrids(imgData, width, height, glyphWidth, glyphHeight, gridOuter, gridInner) {
    // Initialize grids outside the glyph range to alpha 0
    gridOuter.fill(INF, 0, width * height);
    gridInner.fill(0, 0, width * height);

    var offset = (width - glyphWidth) / 2; // This is zero if we're not extracting metrics

    for (var y = 0; y < glyphHeight; y++) {
        for (var x = 0; x < glyphWidth; x++) {
            var j = (y + offset) * width + x + offset;
            var a = imgData.data[4 * (y * glyphWidth + x) + 3] / 255; // alpha value
            if (a === 1) {
                gridOuter[j] = 0;
                gridInner[j] = INF;
            } else if (a === 0) {
                gridOuter[j] = INF;
                gridInner[j] = 0;
            } else {
                var b = Math.max(0, 0.5 - a);
                var c = Math.max(0, a - 0.5);
                gridOuter[j] = b * b;
                gridInner[j] = c * c;
            }
        }
    }
}

function extractAlpha(alphaChannel, width, height, gridOuter, gridInner, radius, cutoff) {
    for (var i = 0; i < width * height; i++) {
        var d = Math.sqrt(gridOuter[i]) - Math.sqrt(gridInner[i]);
        alphaChannel[i] = Math.round(255 - 255 * (d / radius + cutoff));
    }
}

TinySDF.prototype._draw = function (char, getMetrics) {
    var textMetrics = this.ctx.measureText(char);
    // Older browsers only expose the glyph width
    // This is enough for basic layout with all glyphs using the same fixed size
    var advance = textMetrics.width;

    var doubleBuffer = 2 * this.buffer;
    var width, glyphWidth, height, glyphHeight, top;

    var imgTop, imgLeft, baselinePosition;
    // If the browser supports bounding box metrics, we can generate a smaller
    // SDF. This is a significant performance win.
    if (getMetrics && this.useMetrics) {
        // The integer/pixel part of the top alignment is encoded in metrics.top
        // The remainder is implicitly encoded in the rasterization
        top = Math.floor(textMetrics.actualBoundingBoxAscent);
        baselinePosition = this.buffer + Math.ceil(textMetrics.actualBoundingBoxAscent);
        imgTop = this.buffer;
        imgLeft = this.buffer;

        // If the glyph overflows the canvas size, it will be clipped at the
        // bottom/right
        glyphWidth = Math.min(this.size,
            Math.ceil(textMetrics.actualBoundingBoxRight - textMetrics.actualBoundingBoxLeft));
        glyphHeight = Math.min(this.size - imgTop,
            Math.ceil(textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent));

        width = glyphWidth + doubleBuffer;
        height = glyphHeight + doubleBuffer;
        this.ctx.textBaseline = 'alphabetic';
    } else {
        width = glyphWidth = this.size;
        height = glyphHeight = this.size;
        // 19 points is an approximation of the "cap height" ascent from alphabetic
        // baseline (even though actual drawing is from middle baseline, we can
        // use the approximation because every glyph fills the em box)
        top = 19 * this.fontSize / 24;
        imgTop = imgLeft = 0;
        baselinePosition = this.middle;
        this.ctx.textBaseline = 'middle';
    }

    var imgData;
    if (glyphWidth && glyphHeight) {
        this.ctx.clearRect(imgLeft, imgTop, glyphWidth, glyphHeight);
        this.ctx.fillText(char, this.buffer, baselinePosition);
        imgData = this.ctx.getImageData(imgLeft, imgTop, glyphWidth, glyphHeight);
    }

    var alphaChannel = new Uint8ClampedArray(width * height);

    prepareGrids(imgData, width, height, glyphWidth, glyphHeight, this.gridOuter, this.gridInner);

    edt(this.gridOuter, width, height, this.f, this.v, this.z);
    edt(this.gridInner, width, height, this.f, this.v, this.z);

    extractAlpha(alphaChannel, width, height, this.gridOuter, this.gridInner, this.radius, this.cutoff);

    return {
        data: alphaChannel,
        metrics: {
            width: glyphWidth,
            height: glyphHeight,
            sdfWidth: width,
            sdfHeight: height,
            top: top,
            left: 0,
            advance: advance
        }
    };
};

TinySDF.prototype.draw = function (char) {
    return this._draw(char, false).data;
};

TinySDF.prototype.drawWithMetrics = function (char) {
    return this._draw(char, true);
};

// 2D Euclidean squared distance transform by Felzenszwalb & Huttenlocher https://cs.brown.edu/~pff/papers/dt-final.pdf
function edt(data, width, height, f, v, z) {
    for (var x = 0; x < width; x++) edt1d(data, x, width, height, f, v, z);
    for (var y = 0; y < height; y++) edt1d(data, y * width, 1, width, f, v, z);
}

// 1D squared distance transform
function edt1d(grid, offset, stride, length, f, v, z) {
    var q, k, s, r;
    v[0] = 0;
    z[0] = -INF;
    z[1] = INF;

    for (q = 0; q < length; q++) f[q] = grid[offset + q * stride];

    for (q = 1, k = 0, s = 0; q < length; q++) {
        do {
            r = v[k];
            s = (f[q] - f[r] + q * q - r * r) / (q - r) / 2;
        } while (s <= z[k] && --k > -1);

        k++;
        v[k] = q;
        z[k] = s;
        z[k + 1] = INF;
    }

    for (q = 0, k = 0; q < length; q++) {
        while (z[k + 1] < q) k++;
        r = v[k];
        grid[offset + q * stride] = f[r] + (q - r) * (q - r);
    }
}

},{}],"node_modules/@deck.gl/layers/dist/esm/text-layer/utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.autoWrapping = autoWrapping;
exports.buildMapping = buildMapping;
exports.getTextFromBuffer = getTextFromBuffer;
exports.nextPowOfTwo = nextPowOfTwo;
exports.transformParagraph = transformParagraph;

var _core = require("@deck.gl/core");

const MISSING_CHAR_WIDTH = 32;
const SINGLE_LINE = [];

function nextPowOfTwo(number) {
  return Math.pow(2, Math.ceil(Math.log2(number)));
}

function buildMapping({
  characterSet,
  getFontWidth,
  fontHeight,
  buffer,
  maxCanvasWidth,
  mapping = {},
  xOffset = 0,
  yOffset = 0
}) {
  let row = 0;
  let x = xOffset;
  let i = 0;

  for (const char of characterSet) {
    if (!mapping[char]) {
      const width = getFontWidth(char, i++);

      if (x + width + buffer * 2 > maxCanvasWidth) {
        x = 0;
        row++;
      }

      mapping[char] = {
        x: x + buffer,
        y: yOffset + row * (fontHeight + buffer * 2) + buffer,
        width,
        height: fontHeight
      };
      x += width + buffer * 2;
    }
  }

  const rowHeight = fontHeight + buffer * 2;
  return {
    mapping,
    xOffset: x,
    yOffset: yOffset + row * rowHeight,
    canvasHeight: nextPowOfTwo(yOffset + (row + 1) * rowHeight)
  };
}

function getTextWidth(text, startIndex, endIndex, mapping) {
  let width = 0;

  for (let i = startIndex; i < endIndex; i++) {
    const character = text[i];
    let frameWidth = null;
    const frame = mapping && mapping[character];

    if (frame) {
      frameWidth = frame.width;
    }

    width += frameWidth;
  }

  return width;
}

function breakAll(text, startIndex, endIndex, maxWidth, iconMapping, target) {
  let rowStartCharIndex = startIndex;
  let rowOffsetLeft = 0;

  for (let i = startIndex; i < endIndex; i++) {
    const textWidth = getTextWidth(text, i, i + 1, iconMapping);

    if (rowOffsetLeft + textWidth > maxWidth) {
      if (rowStartCharIndex < i) {
        target.push(i);
      }

      rowStartCharIndex = i;
      rowOffsetLeft = 0;
    }

    rowOffsetLeft += textWidth;
  }

  return rowOffsetLeft;
}

function breakWord(text, startIndex, endIndex, maxWidth, iconMapping, target) {
  let rowStartCharIndex = startIndex;
  let groupStartCharIndex = startIndex;
  let groupEndCharIndex = startIndex;
  let rowOffsetLeft = 0;

  for (let i = startIndex; i < endIndex; i++) {
    if (text[i] === ' ') {
      groupEndCharIndex = i + 1;
    } else if (text[i + 1] === ' ' || i + 1 === endIndex) {
      groupEndCharIndex = i + 1;
    }

    if (groupEndCharIndex > groupStartCharIndex) {
      let groupWidth = getTextWidth(text, groupStartCharIndex, groupEndCharIndex, iconMapping);

      if (rowOffsetLeft + groupWidth > maxWidth) {
        if (rowStartCharIndex < groupStartCharIndex) {
          target.push(groupStartCharIndex);
          rowStartCharIndex = groupStartCharIndex;
          rowOffsetLeft = 0;
        }

        if (groupWidth > maxWidth) {
          groupWidth = breakAll(text, groupStartCharIndex, groupEndCharIndex, maxWidth, iconMapping, target);
          rowStartCharIndex = target[target.length - 1];
        }
      }

      groupStartCharIndex = groupEndCharIndex;
      rowOffsetLeft += groupWidth;
    }
  }

  return rowOffsetLeft;
}

function autoWrapping(text, wordBreak, maxWidth, iconMapping, startIndex = 0, endIndex) {
  if (endIndex === undefined) {
    endIndex = text.length;
  }

  const result = [];

  if (wordBreak === 'break-all') {
    breakAll(text, startIndex, endIndex, maxWidth, iconMapping, result);
  } else {
    breakWord(text, startIndex, endIndex, maxWidth, iconMapping, result);
  }

  return result;
}

function transformRow(line, startIndex, endIndex, iconMapping, leftOffsets, rowSize) {
  let x = 0;
  let rowHeight = 0;

  for (let i = startIndex; i < endIndex; i++) {
    const character = line[i];
    const frame = iconMapping[character];

    if (frame) {
      if (!rowHeight) {
        rowHeight = frame.height;
      }

      leftOffsets[i] = x + frame.width / 2;
      x += frame.width;
    } else {
      _core.log.warn("Missing character: ".concat(character, " (").concat(character.codePointAt(0), ")"))();

      leftOffsets[i] = x;
      x += MISSING_CHAR_WIDTH;
    }
  }

  rowSize[0] = x;
  rowSize[1] = rowHeight;
}

function transformParagraph(paragraph, lineHeight, wordBreak, maxWidth, iconMapping) {
  paragraph = Array.from(paragraph);
  const numCharacters = paragraph.length;
  const x = new Array(numCharacters);
  const y = new Array(numCharacters);
  const rowWidth = new Array(numCharacters);
  const autoWrappingEnabled = (wordBreak === 'break-word' || wordBreak === 'break-all') && isFinite(maxWidth) && maxWidth > 0;
  const size = [0, 0];
  const rowSize = [];
  let rowOffsetTop = 0;
  let lineStartIndex = 0;
  let lineEndIndex = 0;

  for (let i = 0; i <= numCharacters; i++) {
    const char = paragraph[i];

    if (char === '\n' || i === numCharacters) {
      lineEndIndex = i;
    }

    if (lineEndIndex > lineStartIndex) {
      const rows = autoWrappingEnabled ? autoWrapping(paragraph, wordBreak, maxWidth, iconMapping, lineStartIndex, lineEndIndex) : SINGLE_LINE;

      for (let rowIndex = 0; rowIndex <= rows.length; rowIndex++) {
        const rowStart = rowIndex === 0 ? lineStartIndex : rows[rowIndex - 1];
        const rowEnd = rowIndex < rows.length ? rows[rowIndex] : lineEndIndex;
        transformRow(paragraph, rowStart, rowEnd, iconMapping, x, rowSize);

        for (let j = rowStart; j < rowEnd; j++) {
          y[j] = rowOffsetTop + rowSize[1] / 2;
          rowWidth[j] = rowSize[0];
        }

        rowOffsetTop = rowOffsetTop + rowSize[1] * lineHeight;
        size[0] = Math.max(size[0], rowSize[0]);
      }

      lineStartIndex = lineEndIndex;
    }

    if (char === '\n') {
      x[lineStartIndex] = 0;
      y[lineStartIndex] = 0;
      rowWidth[lineStartIndex] = 0;
      lineStartIndex++;
    }
  }

  size[1] = rowOffsetTop;
  return {
    x,
    y,
    rowWidth,
    size
  };
}

function getTextFromBuffer({
  value,
  length,
  stride,
  offset,
  startIndices,
  characterSet
}) {
  const bytesPerElement = value.BYTES_PER_ELEMENT;
  const elementStride = stride ? stride / bytesPerElement : 1;
  const elementOffset = offset ? offset / bytesPerElement : 0;
  const characterCount = startIndices[length] || Math.ceil((value.length - elementOffset) / elementStride);
  const autoCharacterSet = characterSet && new Set();
  const texts = new Array(length);
  let codes = value;

  if (elementStride > 1 || elementOffset > 0) {
    codes = new value.constructor(characterCount);

    for (let i = 0; i < characterCount; i++) {
      codes[i] = value[i * elementStride + elementOffset];
    }
  }

  for (let index = 0; index < length; index++) {
    const startIndex = startIndices[index];
    const endIndex = startIndices[index + 1] || characterCount;
    const codesAtIndex = codes.subarray(startIndex, endIndex);
    texts[index] = String.fromCodePoint.apply(null, codesAtIndex);

    if (autoCharacterSet) {
      codesAtIndex.forEach(autoCharacterSet.add, autoCharacterSet);
    }
  }

  if (autoCharacterSet) {
    for (const charCode of autoCharacterSet) {
      characterSet.add(String.fromCodePoint(charCode));
    }
  }

  return {
    texts,
    characterCount
  };
}
},{"@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js"}],"node_modules/@deck.gl/layers/dist/esm/text-layer/lru-cache.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

class LRUCache {
  constructor(limit = 5) {
    this.limit = limit;
    this.clear();
  }

  clear() {
    this._cache = {};
    this._order = [];
  }

  get(key) {
    const value = this._cache[key];

    if (value) {
      this._deleteOrder(key);

      this._appendOrder(key);
    }

    return value;
  }

  set(key, value) {
    if (!this._cache[key]) {
      if (Object.keys(this._cache).length === this.limit) {
        this.delete(this._order[0]);
      }

      this._cache[key] = value;

      this._appendOrder(key);
    } else {
      this.delete(key);
      this._cache[key] = value;

      this._appendOrder(key);
    }
  }

  delete(key) {
    const value = this._cache[key];

    if (value) {
      this._deleteCache(key);

      this._deleteOrder(key);
    }
  }

  _deleteCache(key) {
    delete this._cache[key];
  }

  _deleteOrder(key) {
    const index = this._order.findIndex(o => o === key);

    if (index >= 0) {
      this._order.splice(index, 1);
    }
  }

  _appendOrder(key) {
    this._order.push(key);
  }

}

exports.default = LRUCache;
},{}],"node_modules/@deck.gl/layers/dist/esm/text-layer/font-atlas-manager.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.DEFAULT_RADIUS = exports.DEFAULT_FONT_WEIGHT = exports.DEFAULT_FONT_SIZE = exports.DEFAULT_FONT_FAMILY = exports.DEFAULT_CUTOFF = exports.DEFAULT_CHAR_SET = exports.DEFAULT_BUFFER = void 0;
exports.setFontAtlasCacheLimit = setFontAtlasCacheLimit;

var _tinySdf = _interopRequireDefault(require("@mapbox/tiny-sdf"));

var _core = require("@deck.gl/core");

var _utils = require("./utils");

var _lruCache = _interopRequireDefault(require("./lru-cache"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getDefaultCharacterSet() {
  const charSet = [];

  for (let i = 32; i < 128; i++) {
    charSet.push(String.fromCharCode(i));
  }

  return charSet;
}

const DEFAULT_CHAR_SET = getDefaultCharacterSet();
exports.DEFAULT_CHAR_SET = DEFAULT_CHAR_SET;
const DEFAULT_FONT_FAMILY = 'Monaco, monospace';
exports.DEFAULT_FONT_FAMILY = DEFAULT_FONT_FAMILY;
const DEFAULT_FONT_WEIGHT = 'normal';
exports.DEFAULT_FONT_WEIGHT = DEFAULT_FONT_WEIGHT;
const DEFAULT_FONT_SIZE = 64;
exports.DEFAULT_FONT_SIZE = DEFAULT_FONT_SIZE;
const DEFAULT_BUFFER = 4;
exports.DEFAULT_BUFFER = DEFAULT_BUFFER;
const DEFAULT_CUTOFF = 0.25;
exports.DEFAULT_CUTOFF = DEFAULT_CUTOFF;
const DEFAULT_RADIUS = 12;
exports.DEFAULT_RADIUS = DEFAULT_RADIUS;
const MAX_CANVAS_WIDTH = 1024;
const BASELINE_SCALE = 0.9;
const HEIGHT_SCALE = 1.2;
const CACHE_LIMIT = 3;
let cache = new _lruCache.default(CACHE_LIMIT);
const VALID_PROPS = ['fontFamily', 'fontWeight', 'characterSet', 'fontSize', 'sdf', 'buffer', 'cutoff', 'radius'];

function getNewChars(key, characterSet) {
  const cachedFontAtlas = cache.get(key);

  if (!cachedFontAtlas) {
    return characterSet;
  }

  const newChars = [];
  const cachedMapping = cachedFontAtlas.mapping;
  let cachedCharSet = Object.keys(cachedMapping);
  cachedCharSet = new Set(cachedCharSet);
  let charSet = characterSet;

  if (charSet instanceof Array) {
    charSet = new Set(charSet);
  }

  charSet.forEach(char => {
    if (!cachedCharSet.has(char)) {
      newChars.push(char);
    }
  });
  return newChars;
}

function populateAlphaChannel(alphaChannel, imageData) {
  for (let i = 0; i < alphaChannel.length; i++) {
    imageData.data[4 * i + 3] = alphaChannel[i];
  }
}

function setTextStyle(ctx, fontFamily, fontSize, fontWeight) {
  ctx.font = "".concat(fontWeight, " ").concat(fontSize, "px ").concat(fontFamily);
  ctx.fillStyle = '#000';
  ctx.textBaseline = 'baseline';
  ctx.textAlign = 'left';
}

function setFontAtlasCacheLimit(limit) {
  _core.log.assert(Number.isFinite(limit) && limit >= CACHE_LIMIT, 'Invalid cache limit');

  cache = new _lruCache.default(limit);
}

class FontAtlasManager {
  constructor() {
    this.props = {
      fontFamily: DEFAULT_FONT_FAMILY,
      fontWeight: DEFAULT_FONT_WEIGHT,
      characterSet: DEFAULT_CHAR_SET,
      fontSize: DEFAULT_FONT_SIZE,
      buffer: DEFAULT_BUFFER,
      sdf: false,
      cutoff: DEFAULT_CUTOFF,
      radius: DEFAULT_RADIUS
    };
    this._key = null;
    this._atlas = null;
  }

  get texture() {
    return this._atlas;
  }

  get mapping() {
    return this._atlas && this._atlas.mapping;
  }

  get scale() {
    return HEIGHT_SCALE;
  }

  setProps(props = {}) {
    VALID_PROPS.forEach(prop => {
      if (prop in props) {
        this.props[prop] = props[prop];
      }
    });
    const oldKey = this._key;
    this._key = this._getKey();
    const charSet = getNewChars(this._key, this.props.characterSet);
    const cachedFontAtlas = cache.get(this._key);

    if (cachedFontAtlas && charSet.length === 0) {
      if (this._key !== oldKey) {
        this._atlas = cachedFontAtlas;
      }

      return;
    }

    const fontAtlas = this._generateFontAtlas(this._key, charSet, cachedFontAtlas);

    this._atlas = fontAtlas;
    cache.set(this._key, fontAtlas);
  }

  _generateFontAtlas(key, characterSet, cachedFontAtlas) {
    const {
      fontFamily,
      fontWeight,
      fontSize,
      buffer,
      sdf,
      radius,
      cutoff
    } = this.props;
    let canvas = cachedFontAtlas && cachedFontAtlas.data;

    if (!canvas) {
      canvas = document.createElement('canvas');
      canvas.width = MAX_CANVAS_WIDTH;
    }

    const ctx = canvas.getContext('2d');
    setTextStyle(ctx, fontFamily, fontSize, fontWeight);
    const {
      mapping,
      canvasHeight,
      xOffset,
      yOffset
    } = (0, _utils.buildMapping)({
      getFontWidth: char => ctx.measureText(char).width,
      fontHeight: fontSize * HEIGHT_SCALE,
      buffer,
      characterSet,
      maxCanvasWidth: MAX_CANVAS_WIDTH,
      ...(cachedFontAtlas && {
        mapping: cachedFontAtlas.mapping,
        xOffset: cachedFontAtlas.xOffset,
        yOffset: cachedFontAtlas.yOffset
      })
    });

    if (canvas.height !== canvasHeight) {
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      canvas.height = canvasHeight;
      ctx.putImageData(imageData, 0, 0);
    }

    setTextStyle(ctx, fontFamily, fontSize, fontWeight);

    if (sdf) {
      const tinySDF = new _tinySdf.default(fontSize, buffer, radius, cutoff, fontFamily, fontWeight);
      const imageData = ctx.getImageData(0, 0, tinySDF.size, tinySDF.size);

      for (const char of characterSet) {
        populateAlphaChannel(tinySDF.draw(char), imageData);
        ctx.putImageData(imageData, mapping[char].x - buffer, mapping[char].y + buffer);
      }
    } else {
      for (const char of characterSet) {
        ctx.fillText(char, mapping[char].x, mapping[char].y + fontSize * BASELINE_SCALE);
      }
    }

    return {
      xOffset,
      yOffset,
      mapping,
      data: canvas,
      width: canvas.width,
      height: canvas.height
    };
  }

  _getKey() {
    const {
      fontFamily,
      fontWeight,
      fontSize,
      buffer,
      sdf,
      radius,
      cutoff
    } = this.props;

    if (sdf) {
      return "".concat(fontFamily, " ").concat(fontWeight, " ").concat(fontSize, " ").concat(buffer, " ").concat(radius, " ").concat(cutoff);
    }

    return "".concat(fontFamily, " ").concat(fontWeight, " ").concat(fontSize, " ").concat(buffer);
  }

}

exports.default = FontAtlasManager;
},{"@mapbox/tiny-sdf":"node_modules/@mapbox/tiny-sdf/index.js","@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","./utils":"node_modules/@deck.gl/layers/dist/esm/text-layer/utils.js","./lru-cache":"node_modules/@deck.gl/layers/dist/esm/text-layer/lru-cache.js"}],"node_modules/@deck.gl/layers/dist/esm/text-layer/text-background-layer/text-background-layer-vertex.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME text-background-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute vec4 instanceRects;\nattribute float instanceSizes;\nattribute float instanceAngles;\nattribute vec2 instancePixelOffsets;\nattribute float instanceLineWidths;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\nuniform bool billboard;\nuniform float opacity;\nuniform float sizeScale;\nuniform float sizeMinPixels;\nuniform float sizeMaxPixels;\nuniform vec4 padding;\nuniform int sizeUnits;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying float vLineWidth;\nvarying vec2 uv;\nvarying vec2 dimensions;\n\nvec2 rotate_by_angle(vec2 vertex, float angle) {\n  float angle_radian = radians(angle);\n  float cos_angle = cos(angle_radian);\n  float sin_angle = sin(angle_radian);\n  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\n  return rotationMatrix * vertex;\n}\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.uv = positions;\n  geometry.pickingColor = instancePickingColors;\n  uv = positions;\n  vLineWidth = instanceLineWidths;\n  float sizePixels = clamp(\n    project_size_to_pixel(instanceSizes * sizeScale, sizeUnits),\n    sizeMinPixels, sizeMaxPixels\n  );\n\n  dimensions = instanceRects.zw * sizePixels + padding.xy + padding.zw;\n\n  vec2 pixelOffset = (positions * instanceRects.zw + instanceRects.xy) * sizePixels + mix(-padding.xy, padding.zw, positions);\n  pixelOffset = rotate_by_angle(pixelOffset, instanceAngles);\n  pixelOffset += instancePixelOffsets;\n  pixelOffset.y *= -1.0;\n\n  if (billboard)  {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    vec3 offset = vec3(pixelOffset, 0.0);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n  } else {\n    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);\n    DECKGL_FILTER_SIZE(offset_common, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position);\n  }\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);\n  DECKGL_FILTER_COLOR(vFillColor, geometry);\n  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);\n  DECKGL_FILTER_COLOR(vLineColor, geometry);\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/text-layer/text-background-layer/text-background-layer-fragment.glsl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = "#define SHADER_NAME text-background-layer-fragment-shader\n\nprecision highp float;\n\nuniform bool stroked;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying float vLineWidth;\nvarying vec2 uv;\nvarying vec2 dimensions;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  vec2 pixelPosition = uv * dimensions;\n  if (stroked) {\n    float distToEdge = min(\n      min(pixelPosition.x, dimensions.x - pixelPosition.x),\n      min(pixelPosition.y, dimensions.y - pixelPosition.y)\n    );\n    float isBorder = smoothedge(distToEdge, vLineWidth);\n    gl_FragColor = mix(vFillColor, vLineColor, isBorder);\n  } else {\n    gl_FragColor = vFillColor;\n  }\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";
exports.default = _default;
},{}],"node_modules/@deck.gl/layers/dist/esm/text-layer/text-background-layer/text-background-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _core = require("@deck.gl/core");

var _core2 = require("@luma.gl/core");

var _textBackgroundLayerVertex = _interopRequireDefault(require("./text-background-layer-vertex.glsl"));

var _textBackgroundLayerFragment = _interopRequireDefault(require("./text-background-layer-fragment.glsl"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const defaultProps = {
  billboard: true,
  sizeScale: 1,
  sizeUnits: 'pixels',
  sizeMinPixels: 0,
  sizeMaxPixels: Number.MAX_SAFE_INTEGER,
  padding: {
    type: 'array',
    value: [0, 0, 0, 0]
  },
  getPosition: {
    type: 'accessor',
    value: x => x.position
  },
  getSize: {
    type: 'accessor',
    value: 1
  },
  getAngle: {
    type: 'accessor',
    value: 0
  },
  getPixelOffset: {
    type: 'accessor',
    value: [0, 0]
  },
  getBoundingRect: {
    type: 'accessor',
    value: [0, 0, 0, 0]
  },
  getFillColor: {
    type: 'accessor',
    value: [0, 0, 0, 255]
  },
  getLineColor: {
    type: 'accessor',
    value: [0, 0, 0, 255]
  },
  getLineWidth: {
    type: 'accessor',
    value: 1
  }
};

class TextBackgroundLayer extends _core.Layer {
  getShaders() {
    return super.getShaders({
      vs: _textBackgroundLayerVertex.default,
      fs: _textBackgroundLayerFragment.default,
      modules: [_core.project32, _core.picking]
    });
  }

  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        size: 3,
        type: 5130,
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: 'getPosition'
      },
      instanceSizes: {
        size: 1,
        transition: true,
        accessor: 'getSize',
        defaultValue: 1
      },
      instanceAngles: {
        size: 1,
        transition: true,
        accessor: 'getAngle'
      },
      instanceRects: {
        size: 4,
        accessor: 'getBoundingRect'
      },
      instancePixelOffsets: {
        size: 2,
        transition: true,
        accessor: 'getPixelOffset'
      },
      instanceFillColors: {
        size: 4,
        transition: true,
        normalized: true,
        type: 5121,
        accessor: 'getFillColor',
        defaultValue: [0, 0, 0, 255]
      },
      instanceLineColors: {
        size: 4,
        transition: true,
        normalized: true,
        type: 5121,
        accessor: 'getLineColor',
        defaultValue: [0, 0, 0, 255]
      },
      instanceLineWidths: {
        size: 1,
        transition: true,
        accessor: 'getLineWidth',
        defaultValue: 1
      }
    });
  }

  updateState({
    props,
    oldProps,
    changeFlags
  }) {
    super.updateState({
      props,
      oldProps,
      changeFlags
    });

    if (changeFlags.extensionsChanged) {
      var _this$state$model;

      const {
        gl
      } = this.context;
      (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();
      this.state.model = this._getModel(gl);
      this.getAttributeManager().invalidateAll();
    }
  }

  draw({
    uniforms
  }) {
    const {
      billboard,
      sizeScale,
      sizeUnits,
      sizeMinPixels,
      sizeMaxPixels,
      getLineWidth
    } = this.props;
    let {
      padding
    } = this.props;

    if (padding.length < 4) {
      padding = [padding[0], padding[1], padding[0], padding[1]];
    }

    this.state.model.setUniforms(uniforms).setUniforms({
      billboard,
      stroked: Boolean(getLineWidth),
      padding,
      sizeUnits: _core.UNIT[sizeUnits],
      sizeScale,
      sizeMinPixels,
      sizeMaxPixels
    }).draw();
  }

  _getModel(gl) {
    const positions = [0, 0, 1, 0, 1, 1, 0, 1];
    return new _core2.Model(gl, { ...this.getShaders(),
      id: this.props.id,
      geometry: new _core2.Geometry({
        drawMode: 6,
        vertexCount: 4,
        attributes: {
          positions: {
            size: 2,
            value: new Float32Array(positions)
          }
        }
      }),
      isInstanced: true
    });
  }

}

exports.default = TextBackgroundLayer;
TextBackgroundLayer.layerName = 'TextBackgroundLayer';
TextBackgroundLayer.defaultProps = defaultProps;
},{"@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","@luma.gl/core":"node_modules/@luma.gl/core/dist/esm/index.js","./text-background-layer-vertex.glsl":"node_modules/@deck.gl/layers/dist/esm/text-layer/text-background-layer/text-background-layer-vertex.glsl.js","./text-background-layer-fragment.glsl":"node_modules/@deck.gl/layers/dist/esm/text-layer/text-background-layer/text-background-layer-fragment.glsl.js"}],"node_modules/@deck.gl/layers/dist/esm/text-layer/text-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _core = require("@deck.gl/core");

var _multiIconLayer = _interopRequireDefault(require("./multi-icon-layer/multi-icon-layer"));

var _fontAtlasManager = _interopRequireWildcard(require("./font-atlas-manager"));

var _utils = require("./utils");

var _textBackgroundLayer = _interopRequireDefault(require("./text-background-layer/text-background-layer"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const DEFAULT_FONT_SETTINGS = {
  fontSize: _fontAtlasManager.DEFAULT_FONT_SIZE,
  buffer: _fontAtlasManager.DEFAULT_BUFFER,
  sdf: false,
  radius: _fontAtlasManager.DEFAULT_RADIUS,
  cutoff: _fontAtlasManager.DEFAULT_CUTOFF,
  smoothing: 0.1
};
const TEXT_ANCHOR = {
  start: 1,
  middle: 0,
  end: -1
};
const ALIGNMENT_BASELINE = {
  top: 1,
  center: 0,
  bottom: -1
};
const DEFAULT_COLOR = [0, 0, 0, 255];
const DEFAULT_LINE_HEIGHT = 1.0;
const FONT_SETTINGS_PROPS = ['fontSize', 'buffer', 'sdf', 'radius', 'cutoff'];
const defaultProps = {
  billboard: true,
  sizeScale: 1,
  sizeUnits: 'pixels',
  sizeMinPixels: 0,
  sizeMaxPixels: Number.MAX_SAFE_INTEGER,
  background: false,
  getBackgroundColor: {
    type: 'accessor',
    value: [255, 255, 255, 255]
  },
  getBorderColor: {
    type: 'accessor',
    value: DEFAULT_COLOR
  },
  getBorderWidth: {
    type: 'accessor',
    value: 0
  },
  backgroundPadding: {
    type: 'array',
    value: [0, 0, 0, 0]
  },
  characterSet: {
    type: 'object',
    value: _fontAtlasManager.DEFAULT_CHAR_SET
  },
  fontFamily: _fontAtlasManager.DEFAULT_FONT_FAMILY,
  fontWeight: _fontAtlasManager.DEFAULT_FONT_WEIGHT,
  lineHeight: DEFAULT_LINE_HEIGHT,
  outlineWidth: {
    type: 'number',
    value: 0,
    min: 0
  },
  outlineColor: {
    type: 'color',
    value: DEFAULT_COLOR
  },
  fontSettings: {},
  wordBreak: 'break-word',
  maxWidth: {
    type: 'number',
    value: -1
  },
  getText: {
    type: 'accessor',
    value: x => x.text
  },
  getPosition: {
    type: 'accessor',
    value: x => x.position
  },
  getColor: {
    type: 'accessor',
    value: DEFAULT_COLOR
  },
  getSize: {
    type: 'accessor',
    value: 32
  },
  getAngle: {
    type: 'accessor',
    value: 0
  },
  getTextAnchor: {
    type: 'accessor',
    value: 'middle'
  },
  getAlignmentBaseline: {
    type: 'accessor',
    value: 'center'
  },
  getPixelOffset: {
    type: 'accessor',
    value: [0, 0]
  },
  backgroundColor: {
    deprecatedFor: ['background', 'getBackgroundColor']
  }
};

class TextLayer extends _core.CompositeLayer {
  initializeState() {
    this.state = {
      styleVersion: 0,
      fontAtlasManager: new _fontAtlasManager.default()
    };
  }

  updateState({
    props,
    oldProps,
    changeFlags
  }) {
    const textChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getText);
    const oldCharacterSet = this.state.characterSet;

    if (textChanged) {
      this._updateText();
    }

    const fontChanged = oldCharacterSet !== this.state.characterSet || this._fontChanged(oldProps, props);

    if (fontChanged) {
      this._updateFontAtlas(oldProps, props);
    }

    const styleChanged = fontChanged || props.lineHeight !== oldProps.lineHeight || props.wordBreak !== oldProps.wordBreak || props.maxWidth !== oldProps.maxWidth;

    if (styleChanged) {
      this.setState({
        styleVersion: this.state.styleVersion + 1
      });
    }
  }

  getPickingInfo({
    info
  }) {
    info.object = info.index >= 0 ? this.props.data[info.index] : null;
    return info;
  }

  _updateFontAtlas(oldProps, props) {
    const {
      fontSettings,
      fontFamily,
      fontWeight
    } = props;
    const {
      fontAtlasManager,
      characterSet
    } = this.state;
    fontAtlasManager.setProps({ ...DEFAULT_FONT_SETTINGS,
      ...fontSettings,
      characterSet,
      fontFamily,
      fontWeight
    });
  }

  _fontChanged(oldProps, props) {
    if (oldProps.fontFamily !== props.fontFamily || oldProps.fontWeight !== props.fontWeight) {
      return true;
    }

    if (oldProps.fontSettings === props.fontSettings) {
      return false;
    }

    const oldFontSettings = oldProps.fontSettings || {};
    const fontSettings = props.fontSettings || {};
    return FONT_SETTINGS_PROPS.some(prop => oldFontSettings[prop] !== fontSettings[prop]);
  }

  _updateText() {
    const {
      data,
      characterSet
    } = this.props;
    const textBuffer = data.attributes && data.attributes.getText;
    let {
      getText
    } = this.props;
    let {
      startIndices
    } = data;
    let numInstances;
    const autoCharacterSet = characterSet === 'auto' && new Set();

    if (textBuffer && startIndices) {
      const {
        texts,
        characterCount
      } = (0, _utils.getTextFromBuffer)({ ...(ArrayBuffer.isView(textBuffer) ? {
          value: textBuffer
        } : textBuffer),
        length: data.length,
        startIndices,
        characterSet: autoCharacterSet
      });
      numInstances = characterCount;

      getText = (_, {
        index
      }) => texts[index];
    } else {
      const {
        iterable,
        objectInfo
      } = (0, _core.createIterable)(data);
      startIndices = [0];
      numInstances = 0;

      for (const object of iterable) {
        objectInfo.index++;
        const text = Array.from(getText(object, objectInfo) || '');

        if (autoCharacterSet) {
          text.forEach(autoCharacterSet.add, autoCharacterSet);
        }

        numInstances += text.length;
        startIndices.push(numInstances);
      }
    }

    this.setState({
      getText,
      startIndices,
      numInstances,
      characterSet: autoCharacterSet || characterSet
    });
  }

  getBoundingRect(object, objectInfo) {
    const iconMapping = this.state.fontAtlasManager.mapping;
    const {
      getText
    } = this.state;
    const {
      wordBreak,
      maxWidth,
      lineHeight,
      getTextAnchor,
      getAlignmentBaseline
    } = this.props;
    const paragraph = getText(object, objectInfo) || '';
    const {
      size: [width, height]
    } = (0, _utils.transformParagraph)(paragraph, lineHeight, wordBreak, maxWidth, iconMapping);
    const anchorX = TEXT_ANCHOR[typeof getTextAnchor === 'function' ? getTextAnchor(object, objectInfo) : getTextAnchor];
    const anchorY = ALIGNMENT_BASELINE[typeof getAlignmentBaseline === 'function' ? getAlignmentBaseline(object, objectInfo) : getAlignmentBaseline];
    return [(anchorX - 1) * width / 2, (anchorY - 1) * height / 2, width, height];
  }

  getIconOffsets(object, objectInfo) {
    const iconMapping = this.state.fontAtlasManager.mapping;
    const {
      getText
    } = this.state;
    const {
      wordBreak,
      maxWidth,
      lineHeight,
      getTextAnchor,
      getAlignmentBaseline
    } = this.props;
    const paragraph = getText(object, objectInfo) || '';
    const {
      x,
      y,
      rowWidth,
      size: [width, height]
    } = (0, _utils.transformParagraph)(paragraph, lineHeight, wordBreak, maxWidth, iconMapping);
    const anchorX = TEXT_ANCHOR[typeof getTextAnchor === 'function' ? getTextAnchor(object, objectInfo) : getTextAnchor];
    const anchorY = ALIGNMENT_BASELINE[typeof getAlignmentBaseline === 'function' ? getAlignmentBaseline(object, objectInfo) : getAlignmentBaseline];
    const numCharacters = x.length;
    const offsets = new Array(numCharacters * 2);
    let index = 0;

    for (let i = 0; i < numCharacters; i++) {
      const rowOffset = (1 - anchorX) * (width - rowWidth[i]) / 2;
      offsets[index++] = (anchorX - 1) * width / 2 + rowOffset + x[i];
      offsets[index++] = (anchorY - 1) * height / 2 + y[i];
    }

    return offsets;
  }

  renderLayers() {
    const {
      startIndices,
      numInstances,
      getText,
      fontAtlasManager: {
        scale,
        texture,
        mapping
      },
      styleVersion
    } = this.state;
    const {
      data,
      _dataDiff,
      getPosition,
      getColor,
      getSize,
      getAngle,
      getPixelOffset,
      getBackgroundColor,
      getBorderColor,
      getBorderWidth,
      backgroundPadding,
      background,
      billboard,
      fontSettings,
      outlineWidth,
      outlineColor,
      sizeScale,
      sizeUnits,
      sizeMinPixels,
      sizeMaxPixels,
      transitions,
      updateTriggers
    } = this.props;
    const CharactersLayerClass = this.getSubLayerClass('characters', _multiIconLayer.default);
    const BackgroundLayerClass = this.getSubLayerClass('background', _textBackgroundLayer.default);
    return [background && new BackgroundLayerClass({
      getFillColor: getBackgroundColor,
      getLineColor: getBorderColor,
      getLineWidth: getBorderWidth,
      padding: backgroundPadding,
      getPosition,
      getSize,
      getAngle,
      getPixelOffset,
      billboard,
      sizeScale: sizeScale / this.state.fontAtlasManager.props.fontSize,
      sizeUnits,
      sizeMinPixels,
      sizeMaxPixels,
      transitions: transitions && {
        getPosition: transitions.getPosition,
        getAngle: transitions.getAngle,
        getSize: transitions.getSize,
        getFillColor: transitions.getBackgroundColor,
        getLineColor: transitions.getBorderColor,
        getLineWidth: transitions.getBorderWidth,
        getPixelOffset: transitions.getPixelOffset
      }
    }, this.getSubLayerProps({
      id: 'background',
      updateTriggers: {
        getPosition: updateTriggers.getPosition,
        getAngle: updateTriggers.getAngle,
        getSize: updateTriggers.getSize,
        getFillColor: updateTriggers.getBackgroundColor,
        getLineColor: updateTriggers.getBorderColor,
        getLineWidth: updateTriggers.getBorderWidth,
        getPixelOffset: updateTriggers.getPixelOffset,
        getBoundingRect: {
          getText: updateTriggers.getText,
          getTextAnchor: updateTriggers.getTextAnchor,
          getAlignmentBaseline: updateTriggers.getAlignmentBaseline,
          styleVersion
        }
      }
    }), {
      data: data.attributes && data.attributes.background ? {
        length: data.length,
        attributes: data.attributes.background
      } : data,
      _dataDiff,
      autoHighlight: false,
      getBoundingRect: this.getBoundingRect.bind(this)
    }), new CharactersLayerClass({
      sdf: fontSettings.sdf,
      smoothing: Number.isFinite(fontSettings.smoothing) ? fontSettings.smoothing : DEFAULT_FONT_SETTINGS.smoothing,
      outlineWidth,
      outlineColor,
      iconAtlas: texture,
      iconMapping: mapping,
      getPosition,
      getColor,
      getSize,
      getAngle,
      getPixelOffset,
      billboard,
      sizeScale: sizeScale * scale,
      sizeUnits,
      sizeMinPixels: sizeMinPixels * scale,
      sizeMaxPixels: sizeMaxPixels * scale,
      transitions: transitions && {
        getPosition: transitions.getPosition,
        getAngle: transitions.getAngle,
        getColor: transitions.getColor,
        getSize: transitions.getSize,
        getPixelOffset: transitions.getPixelOffset
      }
    }, this.getSubLayerProps({
      id: 'characters',
      updateTriggers: {
        getIcon: updateTriggers.getText,
        getPosition: updateTriggers.getPosition,
        getAngle: updateTriggers.getAngle,
        getColor: updateTriggers.getColor,
        getSize: updateTriggers.getSize,
        getPixelOffset: updateTriggers.getPixelOffset,
        getIconOffsets: {
          getText: updateTriggers.getText,
          getTextAnchor: updateTriggers.getTextAnchor,
          getAlignmentBaseline: updateTriggers.getAlignmentBaseline,
          styleVersion
        }
      }
    }), {
      data,
      _dataDiff,
      startIndices,
      numInstances,
      getIconOffsets: this.getIconOffsets.bind(this),
      getIcon: getText
    })];
  }

  static set fontAtlasCacheLimit(limit) {
    (0, _fontAtlasManager.setFontAtlasCacheLimit)(limit);
  }

}

exports.default = TextLayer;
TextLayer.layerName = 'TextLayer';
TextLayer.defaultProps = defaultProps;
},{"@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","./multi-icon-layer/multi-icon-layer":"node_modules/@deck.gl/layers/dist/esm/text-layer/multi-icon-layer/multi-icon-layer.js","./font-atlas-manager":"node_modules/@deck.gl/layers/dist/esm/text-layer/font-atlas-manager.js","./utils":"node_modules/@deck.gl/layers/dist/esm/text-layer/utils.js","./text-background-layer/text-background-layer":"node_modules/@deck.gl/layers/dist/esm/text-layer/text-background-layer/text-background-layer.js"}],"node_modules/@deck.gl/layers/dist/esm/geojson-layer/sub-layer-map.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.POLYGON_LAYER = exports.POINT_LAYER = exports.LINE_LAYER = void 0;
exports.forwardProps = forwardProps;
exports.getDefaultProps = getDefaultProps;

var _iconLayer = _interopRequireDefault(require("../icon-layer/icon-layer"));

var _scatterplotLayer = _interopRequireDefault(require("../scatterplot-layer/scatterplot-layer"));

var _textLayer = _interopRequireDefault(require("../text-layer/text-layer"));

var _pathLayer = _interopRequireDefault(require("../path-layer/path-layer"));

var _solidPolygonLayer = _interopRequireDefault(require("../solid-polygon-layer/solid-polygon-layer"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const POINT_LAYER = {
  circle: {
    type: _scatterplotLayer.default,
    props: {
      filled: 'filled',
      stroked: 'stroked',
      lineWidthMaxPixels: 'lineWidthMaxPixels',
      lineWidthMinPixels: 'lineWidthMinPixels',
      lineWidthScale: 'lineWidthScale',
      lineWidthUnits: 'lineWidthUnits',
      pointRadiusMaxPixels: 'radiusMaxPixels',
      pointRadiusMinPixels: 'radiusMinPixels',
      pointRadiusScale: 'radiusScale',
      pointRadiusUnits: 'radiusUnits',
      pointAntialiasing: 'antialiasing',
      pointBillboard: 'billboard',
      getFillColor: 'getFillColor',
      getLineColor: 'getLineColor',
      getLineWidth: 'getLineWidth',
      getPointRadius: 'getRadius'
    }
  },
  icon: {
    type: _iconLayer.default,
    props: {
      iconAtlas: 'iconAtlas',
      iconMapping: 'iconMapping',
      iconSizeMaxPixels: 'sizeMaxPixels',
      iconSizeMinPixels: 'sizeMinPixels',
      iconSizeScale: 'sizeScale',
      iconSizeUnits: 'sizeUnits',
      iconAlphaCutoff: 'alphaCutoff',
      iconBillboard: 'billboard',
      getIcon: 'getIcon',
      getIconAngle: 'getAngle',
      getIconColor: 'getColor',
      getIconPixelOffset: 'getPixelOffset',
      getIconSize: 'getSize'
    }
  },
  text: {
    type: _textLayer.default,
    props: {
      textSizeMaxPixels: 'sizeMaxPixels',
      textSizeMinPixels: 'sizeMinPixels',
      textSizeScale: 'sizeScale',
      textSizeUnits: 'sizeUnits',
      textBackground: 'background',
      textBackgroundPadding: 'backgroundPadding',
      textFontFamily: 'fontFamily',
      textFontWeight: 'fontWeight',
      textLineHeight: 'lineHeight',
      textMaxWidth: 'maxWidth',
      textOutlineColor: 'outlineColor',
      textOutlineWidth: 'outlineWidth',
      textWordBreak: 'wordBreak',
      textCharacterSet: 'characterSet',
      textBillboard: 'billboard',
      textFontSettings: 'fontSettings',
      getText: 'getText',
      getTextAngle: 'getAngle',
      getTextColor: 'getColor',
      getTextPixelOffset: 'getPixelOffset',
      getTextSize: 'getSize',
      getTextAnchor: 'getTextAnchor',
      getTextAlignmentBaseline: 'getAlignmentBaseline',
      getTextBackgroundColor: 'getBackgroundColor',
      getTextBorderColor: 'getBorderColor',
      getTextBorderWidth: 'getBorderWidth'
    }
  }
};
exports.POINT_LAYER = POINT_LAYER;
const LINE_LAYER = {
  type: _pathLayer.default,
  props: {
    lineWidthUnits: 'widthUnits',
    lineWidthScale: 'widthScale',
    lineWidthMinPixels: 'widthMinPixels',
    lineWidthMaxPixels: 'widthMaxPixels',
    lineJointRounded: 'jointRounded',
    lineCapRounded: 'capRounded',
    lineMiterLimit: 'miterLimit',
    lineBillboard: 'billboard',
    getLineColor: 'getColor',
    getLineWidth: 'getWidth'
  }
};
exports.LINE_LAYER = LINE_LAYER;
const POLYGON_LAYER = {
  type: _solidPolygonLayer.default,
  props: {
    extruded: 'extruded',
    filled: 'filled',
    wireframe: 'wireframe',
    elevationScale: 'elevationScale',
    material: 'material',
    getElevation: 'getElevation',
    getFillColor: 'getFillColor',
    getLineColor: 'getLineColor'
  }
};
exports.POLYGON_LAYER = POLYGON_LAYER;

function getDefaultProps({
  type,
  props
}) {
  const result = {};

  for (const key in props) {
    result[key] = type.defaultProps[props[key]];
  }

  return result;
}

function forwardProps(layer, mapping) {
  const {
    transitions,
    updateTriggers
  } = layer.props;
  const result = {
    updateTriggers: {},
    transitions: transitions && {
      getPosition: transitions.geometry
    }
  };

  for (const sourceKey in mapping) {
    const targetKey = mapping[sourceKey];
    let value = layer.props[sourceKey];

    if (sourceKey.startsWith('get')) {
      value = layer.getSubLayerAccessor(value);
      result.updateTriggers[targetKey] = updateTriggers[sourceKey];

      if (transitions) {
        result.transitions[targetKey] = transitions[sourceKey];
      }
    }

    result[targetKey] = value;
  }

  return result;
}
},{"../icon-layer/icon-layer":"node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-layer.js","../scatterplot-layer/scatterplot-layer":"node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer.js","../text-layer/text-layer":"node_modules/@deck.gl/layers/dist/esm/text-layer/text-layer.js","../path-layer/path-layer":"node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer.js","../solid-polygon-layer/solid-polygon-layer":"node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer.js"}],"node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getGeojsonFeatures = getGeojsonFeatures;
exports.separateGeojsonFeatures = separateGeojsonFeatures;
exports.validateGeometry = validateGeometry;

var _core = require("@deck.gl/core");

function getGeojsonFeatures(geojson) {
  if (Array.isArray(geojson)) {
    return geojson;
  }

  _core.log.assert(geojson.type, 'GeoJSON does not have type');

  switch (geojson.type) {
    case 'Feature':
      return [geojson];

    case 'FeatureCollection':
      _core.log.assert(Array.isArray(geojson.features), 'GeoJSON does not have features array');

      return geojson.features;

    default:
      return [{
        geometry: geojson
      }];
  }
}

function separateGeojsonFeatures(features, wrapFeature, dataRange = {}) {
  const separated = {
    pointFeatures: [],
    lineFeatures: [],
    polygonFeatures: [],
    polygonOutlineFeatures: []
  };
  const {
    startRow = 0,
    endRow = features.length
  } = dataRange;

  for (let featureIndex = startRow; featureIndex < endRow; featureIndex++) {
    const feature = features[featureIndex];

    _core.log.assert(feature && feature.geometry, 'GeoJSON does not have geometry');

    const {
      geometry
    } = feature;

    if (geometry.type === 'GeometryCollection') {
      _core.log.assert(Array.isArray(geometry.geometries), 'GeoJSON does not have geometries array');

      const {
        geometries
      } = geometry;

      for (let i = 0; i < geometries.length; i++) {
        const subGeometry = geometries[i];
        separateGeometry(subGeometry, separated, wrapFeature, feature, featureIndex);
      }
    } else {
      separateGeometry(geometry, separated, wrapFeature, feature, featureIndex);
    }
  }

  return separated;
}

function separateGeometry(geometry, separated, wrapFeature, sourceFeature, sourceFeatureIndex) {
  const {
    type,
    coordinates
  } = geometry;
  const {
    pointFeatures,
    lineFeatures,
    polygonFeatures,
    polygonOutlineFeatures
  } = separated;

  if (!validateGeometry(type, coordinates)) {
    _core.log.warn("".concat(type, " coordinates are malformed"))();

    return;
  }

  switch (type) {
    case 'Point':
      pointFeatures.push(wrapFeature({
        geometry
      }, sourceFeature, sourceFeatureIndex));
      break;

    case 'MultiPoint':
      coordinates.forEach(point => {
        pointFeatures.push(wrapFeature({
          geometry: {
            type: 'Point',
            coordinates: point
          }
        }, sourceFeature, sourceFeatureIndex));
      });
      break;

    case 'LineString':
      lineFeatures.push(wrapFeature({
        geometry
      }, sourceFeature, sourceFeatureIndex));
      break;

    case 'MultiLineString':
      coordinates.forEach(path => {
        lineFeatures.push(wrapFeature({
          geometry: {
            type: 'LineString',
            coordinates: path
          }
        }, sourceFeature, sourceFeatureIndex));
      });
      break;

    case 'Polygon':
      polygonFeatures.push(wrapFeature({
        geometry
      }, sourceFeature, sourceFeatureIndex));
      coordinates.forEach(path => {
        polygonOutlineFeatures.push(wrapFeature({
          geometry: {
            type: 'LineString',
            coordinates: path
          }
        }, sourceFeature, sourceFeatureIndex));
      });
      break;

    case 'MultiPolygon':
      coordinates.forEach(polygon => {
        polygonFeatures.push(wrapFeature({
          geometry: {
            type: 'Polygon',
            coordinates: polygon
          }
        }, sourceFeature, sourceFeatureIndex));
        polygon.forEach(path => {
          polygonOutlineFeatures.push(wrapFeature({
            geometry: {
              type: 'LineString',
              coordinates: path
            }
          }, sourceFeature, sourceFeatureIndex));
        });
      });
      break;

    default:
  }
}

const COORDINATE_NEST_LEVEL = {
  Point: 1,
  MultiPoint: 2,
  LineString: 2,
  MultiLineString: 3,
  Polygon: 3,
  MultiPolygon: 4
};

function validateGeometry(type, coordinates) {
  let nestLevel = COORDINATE_NEST_LEVEL[type];

  _core.log.assert(nestLevel, "Unknown GeoJSON type ".concat(type));

  while (coordinates && --nestLevel > 0) {
    coordinates = coordinates[0];
  }

  return coordinates && Number.isFinite(coordinates[0]);
}
},{"@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js"}],"node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson-layer-props.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createLayerPropsFromBinary = createLayerPropsFromBinary;
exports.createLayerPropsFromFeatures = createLayerPropsFromFeatures;

var _geojsonBinary = require("./geojson-binary");

function createEmptyLayerProps() {
  return {
    points: {},
    lines: {},
    polygons: {},
    polygonsOutline: {}
  };
}

function getCoordinates(f) {
  return f.geometry.coordinates;
}

function createLayerPropsFromFeatures(features, featuresDiff) {
  const layerProps = createEmptyLayerProps();
  const {
    pointFeatures,
    lineFeatures,
    polygonFeatures,
    polygonOutlineFeatures
  } = features;
  layerProps.points.data = pointFeatures;

  layerProps.points._dataDiff = featuresDiff.pointFeatures && (() => featuresDiff.pointFeatures);

  layerProps.points.getPosition = getCoordinates;
  layerProps.lines.data = lineFeatures;

  layerProps.lines._dataDiff = featuresDiff.lineFeatures && (() => featuresDiff.lineFeatures);

  layerProps.lines.getPath = getCoordinates;
  layerProps.polygons.data = polygonFeatures;

  layerProps.polygons._dataDiff = featuresDiff.polygonFeatures && (() => featuresDiff.polygonFeatures);

  layerProps.polygons.getPolygon = getCoordinates;
  layerProps.polygonsOutline.data = polygonOutlineFeatures;

  layerProps.polygonsOutline._dataDiff = featuresDiff.polygonOutlineFeatures && (() => featuresDiff.polygonOutlineFeatures);

  layerProps.polygonsOutline.getPath = getCoordinates;
  return layerProps;
}

function createLayerPropsFromBinary(geojsonBinary, encodePickingColor) {
  const layerProps = createEmptyLayerProps();
  const {
    points,
    lines,
    polygons
  } = geojsonBinary;
  const customPickingColors = (0, _geojsonBinary.calculatePickingColors)(geojsonBinary, encodePickingColor);
  layerProps.points.data = {
    length: points.positions.value.length / points.positions.size,
    attributes: { ...points.attributes,
      getPosition: points.positions,
      instancePickingColors: {
        size: 3,
        value: customPickingColors.points
      }
    },
    properties: points.properties,
    numericProps: points.numericProps,
    featureIds: points.featureIds
  };
  layerProps.lines.data = {
    length: lines.pathIndices.value.length - 1,
    startIndices: lines.pathIndices.value,
    attributes: { ...lines.attributes,
      getPath: lines.positions,
      instancePickingColors: {
        size: 3,
        value: customPickingColors.lines
      }
    },
    properties: lines.properties,
    numericProps: lines.numericProps,
    featureIds: lines.featureIds
  };
  layerProps.lines._pathType = 'open';
  layerProps.polygons.data = {
    length: polygons.polygonIndices.value.length - 1,
    startIndices: polygons.polygonIndices.value,
    attributes: { ...polygons.attributes,
      getPolygon: polygons.positions,
      pickingColors: {
        size: 3,
        value: customPickingColors.polygons
      }
    },
    properties: polygons.properties,
    numericProps: polygons.numericProps,
    featureIds: polygons.featureIds
  };
  layerProps.polygons._normalize = false;

  if (polygons.triangles) {
    layerProps.polygons.data.attributes.indices = polygons.triangles.value;
  }

  layerProps.polygonsOutline.data = {
    length: polygons.primitivePolygonIndices.value.length - 1,
    startIndices: polygons.primitivePolygonIndices.value,
    attributes: { ...polygons.attributes,
      getPath: polygons.positions,
      instancePickingColors: {
        size: 3,
        value: customPickingColors.polygons
      }
    },
    properties: polygons.properties,
    numericProps: polygons.numericProps,
    featureIds: polygons.featureIds
  };
  layerProps.polygonsOutline._pathType = 'open';
  return layerProps;
}
},{"./geojson-binary":"node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson-binary.js"}],"node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson-layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _core = require("@deck.gl/core");

var _utils = require("../utils");

var _geojsonBinary = require("./geojson-binary");

var _subLayerMap = require("./sub-layer-map");

var _geojson = require("./geojson");

var _geojsonLayerProps = require("./geojson-layer-props");

const FEATURE_TYPES = ['points', 'linestrings', 'polygons'];
const defaultProps = { ...(0, _subLayerMap.getDefaultProps)(_subLayerMap.POINT_LAYER.circle),
  ...(0, _subLayerMap.getDefaultProps)(_subLayerMap.POINT_LAYER.icon),
  ...(0, _subLayerMap.getDefaultProps)(_subLayerMap.POINT_LAYER.text),
  ...(0, _subLayerMap.getDefaultProps)(_subLayerMap.LINE_LAYER),
  ...(0, _subLayerMap.getDefaultProps)(_subLayerMap.POLYGON_LAYER),
  stroked: true,
  filled: true,
  extruded: false,
  wireframe: false,
  iconAtlas: {
    type: 'object',
    value: null
  },
  iconMapping: {
    type: 'object',
    value: {}
  },
  getIcon: {
    type: 'accessor',
    value: f => f.properties.icon
  },
  getText: {
    type: 'accessor',
    value: f => f.properties.text
  },
  pointType: 'circle',
  getRadius: {
    deprecatedFor: 'getPointRadius'
  }
};

class GeoJsonLayer extends _core.CompositeLayer {
  initializeState() {
    this.state = {
      layerProps: {},
      features: {}
    };

    if (this.props.getLineDashArray) {
      _core.log.removed('getLineDashArray', 'PathStyleExtension')();
    }
  }

  updateState({
    props,
    changeFlags
  }) {
    if (!changeFlags.dataChanged) {
      return;
    }

    const {
      data
    } = this.props;
    const binary = data && 'points' in data && 'polygons' in data && 'lines' in data;
    this.setState({
      binary
    });

    if (binary) {
      this._updateStateBinary({
        props,
        changeFlags
      });
    } else {
      this._updateStateJSON({
        props,
        changeFlags
      });
    }
  }

  _updateStateBinary({
    props,
    changeFlags
  }) {
    const layerProps = (0, _geojsonLayerProps.createLayerPropsFromBinary)(props.data, this.encodePickingColor);
    this.setState({
      layerProps
    });
  }

  _updateStateJSON({
    props,
    changeFlags
  }) {
    const features = (0, _geojson.getGeojsonFeatures)(props.data);
    const wrapFeature = this.getSubLayerRow.bind(this);
    let newFeatures = {};
    const featuresDiff = {};

    if (Array.isArray(changeFlags.dataChanged)) {
      const oldFeatures = this.state.features;

      for (const key in oldFeatures) {
        newFeatures[key] = oldFeatures[key].slice();
        featuresDiff[key] = [];
      }

      for (const dataRange of changeFlags.dataChanged) {
        const partialFeatures = (0, _geojson.separateGeojsonFeatures)(features, wrapFeature, dataRange);

        for (const key in oldFeatures) {
          featuresDiff[key].push((0, _utils.replaceInRange)({
            data: newFeatures[key],
            getIndex: f => f.__source.index,
            dataRange,
            replace: partialFeatures[key]
          }));
        }
      }
    } else {
      newFeatures = (0, _geojson.separateGeojsonFeatures)(features, wrapFeature);
    }

    const layerProps = (0, _geojsonLayerProps.createLayerPropsFromFeatures)(newFeatures, featuresDiff);
    this.setState({
      features: newFeatures,
      featuresDiff,
      layerProps
    });
  }

  getPickingInfo(params) {
    const info = super.getPickingInfo(params);
    const {
      index,
      sourceLayer
    } = info;
    info.featureType = FEATURE_TYPES.find(ft => sourceLayer.id.startsWith("".concat(this.id, "-").concat(ft, "-")));

    if (index >= 0 && sourceLayer.id.startsWith("".concat(this.id, "-points-text")) && this.state.binary) {
      info.index = this.props.data.points.globalFeatureIds.value[index];
    }

    return info;
  }

  _updateAutoHighlight(info) {
    const pointLayerIdPrefix = "".concat(this.id, "-points-");
    const sourceIsPoints = info.featureType === 'points';

    for (const layer of this.getSubLayers()) {
      if (layer.id.startsWith(pointLayerIdPrefix) === sourceIsPoints) {
        layer.updateAutoHighlight(info);
      }
    }
  }

  _renderPolygonLayer() {
    const {
      extruded,
      wireframe
    } = this.props;
    const {
      layerProps
    } = this.state;
    const id = 'polygons-fill';
    const PolygonFillLayer = this.shouldRenderSubLayer(id, layerProps.polygons.data) && this.getSubLayerClass(id, _subLayerMap.POLYGON_LAYER.type);

    if (PolygonFillLayer) {
      const forwardedProps = (0, _subLayerMap.forwardProps)(this, _subLayerMap.POLYGON_LAYER.props);
      const useLineColor = extruded && wireframe;

      if (!useLineColor) {
        delete forwardedProps.getLineColor;
      }

      forwardedProps.updateTriggers.lineColors = useLineColor;
      return new PolygonFillLayer(forwardedProps, this.getSubLayerProps({
        id,
        updateTriggers: forwardedProps.updateTriggers
      }), layerProps.polygons);
    }

    return null;
  }

  _renderLineLayers() {
    const {
      extruded,
      stroked
    } = this.props;
    const {
      layerProps
    } = this.state;
    const polygonStrokeLayerId = 'polygons-stroke';
    const lineStringsLayerId = 'linestrings';
    const PolygonStrokeLayer = !extruded && stroked && this.shouldRenderSubLayer(polygonStrokeLayerId, layerProps.polygonsOutline.data) && this.getSubLayerClass(polygonStrokeLayerId, _subLayerMap.LINE_LAYER.type);
    const LineStringsLayer = this.shouldRenderSubLayer(lineStringsLayerId, layerProps.lines.data) && this.getSubLayerClass(lineStringsLayerId, _subLayerMap.LINE_LAYER.type);

    if (PolygonStrokeLayer || LineStringsLayer) {
      const forwardedProps = (0, _subLayerMap.forwardProps)(this, _subLayerMap.LINE_LAYER.props);
      return [PolygonStrokeLayer && new PolygonStrokeLayer(forwardedProps, this.getSubLayerProps({
        id: polygonStrokeLayerId,
        updateTriggers: forwardedProps.updateTriggers
      }), layerProps.polygonsOutline), LineStringsLayer && new LineStringsLayer(forwardedProps, this.getSubLayerProps({
        id: lineStringsLayerId,
        updateTriggers: forwardedProps.updateTriggers
      }), layerProps.lines)];
    }

    return null;
  }

  _renderPointLayers() {
    const {
      pointType
    } = this.props;
    const {
      layerProps,
      binary
    } = this.state;
    let {
      highlightedObjectIndex
    } = this.props;

    if (!binary && Number.isFinite(highlightedObjectIndex)) {
      highlightedObjectIndex = layerProps.points.data.findIndex(d => d.__source.index === highlightedObjectIndex);
    }

    const types = new Set(pointType.split('+'));
    const pointLayers = [];

    for (const type of types) {
      const id = "points-".concat(type);
      const PointLayerMapping = _subLayerMap.POINT_LAYER[type];
      const PointsLayer = PointLayerMapping && this.shouldRenderSubLayer(id, layerProps.points.data) && this.getSubLayerClass(id, PointLayerMapping.type);

      if (PointsLayer) {
        const forwardedProps = (0, _subLayerMap.forwardProps)(this, PointLayerMapping.props);
        let pointsLayerProps = layerProps.points;

        if (type === 'text' && this.state.binary) {
          const {
            instancePickingColors,
            ...rest
          } = pointsLayerProps.data.attributes;
          pointsLayerProps = { ...pointsLayerProps,
            data: { ...pointsLayerProps.data,
              attributes: rest
            }
          };
        }

        pointLayers.push(new PointsLayer(forwardedProps, this.getSubLayerProps({
          id,
          updateTriggers: forwardedProps.updateTriggers,
          highlightedObjectIndex
        }), pointsLayerProps));
      }
    }

    return pointLayers;
  }

  renderLayers() {
    const {
      extruded
    } = this.props;

    const polygonFillLayer = this._renderPolygonLayer();

    const lineLayers = this._renderLineLayers();

    const pointLayers = this._renderPointLayers();

    return [!extruded && polygonFillLayer, lineLayers, pointLayers, extruded && polygonFillLayer];
  }

  getSubLayerAccessor(accessor) {
    const {
      binary
    } = this.state;

    if (!binary || typeof accessor !== 'function') {
      return super.getSubLayerAccessor(accessor);
    }

    return (object, info) => {
      const {
        data,
        index
      } = info;
      const feature = (0, _geojsonBinary.binaryToFeatureForAccesor)(data, index);
      return accessor(feature, info);
    };
  }

}

exports.default = GeoJsonLayer;
GeoJsonLayer.layerName = 'GeoJsonLayer';
GeoJsonLayer.defaultProps = defaultProps;
},{"@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","../utils":"node_modules/@deck.gl/layers/dist/esm/utils.js","./geojson-binary":"node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson-binary.js","./sub-layer-map":"node_modules/@deck.gl/layers/dist/esm/geojson-layer/sub-layer-map.js","./geojson":"node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson.js","./geojson-layer-props":"node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson-layer-props.js"}],"node_modules/@deck.gl/layers/dist/esm/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "ArcLayer", {
  enumerable: true,
  get: function () {
    return _arcLayer.default;
  }
});
Object.defineProperty(exports, "BitmapLayer", {
  enumerable: true,
  get: function () {
    return _bitmapLayer.default;
  }
});
Object.defineProperty(exports, "ColumnLayer", {
  enumerable: true,
  get: function () {
    return _columnLayer.default;
  }
});
Object.defineProperty(exports, "GeoJsonLayer", {
  enumerable: true,
  get: function () {
    return _geojsonLayer.default;
  }
});
Object.defineProperty(exports, "GridCellLayer", {
  enumerable: true,
  get: function () {
    return _gridCellLayer.default;
  }
});
Object.defineProperty(exports, "IconLayer", {
  enumerable: true,
  get: function () {
    return _iconLayer.default;
  }
});
Object.defineProperty(exports, "LineLayer", {
  enumerable: true,
  get: function () {
    return _lineLayer.default;
  }
});
Object.defineProperty(exports, "PathLayer", {
  enumerable: true,
  get: function () {
    return _pathLayer.default;
  }
});
Object.defineProperty(exports, "PointCloudLayer", {
  enumerable: true,
  get: function () {
    return _pointCloudLayer.default;
  }
});
Object.defineProperty(exports, "PolygonLayer", {
  enumerable: true,
  get: function () {
    return _polygonLayer.default;
  }
});
Object.defineProperty(exports, "ScatterplotLayer", {
  enumerable: true,
  get: function () {
    return _scatterplotLayer.default;
  }
});
Object.defineProperty(exports, "SolidPolygonLayer", {
  enumerable: true,
  get: function () {
    return _solidPolygonLayer.default;
  }
});
Object.defineProperty(exports, "TextLayer", {
  enumerable: true,
  get: function () {
    return _textLayer.default;
  }
});
Object.defineProperty(exports, "_MultiIconLayer", {
  enumerable: true,
  get: function () {
    return _multiIconLayer.default;
  }
});
Object.defineProperty(exports, "_TextBackgroundLayer", {
  enumerable: true,
  get: function () {
    return _textBackgroundLayer.default;
  }
});

var _arcLayer = _interopRequireDefault(require("./arc-layer/arc-layer"));

var _bitmapLayer = _interopRequireDefault(require("./bitmap-layer/bitmap-layer"));

var _iconLayer = _interopRequireDefault(require("./icon-layer/icon-layer"));

var _lineLayer = _interopRequireDefault(require("./line-layer/line-layer"));

var _pointCloudLayer = _interopRequireDefault(require("./point-cloud-layer/point-cloud-layer"));

var _scatterplotLayer = _interopRequireDefault(require("./scatterplot-layer/scatterplot-layer"));

var _columnLayer = _interopRequireDefault(require("./column-layer/column-layer"));

var _gridCellLayer = _interopRequireDefault(require("./column-layer/grid-cell-layer"));

var _pathLayer = _interopRequireDefault(require("./path-layer/path-layer"));

var _polygonLayer = _interopRequireDefault(require("./polygon-layer/polygon-layer"));

var _geojsonLayer = _interopRequireDefault(require("./geojson-layer/geojson-layer"));

var _textLayer = _interopRequireDefault(require("./text-layer/text-layer"));

var _solidPolygonLayer = _interopRequireDefault(require("./solid-polygon-layer/solid-polygon-layer"));

var _multiIconLayer = _interopRequireDefault(require("./text-layer/multi-icon-layer/multi-icon-layer"));

var _textBackgroundLayer = _interopRequireDefault(require("./text-layer/text-background-layer/text-background-layer"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./arc-layer/arc-layer":"node_modules/@deck.gl/layers/dist/esm/arc-layer/arc-layer.js","./bitmap-layer/bitmap-layer":"node_modules/@deck.gl/layers/dist/esm/bitmap-layer/bitmap-layer.js","./icon-layer/icon-layer":"node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-layer.js","./line-layer/line-layer":"node_modules/@deck.gl/layers/dist/esm/line-layer/line-layer.js","./point-cloud-layer/point-cloud-layer":"node_modules/@deck.gl/layers/dist/esm/point-cloud-layer/point-cloud-layer.js","./scatterplot-layer/scatterplot-layer":"node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer.js","./column-layer/column-layer":"node_modules/@deck.gl/layers/dist/esm/column-layer/column-layer.js","./column-layer/grid-cell-layer":"node_modules/@deck.gl/layers/dist/esm/column-layer/grid-cell-layer.js","./path-layer/path-layer":"node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer.js","./polygon-layer/polygon-layer":"node_modules/@deck.gl/layers/dist/esm/polygon-layer/polygon-layer.js","./geojson-layer/geojson-layer":"node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson-layer.js","./text-layer/text-layer":"node_modules/@deck.gl/layers/dist/esm/text-layer/text-layer.js","./solid-polygon-layer/solid-polygon-layer":"node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer.js","./text-layer/multi-icon-layer/multi-icon-layer":"node_modules/@deck.gl/layers/dist/esm/text-layer/multi-icon-layer/multi-icon-layer.js","./text-layer/text-background-layer/text-background-layer":"node_modules/@deck.gl/layers/dist/esm/text-layer/text-background-layer/text-background-layer.js"}],"node_modules/mapbox-gl/dist/mapbox-gl.js":[function(require,module,exports) {
var define;
var global = arguments[3];
/* Mapbox GL JS is Copyright © 2020 Mapbox and subject to the Mapbox Terms of Service ((https://www.mapbox.com/legal/tos/). */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.mapboxgl = factory());
})(this, function () {
  'use strict';
  /* eslint-disable */

  var shared, worker, mapboxgl; // define gets called three times: one for each chunk. we rely on the order
  // they're imported to know which is which

  function define(_, chunk) {
    if (!shared) {
      shared = chunk;
    } else if (!worker) {
      worker = chunk;
    } else {
      var workerBundleString = "self.onerror = function() { console.error('An error occurred while parsing the WebWorker bundle. This is most likely due to improper transpilation by Babel; please see https://docs.mapbox.com/mapbox-gl-js/guides/install/#transpiling'); }; var sharedChunk = {}; (" + shared + ")(sharedChunk); (" + worker + ")(sharedChunk); self.onerror = null;";
      var sharedChunk = {};
      shared(sharedChunk);
      mapboxgl = chunk(sharedChunk);

      if (typeof window !== 'undefined' && window && window.URL && window.URL.createObjectURL) {
        mapboxgl.workerUrl = window.URL.createObjectURL(new Blob([workerBundleString], {
          type: 'text/javascript'
        }));
      }
    }
  }

  define(["exports"], function (t) {
    "use strict";

    var e = "2.8.2",
        r = n;

    function n(t, e, r, n) {
      this.cx = 3 * t, this.bx = 3 * (r - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e, this.by = 3 * (n - e) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = n, this.p2x = r, this.p2y = n;
    }

    n.prototype.sampleCurveX = function (t) {
      return ((this.ax * t + this.bx) * t + this.cx) * t;
    }, n.prototype.sampleCurveY = function (t) {
      return ((this.ay * t + this.by) * t + this.cy) * t;
    }, n.prototype.sampleCurveDerivativeX = function (t) {
      return (3 * this.ax * t + 2 * this.bx) * t + this.cx;
    }, n.prototype.solveCurveX = function (t, e) {
      var r, n, i, s, a;

      for (void 0 === e && (e = 1e-6), i = t, a = 0; a < 8; a++) {
        if (s = this.sampleCurveX(i) - t, Math.abs(s) < e) return i;
        var o = this.sampleCurveDerivativeX(i);
        if (Math.abs(o) < 1e-6) break;
        i -= s / o;
      }

      if ((i = t) < (r = 0)) return r;
      if (i > (n = 1)) return n;

      for (; r < n;) {
        if (s = this.sampleCurveX(i), Math.abs(s - t) < e) return i;
        t > s ? r = i : n = i, i = .5 * (n - r) + r;
      }

      return i;
    }, n.prototype.solve = function (t, e) {
      return this.sampleCurveY(this.solveCurveX(t, e));
    };
    var i = s;

    function s(t, e) {
      this.x = t, this.y = e;
    }

    s.prototype = {
      clone: function () {
        return new s(this.x, this.y);
      },
      add: function (t) {
        return this.clone()._add(t);
      },
      sub: function (t) {
        return this.clone()._sub(t);
      },
      multByPoint: function (t) {
        return this.clone()._multByPoint(t);
      },
      divByPoint: function (t) {
        return this.clone()._divByPoint(t);
      },
      mult: function (t) {
        return this.clone()._mult(t);
      },
      div: function (t) {
        return this.clone()._div(t);
      },
      rotate: function (t) {
        return this.clone()._rotate(t);
      },
      rotateAround: function (t, e) {
        return this.clone()._rotateAround(t, e);
      },
      matMult: function (t) {
        return this.clone()._matMult(t);
      },
      unit: function () {
        return this.clone()._unit();
      },
      perp: function () {
        return this.clone()._perp();
      },
      round: function () {
        return this.clone()._round();
      },
      mag: function () {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      },
      equals: function (t) {
        return this.x === t.x && this.y === t.y;
      },
      dist: function (t) {
        return Math.sqrt(this.distSqr(t));
      },
      distSqr: function (t) {
        var e = t.x - this.x,
            r = t.y - this.y;
        return e * e + r * r;
      },
      angle: function () {
        return Math.atan2(this.y, this.x);
      },
      angleTo: function (t) {
        return Math.atan2(this.y - t.y, this.x - t.x);
      },
      angleWith: function (t) {
        return this.angleWithSep(t.x, t.y);
      },
      angleWithSep: function (t, e) {
        return Math.atan2(this.x * e - this.y * t, this.x * t + this.y * e);
      },
      _matMult: function (t) {
        var e = t[2] * this.x + t[3] * this.y;
        return this.x = t[0] * this.x + t[1] * this.y, this.y = e, this;
      },
      _add: function (t) {
        return this.x += t.x, this.y += t.y, this;
      },
      _sub: function (t) {
        return this.x -= t.x, this.y -= t.y, this;
      },
      _mult: function (t) {
        return this.x *= t, this.y *= t, this;
      },
      _div: function (t) {
        return this.x /= t, this.y /= t, this;
      },
      _multByPoint: function (t) {
        return this.x *= t.x, this.y *= t.y, this;
      },
      _divByPoint: function (t) {
        return this.x /= t.x, this.y /= t.y, this;
      },
      _unit: function () {
        return this._div(this.mag()), this;
      },
      _perp: function () {
        var t = this.y;
        return this.y = this.x, this.x = -t, this;
      },
      _rotate: function (t) {
        var e = Math.cos(t),
            r = Math.sin(t),
            n = r * this.x + e * this.y;
        return this.x = e * this.x - r * this.y, this.y = n, this;
      },
      _rotateAround: function (t, e) {
        var r = Math.cos(t),
            n = Math.sin(t),
            i = e.y + n * (this.x - e.x) + r * (this.y - e.y);
        return this.x = e.x + r * (this.x - e.x) - n * (this.y - e.y), this.y = i, this;
      },
      _round: function () {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
      }
    }, s.convert = function (t) {
      return t instanceof s ? t : Array.isArray(t) ? new s(t[0], t[1]) : t;
    };
    var a = "undefined" != typeof self ? self : {};
    const o = Math.PI / 180,
          l = 180 / Math.PI;

    function u(t) {
      return t * o;
    }

    function c(t) {
      return t * l;
    }

    const h = [[0, 0], [1, 0], [1, 1], [0, 1]];

    function p(t) {
      if (t <= 0) return 0;
      if (t >= 1) return 1;
      const e = t * t,
            r = e * t;
      return 4 * (t < .5 ? r : 3 * (t - e) + r - .75);
    }

    function f(t, e, n, i) {
      const s = new r(t, e, n, i);
      return function (t) {
        return s.solve(t);
      };
    }

    const d = f(.25, .1, .25, 1);

    function y(t, e, r) {
      return Math.min(r, Math.max(e, t));
    }

    function m(t, e, r) {
      return (r = y((r - t) / (e - t), 0, 1)) * r * (3 - 2 * r);
    }

    function g(t, e, r) {
      const n = r - e,
            i = ((t - e) % n + n) % n + e;
      return i === e ? r : i;
    }

    function x(t, e, r) {
      if (!t.length) return r(null, []);
      let n = t.length;
      const i = new Array(t.length);
      let s = null;
      t.forEach((t, a) => {
        e(t, (t, e) => {
          t && (s = t), i[a] = e, 0 == --n && r(s, i);
        });
      });
    }

    function v(t) {
      const e = [];

      for (const r in t) e.push(t[r]);

      return e;
    }

    function b(t, ...e) {
      for (const r of e) for (const e in r) t[e] = r[e];

      return t;
    }

    let _ = 1;

    function w() {
      return _++;
    }

    function A() {
      return function t(e) {
        return e ? (e ^ Math.random() * (16 >> e / 4)).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, t);
      }();
    }

    function k(t) {
      return t <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));
    }

    function S(t) {
      return !!t && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(t);
    }

    function I(t, e) {
      t.forEach(t => {
        e[t] && (e[t] = e[t].bind(e));
      });
    }

    function M(t, e) {
      return -1 !== t.indexOf(e, t.length - e.length);
    }

    function T(t, e, r) {
      const n = {};

      for (const i in t) n[i] = e.call(r || this, t[i], i, t);

      return n;
    }

    function z(t, e, r) {
      const n = {};

      for (const i in t) e.call(r || this, t[i], i, t) && (n[i] = t[i]);

      return n;
    }

    function B(t) {
      return Array.isArray(t) ? t.map(B) : "object" == typeof t && t ? T(t, B) : t;
    }

    const E = {};

    function C(t) {
      E[t] || ("undefined" != typeof console && console.warn(t), E[t] = !0);
    }

    function D(t, e, r) {
      return (r.y - t.y) * (e.x - t.x) > (e.y - t.y) * (r.x - t.x);
    }

    function P(t) {
      let e = 0;

      for (let r, n, i = 0, s = t.length, a = s - 1; i < s; a = i++) r = t[i], n = t[a], e += (n.x - r.x) * (r.y + n.y);

      return e;
    }

    function V() {
      return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope;
    }

    function F(t) {
      const e = {};

      if (t.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (t, r, n, i) => {
        const s = n || i;
        return e[r] = !s || s.toLowerCase(), "";
      }), e["max-age"]) {
        const t = parseInt(e["max-age"], 10);
        isNaN(t) ? delete e["max-age"] : e["max-age"] = t;
      }

      return e;
    }

    let L,
        R,
        U,
        $,
        j = null;

    function O(t) {
      if (null == j) {
        const e = t.navigator ? t.navigator.userAgent : null;
        j = !!t.safari || !(!e || !(/\b(iPad|iPhone|iPod)\b/.test(e) || e.match("Safari") && !e.match("Chrome")));
      }

      return j;
    }

    function q(t) {
      try {
        const e = a[t];
        return e.setItem("_mapbox_test_", 1), e.removeItem("_mapbox_test_"), !0;
      } catch (t) {
        return !1;
      }
    }

    const N = {
      now: () => void 0 !== U ? U : a.performance.now(),

      setNow(t) {
        U = t;
      },

      restoreNow() {
        U = void 0;
      },

      frame(t) {
        const e = a.requestAnimationFrame(t);
        return {
          cancel: () => a.cancelAnimationFrame(e)
        };
      },

      getImageData(t, e = 0) {
        const {
          width: r,
          height: n
        } = t;
        $ || ($ = a.document.createElement("canvas"));
        const i = $.getContext("2d");
        if (!i) throw new Error("failed to create canvas 2d context");
        return (r > $.width || n > $.height) && ($.width = r, $.height = n), i.clearRect(-e, -e, r + 2 * e, n + 2 * e), i.drawImage(t, 0, 0, r, n), i.getImageData(-e, -e, r + 2 * e, n + 2 * e);
      },

      resolveURL: t => (L || (L = a.document.createElement("a")), L.href = t, L.href),

      get devicePixelRatio() {
        return a.devicePixelRatio;
      },

      get prefersReducedMotion() {
        return !!a.matchMedia && (null == R && (R = a.matchMedia("(prefers-reduced-motion: reduce)")), R.matches);
      }

    };
    let G;
    const Z = {
      API_URL: "https://api.mapbox.com",

      get API_URL_REGEX() {
        if (null == G) {
          const t = /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i;

          try {
            G = null != undefined ? new RegExp(undefined) : t;
          } catch (e) {
            G = t;
          }
        }

        return G;
      },

      get EVENTS_URL() {
        return this.API_URL ? 0 === this.API_URL.indexOf("https://api.mapbox.cn") ? "https://events.mapbox.cn/events/v2" : 0 === this.API_URL.indexOf("https://api.mapbox.com") ? "https://events.mapbox.com/events/v2" : null : null;
      },

      SESSION_PATH: "/map-sessions/v1",
      FEEDBACK_URL: "https://apps.mapbox.com/feedback",
      TILE_URL_VERSION: "v4",
      RASTER_URL_PREFIX: "raster/v1",
      REQUIRE_ACCESS_TOKEN: !0,
      ACCESS_TOKEN: null,
      MAX_PARALLEL_IMAGE_REQUESTS: 16
    },
          X = {
      supported: !1,
      testSupport: function (t) {
        !H && Y && (W ? J(t) : K = t);
      }
    };
    let K,
        Y,
        H = !1,
        W = !1;

    function J(t) {
      const e = t.createTexture();
      t.bindTexture(t.TEXTURE_2D, e);

      try {
        if (t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, Y), t.isContextLost()) return;
        X.supported = !0;
      } catch (t) {}

      t.deleteTexture(e), H = !0;
    }

    a.document && (Y = a.document.createElement("img"), Y.onload = function () {
      K && J(K), K = null, W = !0;
    }, Y.onerror = function () {
      H = !0, K = null;
    }, Y.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
    const Q = "01",
          tt = "NO_ACCESS_TOKEN";

    function et(t) {
      return 0 === t.indexOf("mapbox:");
    }

    function rt(t) {
      return Z.API_URL_REGEX.test(t);
    }

    const nt = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;

    function it(t) {
      const e = t.match(nt);
      if (!e) throw new Error("Unable to parse URL object");
      return {
        protocol: e[1],
        authority: e[2],
        path: e[3] || "/",
        params: e[4] ? e[4].split("&") : []
      };
    }

    function st(t) {
      const e = t.params.length ? `?${t.params.join("&")}` : "";
      return `${t.protocol}://${t.authority}${t.path}${e}`;
    }

    function at(t) {
      if (!t) return null;
      const e = t.split(".");
      if (!e || 3 !== e.length) return null;

      try {
        return JSON.parse(decodeURIComponent(a.atob(e[1]).split("").map(t => "%" + ("00" + t.charCodeAt(0).toString(16)).slice(-2)).join("")));
      } catch (t) {
        return null;
      }
    }

    class ot {
      constructor(t) {
        this.type = t, this.anonId = null, this.eventData = {}, this.queue = [], this.pendingRequest = null;
      }

      getStorageKey(t) {
        const e = at(Z.ACCESS_TOKEN);
        let r = "";
        return r = e && e.u ? a.btoa(encodeURIComponent(e.u).replace(/%([0-9A-F]{2})/g, (t, e) => String.fromCharCode(Number("0x" + e)))) : Z.ACCESS_TOKEN || "", t ? `mapbox.eventData.${t}:${r}` : `mapbox.eventData:${r}`;
      }

      fetchEventData() {
        const t = q("localStorage"),
              e = this.getStorageKey(),
              r = this.getStorageKey("uuid");
        if (t) try {
          const t = a.localStorage.getItem(e);
          t && (this.eventData = JSON.parse(t));
          const n = a.localStorage.getItem(r);
          n && (this.anonId = n);
        } catch (t) {
          C("Unable to read from LocalStorage");
        }
      }

      saveEventData() {
        const t = q("localStorage"),
              e = this.getStorageKey(),
              r = this.getStorageKey("uuid");
        if (t) try {
          a.localStorage.setItem(r, this.anonId), Object.keys(this.eventData).length >= 1 && a.localStorage.setItem(e, JSON.stringify(this.eventData));
        } catch (t) {
          C("Unable to write to LocalStorage");
        }
      }

      processRequests(t) {}

      postEvent(t, r, n, i) {
        if (!Z.EVENTS_URL) return;
        const s = it(Z.EVENTS_URL);
        s.params.push(`access_token=${i || Z.ACCESS_TOKEN || ""}`);
        const a = {
          event: this.type,
          created: new Date(t).toISOString(),
          sdkIdentifier: "mapbox-gl-js",
          sdkVersion: e,
          skuId: Q,
          userId: this.anonId
        },
              o = r ? b(a, r) : a,
              l = {
          url: st(s),
          headers: {
            "Content-Type": "text/plain"
          },
          body: JSON.stringify([o])
        };
        this.pendingRequest = Tt(l, t => {
          this.pendingRequest = null, n(t), this.saveEventData(), this.processRequests(i);
        });
      }

      queueRequest(t, e) {
        this.queue.push(t), this.processRequests(e);
      }

    }

    const lt = new class extends ot {
      constructor(t) {
        super("appUserTurnstile"), this._customAccessToken = t;
      }

      postTurnstileEvent(t, e) {
        Z.EVENTS_URL && Z.ACCESS_TOKEN && Array.isArray(t) && t.some(t => et(t) || rt(t)) && this.queueRequest(Date.now(), e);
      }

      processRequests(t) {
        if (this.pendingRequest || 0 === this.queue.length) return;
        this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData();
        const e = at(Z.ACCESS_TOKEN),
              r = e ? e.u : Z.ACCESS_TOKEN;
        let n = r !== this.eventData.tokenU;
        S(this.anonId) || (this.anonId = A(), n = !0);
        const i = this.queue.shift();

        if (this.eventData.lastSuccess) {
          const t = new Date(this.eventData.lastSuccess),
                e = new Date(i),
                r = (i - this.eventData.lastSuccess) / 864e5;
          n = n || r >= 1 || r < -1 || t.getDate() !== e.getDate();
        } else n = !0;

        n ? this.postEvent(i, {
          "enabled.telemetry": !1
        }, t => {
          t || (this.eventData.lastSuccess = i, this.eventData.tokenU = r);
        }, t) : this.processRequests();
      }

    }(),
          ut = lt.postTurnstileEvent.bind(lt),
          ct = new class extends ot {
      constructor() {
        super("map.load"), this.success = {}, this.skuToken = "";
      }

      postMapLoadEvent(t, e, r, n) {
        this.skuToken = e, this.errorCb = n, Z.EVENTS_URL && (r || Z.ACCESS_TOKEN ? this.queueRequest({
          id: t,
          timestamp: Date.now()
        }, r) : this.errorCb(new Error(tt)));
      }

      processRequests(t) {
        if (this.pendingRequest || 0 === this.queue.length) return;
        const {
          id: e,
          timestamp: r
        } = this.queue.shift();
        e && this.success[e] || (this.anonId || this.fetchEventData(), S(this.anonId) || (this.anonId = A()), this.postEvent(r, {
          skuToken: this.skuToken
        }, t => {
          t ? this.errorCb(t) : e && (this.success[e] = !0);
        }, t));
      }

    }(),
          ht = ct.postMapLoadEvent.bind(ct),
          pt = new class extends ot {
      constructor() {
        super("map.auth"), this.success = {}, this.skuToken = "";
      }

      getSession(t, e, r, n) {
        if (!Z.API_URL || !Z.SESSION_PATH) return;
        const i = it(Z.API_URL + Z.SESSION_PATH);
        i.params.push(`sku=${e || ""}`), i.params.push(`access_token=${n || Z.ACCESS_TOKEN || ""}`);
        const s = {
          url: st(i),
          headers: {
            "Content-Type": "text/plain"
          }
        };
        this.pendingRequest = zt(s, t => {
          this.pendingRequest = null, r(t), this.saveEventData(), this.processRequests(n);
        });
      }

      getSessionAPI(t, e, r, n) {
        this.skuToken = e, this.errorCb = n, Z.SESSION_PATH && Z.API_URL && (r || Z.ACCESS_TOKEN ? this.queueRequest({
          id: t,
          timestamp: Date.now()
        }, r) : this.errorCb(new Error(tt)));
      }

      processRequests(t) {
        if (this.pendingRequest || 0 === this.queue.length) return;
        const {
          id: e,
          timestamp: r
        } = this.queue.shift();
        e && this.success[e] || this.getSession(r, this.skuToken, t => {
          t ? this.errorCb(t) : e && (this.success[e] = !0);
        }, t);
      }

    }(),
          ft = pt.getSessionAPI.bind(pt),
          dt = new Set(),
          yt = "mapbox-tiles";
    let mt,
        gt,
        xt = 500,
        vt = 50;

    function bt() {
      a.caches && !mt && (mt = a.caches.open(yt));
    }

    function _t(t) {
      const e = t.indexOf("?");
      return e < 0 ? t : t.slice(0, e);
    }

    let wt = 1 / 0;
    const At = {
      Unknown: "Unknown",
      Style: "Style",
      Source: "Source",
      Tile: "Tile",
      Glyphs: "Glyphs",
      SpriteImage: "SpriteImage",
      SpriteJSON: "SpriteJSON",
      Image: "Image"
    };
    "function" == typeof Object.freeze && Object.freeze(At);

    class kt extends Error {
      constructor(t, e, r) {
        401 === e && rt(r) && (t += ": you may have provided an invalid Mapbox access token. See https://www.mapbox.com/api-documentation/#access-tokens-and-token-scopes"), super(t), this.status = e, this.url = r;
      }

      toString() {
        return `${this.name}: ${this.message} (${this.status}): ${this.url}`;
      }

    }

    const St = V() ? () => self.worker && self.worker.referrer : () => ("blob:" === a.location.protocol ? a.parent : a).location.href;

    const It = function (t, e) {
      if (!(/^file:/.test(r = t.url) || /^file:/.test(St()) && !/^\w+:/.test(r))) {
        if (a.fetch && a.Request && a.AbortController && a.Request.prototype.hasOwnProperty("signal")) return function (t, e) {
          const r = new a.AbortController(),
                n = new a.Request(t.url, {
            method: t.method || "GET",
            body: t.body,
            credentials: t.credentials,
            headers: t.headers,
            referrer: St(),
            signal: r.signal
          });
          let i = !1,
              s = !1;
          const o = (l = n.url).indexOf("sku=") > 0 && rt(l);
          var l;
          "json" === t.type && n.headers.set("Accept", "application/json");

          const u = (r, i, l) => {
            if (s) return;
            if (r && "SecurityError" !== r.message && C(r), i && l) return c(i);
            const u = Date.now();
            a.fetch(n).then(r => {
              if (r.ok) {
                const t = o ? r.clone() : null;
                return c(r, t, u);
              }

              return e(new kt(r.statusText, r.status, t.url));
            }).catch(t => {
              20 !== t.code && e(new Error(t.message));
            });
          },
                c = (r, o, l) => {
            ("arrayBuffer" === t.type ? r.arrayBuffer() : "json" === t.type ? r.json() : r.text()).then(t => {
              s || (o && l && function (t, e, r) {
                if (bt(), !mt) return;
                const n = {
                  status: e.status,
                  statusText: e.statusText,
                  headers: new a.Headers()
                };
                e.headers.forEach((t, e) => n.headers.set(e, t));
                const i = F(e.headers.get("Cache-Control") || "");
                if (i["no-store"]) return;
                i["max-age"] && n.headers.set("Expires", new Date(r + 1e3 * i["max-age"]).toUTCString());
                const s = n.headers.get("Expires");
                s && (new Date(s).getTime() - r < 42e4 || function (t, e) {
                  if (void 0 === gt) try {
                    new Response(new ReadableStream()), gt = !0;
                  } catch (t) {
                    gt = !1;
                  }
                  gt ? e(t.body) : t.blob().then(e);
                }(e, e => {
                  const r = new a.Response(e, n);
                  bt(), mt && mt.then(e => e.put(_t(t.url), r)).catch(t => C(t.message));
                }));
              }(n, o, l), i = !0, e(null, t, r.headers.get("Cache-Control"), r.headers.get("Expires")));
            }).catch(t => {
              s || e(new Error(t.message));
            });
          };

          return o ? function (t, e) {
            if (bt(), !mt) return e(null);

            const r = _t(t.url);

            mt.then(t => {
              t.match(r).then(n => {
                const i = function (t) {
                  if (!t) return !1;
                  const e = new Date(t.headers.get("Expires") || 0),
                        r = F(t.headers.get("Cache-Control") || "");
                  return e > Date.now() && !r["no-cache"];
                }(n);

                t.delete(r), i && t.put(r, n.clone()), e(null, n, i);
              }).catch(e);
            }).catch(e);
          }(n, u) : u(null, null), {
            cancel: () => {
              s = !0, i || r.abort();
            }
          };
        }(t, e);
        if (V() && self.worker && self.worker.actor) return self.worker.actor.send("getResource", t, e, void 0, !0);
      }

      var r;
      return function (t, e) {
        const r = new a.XMLHttpRequest();
        r.open(t.method || "GET", t.url, !0), "arrayBuffer" === t.type && (r.responseType = "arraybuffer");

        for (const e in t.headers) r.setRequestHeader(e, t.headers[e]);

        return "json" === t.type && (r.responseType = "text", r.setRequestHeader("Accept", "application/json")), r.withCredentials = "include" === t.credentials, r.onerror = () => {
          e(new Error(r.statusText));
        }, r.onload = () => {
          if ((r.status >= 200 && r.status < 300 || 0 === r.status) && null !== r.response) {
            let n = r.response;
            if ("json" === t.type) try {
              n = JSON.parse(r.response);
            } catch (t) {
              return e(t);
            }
            e(null, n, r.getResponseHeader("Cache-Control"), r.getResponseHeader("Expires"));
          } else e(new kt(r.statusText, r.status, t.url));
        }, r.send(t.body), {
          cancel: () => r.abort()
        };
      }(t, e);
    },
          Mt = function (t, e) {
      return It(b(t, {
        type: "arrayBuffer"
      }), e);
    },
          Tt = function (t, e) {
      return It(b(t, {
        method: "POST"
      }), e);
    },
          zt = function (t, e) {
      return It(b(t, {
        method: "GET"
      }), e);
    };

    function Bt(t) {
      const e = a.document.createElement("a");
      return e.href = t, e.protocol === a.document.location.protocol && e.host === a.document.location.host;
    }

    const Et = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
    let Ct, Dt;
    Ct = [], Dt = 0;

    const Pt = function (t, e) {
      if (X.supported && (t.headers || (t.headers = {}), t.headers.accept = "image/webp,*/*"), Dt >= Z.MAX_PARALLEL_IMAGE_REQUESTS) {
        const r = {
          requestParameters: t,
          callback: e,
          cancelled: !1,

          cancel() {
            this.cancelled = !0;
          }

        };
        return Ct.push(r), r;
      }

      Dt++;
      let r = !1;

      const n = () => {
        if (!r) for (r = !0, Dt--; Ct.length && Dt < Z.MAX_PARALLEL_IMAGE_REQUESTS;) {
          const t = Ct.shift(),
                {
            requestParameters: e,
            callback: r,
            cancelled: n
          } = t;
          n || (t.cancel = Pt(e, r).cancel);
        }
      },
            i = Mt(t, (t, r, i, s) => {
        n(), t ? e(t) : r && (a.createImageBitmap ? function (t, e) {
          const r = new a.Blob([new Uint8Array(t)], {
            type: "image/png"
          });
          a.createImageBitmap(r).then(t => {
            e(null, t);
          }).catch(t => {
            e(new Error(`Could not load image because of ${t.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`));
          });
        }(r, (t, r) => e(t, r, i, s)) : function (t, e) {
          const r = new a.Image(),
                n = a.URL;
          r.onload = () => {
            e(null, r), n.revokeObjectURL(r.src), r.onload = null, a.requestAnimationFrame(() => {
              r.src = Et;
            });
          }, r.onerror = () => e(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
          const i = new a.Blob([new Uint8Array(t)], {
            type: "image/png"
          });
          r.src = t.byteLength ? n.createObjectURL(i) : Et;
        }(r, (t, r) => e(t, r, i, s)));
      });

      return {
        cancel: () => {
          i.cancel(), n();
        }
      };
    };

    function Vt(t, e, r) {
      r[t] && -1 !== r[t].indexOf(e) || (r[t] = r[t] || [], r[t].push(e));
    }

    function Ft(t, e, r) {
      if (r && r[t]) {
        const n = r[t].indexOf(e);
        -1 !== n && r[t].splice(n, 1);
      }
    }

    class Lt {
      constructor(t, e = {}) {
        b(this, e), this.type = t;
      }

    }

    class Rt extends Lt {
      constructor(t, e = {}) {
        super("error", b({
          error: t
        }, e));
      }

    }

    class Ut {
      on(t, e) {
        return this._listeners = this._listeners || {}, Vt(t, e, this._listeners), this;
      }

      off(t, e) {
        return Ft(t, e, this._listeners), Ft(t, e, this._oneTimeListeners), this;
      }

      once(t, e) {
        return e ? (this._oneTimeListeners = this._oneTimeListeners || {}, Vt(t, e, this._oneTimeListeners), this) : new Promise(e => this.once(t, e));
      }

      fire(t, e) {
        "string" == typeof t && (t = new Lt(t, e || {}));
        const r = t.type;

        if (this.listens(r)) {
          t.target = this;
          const e = this._listeners && this._listeners[r] ? this._listeners[r].slice() : [];

          for (const r of e) r.call(this, t);

          const n = this._oneTimeListeners && this._oneTimeListeners[r] ? this._oneTimeListeners[r].slice() : [];

          for (const e of n) Ft(r, e, this._oneTimeListeners), e.call(this, t);

          const i = this._eventedParent;
          i && (b(t, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), i.fire(t));
        } else t instanceof Rt && console.error(t.error);

        return this;
      }

      listens(t) {
        return !!(this._listeners && this._listeners[t] && this._listeners[t].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t] && this._oneTimeListeners[t].length > 0 || this._eventedParent && this._eventedParent.listens(t));
      }

      setEventedParent(t, e) {
        return this._eventedParent = t, this._eventedParentData = e, this;
      }

    }

    var $t = JSON.parse('{"$version":8,"$root":{"version":{"required":true,"type":"enum","values":[8]},"name":{"type":"string"},"metadata":{"type":"*"},"center":{"type":"array","value":"number"},"zoom":{"type":"number"},"bearing":{"type":"number","default":0,"period":360,"units":"degrees"},"pitch":{"type":"number","default":0,"units":"degrees"},"light":{"type":"light"},"terrain":{"type":"terrain"},"fog":{"type":"fog"},"sources":{"required":true,"type":"sources"},"sprite":{"type":"string"},"glyphs":{"type":"string"},"transition":{"type":"transition"},"projection":{"type":"projection"},"layers":{"required":true,"type":"array","value":"layer"}},"sources":{"*":{"type":"source"}},"source":["source_vector","source_raster","source_raster_dem","source_geojson","source_video","source_image"],"source_vector":{"type":{"required":true,"type":"enum","values":{"vector":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"scheme":{"type":"enum","values":{"xyz":{},"tms":{}},"default":"xyz"},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"attribution":{"type":"string"},"promoteId":{"type":"promoteId"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster":{"type":{"required":true,"type":"enum","values":{"raster":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512,"units":"pixels"},"scheme":{"type":"enum","values":{"xyz":{},"tms":{}},"default":"xyz"},"attribution":{"type":"string"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_dem":{"type":{"required":true,"type":"enum","values":{"raster-dem":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512,"units":"pixels"},"attribution":{"type":"string"},"encoding":{"type":"enum","values":{"terrarium":{},"mapbox":{}},"default":"mapbox"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_geojson":{"type":{"required":true,"type":"enum","values":{"geojson":{}}},"data":{"type":"*"},"maxzoom":{"type":"number","default":18},"attribution":{"type":"string"},"buffer":{"type":"number","default":128,"maximum":512,"minimum":0},"filter":{"type":"*"},"tolerance":{"type":"number","default":0.375},"cluster":{"type":"boolean","default":false},"clusterRadius":{"type":"number","default":50,"minimum":0},"clusterMaxZoom":{"type":"number"},"clusterMinPoints":{"type":"number"},"clusterProperties":{"type":"*"},"lineMetrics":{"type":"boolean","default":false},"generateId":{"type":"boolean","default":false},"promoteId":{"type":"promoteId"}},"source_video":{"type":{"required":true,"type":"enum","values":{"video":{}}},"urls":{"required":true,"type":"array","value":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_image":{"type":{"required":true,"type":"enum","values":{"image":{}}},"url":{"required":true,"type":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"layer":{"id":{"type":"string","required":true},"type":{"type":"enum","values":{"fill":{},"line":{},"symbol":{},"circle":{},"heatmap":{},"fill-extrusion":{},"raster":{},"hillshade":{},"background":{},"sky":{}},"required":true},"metadata":{"type":"*"},"source":{"type":"string"},"source-layer":{"type":"string"},"minzoom":{"type":"number","minimum":0,"maximum":24},"maxzoom":{"type":"number","minimum":0,"maximum":24},"filter":{"type":"filter"},"layout":{"type":"layout"},"paint":{"type":"paint"}},"layout":["layout_fill","layout_line","layout_circle","layout_heatmap","layout_fill-extrusion","layout_symbol","layout_raster","layout_hillshade","layout_background","layout_sky"],"layout_background":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_sky":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_fill":{"fill-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_circle":{"circle-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_heatmap":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_fill-extrusion":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_line":{"line-cap":{"type":"enum","values":{"butt":{},"round":{},"square":{}},"default":"butt","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-join":{"type":"enum","values":{"bevel":{},"round":{},"miter":{}},"default":"miter","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-miter-limit":{"type":"number","default":2,"requires":[{"line-join":"miter"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-round-limit":{"type":"number","default":1.05,"requires":[{"line-join":"round"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_symbol":{"symbol-placement":{"type":"enum","values":{"point":{},"line":{},"line-center":{}},"default":"point","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-spacing":{"type":"number","default":250,"minimum":1,"units":"pixels","requires":[{"symbol-placement":"line"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-avoid-edges":{"type":"boolean","default":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"symbol-z-order":{"type":"enum","values":{"auto":{},"viewport-y":{},"source":{}},"default":"auto","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-allow-overlap":{"type":"boolean","default":false,"requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-ignore-placement":{"type":"boolean","default":false,"requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-optional":{"type":"boolean","default":false,"requires":["icon-image","text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-rotation-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-size":{"type":"number","default":1,"minimum":0,"units":"factor of the original icon size","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit":{"type":"enum","values":{"none":{},"width":{},"height":{},"both":{}},"default":"none","requires":["icon-image","text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-text-fit-padding":{"type":"array","value":"number","length":4,"default":[0,0,0,0],"units":"pixels","requires":["icon-image","text-field",{"icon-text-fit":["both","width","height"]}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-image":{"type":"resolvedImage","tokens":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-rotate":{"type":"number","default":0,"period":360,"units":"degrees","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-padding":{"type":"number","default":2,"minimum":0,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-keep-upright":{"type":"boolean","default":false,"requires":["icon-image",{"icon-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-offset":{"type":"array","value":"number","length":2,"default":[0,0],"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-anchor":{"type":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"default":"center","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-rotation-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-field":{"type":"formatted","default":"","tokens":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-font":{"type":"array","value":"string","default":["Open Sans Regular","Arial Unicode MS Regular"],"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size":{"type":"number","default":16,"minimum":0,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-width":{"type":"number","default":10,"minimum":0,"units":"ems","requires":["text-field",{"symbol-placement":["point"]}],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-line-height":{"type":"number","default":1.2,"units":"ems","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-letter-spacing":{"type":"number","default":0,"units":"ems","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-justify":{"type":"enum","values":{"auto":{},"left":{},"center":{},"right":{}},"default":"center","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-radial-offset":{"type":"number","units":"ems","default":0,"requires":["text-field"],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["zoom","feature"]}},"text-variable-anchor":{"type":"array","value":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"requires":["text-field",{"symbol-placement":["point"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-anchor":{"type":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"default":"center","requires":["text-field",{"!":"text-variable-anchor"}],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-angle":{"type":"number","default":45,"units":"degrees","requires":["text-field",{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-writing-mode":{"type":"array","value":"enum","values":{"horizontal":{},"vertical":{}},"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-rotate":{"type":"number","default":0,"period":360,"units":"degrees","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-padding":{"type":"number","default":2,"minimum":0,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-keep-upright":{"type":"boolean","default":true,"requires":["text-field",{"text-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-transform":{"type":"enum","values":{"none":{},"uppercase":{},"lowercase":{}},"default":"none","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-offset":{"type":"array","value":"number","units":"ems","length":2,"default":[0,0],"requires":["text-field",{"!":"text-radial-offset"}],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-allow-overlap":{"type":"boolean","default":false,"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-ignore-placement":{"type":"boolean","default":false,"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-optional":{"type":"boolean","default":false,"requires":["text-field","icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_raster":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_hillshade":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"filter":{"type":"array","value":"*"},"filter_symbol":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature","pitch","distance-from-center"]}},"filter_fill":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_line":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_circle":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_fill-extrusion":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_heatmap":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_operator":{"type":"enum","values":{"==":{},"!=":{},">":{},">=":{},"<":{},"<=":{},"in":{},"!in":{},"all":{},"any":{},"none":{},"has":{},"!has":{},"within":{}}},"geometry_type":{"type":"enum","values":{"Point":{},"LineString":{},"Polygon":{}}},"function":{"expression":{"type":"expression"},"stops":{"type":"array","value":"function_stop"},"base":{"type":"number","default":1,"minimum":0},"property":{"type":"string","default":"$zoom"},"type":{"type":"enum","values":{"identity":{},"exponential":{},"interval":{},"categorical":{}},"default":"exponential"},"colorSpace":{"type":"enum","values":{"rgb":{},"lab":{},"hcl":{}},"default":"rgb"},"default":{"type":"*","required":false}},"function_stop":{"type":"array","minimum":0,"maximum":24,"value":["number","color"],"length":2},"expression":{"type":"array","value":"*","minimum":1},"fog":{"range":{"type":"array","default":[0.5,10],"minimum":-20,"maximum":20,"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"horizon-blend":{"type":"number","property-type":"data-constant","default":0.1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"light":{"anchor":{"type":"enum","default":"viewport","values":{"map":{},"viewport":{}},"property-type":"data-constant","transition":false,"expression":{"interpolated":false,"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"projection":{"name":{"type":"enum","values":{"albers":{},"equalEarth":{},"equirectangular":{},"lambertConformalConic":{},"mercator":{},"naturalEarth":{},"winkelTripel":{}},"default":"mercator","required":true},"center":{"type":"array","length":2,"value":"number","property-type":"data-constant","transition":false,"requires":[{"name":["albers","lambertConformalConic"]}]},"parallels":{"type":"array","length":2,"value":"number","property-type":"data-constant","transition":false,"requires":[{"name":["albers","lambertConformalConic"]}]}},"terrain":{"source":{"type":"string","required":true},"exaggeration":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1000,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"paint":["paint_fill","paint_line","paint_circle","paint_heatmap","paint_fill-extrusion","paint_symbol","paint_raster","paint_hillshade","paint_background","paint_sky"],"paint_fill":{"fill-antialias":{"type":"boolean","default":true,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"fill-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-outline-color":{"type":"color","transition":true,"requires":[{"!":"fill-pattern"},{"fill-antialias":true}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["fill-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-pattern":{"type":"resolvedImage","transition":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"cross-faded-data-driven"}},"paint_fill-extrusion":{"fill-extrusion-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"fill-extrusion-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["fill-extrusion-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-pattern":{"type":"resolvedImage","transition":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"cross-faded-data-driven"},"fill-extrusion-height":{"type":"number","default":0,"minimum":0,"units":"meters","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-base":{"type":"number","default":0,"minimum":0,"units":"meters","transition":true,"requires":["fill-extrusion-height"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-vertical-gradient":{"type":"boolean","default":true,"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_line":{"line-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"line-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["line-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"line-width":{"type":"number","default":1,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-gap-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-offset":{"type":"number","default":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-dasharray":{"type":"array","value":"number","minimum":0,"transition":true,"units":"line widths","requires":[{"!":"line-pattern"}],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"cross-faded-data-driven"},"line-pattern":{"type":"resolvedImage","transition":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"cross-faded-data-driven"},"line-gradient":{"type":"color","transition":false,"requires":[{"!":"line-pattern"},{"source":"geojson","has":{"lineMetrics":true}}],"expression":{"interpolated":true,"parameters":["line-progress"]},"property-type":"color-ramp"}},"paint_circle":{"circle-radius":{"type":"number","default":5,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-blur":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"circle-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["circle-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-scale":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{}},"default":"viewport","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-stroke-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"}},"paint_heatmap":{"heatmap-radius":{"type":"number","default":30,"minimum":1,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-weight":{"type":"number","default":1,"minimum":0,"transition":false,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-intensity":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"heatmap-color":{"type":"color","default":["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255, 0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"],"transition":false,"expression":{"interpolated":true,"parameters":["heatmap-density"]},"property-type":"color-ramp"},"heatmap-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_symbol":{"icon-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-color":{"type":"color","default":"#000000","transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["icon-image","icon-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-color":{"type":"color","default":"#000000","transition":true,"overridable":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["text-field","text-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_raster":{"raster-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-hue-rotate":{"type":"number","default":0,"period":360,"transition":true,"units":"degrees","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-resampling":{"type":"enum","values":{"linear":{},"nearest":{}},"default":"linear","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"raster-fade-duration":{"type":"number","default":300,"minimum":0,"transition":false,"units":"milliseconds","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_hillshade":{"hillshade-illumination-direction":{"type":"number","default":335,"minimum":0,"maximum":359,"transition":false,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-illumination-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"viewport","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-exaggeration":{"type":"number","default":0.5,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-shadow-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-highlight-color":{"type":"color","default":"#FFFFFF","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-accent-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_background":{"background-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"background-pattern"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"background-pattern":{"type":"resolvedImage","transition":true,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"cross-faded"},"background-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_sky":{"sky-type":{"type":"enum","values":{"gradient":{},"atmosphere":{}},"default":"atmosphere","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun":{"type":"array","value":"number","length":2,"units":"degrees","minimum":[0,0],"maximum":[360,180],"transition":false,"requires":[{"sky-type":"atmosphere"}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun-intensity":{"type":"number","requires":[{"sky-type":"atmosphere"}],"default":10,"minimum":0,"maximum":100,"transition":false,"property-type":"data-constant"},"sky-gradient-center":{"type":"array","requires":[{"sky-type":"gradient"}],"value":"number","default":[0,0],"length":2,"units":"degrees","minimum":[0,0],"maximum":[360,180],"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient-radius":{"type":"number","requires":[{"sky-type":"gradient"}],"default":90,"minimum":0,"maximum":180,"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient":{"type":"color","default":["interpolate",["linear"],["sky-radial-progress"],0.8,"#87ceeb",1,"white"],"transition":false,"requires":[{"sky-type":"gradient"}],"expression":{"interpolated":true,"parameters":["sky-radial-progress"]},"property-type":"color-ramp"},"sky-atmosphere-halo-color":{"type":"color","default":"white","transition":false,"requires":[{"sky-type":"atmosphere"}],"property-type":"data-constant"},"sky-atmosphere-color":{"type":"color","default":"white","transition":false,"requires":[{"sky-type":"atmosphere"}],"property-type":"data-constant"},"sky-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"transition":{"duration":{"type":"number","default":300,"minimum":0,"units":"milliseconds"},"delay":{"type":"number","default":0,"minimum":0,"units":"milliseconds"}},"property-type":{"data-driven":{"type":"property-type"},"cross-faded":{"type":"property-type"},"cross-faded-data-driven":{"type":"property-type"},"color-ramp":{"type":"property-type"},"data-constant":{"type":"property-type"},"constant":{"type":"property-type"}},"promoteId":{"*":{"type":"string"}}}');

    function jt(t, ...e) {
      for (const r of e) for (const e in r) t[e] = r[e];

      return t;
    }

    function Ot(t) {
      return t instanceof Number || t instanceof String || t instanceof Boolean ? t.valueOf() : t;
    }

    function qt(t) {
      if (Array.isArray(t)) return t.map(qt);

      if (t instanceof Object && !(t instanceof Number || t instanceof String || t instanceof Boolean)) {
        const e = {};

        for (const r in t) e[r] = qt(t[r]);

        return e;
      }

      return Ot(t);
    }

    class Nt extends Error {
      constructor(t, e) {
        super(e), this.message = e, this.key = t;
      }

    }

    class Gt {
      constructor(t, e = []) {
        this.parent = t, this.bindings = {};

        for (const [t, r] of e) this.bindings[t] = r;
      }

      concat(t) {
        return new Gt(this, t);
      }

      get(t) {
        if (this.bindings[t]) return this.bindings[t];
        if (this.parent) return this.parent.get(t);
        throw new Error(`${t} not found in scope.`);
      }

      has(t) {
        return !!this.bindings[t] || !!this.parent && this.parent.has(t);
      }

    }

    const Zt = {
      kind: "null"
    },
          Xt = {
      kind: "number"
    },
          Kt = {
      kind: "string"
    },
          Yt = {
      kind: "boolean"
    },
          Ht = {
      kind: "color"
    },
          Wt = {
      kind: "object"
    },
          Jt = {
      kind: "value"
    },
          Qt = {
      kind: "collator"
    },
          te = {
      kind: "formatted"
    },
          ee = {
      kind: "resolvedImage"
    };

    function re(t, e) {
      return {
        kind: "array",
        itemType: t,
        N: e
      };
    }

    function ne(t) {
      if ("array" === t.kind) {
        const e = ne(t.itemType);
        return "number" == typeof t.N ? `array<${e}, ${t.N}>` : "value" === t.itemType.kind ? "array" : `array<${e}>`;
      }

      return t.kind;
    }

    const ie = [Zt, Xt, Kt, Yt, Ht, te, Wt, re(Jt), ee];

    function se(t, e) {
      if ("error" === e.kind) return null;

      if ("array" === t.kind) {
        if ("array" === e.kind && (0 === e.N && "value" === e.itemType.kind || !se(t.itemType, e.itemType)) && ("number" != typeof t.N || t.N === e.N)) return null;
      } else {
        if (t.kind === e.kind) return null;
        if ("value" === t.kind) for (const t of ie) if (!se(t, e)) return null;
      }

      return `Expected ${ne(t)} but found ${ne(e)} instead.`;
    }

    function ae(t, e) {
      return e.some(e => e.kind === t.kind);
    }

    function oe(t, e) {
      return e.some(e => "null" === e ? null === t : "array" === e ? Array.isArray(t) : "object" === e ? t && !Array.isArray(t) && "object" == typeof t : e === typeof t);
    }

    function le(t) {
      var e = {
        exports: {}
      };
      return t(e, e.exports), e.exports;
    }

    var ue = le(function (t, e) {
      var r = {
        transparent: [0, 0, 0, 0],
        aliceblue: [240, 248, 255, 1],
        antiquewhite: [250, 235, 215, 1],
        aqua: [0, 255, 255, 1],
        aquamarine: [127, 255, 212, 1],
        azure: [240, 255, 255, 1],
        beige: [245, 245, 220, 1],
        bisque: [255, 228, 196, 1],
        black: [0, 0, 0, 1],
        blanchedalmond: [255, 235, 205, 1],
        blue: [0, 0, 255, 1],
        blueviolet: [138, 43, 226, 1],
        brown: [165, 42, 42, 1],
        burlywood: [222, 184, 135, 1],
        cadetblue: [95, 158, 160, 1],
        chartreuse: [127, 255, 0, 1],
        chocolate: [210, 105, 30, 1],
        coral: [255, 127, 80, 1],
        cornflowerblue: [100, 149, 237, 1],
        cornsilk: [255, 248, 220, 1],
        crimson: [220, 20, 60, 1],
        cyan: [0, 255, 255, 1],
        darkblue: [0, 0, 139, 1],
        darkcyan: [0, 139, 139, 1],
        darkgoldenrod: [184, 134, 11, 1],
        darkgray: [169, 169, 169, 1],
        darkgreen: [0, 100, 0, 1],
        darkgrey: [169, 169, 169, 1],
        darkkhaki: [189, 183, 107, 1],
        darkmagenta: [139, 0, 139, 1],
        darkolivegreen: [85, 107, 47, 1],
        darkorange: [255, 140, 0, 1],
        darkorchid: [153, 50, 204, 1],
        darkred: [139, 0, 0, 1],
        darksalmon: [233, 150, 122, 1],
        darkseagreen: [143, 188, 143, 1],
        darkslateblue: [72, 61, 139, 1],
        darkslategray: [47, 79, 79, 1],
        darkslategrey: [47, 79, 79, 1],
        darkturquoise: [0, 206, 209, 1],
        darkviolet: [148, 0, 211, 1],
        deeppink: [255, 20, 147, 1],
        deepskyblue: [0, 191, 255, 1],
        dimgray: [105, 105, 105, 1],
        dimgrey: [105, 105, 105, 1],
        dodgerblue: [30, 144, 255, 1],
        firebrick: [178, 34, 34, 1],
        floralwhite: [255, 250, 240, 1],
        forestgreen: [34, 139, 34, 1],
        fuchsia: [255, 0, 255, 1],
        gainsboro: [220, 220, 220, 1],
        ghostwhite: [248, 248, 255, 1],
        gold: [255, 215, 0, 1],
        goldenrod: [218, 165, 32, 1],
        gray: [128, 128, 128, 1],
        green: [0, 128, 0, 1],
        greenyellow: [173, 255, 47, 1],
        grey: [128, 128, 128, 1],
        honeydew: [240, 255, 240, 1],
        hotpink: [255, 105, 180, 1],
        indianred: [205, 92, 92, 1],
        indigo: [75, 0, 130, 1],
        ivory: [255, 255, 240, 1],
        khaki: [240, 230, 140, 1],
        lavender: [230, 230, 250, 1],
        lavenderblush: [255, 240, 245, 1],
        lawngreen: [124, 252, 0, 1],
        lemonchiffon: [255, 250, 205, 1],
        lightblue: [173, 216, 230, 1],
        lightcoral: [240, 128, 128, 1],
        lightcyan: [224, 255, 255, 1],
        lightgoldenrodyellow: [250, 250, 210, 1],
        lightgray: [211, 211, 211, 1],
        lightgreen: [144, 238, 144, 1],
        lightgrey: [211, 211, 211, 1],
        lightpink: [255, 182, 193, 1],
        lightsalmon: [255, 160, 122, 1],
        lightseagreen: [32, 178, 170, 1],
        lightskyblue: [135, 206, 250, 1],
        lightslategray: [119, 136, 153, 1],
        lightslategrey: [119, 136, 153, 1],
        lightsteelblue: [176, 196, 222, 1],
        lightyellow: [255, 255, 224, 1],
        lime: [0, 255, 0, 1],
        limegreen: [50, 205, 50, 1],
        linen: [250, 240, 230, 1],
        magenta: [255, 0, 255, 1],
        maroon: [128, 0, 0, 1],
        mediumaquamarine: [102, 205, 170, 1],
        mediumblue: [0, 0, 205, 1],
        mediumorchid: [186, 85, 211, 1],
        mediumpurple: [147, 112, 219, 1],
        mediumseagreen: [60, 179, 113, 1],
        mediumslateblue: [123, 104, 238, 1],
        mediumspringgreen: [0, 250, 154, 1],
        mediumturquoise: [72, 209, 204, 1],
        mediumvioletred: [199, 21, 133, 1],
        midnightblue: [25, 25, 112, 1],
        mintcream: [245, 255, 250, 1],
        mistyrose: [255, 228, 225, 1],
        moccasin: [255, 228, 181, 1],
        navajowhite: [255, 222, 173, 1],
        navy: [0, 0, 128, 1],
        oldlace: [253, 245, 230, 1],
        olive: [128, 128, 0, 1],
        olivedrab: [107, 142, 35, 1],
        orange: [255, 165, 0, 1],
        orangered: [255, 69, 0, 1],
        orchid: [218, 112, 214, 1],
        palegoldenrod: [238, 232, 170, 1],
        palegreen: [152, 251, 152, 1],
        paleturquoise: [175, 238, 238, 1],
        palevioletred: [219, 112, 147, 1],
        papayawhip: [255, 239, 213, 1],
        peachpuff: [255, 218, 185, 1],
        peru: [205, 133, 63, 1],
        pink: [255, 192, 203, 1],
        plum: [221, 160, 221, 1],
        powderblue: [176, 224, 230, 1],
        purple: [128, 0, 128, 1],
        rebeccapurple: [102, 51, 153, 1],
        red: [255, 0, 0, 1],
        rosybrown: [188, 143, 143, 1],
        royalblue: [65, 105, 225, 1],
        saddlebrown: [139, 69, 19, 1],
        salmon: [250, 128, 114, 1],
        sandybrown: [244, 164, 96, 1],
        seagreen: [46, 139, 87, 1],
        seashell: [255, 245, 238, 1],
        sienna: [160, 82, 45, 1],
        silver: [192, 192, 192, 1],
        skyblue: [135, 206, 235, 1],
        slateblue: [106, 90, 205, 1],
        slategray: [112, 128, 144, 1],
        slategrey: [112, 128, 144, 1],
        snow: [255, 250, 250, 1],
        springgreen: [0, 255, 127, 1],
        steelblue: [70, 130, 180, 1],
        tan: [210, 180, 140, 1],
        teal: [0, 128, 128, 1],
        thistle: [216, 191, 216, 1],
        tomato: [255, 99, 71, 1],
        turquoise: [64, 224, 208, 1],
        violet: [238, 130, 238, 1],
        wheat: [245, 222, 179, 1],
        white: [255, 255, 255, 1],
        whitesmoke: [245, 245, 245, 1],
        yellow: [255, 255, 0, 1],
        yellowgreen: [154, 205, 50, 1]
      };

      function n(t) {
        return (t = Math.round(t)) < 0 ? 0 : t > 255 ? 255 : t;
      }

      function i(t) {
        return n("%" === t[t.length - 1] ? parseFloat(t) / 100 * 255 : parseInt(t));
      }

      function s(t) {
        return (e = "%" === t[t.length - 1] ? parseFloat(t) / 100 : parseFloat(t)) < 0 ? 0 : e > 1 ? 1 : e;
        var e;
      }

      function a(t, e, r) {
        return r < 0 ? r += 1 : r > 1 && (r -= 1), 6 * r < 1 ? t + (e - t) * r * 6 : 2 * r < 1 ? e : 3 * r < 2 ? t + (e - t) * (2 / 3 - r) * 6 : t;
      }

      try {
        e.parseCSSColor = function (t) {
          var e,
              o = t.replace(/ /g, "").toLowerCase();
          if (o in r) return r[o].slice();
          if ("#" === o[0]) return 4 === o.length ? (e = parseInt(o.substr(1), 16)) >= 0 && e <= 4095 ? [(3840 & e) >> 4 | (3840 & e) >> 8, 240 & e | (240 & e) >> 4, 15 & e | (15 & e) << 4, 1] : null : 7 === o.length && (e = parseInt(o.substr(1), 16)) >= 0 && e <= 16777215 ? [(16711680 & e) >> 16, (65280 & e) >> 8, 255 & e, 1] : null;
          var l = o.indexOf("("),
              u = o.indexOf(")");

          if (-1 !== l && u + 1 === o.length) {
            var c = o.substr(0, l),
                h = o.substr(l + 1, u - (l + 1)).split(","),
                p = 1;

            switch (c) {
              case "rgba":
                if (4 !== h.length) return null;
                p = s(h.pop());

              case "rgb":
                return 3 !== h.length ? null : [i(h[0]), i(h[1]), i(h[2]), p];

              case "hsla":
                if (4 !== h.length) return null;
                p = s(h.pop());

              case "hsl":
                if (3 !== h.length) return null;
                var f = (parseFloat(h[0]) % 360 + 360) % 360 / 360,
                    d = s(h[1]),
                    y = s(h[2]),
                    m = y <= .5 ? y * (d + 1) : y + d - y * d,
                    g = 2 * y - m;
                return [n(255 * a(g, m, f + 1 / 3)), n(255 * a(g, m, f)), n(255 * a(g, m, f - 1 / 3)), p];

              default:
                return null;
            }
          }

          return null;
        };
      } catch (t) {}
    });

    class ce {
      constructor(t, e, r, n = 1) {
        this.r = t, this.g = e, this.b = r, this.a = n;
      }

      static parse(t) {
        if (!t) return;
        if (t instanceof ce) return t;
        if ("string" != typeof t) return;
        const e = ue.parseCSSColor(t);
        return e ? new ce(e[0] / 255 * e[3], e[1] / 255 * e[3], e[2] / 255 * e[3], e[3]) : void 0;
      }

      toString() {
        const [t, e, r, n] = this.toArray();
        return `rgba(${Math.round(t)},${Math.round(e)},${Math.round(r)},${n})`;
      }

      toArray() {
        const {
          r: t,
          g: e,
          b: r,
          a: n
        } = this;
        return 0 === n ? [0, 0, 0, 0] : [255 * t / n, 255 * e / n, 255 * r / n, n];
      }

    }

    ce.black = new ce(0, 0, 0, 1), ce.white = new ce(1, 1, 1, 1), ce.transparent = new ce(0, 0, 0, 0), ce.red = new ce(1, 0, 0, 1), ce.blue = new ce(0, 0, 1, 1);

    class he {
      constructor(t, e, r) {
        this.sensitivity = t ? e ? "variant" : "case" : e ? "accent" : "base", this.locale = r, this.collator = new Intl.Collator(this.locale ? this.locale : [], {
          sensitivity: this.sensitivity,
          usage: "search"
        });
      }

      compare(t, e) {
        return this.collator.compare(t, e);
      }

      resolvedLocale() {
        return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
      }

    }

    class pe {
      constructor(t, e, r, n, i) {
        this.text = t.normalize ? t.normalize() : t, this.image = e, this.scale = r, this.fontStack = n, this.textColor = i;
      }

    }

    class fe {
      constructor(t) {
        this.sections = t;
      }

      static fromString(t) {
        return new fe([new pe(t, null, null, null, null)]);
      }

      isEmpty() {
        return 0 === this.sections.length || !this.sections.some(t => 0 !== t.text.length || t.image && 0 !== t.image.name.length);
      }

      static factory(t) {
        return t instanceof fe ? t : fe.fromString(t);
      }

      toString() {
        return 0 === this.sections.length ? "" : this.sections.map(t => t.text).join("");
      }

      serialize() {
        const t = ["format"];

        for (const e of this.sections) {
          if (e.image) {
            t.push(["image", e.image.name]);
            continue;
          }

          t.push(e.text);
          const r = {};
          e.fontStack && (r["text-font"] = ["literal", e.fontStack.split(",")]), e.scale && (r["font-scale"] = e.scale), e.textColor && (r["text-color"] = ["rgba"].concat(e.textColor.toArray())), t.push(r);
        }

        return t;
      }

    }

    class de {
      constructor(t) {
        this.name = t.name, this.available = t.available;
      }

      toString() {
        return this.name;
      }

      static fromString(t) {
        return t ? new de({
          name: t,
          available: !1
        }) : null;
      }

      serialize() {
        return ["image", this.name];
      }

    }

    function ye(t, e, r, n) {
      return "number" == typeof t && t >= 0 && t <= 255 && "number" == typeof e && e >= 0 && e <= 255 && "number" == typeof r && r >= 0 && r <= 255 ? void 0 === n || "number" == typeof n && n >= 0 && n <= 1 ? null : `Invalid rgba value [${[t, e, r, n].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${("number" == typeof n ? [t, e, r, n] : [t, e, r]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
    }

    function me(t) {
      if (null === t) return !0;
      if ("string" == typeof t) return !0;
      if ("boolean" == typeof t) return !0;
      if ("number" == typeof t) return !0;
      if (t instanceof ce) return !0;
      if (t instanceof he) return !0;
      if (t instanceof fe) return !0;
      if (t instanceof de) return !0;

      if (Array.isArray(t)) {
        for (const e of t) if (!me(e)) return !1;

        return !0;
      }

      if ("object" == typeof t) {
        for (const e in t) if (!me(t[e])) return !1;

        return !0;
      }

      return !1;
    }

    function ge(t) {
      if (null === t) return Zt;
      if ("string" == typeof t) return Kt;
      if ("boolean" == typeof t) return Yt;
      if ("number" == typeof t) return Xt;
      if (t instanceof ce) return Ht;
      if (t instanceof he) return Qt;
      if (t instanceof fe) return te;
      if (t instanceof de) return ee;

      if (Array.isArray(t)) {
        const e = t.length;
        let r;

        for (const e of t) {
          const t = ge(e);

          if (r) {
            if (r === t) continue;
            r = Jt;
            break;
          }

          r = t;
        }

        return re(r || Jt, e);
      }

      return Wt;
    }

    function xe(t) {
      const e = typeof t;
      return null === t ? "" : "string" === e || "number" === e || "boolean" === e ? String(t) : t instanceof ce || t instanceof fe || t instanceof de ? t.toString() : JSON.stringify(t);
    }

    class ve {
      constructor(t, e) {
        this.type = t, this.value = e;
      }

      static parse(t, e) {
        if (2 !== t.length) return e.error(`'literal' expression requires exactly one argument, but found ${t.length - 1} instead.`);
        if (!me(t[1])) return e.error("invalid value");
        const r = t[1];
        let n = ge(r);
        const i = e.expectedType;
        return "array" !== n.kind || 0 !== n.N || !i || "array" !== i.kind || "number" == typeof i.N && 0 !== i.N || (n = i), new ve(n, r);
      }

      evaluate() {
        return this.value;
      }

      eachChild() {}

      outputDefined() {
        return !0;
      }

      serialize() {
        return "array" === this.type.kind || "object" === this.type.kind ? ["literal", this.value] : this.value instanceof ce ? ["rgba"].concat(this.value.toArray()) : this.value instanceof fe ? this.value.serialize() : this.value;
      }

    }

    class be {
      constructor(t) {
        this.name = "ExpressionEvaluationError", this.message = t;
      }

      toJSON() {
        return this.message;
      }

    }

    const _e = {
      string: Kt,
      number: Xt,
      boolean: Yt,
      object: Wt
    };

    class we {
      constructor(t, e) {
        this.type = t, this.args = e;
      }

      static parse(t, e) {
        if (t.length < 2) return e.error("Expected at least one argument.");
        let r,
            n = 1;
        const i = t[0];

        if ("array" === i) {
          let i, s;

          if (t.length > 2) {
            const r = t[1];
            if ("string" != typeof r || !(r in _e) || "object" === r) return e.error('The item type argument of "array" must be one of string, number, boolean', 1);
            i = _e[r], n++;
          } else i = Jt;

          if (t.length > 3) {
            if (null !== t[2] && ("number" != typeof t[2] || t[2] < 0 || t[2] !== Math.floor(t[2]))) return e.error('The length argument to "array" must be a positive integer literal', 2);
            s = t[2], n++;
          }

          r = re(i, s);
        } else r = _e[i];

        const s = [];

        for (; n < t.length; n++) {
          const r = e.parse(t[n], n, Jt);
          if (!r) return null;
          s.push(r);
        }

        return new we(r, s);
      }

      evaluate(t) {
        for (let e = 0; e < this.args.length; e++) {
          const r = this.args[e].evaluate(t);
          if (!se(this.type, ge(r))) return r;
          if (e === this.args.length - 1) throw new be(`Expected value to be of type ${ne(this.type)}, but found ${ne(ge(r))} instead.`);
        }

        return null;
      }

      eachChild(t) {
        this.args.forEach(t);
      }

      outputDefined() {
        return this.args.every(t => t.outputDefined());
      }

      serialize() {
        const t = this.type,
              e = [t.kind];

        if ("array" === t.kind) {
          const r = t.itemType;

          if ("string" === r.kind || "number" === r.kind || "boolean" === r.kind) {
            e.push(r.kind);
            const n = t.N;
            ("number" == typeof n || this.args.length > 1) && e.push(n);
          }
        }

        return e.concat(this.args.map(t => t.serialize()));
      }

    }

    class Ae {
      constructor(t) {
        this.type = te, this.sections = t;
      }

      static parse(t, e) {
        if (t.length < 2) return e.error("Expected at least one argument.");
        const r = t[1];
        if (!Array.isArray(r) && "object" == typeof r) return e.error("First argument must be an image or text section.");
        const n = [];
        let i = !1;

        for (let r = 1; r <= t.length - 1; ++r) {
          const s = t[r];

          if (i && "object" == typeof s && !Array.isArray(s)) {
            i = !1;
            let t = null;
            if (s["font-scale"] && (t = e.parse(s["font-scale"], 1, Xt), !t)) return null;
            let r = null;
            if (s["text-font"] && (r = e.parse(s["text-font"], 1, re(Kt)), !r)) return null;
            let a = null;
            if (s["text-color"] && (a = e.parse(s["text-color"], 1, Ht), !a)) return null;
            const o = n[n.length - 1];
            o.scale = t, o.font = r, o.textColor = a;
          } else {
            const s = e.parse(t[r], 1, Jt);
            if (!s) return null;
            const a = s.type.kind;
            if ("string" !== a && "value" !== a && "null" !== a && "resolvedImage" !== a) return e.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
            i = !0, n.push({
              content: s,
              scale: null,
              font: null,
              textColor: null
            });
          }
        }

        return new Ae(n);
      }

      evaluate(t) {
        return new fe(this.sections.map(e => {
          const r = e.content.evaluate(t);
          return ge(r) === ee ? new pe("", r, null, null, null) : new pe(xe(r), null, e.scale ? e.scale.evaluate(t) : null, e.font ? e.font.evaluate(t).join(",") : null, e.textColor ? e.textColor.evaluate(t) : null);
        }));
      }

      eachChild(t) {
        for (const e of this.sections) t(e.content), e.scale && t(e.scale), e.font && t(e.font), e.textColor && t(e.textColor);
      }

      outputDefined() {
        return !1;
      }

      serialize() {
        const t = ["format"];

        for (const e of this.sections) {
          t.push(e.content.serialize());
          const r = {};
          e.scale && (r["font-scale"] = e.scale.serialize()), e.font && (r["text-font"] = e.font.serialize()), e.textColor && (r["text-color"] = e.textColor.serialize()), t.push(r);
        }

        return t;
      }

    }

    class ke {
      constructor(t) {
        this.type = ee, this.input = t;
      }

      static parse(t, e) {
        if (2 !== t.length) return e.error("Expected two arguments.");
        const r = e.parse(t[1], 1, Kt);
        return r ? new ke(r) : e.error("No image name provided.");
      }

      evaluate(t) {
        const e = this.input.evaluate(t),
              r = de.fromString(e);
        return r && t.availableImages && (r.available = t.availableImages.indexOf(e) > -1), r;
      }

      eachChild(t) {
        t(this.input);
      }

      outputDefined() {
        return !1;
      }

      serialize() {
        return ["image", this.input.serialize()];
      }

    }

    const Se = {
      "to-boolean": Yt,
      "to-color": Ht,
      "to-number": Xt,
      "to-string": Kt
    };

    class Ie {
      constructor(t, e) {
        this.type = t, this.args = e;
      }

      static parse(t, e) {
        if (t.length < 2) return e.error("Expected at least one argument.");
        const r = t[0];
        if (("to-boolean" === r || "to-string" === r) && 2 !== t.length) return e.error("Expected one argument.");
        const n = Se[r],
              i = [];

        for (let r = 1; r < t.length; r++) {
          const n = e.parse(t[r], r, Jt);
          if (!n) return null;
          i.push(n);
        }

        return new Ie(n, i);
      }

      evaluate(t) {
        if ("boolean" === this.type.kind) return Boolean(this.args[0].evaluate(t));

        if ("color" === this.type.kind) {
          let e, r;

          for (const n of this.args) {
            if (e = n.evaluate(t), r = null, e instanceof ce) return e;

            if ("string" == typeof e) {
              const r = t.parseColor(e);
              if (r) return r;
            } else if (Array.isArray(e) && (r = e.length < 3 || e.length > 4 ? `Invalid rbga value ${JSON.stringify(e)}: expected an array containing either three or four numeric values.` : ye(e[0], e[1], e[2], e[3]), !r)) return new ce(e[0] / 255, e[1] / 255, e[2] / 255, e[3]);
          }

          throw new be(r || `Could not parse color from value '${"string" == typeof e ? e : String(JSON.stringify(e))}'`);
        }

        if ("number" === this.type.kind) {
          let e = null;

          for (const r of this.args) {
            if (e = r.evaluate(t), null === e) return 0;
            const n = Number(e);
            if (!isNaN(n)) return n;
          }

          throw new be(`Could not convert ${JSON.stringify(e)} to number.`);
        }

        return "formatted" === this.type.kind ? fe.fromString(xe(this.args[0].evaluate(t))) : "resolvedImage" === this.type.kind ? de.fromString(xe(this.args[0].evaluate(t))) : xe(this.args[0].evaluate(t));
      }

      eachChild(t) {
        this.args.forEach(t);
      }

      outputDefined() {
        return this.args.every(t => t.outputDefined());
      }

      serialize() {
        if ("formatted" === this.type.kind) return new Ae([{
          content: this.args[0],
          scale: null,
          font: null,
          textColor: null
        }]).serialize();
        if ("resolvedImage" === this.type.kind) return new ke(this.args[0]).serialize();
        const t = [`to-${this.type.kind}`];
        return this.eachChild(e => {
          t.push(e.serialize());
        }), t;
      }

    }

    const Me = ["Unknown", "Point", "LineString", "Polygon"];

    class Te {
      constructor() {
        this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null, this.featureTileCoord = null, this.featureDistanceData = null;
      }

      id() {
        return this.feature && "id" in this.feature && this.feature.id ? this.feature.id : null;
      }

      geometryType() {
        return this.feature ? "number" == typeof this.feature.type ? Me[this.feature.type] : this.feature.type : null;
      }

      geometry() {
        return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
      }

      canonicalID() {
        return this.canonical;
      }

      properties() {
        return this.feature && this.feature.properties || {};
      }

      distanceFromCenter() {
        if (this.featureTileCoord && this.featureDistanceData) {
          const t = this.featureDistanceData.center,
                e = this.featureDistanceData.scale,
                {
            x: r,
            y: n
          } = this.featureTileCoord;
          return this.featureDistanceData.bearing[0] * (r * e - t[0]) + this.featureDistanceData.bearing[1] * (n * e - t[1]);
        }

        return 0;
      }

      parseColor(t) {
        let e = this._parseColorCache[t];
        return e || (e = this._parseColorCache[t] = ce.parse(t)), e;
      }

    }

    class ze {
      constructor(t, e, r, n) {
        this.name = t, this.type = e, this._evaluate = r, this.args = n;
      }

      evaluate(t) {
        return this._evaluate(t, this.args);
      }

      eachChild(t) {
        this.args.forEach(t);
      }

      outputDefined() {
        return !1;
      }

      serialize() {
        return [this.name].concat(this.args.map(t => t.serialize()));
      }

      static parse(t, e) {
        const r = t[0],
              n = ze.definitions[r];
        if (!n) return e.error(`Unknown expression "${r}". If you wanted a literal array, use ["literal", [...]].`, 0);
        const i = Array.isArray(n) ? n[0] : n.type,
              s = Array.isArray(n) ? [[n[1], n[2]]] : n.overloads,
              a = s.filter(([e]) => !Array.isArray(e) || e.length === t.length - 1);
        let o = null;

        for (const [n, s] of a) {
          o = new Je(e.registry, e.path, null, e.scope);
          const a = [];
          let l = !1;

          for (let e = 1; e < t.length; e++) {
            const r = t[e],
                  i = Array.isArray(n) ? n[e - 1] : n.type,
                  s = o.parse(r, 1 + a.length, i);

            if (!s) {
              l = !0;
              break;
            }

            a.push(s);
          }

          if (!l) if (Array.isArray(n) && n.length !== a.length) o.error(`Expected ${n.length} arguments, but found ${a.length} instead.`);else {
            for (let t = 0; t < a.length; t++) {
              const e = Array.isArray(n) ? n[t] : n.type,
                    r = a[t];
              o.concat(t + 1).checkSubtype(e, r.type);
            }

            if (0 === o.errors.length) return new ze(r, i, s, a);
          }
        }

        if (1 === a.length) e.errors.push(...o.errors);else {
          const r = (a.length ? a : s).map(([t]) => {
            return e = t, Array.isArray(e) ? `(${e.map(ne).join(", ")})` : `(${ne(e.type)}...)`;
            var e;
          }).join(" | "),
                n = [];

          for (let r = 1; r < t.length; r++) {
            const i = e.parse(t[r], 1 + n.length);
            if (!i) return null;
            n.push(ne(i.type));
          }

          e.error(`Expected arguments of type ${r}, but found (${n.join(", ")}) instead.`);
        }
        return null;
      }

      static register(t, e) {
        ze.definitions = e;

        for (const r in e) t[r] = ze;
      }

    }

    class Be {
      constructor(t, e, r) {
        this.type = Qt, this.locale = r, this.caseSensitive = t, this.diacriticSensitive = e;
      }

      static parse(t, e) {
        if (2 !== t.length) return e.error("Expected one argument.");
        const r = t[1];
        if ("object" != typeof r || Array.isArray(r)) return e.error("Collator options argument must be an object.");
        const n = e.parse(void 0 !== r["case-sensitive"] && r["case-sensitive"], 1, Yt);
        if (!n) return null;
        const i = e.parse(void 0 !== r["diacritic-sensitive"] && r["diacritic-sensitive"], 1, Yt);
        if (!i) return null;
        let s = null;
        return r.locale && (s = e.parse(r.locale, 1, Kt), !s) ? null : new Be(n, i, s);
      }

      evaluate(t) {
        return new he(this.caseSensitive.evaluate(t), this.diacriticSensitive.evaluate(t), this.locale ? this.locale.evaluate(t) : null);
      }

      eachChild(t) {
        t(this.caseSensitive), t(this.diacriticSensitive), this.locale && t(this.locale);
      }

      outputDefined() {
        return !1;
      }

      serialize() {
        const t = {};
        return t["case-sensitive"] = this.caseSensitive.serialize(), t["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (t.locale = this.locale.serialize()), ["collator", t];
      }

    }

    const Ee = 8192;

    function Ce(t, e) {
      t[0] = Math.min(t[0], e[0]), t[1] = Math.min(t[1], e[1]), t[2] = Math.max(t[2], e[0]), t[3] = Math.max(t[3], e[1]);
    }

    function De(t, e) {
      return !(t[0] <= e[0] || t[2] >= e[2] || t[1] <= e[1] || t[3] >= e[3]);
    }

    function Pe(t, e) {
      const r = (180 + t[0]) / 360,
            n = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t[1] * Math.PI / 360))) / 360,
            i = Math.pow(2, e.z);
      return [Math.round(r * i * Ee), Math.round(n * i * Ee)];
    }

    function Ve(t, e, r) {
      const n = t[0] - e[0],
            i = t[1] - e[1],
            s = t[0] - r[0],
            a = t[1] - r[1];
      return n * a - s * i == 0 && n * s <= 0 && i * a <= 0;
    }

    function Fe(t, e) {
      let r = !1;

      for (let a = 0, o = e.length; a < o; a++) {
        const o = e[a];

        for (let e = 0, a = o.length; e < a - 1; e++) {
          if (Ve(t, o[e], o[e + 1])) return !1;
          (i = o[e])[1] > (n = t)[1] != (s = o[e + 1])[1] > n[1] && n[0] < (s[0] - i[0]) * (n[1] - i[1]) / (s[1] - i[1]) + i[0] && (r = !r);
        }
      }

      var n, i, s;
      return r;
    }

    function Le(t, e) {
      for (let r = 0; r < e.length; r++) if (Fe(t, e[r])) return !0;

      return !1;
    }

    function Re(t, e, r, n) {
      const i = n[0] - r[0],
            s = n[1] - r[1],
            a = (t[0] - r[0]) * s - i * (t[1] - r[1]),
            o = (e[0] - r[0]) * s - i * (e[1] - r[1]);
      return a > 0 && o < 0 || a < 0 && o > 0;
    }

    function Ue(t, e, r) {
      for (const u of r) for (let r = 0; r < u.length - 1; ++r) if (0 != (o = [(a = u[r + 1])[0] - (s = u[r])[0], a[1] - s[1]])[0] * (l = [(i = e)[0] - (n = t)[0], i[1] - n[1]])[1] - o[1] * l[0] && Re(n, i, s, a) && Re(s, a, n, i)) return !0;

      var n, i, s, a, o, l;
      return !1;
    }

    function $e(t, e) {
      for (let r = 0; r < t.length; ++r) if (!Fe(t[r], e)) return !1;

      for (let r = 0; r < t.length - 1; ++r) if (Ue(t[r], t[r + 1], e)) return !1;

      return !0;
    }

    function je(t, e) {
      for (let r = 0; r < e.length; r++) if ($e(t, e[r])) return !0;

      return !1;
    }

    function Oe(t, e, r) {
      const n = [];

      for (let i = 0; i < t.length; i++) {
        const s = [];

        for (let n = 0; n < t[i].length; n++) {
          const a = Pe(t[i][n], r);
          Ce(e, a), s.push(a);
        }

        n.push(s);
      }

      return n;
    }

    function qe(t, e, r) {
      const n = [];

      for (let i = 0; i < t.length; i++) {
        const s = Oe(t[i], e, r);
        n.push(s);
      }

      return n;
    }

    function Ne(t, e, r, n) {
      if (t[0] < r[0] || t[0] > r[2]) {
        const e = .5 * n;
        let i = t[0] - r[0] > e ? -n : r[0] - t[0] > e ? n : 0;
        0 === i && (i = t[0] - r[2] > e ? -n : r[2] - t[0] > e ? n : 0), t[0] += i;
      }

      Ce(e, t);
    }

    function Ge(t, e, r, n) {
      const i = Math.pow(2, n.z) * Ee,
            s = [n.x * Ee, n.y * Ee],
            a = [];
      if (!t) return a;

      for (const n of t) for (const t of n) {
        const n = [t.x + s[0], t.y + s[1]];
        Ne(n, e, r, i), a.push(n);
      }

      return a;
    }

    function Ze(t, e, r, n) {
      const i = Math.pow(2, n.z) * Ee,
            s = [n.x * Ee, n.y * Ee],
            a = [];
      if (!t) return a;

      for (const r of t) {
        const t = [];

        for (const n of r) {
          const r = [n.x + s[0], n.y + s[1]];
          Ce(e, r), t.push(r);
        }

        a.push(t);
      }

      if (e[2] - e[0] <= i / 2) {
        (o = e)[0] = o[1] = 1 / 0, o[2] = o[3] = -1 / 0;

        for (const t of a) for (const n of t) Ne(n, e, r, i);
      }

      var o;
      return a;
    }

    class Xe {
      constructor(t, e) {
        this.type = Yt, this.geojson = t, this.geometries = e;
      }

      static parse(t, e) {
        if (2 !== t.length) return e.error(`'within' expression requires exactly one argument, but found ${t.length - 1} instead.`);

        if (me(t[1])) {
          const e = t[1];
          if ("FeatureCollection" === e.type) for (let t = 0; t < e.features.length; ++t) {
            const r = e.features[t].geometry.type;
            if ("Polygon" === r || "MultiPolygon" === r) return new Xe(e, e.features[t].geometry);
          } else if ("Feature" === e.type) {
            const t = e.geometry.type;
            if ("Polygon" === t || "MultiPolygon" === t) return new Xe(e, e.geometry);
          } else if ("Polygon" === e.type || "MultiPolygon" === e.type) return new Xe(e, e);
        }

        return e.error("'within' expression requires valid geojson object that contains polygon geometry type.");
      }

      evaluate(t) {
        if (null != t.geometry() && null != t.canonicalID()) {
          if ("Point" === t.geometryType()) return function (t, e) {
            const r = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  n = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  i = t.canonicalID();
            if (!i) return !1;

            if ("Polygon" === e.type) {
              const s = Oe(e.coordinates, n, i),
                    a = Ge(t.geometry(), r, n, i);
              if (!De(r, n)) return !1;

              for (const t of a) if (!Fe(t, s)) return !1;
            }

            if ("MultiPolygon" === e.type) {
              const s = qe(e.coordinates, n, i),
                    a = Ge(t.geometry(), r, n, i);
              if (!De(r, n)) return !1;

              for (const t of a) if (!Le(t, s)) return !1;
            }

            return !0;
          }(t, this.geometries);
          if ("LineString" === t.geometryType()) return function (t, e) {
            const r = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  n = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  i = t.canonicalID();
            if (!i) return !1;

            if ("Polygon" === e.type) {
              const s = Oe(e.coordinates, n, i),
                    a = Ze(t.geometry(), r, n, i);
              if (!De(r, n)) return !1;

              for (const t of a) if (!$e(t, s)) return !1;
            }

            if ("MultiPolygon" === e.type) {
              const s = qe(e.coordinates, n, i),
                    a = Ze(t.geometry(), r, n, i);
              if (!De(r, n)) return !1;

              for (const t of a) if (!je(t, s)) return !1;
            }

            return !0;
          }(t, this.geometries);
        }

        return !1;
      }

      eachChild() {}

      outputDefined() {
        return !0;
      }

      serialize() {
        return ["within", this.geojson];
      }

    }

    function Ke(t) {
      if (t instanceof ze) {
        if ("get" === t.name && 1 === t.args.length) return !1;
        if ("feature-state" === t.name) return !1;
        if ("has" === t.name && 1 === t.args.length) return !1;
        if ("properties" === t.name || "geometry-type" === t.name || "id" === t.name) return !1;
        if (/^filter-/.test(t.name)) return !1;
      }

      if (t instanceof Xe) return !1;
      let e = !0;
      return t.eachChild(t => {
        e && !Ke(t) && (e = !1);
      }), e;
    }

    function Ye(t) {
      if (t instanceof ze && "feature-state" === t.name) return !1;
      let e = !0;
      return t.eachChild(t => {
        e && !Ye(t) && (e = !1);
      }), e;
    }

    function He(t, e) {
      if (t instanceof ze && e.indexOf(t.name) >= 0) return !1;
      let r = !0;
      return t.eachChild(t => {
        r && !He(t, e) && (r = !1);
      }), r;
    }

    class We {
      constructor(t, e) {
        this.type = e.type, this.name = t, this.boundExpression = e;
      }

      static parse(t, e) {
        if (2 !== t.length || "string" != typeof t[1]) return e.error("'var' expression requires exactly one string literal argument.");
        const r = t[1];
        return e.scope.has(r) ? new We(r, e.scope.get(r)) : e.error(`Unknown variable "${r}". Make sure "${r}" has been bound in an enclosing "let" expression before using it.`, 1);
      }

      evaluate(t) {
        return this.boundExpression.evaluate(t);
      }

      eachChild() {}

      outputDefined() {
        return !1;
      }

      serialize() {
        return ["var", this.name];
      }

    }

    class Je {
      constructor(t, e = [], r, n = new Gt(), i = []) {
        this.registry = t, this.path = e, this.key = e.map(t => `[${t}]`).join(""), this.scope = n, this.errors = i, this.expectedType = r;
      }

      parse(t, e, r, n, i = {}) {
        return e ? this.concat(e, r, n)._parse(t, i) : this._parse(t, i);
      }

      _parse(t, e) {
        function r(t, e, r) {
          return "assert" === r ? new we(e, [t]) : "coerce" === r ? new Ie(e, [t]) : t;
        }

        if (null !== t && "string" != typeof t && "boolean" != typeof t && "number" != typeof t || (t = ["literal", t]), Array.isArray(t)) {
          if (0 === t.length) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
          const n = t[0];
          if ("string" != typeof n) return this.error(`Expression name must be a string, but found ${typeof n} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
          const i = this.registry[n];

          if (i) {
            let n = i.parse(t, this);
            if (!n) return null;

            if (this.expectedType) {
              const t = this.expectedType,
                    i = n.type;
              if ("string" !== t.kind && "number" !== t.kind && "boolean" !== t.kind && "object" !== t.kind && "array" !== t.kind || "value" !== i.kind) {
                if ("color" !== t.kind && "formatted" !== t.kind && "resolvedImage" !== t.kind || "value" !== i.kind && "string" !== i.kind) {
                  if (this.checkSubtype(t, i)) return null;
                } else n = r(n, t, e.typeAnnotation || "coerce");
              } else n = r(n, t, e.typeAnnotation || "assert");
            }

            if (!(n instanceof ve) && "resolvedImage" !== n.type.kind && Qe(n)) {
              const t = new Te();

              try {
                n = new ve(n.type, n.evaluate(t));
              } catch (t) {
                return this.error(t.message), null;
              }
            }

            return n;
          }

          return this.error(`Unknown expression "${n}". If you wanted a literal array, use ["literal", [...]].`, 0);
        }

        return this.error(void 0 === t ? "'undefined' value invalid. Use null instead." : "object" == typeof t ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t} instead.`);
      }

      concat(t, e, r) {
        const n = "number" == typeof t ? this.path.concat(t) : this.path,
              i = r ? this.scope.concat(r) : this.scope;
        return new Je(this.registry, n, e || null, i, this.errors);
      }

      error(t, ...e) {
        const r = `${this.key}${e.map(t => `[${t}]`).join("")}`;
        this.errors.push(new Nt(r, t));
      }

      checkSubtype(t, e) {
        const r = se(t, e);
        return r && this.error(r), r;
      }

    }

    function Qe(t) {
      if (t instanceof We) return Qe(t.boundExpression);
      if (t instanceof ze && "error" === t.name) return !1;
      if (t instanceof Be) return !1;
      if (t instanceof Xe) return !1;
      const e = t instanceof Ie || t instanceof we;
      let r = !0;
      return t.eachChild(t => {
        r = e ? r && Qe(t) : r && t instanceof ve;
      }), !!r && Ke(t) && He(t, ["zoom", "heatmap-density", "line-progress", "sky-radial-progress", "accumulated", "is-supported-script", "pitch", "distance-from-center"]);
    }

    function tr(t, e) {
      const r = t.length - 1;
      let n,
          i,
          s = 0,
          a = r,
          o = 0;

      for (; s <= a;) if (o = Math.floor((s + a) / 2), n = t[o], i = t[o + 1], n <= e) {
        if (o === r || e < i) return o;
        s = o + 1;
      } else {
        if (!(n > e)) throw new be("Input is not a number.");
        a = o - 1;
      }

      return 0;
    }

    class er {
      constructor(t, e, r) {
        this.type = t, this.input = e, this.labels = [], this.outputs = [];

        for (const [t, e] of r) this.labels.push(t), this.outputs.push(e);
      }

      static parse(t, e) {
        if (t.length - 1 < 4) return e.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
        if ((t.length - 1) % 2 != 0) return e.error("Expected an even number of arguments.");
        const r = e.parse(t[1], 1, Xt);
        if (!r) return null;
        const n = [];
        let i = null;
        e.expectedType && "value" !== e.expectedType.kind && (i = e.expectedType);

        for (let r = 1; r < t.length; r += 2) {
          const s = 1 === r ? -1 / 0 : t[r],
                a = t[r + 1],
                o = r,
                l = r + 1;
          if ("number" != typeof s) return e.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', o);
          if (n.length && n[n.length - 1][0] >= s) return e.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', o);
          const u = e.parse(a, l, i);
          if (!u) return null;
          i = i || u.type, n.push([s, u]);
        }

        return new er(i, r, n);
      }

      evaluate(t) {
        const e = this.labels,
              r = this.outputs;
        if (1 === e.length) return r[0].evaluate(t);
        const n = this.input.evaluate(t);
        if (n <= e[0]) return r[0].evaluate(t);
        const i = e.length;
        return n >= e[i - 1] ? r[i - 1].evaluate(t) : r[tr(e, n)].evaluate(t);
      }

      eachChild(t) {
        t(this.input);

        for (const e of this.outputs) t(e);
      }

      outputDefined() {
        return this.outputs.every(t => t.outputDefined());
      }

      serialize() {
        const t = ["step", this.input.serialize()];

        for (let e = 0; e < this.labels.length; e++) e > 0 && t.push(this.labels[e]), t.push(this.outputs[e].serialize());

        return t;
      }

    }

    function rr(t, e, r) {
      return t * (1 - r) + e * r;
    }

    var nr = Object.freeze({
      __proto__: null,
      number: rr,
      color: function (t, e, r) {
        return new ce(rr(t.r, e.r, r), rr(t.g, e.g, r), rr(t.b, e.b, r), rr(t.a, e.a, r));
      },
      array: function (t, e, r) {
        return t.map((t, n) => rr(t, e[n], r));
      }
    });
    const ir = .95047,
          sr = 1.08883,
          ar = 4 / 29,
          or = 6 / 29,
          lr = 3 * or * or,
          ur = Math.PI / 180,
          cr = 180 / Math.PI;

    function hr(t) {
      return t > .008856451679035631 ? Math.pow(t, 1 / 3) : t / lr + ar;
    }

    function pr(t) {
      return t > or ? t * t * t : lr * (t - ar);
    }

    function fr(t) {
      return 255 * (t <= .0031308 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - .055);
    }

    function dr(t) {
      return (t /= 255) <= .04045 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4);
    }

    function yr(t) {
      const e = dr(t.r),
            r = dr(t.g),
            n = dr(t.b),
            i = hr((.4124564 * e + .3575761 * r + .1804375 * n) / ir),
            s = hr((.2126729 * e + .7151522 * r + .072175 * n) / 1);
      return {
        l: 116 * s - 16,
        a: 500 * (i - s),
        b: 200 * (s - hr((.0193339 * e + .119192 * r + .9503041 * n) / sr)),
        alpha: t.a
      };
    }

    function mr(t) {
      let e = (t.l + 16) / 116,
          r = isNaN(t.a) ? e : e + t.a / 500,
          n = isNaN(t.b) ? e : e - t.b / 200;
      return e = 1 * pr(e), r = ir * pr(r), n = sr * pr(n), new ce(fr(3.2404542 * r - 1.5371385 * e - .4985314 * n), fr(-.969266 * r + 1.8760108 * e + .041556 * n), fr(.0556434 * r - .2040259 * e + 1.0572252 * n), t.alpha);
    }

    function gr(t, e, r) {
      const n = e - t;
      return t + r * (n > 180 || n < -180 ? n - 360 * Math.round(n / 360) : n);
    }

    const xr = {
      forward: yr,
      reverse: mr,
      interpolate: function (t, e, r) {
        return {
          l: rr(t.l, e.l, r),
          a: rr(t.a, e.a, r),
          b: rr(t.b, e.b, r),
          alpha: rr(t.alpha, e.alpha, r)
        };
      }
    },
          vr = {
      forward: function (t) {
        const {
          l: e,
          a: r,
          b: n
        } = yr(t),
              i = Math.atan2(n, r) * cr;
        return {
          h: i < 0 ? i + 360 : i,
          c: Math.sqrt(r * r + n * n),
          l: e,
          alpha: t.a
        };
      },
      reverse: function (t) {
        const e = t.h * ur,
              r = t.c;
        return mr({
          l: t.l,
          a: Math.cos(e) * r,
          b: Math.sin(e) * r,
          alpha: t.alpha
        });
      },
      interpolate: function (t, e, r) {
        return {
          h: gr(t.h, e.h, r),
          c: rr(t.c, e.c, r),
          l: rr(t.l, e.l, r),
          alpha: rr(t.alpha, e.alpha, r)
        };
      }
    };
    var br = Object.freeze({
      __proto__: null,
      lab: xr,
      hcl: vr
    });

    class _r {
      constructor(t, e, r, n, i) {
        this.type = t, this.operator = e, this.interpolation = r, this.input = n, this.labels = [], this.outputs = [];

        for (const [t, e] of i) this.labels.push(t), this.outputs.push(e);
      }

      static interpolationFactor(t, e, n, i) {
        let s = 0;
        if ("exponential" === t.name) s = wr(e, t.base, n, i);else if ("linear" === t.name) s = wr(e, 1, n, i);else if ("cubic-bezier" === t.name) {
          const a = t.controlPoints;
          s = new r(a[0], a[1], a[2], a[3]).solve(wr(e, 1, n, i));
        }
        return s;
      }

      static parse(t, e) {
        let [r, n, i, ...s] = t;
        if (!Array.isArray(n) || 0 === n.length) return e.error("Expected an interpolation type expression.", 1);
        if ("linear" === n[0]) n = {
          name: "linear"
        };else if ("exponential" === n[0]) {
          const t = n[1];
          if ("number" != typeof t) return e.error("Exponential interpolation requires a numeric base.", 1, 1);
          n = {
            name: "exponential",
            base: t
          };
        } else {
          if ("cubic-bezier" !== n[0]) return e.error(`Unknown interpolation type ${String(n[0])}`, 1, 0);
          {
            const t = n.slice(1);
            if (4 !== t.length || t.some(t => "number" != typeof t || t < 0 || t > 1)) return e.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
            n = {
              name: "cubic-bezier",
              controlPoints: t
            };
          }
        }
        if (t.length - 1 < 4) return e.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
        if ((t.length - 1) % 2 != 0) return e.error("Expected an even number of arguments.");
        if (i = e.parse(i, 2, Xt), !i) return null;
        const a = [];
        let o = null;
        "interpolate-hcl" === r || "interpolate-lab" === r ? o = Ht : e.expectedType && "value" !== e.expectedType.kind && (o = e.expectedType);

        for (let t = 0; t < s.length; t += 2) {
          const r = s[t],
                n = s[t + 1],
                i = t + 3,
                l = t + 4;
          if ("number" != typeof r) return e.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', i);
          if (a.length && a[a.length - 1][0] >= r) return e.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', i);
          const u = e.parse(n, l, o);
          if (!u) return null;
          o = o || u.type, a.push([r, u]);
        }

        return "number" === o.kind || "color" === o.kind || "array" === o.kind && "number" === o.itemType.kind && "number" == typeof o.N ? new _r(o, r, n, i, a) : e.error(`Type ${ne(o)} is not interpolatable.`);
      }

      evaluate(t) {
        const e = this.labels,
              r = this.outputs;
        if (1 === e.length) return r[0].evaluate(t);
        const n = this.input.evaluate(t);
        if (n <= e[0]) return r[0].evaluate(t);
        const i = e.length;
        if (n >= e[i - 1]) return r[i - 1].evaluate(t);

        const s = tr(e, n),
              a = _r.interpolationFactor(this.interpolation, n, e[s], e[s + 1]),
              o = r[s].evaluate(t),
              l = r[s + 1].evaluate(t);

        return "interpolate" === this.operator ? nr[this.type.kind.toLowerCase()](o, l, a) : "interpolate-hcl" === this.operator ? vr.reverse(vr.interpolate(vr.forward(o), vr.forward(l), a)) : xr.reverse(xr.interpolate(xr.forward(o), xr.forward(l), a));
      }

      eachChild(t) {
        t(this.input);

        for (const e of this.outputs) t(e);
      }

      outputDefined() {
        return this.outputs.every(t => t.outputDefined());
      }

      serialize() {
        let t;
        t = "linear" === this.interpolation.name ? ["linear"] : "exponential" === this.interpolation.name ? 1 === this.interpolation.base ? ["linear"] : ["exponential", this.interpolation.base] : ["cubic-bezier"].concat(this.interpolation.controlPoints);
        const e = [this.operator, t, this.input.serialize()];

        for (let t = 0; t < this.labels.length; t++) e.push(this.labels[t], this.outputs[t].serialize());

        return e;
      }

    }

    function wr(t, e, r, n) {
      const i = n - r,
            s = t - r;
      return 0 === i ? 0 : 1 === e ? s / i : (Math.pow(e, s) - 1) / (Math.pow(e, i) - 1);
    }

    class Ar {
      constructor(t, e) {
        this.type = t, this.args = e;
      }

      static parse(t, e) {
        if (t.length < 2) return e.error("Expectected at least one argument.");
        let r = null;
        const n = e.expectedType;
        n && "value" !== n.kind && (r = n);
        const i = [];

        for (const n of t.slice(1)) {
          const t = e.parse(n, 1 + i.length, r, void 0, {
            typeAnnotation: "omit"
          });
          if (!t) return null;
          r = r || t.type, i.push(t);
        }

        const s = n && i.some(t => se(n, t.type));
        return new Ar(s ? Jt : r, i);
      }

      evaluate(t) {
        let e,
            r = null,
            n = 0;

        for (const i of this.args) {
          if (n++, r = i.evaluate(t), r && r instanceof de && !r.available && (e || (e = r), r = null, n === this.args.length)) return e;
          if (null !== r) break;
        }

        return r;
      }

      eachChild(t) {
        this.args.forEach(t);
      }

      outputDefined() {
        return this.args.every(t => t.outputDefined());
      }

      serialize() {
        const t = ["coalesce"];
        return this.eachChild(e => {
          t.push(e.serialize());
        }), t;
      }

    }

    class kr {
      constructor(t, e) {
        this.type = e.type, this.bindings = [].concat(t), this.result = e;
      }

      evaluate(t) {
        return this.result.evaluate(t);
      }

      eachChild(t) {
        for (const e of this.bindings) t(e[1]);

        t(this.result);
      }

      static parse(t, e) {
        if (t.length < 4) return e.error(`Expected at least 3 arguments, but found ${t.length - 1} instead.`);
        const r = [];

        for (let n = 1; n < t.length - 1; n += 2) {
          const i = t[n];
          if ("string" != typeof i) return e.error(`Expected string, but found ${typeof i} instead.`, n);
          if (/[^a-zA-Z0-9_]/.test(i)) return e.error("Variable names must contain only alphanumeric characters or '_'.", n);
          const s = e.parse(t[n + 1], n + 1);
          if (!s) return null;
          r.push([i, s]);
        }

        const n = e.parse(t[t.length - 1], t.length - 1, e.expectedType, r);
        return n ? new kr(r, n) : null;
      }

      outputDefined() {
        return this.result.outputDefined();
      }

      serialize() {
        const t = ["let"];

        for (const [e, r] of this.bindings) t.push(e, r.serialize());

        return t.push(this.result.serialize()), t;
      }

    }

    class Sr {
      constructor(t, e, r) {
        this.type = t, this.index = e, this.input = r;
      }

      static parse(t, e) {
        if (3 !== t.length) return e.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);
        const r = e.parse(t[1], 1, Xt),
              n = e.parse(t[2], 2, re(e.expectedType || Jt));
        return r && n ? new Sr(n.type.itemType, r, n) : null;
      }

      evaluate(t) {
        const e = this.index.evaluate(t),
              r = this.input.evaluate(t);
        if (e < 0) throw new be(`Array index out of bounds: ${e} < 0.`);
        if (e >= r.length) throw new be(`Array index out of bounds: ${e} > ${r.length - 1}.`);
        if (e !== Math.floor(e)) throw new be(`Array index must be an integer, but found ${e} instead.`);
        return r[e];
      }

      eachChild(t) {
        t(this.index), t(this.input);
      }

      outputDefined() {
        return !1;
      }

      serialize() {
        return ["at", this.index.serialize(), this.input.serialize()];
      }

    }

    class Ir {
      constructor(t, e) {
        this.type = Yt, this.needle = t, this.haystack = e;
      }

      static parse(t, e) {
        if (3 !== t.length) return e.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);
        const r = e.parse(t[1], 1, Jt),
              n = e.parse(t[2], 2, Jt);
        return r && n ? ae(r.type, [Yt, Kt, Xt, Zt, Jt]) ? new Ir(r, n) : e.error(`Expected first argument to be of type boolean, string, number or null, but found ${ne(r.type)} instead`) : null;
      }

      evaluate(t) {
        const e = this.needle.evaluate(t),
              r = this.haystack.evaluate(t);
        if (null == r) return !1;
        if (!oe(e, ["boolean", "string", "number", "null"])) throw new be(`Expected first argument to be of type boolean, string, number or null, but found ${ne(ge(e))} instead.`);
        if (!oe(r, ["string", "array"])) throw new be(`Expected second argument to be of type array or string, but found ${ne(ge(r))} instead.`);
        return r.indexOf(e) >= 0;
      }

      eachChild(t) {
        t(this.needle), t(this.haystack);
      }

      outputDefined() {
        return !0;
      }

      serialize() {
        return ["in", this.needle.serialize(), this.haystack.serialize()];
      }

    }

    class Mr {
      constructor(t, e, r) {
        this.type = Xt, this.needle = t, this.haystack = e, this.fromIndex = r;
      }

      static parse(t, e) {
        if (t.length <= 2 || t.length >= 5) return e.error(`Expected 3 or 4 arguments, but found ${t.length - 1} instead.`);
        const r = e.parse(t[1], 1, Jt),
              n = e.parse(t[2], 2, Jt);
        if (!r || !n) return null;
        if (!ae(r.type, [Yt, Kt, Xt, Zt, Jt])) return e.error(`Expected first argument to be of type boolean, string, number or null, but found ${ne(r.type)} instead`);

        if (4 === t.length) {
          const i = e.parse(t[3], 3, Xt);
          return i ? new Mr(r, n, i) : null;
        }

        return new Mr(r, n);
      }

      evaluate(t) {
        const e = this.needle.evaluate(t),
              r = this.haystack.evaluate(t);
        if (!oe(e, ["boolean", "string", "number", "null"])) throw new be(`Expected first argument to be of type boolean, string, number or null, but found ${ne(ge(e))} instead.`);
        if (!oe(r, ["string", "array"])) throw new be(`Expected second argument to be of type array or string, but found ${ne(ge(r))} instead.`);

        if (this.fromIndex) {
          const n = this.fromIndex.evaluate(t);
          return r.indexOf(e, n);
        }

        return r.indexOf(e);
      }

      eachChild(t) {
        t(this.needle), t(this.haystack), this.fromIndex && t(this.fromIndex);
      }

      outputDefined() {
        return !1;
      }

      serialize() {
        if (null != this.fromIndex && void 0 !== this.fromIndex) {
          const t = this.fromIndex.serialize();
          return ["index-of", this.needle.serialize(), this.haystack.serialize(), t];
        }

        return ["index-of", this.needle.serialize(), this.haystack.serialize()];
      }

    }

    class Tr {
      constructor(t, e, r, n, i, s) {
        this.inputType = t, this.type = e, this.input = r, this.cases = n, this.outputs = i, this.otherwise = s;
      }

      static parse(t, e) {
        if (t.length < 5) return e.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
        if (t.length % 2 != 1) return e.error("Expected an even number of arguments.");
        let r, n;
        e.expectedType && "value" !== e.expectedType.kind && (n = e.expectedType);
        const i = {},
              s = [];

        for (let a = 2; a < t.length - 1; a += 2) {
          let o = t[a];
          const l = t[a + 1];
          Array.isArray(o) || (o = [o]);
          const u = e.concat(a);
          if (0 === o.length) return u.error("Expected at least one branch label.");

          for (const t of o) {
            if ("number" != typeof t && "string" != typeof t) return u.error("Branch labels must be numbers or strings.");
            if ("number" == typeof t && Math.abs(t) > Number.MAX_SAFE_INTEGER) return u.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
            if ("number" == typeof t && Math.floor(t) !== t) return u.error("Numeric branch labels must be integer values.");

            if (r) {
              if (u.checkSubtype(r, ge(t))) return null;
            } else r = ge(t);

            if (void 0 !== i[String(t)]) return u.error("Branch labels must be unique.");
            i[String(t)] = s.length;
          }

          const c = e.parse(l, a, n);
          if (!c) return null;
          n = n || c.type, s.push(c);
        }

        const a = e.parse(t[1], 1, Jt);
        if (!a) return null;
        const o = e.parse(t[t.length - 1], t.length - 1, n);
        return o ? "value" !== a.type.kind && e.concat(1).checkSubtype(r, a.type) ? null : new Tr(r, n, a, i, s, o) : null;
      }

      evaluate(t) {
        const e = this.input.evaluate(t);
        return (ge(e) === this.inputType && this.outputs[this.cases[e]] || this.otherwise).evaluate(t);
      }

      eachChild(t) {
        t(this.input), this.outputs.forEach(t), t(this.otherwise);
      }

      outputDefined() {
        return this.outputs.every(t => t.outputDefined()) && this.otherwise.outputDefined();
      }

      serialize() {
        const t = ["match", this.input.serialize()],
              e = Object.keys(this.cases).sort(),
              r = [],
              n = {};

        for (const t of e) {
          const e = n[this.cases[t]];
          void 0 === e ? (n[this.cases[t]] = r.length, r.push([this.cases[t], [t]])) : r[e][1].push(t);
        }

        const i = t => "number" === this.inputType.kind ? Number(t) : t;

        for (const [e, n] of r) t.push(1 === n.length ? i(n[0]) : n.map(i)), t.push(this.outputs[e].serialize());

        return t.push(this.otherwise.serialize()), t;
      }

    }

    class zr {
      constructor(t, e, r) {
        this.type = t, this.branches = e, this.otherwise = r;
      }

      static parse(t, e) {
        if (t.length < 4) return e.error(`Expected at least 3 arguments, but found only ${t.length - 1}.`);
        if (t.length % 2 != 0) return e.error("Expected an odd number of arguments.");
        let r;
        e.expectedType && "value" !== e.expectedType.kind && (r = e.expectedType);
        const n = [];

        for (let i = 1; i < t.length - 1; i += 2) {
          const s = e.parse(t[i], i, Yt);
          if (!s) return null;
          const a = e.parse(t[i + 1], i + 1, r);
          if (!a) return null;
          n.push([s, a]), r = r || a.type;
        }

        const i = e.parse(t[t.length - 1], t.length - 1, r);
        return i ? new zr(r, n, i) : null;
      }

      evaluate(t) {
        for (const [e, r] of this.branches) if (e.evaluate(t)) return r.evaluate(t);

        return this.otherwise.evaluate(t);
      }

      eachChild(t) {
        for (const [e, r] of this.branches) t(e), t(r);

        t(this.otherwise);
      }

      outputDefined() {
        return this.branches.every(([t, e]) => e.outputDefined()) && this.otherwise.outputDefined();
      }

      serialize() {
        const t = ["case"];
        return this.eachChild(e => {
          t.push(e.serialize());
        }), t;
      }

    }

    class Br {
      constructor(t, e, r, n) {
        this.type = t, this.input = e, this.beginIndex = r, this.endIndex = n;
      }

      static parse(t, e) {
        if (t.length <= 2 || t.length >= 5) return e.error(`Expected 3 or 4 arguments, but found ${t.length - 1} instead.`);
        const r = e.parse(t[1], 1, Jt),
              n = e.parse(t[2], 2, Xt);
        if (!r || !n) return null;
        if (!ae(r.type, [re(Jt), Kt, Jt])) return e.error(`Expected first argument to be of type array or string, but found ${ne(r.type)} instead`);

        if (4 === t.length) {
          const i = e.parse(t[3], 3, Xt);
          return i ? new Br(r.type, r, n, i) : null;
        }

        return new Br(r.type, r, n);
      }

      evaluate(t) {
        const e = this.input.evaluate(t),
              r = this.beginIndex.evaluate(t);
        if (!oe(e, ["string", "array"])) throw new be(`Expected first argument to be of type array or string, but found ${ne(ge(e))} instead.`);

        if (this.endIndex) {
          const n = this.endIndex.evaluate(t);
          return e.slice(r, n);
        }

        return e.slice(r);
      }

      eachChild(t) {
        t(this.input), t(this.beginIndex), this.endIndex && t(this.endIndex);
      }

      outputDefined() {
        return !1;
      }

      serialize() {
        if (null != this.endIndex && void 0 !== this.endIndex) {
          const t = this.endIndex.serialize();
          return ["slice", this.input.serialize(), this.beginIndex.serialize(), t];
        }

        return ["slice", this.input.serialize(), this.beginIndex.serialize()];
      }

    }

    function Er(t, e) {
      return "==" === t || "!=" === t ? "boolean" === e.kind || "string" === e.kind || "number" === e.kind || "null" === e.kind || "value" === e.kind : "string" === e.kind || "number" === e.kind || "value" === e.kind;
    }

    function Cr(t, e, r, n) {
      return 0 === n.compare(e, r);
    }

    function Dr(t, e, r) {
      const n = "==" !== t && "!=" !== t;
      return class i {
        constructor(t, e, r) {
          this.type = Yt, this.lhs = t, this.rhs = e, this.collator = r, this.hasUntypedArgument = "value" === t.type.kind || "value" === e.type.kind;
        }

        static parse(t, e) {
          if (3 !== t.length && 4 !== t.length) return e.error("Expected two or three arguments.");
          const r = t[0];
          let s = e.parse(t[1], 1, Jt);
          if (!s) return null;
          if (!Er(r, s.type)) return e.concat(1).error(`"${r}" comparisons are not supported for type '${ne(s.type)}'.`);
          let a = e.parse(t[2], 2, Jt);
          if (!a) return null;
          if (!Er(r, a.type)) return e.concat(2).error(`"${r}" comparisons are not supported for type '${ne(a.type)}'.`);
          if (s.type.kind !== a.type.kind && "value" !== s.type.kind && "value" !== a.type.kind) return e.error(`Cannot compare types '${ne(s.type)}' and '${ne(a.type)}'.`);
          n && ("value" === s.type.kind && "value" !== a.type.kind ? s = new we(a.type, [s]) : "value" !== s.type.kind && "value" === a.type.kind && (a = new we(s.type, [a])));
          let o = null;

          if (4 === t.length) {
            if ("string" !== s.type.kind && "string" !== a.type.kind && "value" !== s.type.kind && "value" !== a.type.kind) return e.error("Cannot use collator to compare non-string types.");
            if (o = e.parse(t[3], 3, Qt), !o) return null;
          }

          return new i(s, a, o);
        }

        evaluate(i) {
          const s = this.lhs.evaluate(i),
                a = this.rhs.evaluate(i);

          if (n && this.hasUntypedArgument) {
            const e = ge(s),
                  r = ge(a);
            if (e.kind !== r.kind || "string" !== e.kind && "number" !== e.kind) throw new be(`Expected arguments for "${t}" to be (string, string) or (number, number), but found (${e.kind}, ${r.kind}) instead.`);
          }

          if (this.collator && !n && this.hasUntypedArgument) {
            const t = ge(s),
                  r = ge(a);
            if ("string" !== t.kind || "string" !== r.kind) return e(i, s, a);
          }

          return this.collator ? r(i, s, a, this.collator.evaluate(i)) : e(i, s, a);
        }

        eachChild(t) {
          t(this.lhs), t(this.rhs), this.collator && t(this.collator);
        }

        outputDefined() {
          return !0;
        }

        serialize() {
          const e = [t];
          return this.eachChild(t => {
            e.push(t.serialize());
          }), e;
        }

      };
    }

    const Pr = Dr("==", function (t, e, r) {
      return e === r;
    }, Cr),
          Vr = Dr("!=", function (t, e, r) {
      return e !== r;
    }, function (t, e, r, n) {
      return !Cr(0, e, r, n);
    }),
          Fr = Dr("<", function (t, e, r) {
      return e < r;
    }, function (t, e, r, n) {
      return n.compare(e, r) < 0;
    }),
          Lr = Dr(">", function (t, e, r) {
      return e > r;
    }, function (t, e, r, n) {
      return n.compare(e, r) > 0;
    }),
          Rr = Dr("<=", function (t, e, r) {
      return e <= r;
    }, function (t, e, r, n) {
      return n.compare(e, r) <= 0;
    }),
          Ur = Dr(">=", function (t, e, r) {
      return e >= r;
    }, function (t, e, r, n) {
      return n.compare(e, r) >= 0;
    });

    class $r {
      constructor(t, e, r, n, i) {
        this.type = Kt, this.number = t, this.locale = e, this.currency = r, this.minFractionDigits = n, this.maxFractionDigits = i;
      }

      static parse(t, e) {
        if (3 !== t.length) return e.error("Expected two arguments.");
        const r = e.parse(t[1], 1, Xt);
        if (!r) return null;
        const n = t[2];
        if ("object" != typeof n || Array.isArray(n)) return e.error("NumberFormat options argument must be an object.");
        let i = null;
        if (n.locale && (i = e.parse(n.locale, 1, Kt), !i)) return null;
        let s = null;
        if (n.currency && (s = e.parse(n.currency, 1, Kt), !s)) return null;
        let a = null;
        if (n["min-fraction-digits"] && (a = e.parse(n["min-fraction-digits"], 1, Xt), !a)) return null;
        let o = null;
        return n["max-fraction-digits"] && (o = e.parse(n["max-fraction-digits"], 1, Xt), !o) ? null : new $r(r, i, s, a, o);
      }

      evaluate(t) {
        return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t) : [], {
          style: this.currency ? "currency" : "decimal",
          currency: this.currency ? this.currency.evaluate(t) : void 0,
          minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t) : void 0,
          maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t) : void 0
        }).format(this.number.evaluate(t));
      }

      eachChild(t) {
        t(this.number), this.locale && t(this.locale), this.currency && t(this.currency), this.minFractionDigits && t(this.minFractionDigits), this.maxFractionDigits && t(this.maxFractionDigits);
      }

      outputDefined() {
        return !1;
      }

      serialize() {
        const t = {};
        return this.locale && (t.locale = this.locale.serialize()), this.currency && (t.currency = this.currency.serialize()), this.minFractionDigits && (t["min-fraction-digits"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (t["max-fraction-digits"] = this.maxFractionDigits.serialize()), ["number-format", this.number.serialize(), t];
      }

    }

    class jr {
      constructor(t) {
        this.type = Xt, this.input = t;
      }

      static parse(t, e) {
        if (2 !== t.length) return e.error(`Expected 1 argument, but found ${t.length - 1} instead.`);
        const r = e.parse(t[1], 1);
        return r ? "array" !== r.type.kind && "string" !== r.type.kind && "value" !== r.type.kind ? e.error(`Expected argument of type string or array, but found ${ne(r.type)} instead.`) : new jr(r) : null;
      }

      evaluate(t) {
        const e = this.input.evaluate(t);
        if ("string" == typeof e) return e.length;
        if (Array.isArray(e)) return e.length;
        throw new be(`Expected value to be of type string or array, but found ${ne(ge(e))} instead.`);
      }

      eachChild(t) {
        t(this.input);
      }

      outputDefined() {
        return !1;
      }

      serialize() {
        const t = ["length"];
        return this.eachChild(e => {
          t.push(e.serialize());
        }), t;
      }

    }

    const Or = {
      "==": Pr,
      "!=": Vr,
      ">": Lr,
      "<": Fr,
      ">=": Ur,
      "<=": Rr,
      array: we,
      at: Sr,
      boolean: we,
      case: zr,
      coalesce: Ar,
      collator: Be,
      format: Ae,
      image: ke,
      in: Ir,
      "index-of": Mr,
      interpolate: _r,
      "interpolate-hcl": _r,
      "interpolate-lab": _r,
      length: jr,
      let: kr,
      literal: ve,
      match: Tr,
      number: we,
      "number-format": $r,
      object: we,
      slice: Br,
      step: er,
      string: we,
      "to-boolean": Ie,
      "to-color": Ie,
      "to-number": Ie,
      "to-string": Ie,
      var: We,
      within: Xe
    };

    function qr(t, [e, r, n, i]) {
      e = e.evaluate(t), r = r.evaluate(t), n = n.evaluate(t);
      const s = i ? i.evaluate(t) : 1,
            a = ye(e, r, n, s);
      if (a) throw new be(a);
      return new ce(e / 255 * s, r / 255 * s, n / 255 * s, s);
    }

    function Nr(t, e) {
      return t in e;
    }

    function Gr(t, e) {
      const r = e[t];
      return void 0 === r ? null : r;
    }

    function Zr(t) {
      return {
        type: t
      };
    }

    function Xr(t) {
      return {
        result: "success",
        value: t
      };
    }

    function Kr(t) {
      return {
        result: "error",
        value: t
      };
    }

    function Yr(t) {
      return "data-driven" === t["property-type"] || "cross-faded-data-driven" === t["property-type"];
    }

    function Hr(t) {
      return !!t.expression && t.expression.parameters.indexOf("zoom") > -1;
    }

    function Wr(t) {
      return !!t.expression && t.expression.interpolated;
    }

    function Jr(t) {
      return t instanceof Number ? "number" : t instanceof String ? "string" : t instanceof Boolean ? "boolean" : Array.isArray(t) ? "array" : null === t ? "null" : typeof t;
    }

    function Qr(t) {
      return "object" == typeof t && null !== t && !Array.isArray(t);
    }

    function tn(t) {
      return t;
    }

    function en(t, e) {
      const r = "color" === e.type,
            n = t.stops && "object" == typeof t.stops[0][0],
            i = n || !(n || void 0 !== t.property),
            s = t.type || (Wr(e) ? "exponential" : "interval");
      if (r && ((t = jt({}, t)).stops && (t.stops = t.stops.map(t => [t[0], ce.parse(t[1])])), t.default = ce.parse(t.default ? t.default : e.default)), t.colorSpace && "rgb" !== t.colorSpace && !br[t.colorSpace]) throw new Error(`Unknown color space: ${t.colorSpace}`);
      let a, o, l;
      if ("exponential" === s) a = an;else if ("interval" === s) a = sn;else if ("categorical" === s) {
        a = nn, o = Object.create(null);

        for (const e of t.stops) o[e[0]] = e[1];

        l = typeof t.stops[0][0];
      } else {
        if ("identity" !== s) throw new Error(`Unknown function type "${s}"`);
        a = on;
      }

      if (n) {
        const r = {},
              n = [];

        for (let e = 0; e < t.stops.length; e++) {
          const i = t.stops[e],
                s = i[0].zoom;
          void 0 === r[s] && (r[s] = {
            zoom: s,
            type: t.type,
            property: t.property,
            default: t.default,
            stops: []
          }, n.push(s)), r[s].stops.push([i[0].value, i[1]]);
        }

        const i = [];

        for (const t of n) i.push([r[t].zoom, en(r[t], e)]);

        const s = {
          name: "linear"
        };
        return {
          kind: "composite",
          interpolationType: s,
          interpolationFactor: _r.interpolationFactor.bind(void 0, s),
          zoomStops: i.map(t => t[0]),
          evaluate: ({
            zoom: r
          }, n) => an({
            stops: i,
            base: t.base
          }, e, r).evaluate(r, n)
        };
      }

      if (i) {
        const r = "exponential" === s ? {
          name: "exponential",
          base: void 0 !== t.base ? t.base : 1
        } : null;
        return {
          kind: "camera",
          interpolationType: r,
          interpolationFactor: _r.interpolationFactor.bind(void 0, r),
          zoomStops: t.stops.map(t => t[0]),
          evaluate: ({
            zoom: r
          }) => a(t, e, r, o, l)
        };
      }

      return {
        kind: "source",

        evaluate(r, n) {
          const i = n && n.properties ? n.properties[t.property] : void 0;
          return void 0 === i ? rn(t.default, e.default) : a(t, e, i, o, l);
        }

      };
    }

    function rn(t, e, r) {
      return void 0 !== t ? t : void 0 !== e ? e : void 0 !== r ? r : void 0;
    }

    function nn(t, e, r, n, i) {
      return rn(typeof r === i ? n[r] : void 0, t.default, e.default);
    }

    function sn(t, e, r) {
      if ("number" !== Jr(r)) return rn(t.default, e.default);
      const n = t.stops.length;
      if (1 === n) return t.stops[0][1];
      if (r <= t.stops[0][0]) return t.stops[0][1];
      if (r >= t.stops[n - 1][0]) return t.stops[n - 1][1];
      const i = tr(t.stops.map(t => t[0]), r);
      return t.stops[i][1];
    }

    function an(t, e, r) {
      const n = void 0 !== t.base ? t.base : 1;
      if ("number" !== Jr(r)) return rn(t.default, e.default);
      const i = t.stops.length;
      if (1 === i) return t.stops[0][1];
      if (r <= t.stops[0][0]) return t.stops[0][1];
      if (r >= t.stops[i - 1][0]) return t.stops[i - 1][1];

      const s = tr(t.stops.map(t => t[0]), r),
            a = function (t, e, r, n) {
        const i = n - r,
              s = t - r;
        return 0 === i ? 0 : 1 === e ? s / i : (Math.pow(e, s) - 1) / (Math.pow(e, i) - 1);
      }(r, n, t.stops[s][0], t.stops[s + 1][0]),
            o = t.stops[s][1],
            l = t.stops[s + 1][1];

      let u = nr[e.type] || tn;

      if (t.colorSpace && "rgb" !== t.colorSpace) {
        const e = br[t.colorSpace];

        u = (t, r) => e.reverse(e.interpolate(e.forward(t), e.forward(r), a));
      }

      return "function" == typeof o.evaluate ? {
        evaluate(...t) {
          const e = o.evaluate.apply(void 0, t),
                r = l.evaluate.apply(void 0, t);
          if (void 0 !== e && void 0 !== r) return u(e, r, a);
        }

      } : u(o, l, a);
    }

    function on(t, e, r) {
      return "color" === e.type ? r = ce.parse(r) : "formatted" === e.type ? r = fe.fromString(r.toString()) : "resolvedImage" === e.type ? r = de.fromString(r.toString()) : Jr(r) === e.type || "enum" === e.type && e.values[r] || (r = void 0), rn(r, t.default, e.default);
    }

    ze.register(Or, {
      error: [{
        kind: "error"
      }, [Kt], (t, [e]) => {
        throw new be(e.evaluate(t));
      }],
      typeof: [Kt, [Jt], (t, [e]) => ne(ge(e.evaluate(t)))],
      "to-rgba": [re(Xt, 4), [Ht], (t, [e]) => e.evaluate(t).toArray()],
      rgb: [Ht, [Xt, Xt, Xt], qr],
      rgba: [Ht, [Xt, Xt, Xt, Xt], qr],
      has: {
        type: Yt,
        overloads: [[[Kt], (t, [e]) => Nr(e.evaluate(t), t.properties())], [[Kt, Wt], (t, [e, r]) => Nr(e.evaluate(t), r.evaluate(t))]]
      },
      get: {
        type: Jt,
        overloads: [[[Kt], (t, [e]) => Gr(e.evaluate(t), t.properties())], [[Kt, Wt], (t, [e, r]) => Gr(e.evaluate(t), r.evaluate(t))]]
      },
      "feature-state": [Jt, [Kt], (t, [e]) => Gr(e.evaluate(t), t.featureState || {})],
      properties: [Wt, [], t => t.properties()],
      "geometry-type": [Kt, [], t => t.geometryType()],
      id: [Jt, [], t => t.id()],
      zoom: [Xt, [], t => t.globals.zoom],
      pitch: [Xt, [], t => t.globals.pitch || 0],
      "distance-from-center": [Xt, [], t => t.distanceFromCenter()],
      "heatmap-density": [Xt, [], t => t.globals.heatmapDensity || 0],
      "line-progress": [Xt, [], t => t.globals.lineProgress || 0],
      "sky-radial-progress": [Xt, [], t => t.globals.skyRadialProgress || 0],
      accumulated: [Jt, [], t => void 0 === t.globals.accumulated ? null : t.globals.accumulated],
      "+": [Xt, Zr(Xt), (t, e) => {
        let r = 0;

        for (const n of e) r += n.evaluate(t);

        return r;
      }],
      "*": [Xt, Zr(Xt), (t, e) => {
        let r = 1;

        for (const n of e) r *= n.evaluate(t);

        return r;
      }],
      "-": {
        type: Xt,
        overloads: [[[Xt, Xt], (t, [e, r]) => e.evaluate(t) - r.evaluate(t)], [[Xt], (t, [e]) => -e.evaluate(t)]]
      },
      "/": [Xt, [Xt, Xt], (t, [e, r]) => e.evaluate(t) / r.evaluate(t)],
      "%": [Xt, [Xt, Xt], (t, [e, r]) => e.evaluate(t) % r.evaluate(t)],
      ln2: [Xt, [], () => Math.LN2],
      pi: [Xt, [], () => Math.PI],
      e: [Xt, [], () => Math.E],
      "^": [Xt, [Xt, Xt], (t, [e, r]) => Math.pow(e.evaluate(t), r.evaluate(t))],
      sqrt: [Xt, [Xt], (t, [e]) => Math.sqrt(e.evaluate(t))],
      log10: [Xt, [Xt], (t, [e]) => Math.log(e.evaluate(t)) / Math.LN10],
      ln: [Xt, [Xt], (t, [e]) => Math.log(e.evaluate(t))],
      log2: [Xt, [Xt], (t, [e]) => Math.log(e.evaluate(t)) / Math.LN2],
      sin: [Xt, [Xt], (t, [e]) => Math.sin(e.evaluate(t))],
      cos: [Xt, [Xt], (t, [e]) => Math.cos(e.evaluate(t))],
      tan: [Xt, [Xt], (t, [e]) => Math.tan(e.evaluate(t))],
      asin: [Xt, [Xt], (t, [e]) => Math.asin(e.evaluate(t))],
      acos: [Xt, [Xt], (t, [e]) => Math.acos(e.evaluate(t))],
      atan: [Xt, [Xt], (t, [e]) => Math.atan(e.evaluate(t))],
      min: [Xt, Zr(Xt), (t, e) => Math.min(...e.map(e => e.evaluate(t)))],
      max: [Xt, Zr(Xt), (t, e) => Math.max(...e.map(e => e.evaluate(t)))],
      abs: [Xt, [Xt], (t, [e]) => Math.abs(e.evaluate(t))],
      round: [Xt, [Xt], (t, [e]) => {
        const r = e.evaluate(t);
        return r < 0 ? -Math.round(-r) : Math.round(r);
      }],
      floor: [Xt, [Xt], (t, [e]) => Math.floor(e.evaluate(t))],
      ceil: [Xt, [Xt], (t, [e]) => Math.ceil(e.evaluate(t))],
      "filter-==": [Yt, [Kt, Jt], (t, [e, r]) => t.properties()[e.value] === r.value],
      "filter-id-==": [Yt, [Jt], (t, [e]) => t.id() === e.value],
      "filter-type-==": [Yt, [Kt], (t, [e]) => t.geometryType() === e.value],
      "filter-<": [Yt, [Kt, Jt], (t, [e, r]) => {
        const n = t.properties()[e.value],
              i = r.value;
        return typeof n == typeof i && n < i;
      }],
      "filter-id-<": [Yt, [Jt], (t, [e]) => {
        const r = t.id(),
              n = e.value;
        return typeof r == typeof n && r < n;
      }],
      "filter->": [Yt, [Kt, Jt], (t, [e, r]) => {
        const n = t.properties()[e.value],
              i = r.value;
        return typeof n == typeof i && n > i;
      }],
      "filter-id->": [Yt, [Jt], (t, [e]) => {
        const r = t.id(),
              n = e.value;
        return typeof r == typeof n && r > n;
      }],
      "filter-<=": [Yt, [Kt, Jt], (t, [e, r]) => {
        const n = t.properties()[e.value],
              i = r.value;
        return typeof n == typeof i && n <= i;
      }],
      "filter-id-<=": [Yt, [Jt], (t, [e]) => {
        const r = t.id(),
              n = e.value;
        return typeof r == typeof n && r <= n;
      }],
      "filter->=": [Yt, [Kt, Jt], (t, [e, r]) => {
        const n = t.properties()[e.value],
              i = r.value;
        return typeof n == typeof i && n >= i;
      }],
      "filter-id->=": [Yt, [Jt], (t, [e]) => {
        const r = t.id(),
              n = e.value;
        return typeof r == typeof n && r >= n;
      }],
      "filter-has": [Yt, [Jt], (t, [e]) => e.value in t.properties()],
      "filter-has-id": [Yt, [], t => null !== t.id() && void 0 !== t.id()],
      "filter-type-in": [Yt, [re(Kt)], (t, [e]) => e.value.indexOf(t.geometryType()) >= 0],
      "filter-id-in": [Yt, [re(Jt)], (t, [e]) => e.value.indexOf(t.id()) >= 0],
      "filter-in-small": [Yt, [Kt, re(Jt)], (t, [e, r]) => r.value.indexOf(t.properties()[e.value]) >= 0],
      "filter-in-large": [Yt, [Kt, re(Jt)], (t, [e, r]) => function (t, e, r, n) {
        for (; r <= n;) {
          const i = r + n >> 1;
          if (e[i] === t) return !0;
          e[i] > t ? n = i - 1 : r = i + 1;
        }

        return !1;
      }(t.properties()[e.value], r.value, 0, r.value.length - 1)],
      all: {
        type: Yt,
        overloads: [[[Yt, Yt], (t, [e, r]) => e.evaluate(t) && r.evaluate(t)], [Zr(Yt), (t, e) => {
          for (const r of e) if (!r.evaluate(t)) return !1;

          return !0;
        }]]
      },
      any: {
        type: Yt,
        overloads: [[[Yt, Yt], (t, [e, r]) => e.evaluate(t) || r.evaluate(t)], [Zr(Yt), (t, e) => {
          for (const r of e) if (r.evaluate(t)) return !0;

          return !1;
        }]]
      },
      "!": [Yt, [Yt], (t, [e]) => !e.evaluate(t)],
      "is-supported-script": [Yt, [Kt], (t, [e]) => {
        const r = t.globals && t.globals.isSupportedScript;
        return !r || r(e.evaluate(t));
      }],
      upcase: [Kt, [Kt], (t, [e]) => e.evaluate(t).toUpperCase()],
      downcase: [Kt, [Kt], (t, [e]) => e.evaluate(t).toLowerCase()],
      concat: [Kt, Zr(Jt), (t, e) => e.map(e => xe(e.evaluate(t))).join("")],
      "resolved-locale": [Kt, [Qt], (t, [e]) => e.evaluate(t).resolvedLocale()]
    });

    class ln {
      constructor(t, e) {
        this.expression = t, this._warningHistory = {}, this._evaluator = new Te(), this._defaultValue = e ? function (t) {
          return "color" === t.type && Qr(t.default) ? new ce(0, 0, 0, 0) : "color" === t.type ? ce.parse(t.default) || null : void 0 === t.default ? null : t.default;
        }(e) : null, this._enumValues = e && "enum" === e.type ? e.values : null;
      }

      evaluateWithoutErrorHandling(t, e, r, n, i, s, a, o) {
        return this._evaluator.globals = t, this._evaluator.feature = e, this._evaluator.featureState = r, this._evaluator.canonical = n || null, this._evaluator.availableImages = i || null, this._evaluator.formattedSection = s, this._evaluator.featureTileCoord = a || null, this._evaluator.featureDistanceData = o || null, this.expression.evaluate(this._evaluator);
      }

      evaluate(t, e, r, n, i, s, a, o) {
        this._evaluator.globals = t, this._evaluator.feature = e || null, this._evaluator.featureState = r || null, this._evaluator.canonical = n || null, this._evaluator.availableImages = i || null, this._evaluator.formattedSection = s || null, this._evaluator.featureTileCoord = a || null, this._evaluator.featureDistanceData = o || null;

        try {
          const t = this.expression.evaluate(this._evaluator);
          if (null == t || "number" == typeof t && t != t) return this._defaultValue;
          if (this._enumValues && !(t in this._enumValues)) throw new be(`Expected value to be one of ${Object.keys(this._enumValues).map(t => JSON.stringify(t)).join(", ")}, but found ${JSON.stringify(t)} instead.`);
          return t;
        } catch (t) {
          return this._warningHistory[t.message] || (this._warningHistory[t.message] = !0, "undefined" != typeof console && console.warn(t.message)), this._defaultValue;
        }
      }

    }

    function un(t) {
      return Array.isArray(t) && t.length > 0 && "string" == typeof t[0] && t[0] in Or;
    }

    function cn(t, e) {
      const r = new Je(Or, [], e ? function (t) {
        const e = {
          color: Ht,
          string: Kt,
          number: Xt,
          enum: Kt,
          boolean: Yt,
          formatted: te,
          resolvedImage: ee
        };
        return "array" === t.type ? re(e[t.value] || Jt, t.length) : e[t.type];
      }(e) : void 0),
            n = r.parse(t, void 0, void 0, void 0, e && "string" === e.type ? {
        typeAnnotation: "coerce"
      } : void 0);
      return n ? Xr(new ln(n, e)) : Kr(r.errors);
    }

    class hn {
      constructor(t, e) {
        this.kind = t, this._styleExpression = e, this.isStateDependent = "constant" !== t && !Ye(e.expression);
      }

      evaluateWithoutErrorHandling(t, e, r, n, i, s) {
        return this._styleExpression.evaluateWithoutErrorHandling(t, e, r, n, i, s);
      }

      evaluate(t, e, r, n, i, s) {
        return this._styleExpression.evaluate(t, e, r, n, i, s);
      }

    }

    class pn {
      constructor(t, e, r, n) {
        this.kind = t, this.zoomStops = r, this._styleExpression = e, this.isStateDependent = "camera" !== t && !Ye(e.expression), this.interpolationType = n;
      }

      evaluateWithoutErrorHandling(t, e, r, n, i, s) {
        return this._styleExpression.evaluateWithoutErrorHandling(t, e, r, n, i, s);
      }

      evaluate(t, e, r, n, i, s) {
        return this._styleExpression.evaluate(t, e, r, n, i, s);
      }

      interpolationFactor(t, e, r) {
        return this.interpolationType ? _r.interpolationFactor(this.interpolationType, t, e, r) : 0;
      }

    }

    function fn(t, e) {
      if ("error" === (t = cn(t, e)).result) return t;
      const r = t.value.expression,
            n = Ke(r);
      if (!n && !Yr(e)) return Kr([new Nt("", "data expressions not supported")]);
      const i = He(r, ["zoom", "pitch", "distance-from-center"]);
      if (!i && !Hr(e)) return Kr([new Nt("", "zoom expressions not supported")]);
      const s = yn(r);
      return s || i ? s instanceof Nt ? Kr([s]) : s instanceof _r && !Wr(e) ? Kr([new Nt("", '"interpolate" expressions cannot be used with this property')]) : Xr(s ? new pn(n ? "camera" : "composite", t.value, s.labels, s instanceof _r ? s.interpolation : void 0) : new hn(n ? "constant" : "source", t.value)) : Kr([new Nt("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
    }

    class dn {
      constructor(t, e) {
        this._parameters = t, this._specification = e, jt(this, en(this._parameters, this._specification));
      }

      static deserialize(t) {
        return new dn(t._parameters, t._specification);
      }

      static serialize(t) {
        return {
          _parameters: t._parameters,
          _specification: t._specification
        };
      }

    }

    function yn(t) {
      let e = null;
      if (t instanceof kr) e = yn(t.result);else if (t instanceof Ar) {
        for (const r of t.args) if (e = yn(r), e) break;
      } else (t instanceof er || t instanceof _r) && t.input instanceof ze && "zoom" === t.input.name && (e = t);
      return e instanceof Nt || t.eachChild(t => {
        const r = yn(t);
        r instanceof Nt ? e = r : !e && r ? e = new Nt("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : e && r && e !== r && (e = new Nt("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
      }), e;
    }

    class mn {
      constructor(t, e, r, n) {
        this.message = (t ? `${t}: ` : "") + r, n && (this.identifier = n), null != e && e.__line__ && (this.line = e.__line__);
      }

    }

    function gn(t) {
      const e = t.key,
            r = t.value,
            n = t.valueSpec || {},
            i = t.objectElementValidators || {},
            s = t.style,
            a = t.styleSpec;
      let o = [];
      const l = Jr(r);
      if ("object" !== l) return [new mn(e, r, `object expected, ${l} found`)];

      for (const t in r) {
        const l = t.split(".")[0],
              u = n[l] || n["*"];
        let c;
        i[l] ? c = i[l] : n[l] ? c = Hn : i["*"] ? c = i["*"] : n["*"] && (c = Hn), c ? o = o.concat(c({
          key: (e ? `${e}.` : e) + t,
          value: r[t],
          valueSpec: u,
          style: s,
          styleSpec: a,
          object: r,
          objectKey: t
        }, r)) : o.push(new mn(e, r[t], `unknown property "${t}"`));
      }

      for (const t in n) i[t] || n[t].required && void 0 === n[t].default && void 0 === r[t] && o.push(new mn(e, r, `missing required property "${t}"`));

      return o;
    }

    function xn(t) {
      const e = t.value,
            r = t.valueSpec,
            n = t.style,
            i = t.styleSpec,
            s = t.key,
            a = t.arrayElementValidator || Hn;
      if ("array" !== Jr(e)) return [new mn(s, e, `array expected, ${Jr(e)} found`)];
      if (r.length && e.length !== r.length) return [new mn(s, e, `array length ${r.length} expected, length ${e.length} found`)];
      if (r["min-length"] && e.length < r["min-length"]) return [new mn(s, e, `array length at least ${r["min-length"]} expected, length ${e.length} found`)];
      let o = {
        type: r.value,
        values: r.values,
        minimum: r.minimum,
        maximum: r.maximum,
        function: void 0
      };
      i.$version < 7 && (o.function = r.function), "object" === Jr(r.value) && (o = r.value);
      let l = [];

      for (let t = 0; t < e.length; t++) l = l.concat(a({
        array: e,
        arrayIndex: t,
        value: e[t],
        valueSpec: o,
        style: n,
        styleSpec: i,
        key: `${s}[${t}]`
      }));

      return l;
    }

    function vn(t) {
      const e = t.key,
            r = t.value,
            n = t.valueSpec;
      let i = Jr(r);
      if ("number" === i && r != r && (i = "NaN"), "number" !== i) return [new mn(e, r, `number expected, ${i} found`)];

      if ("minimum" in n) {
        let i = n.minimum;
        if ("array" === Jr(n.minimum) && (i = n.minimum[t.arrayIndex]), r < i) return [new mn(e, r, `${r} is less than the minimum value ${i}`)];
      }

      if ("maximum" in n) {
        let i = n.maximum;
        if ("array" === Jr(n.maximum) && (i = n.maximum[t.arrayIndex]), r > i) return [new mn(e, r, `${r} is greater than the maximum value ${i}`)];
      }

      return [];
    }

    function bn(t) {
      const e = t.valueSpec,
            r = Ot(t.value.type);
      let n,
          i,
          s,
          a = {};
      const o = "categorical" !== r && void 0 === t.value.property,
            l = !o,
            u = "array" === Jr(t.value.stops) && "array" === Jr(t.value.stops[0]) && "object" === Jr(t.value.stops[0][0]),
            c = gn({
        key: t.key,
        value: t.value,
        valueSpec: t.styleSpec.function,
        style: t.style,
        styleSpec: t.styleSpec,
        objectElementValidators: {
          stops: function (t) {
            if ("identity" === r) return [new mn(t.key, t.value, 'identity function may not have a "stops" property')];
            let e = [];
            const n = t.value;
            return e = e.concat(xn({
              key: t.key,
              value: n,
              valueSpec: t.valueSpec,
              style: t.style,
              styleSpec: t.styleSpec,
              arrayElementValidator: h
            })), "array" === Jr(n) && 0 === n.length && e.push(new mn(t.key, n, "array must have at least one stop")), e;
          },
          default: function (t) {
            return Hn({
              key: t.key,
              value: t.value,
              valueSpec: e,
              style: t.style,
              styleSpec: t.styleSpec
            });
          }
        }
      });
      return "identity" === r && o && c.push(new mn(t.key, t.value, 'missing required property "property"')), "identity" === r || t.value.stops || c.push(new mn(t.key, t.value, 'missing required property "stops"')), "exponential" === r && t.valueSpec.expression && !Wr(t.valueSpec) && c.push(new mn(t.key, t.value, "exponential functions not supported")), t.styleSpec.$version >= 8 && (l && !Yr(t.valueSpec) ? c.push(new mn(t.key, t.value, "property functions not supported")) : o && !Hr(t.valueSpec) && c.push(new mn(t.key, t.value, "zoom functions not supported"))), "categorical" !== r && !u || void 0 !== t.value.property || c.push(new mn(t.key, t.value, '"property" property is required')), c;

      function h(t) {
        let r = [];
        const n = t.value,
              o = t.key;
        if ("array" !== Jr(n)) return [new mn(o, n, `array expected, ${Jr(n)} found`)];
        if (2 !== n.length) return [new mn(o, n, `array length 2 expected, length ${n.length} found`)];

        if (u) {
          if ("object" !== Jr(n[0])) return [new mn(o, n, `object expected, ${Jr(n[0])} found`)];
          if (void 0 === n[0].zoom) return [new mn(o, n, "object stop key must have zoom")];
          if (void 0 === n[0].value) return [new mn(o, n, "object stop key must have value")];
          const e = Ot(n[0].zoom);
          if ("number" != typeof e) return [new mn(o, n[0].zoom, "stop zoom values must be numbers")];
          if (s && s > e) return [new mn(o, n[0].zoom, "stop zoom values must appear in ascending order")];
          e !== s && (s = e, i = void 0, a = {}), r = r.concat(gn({
            key: `${o}[0]`,
            value: n[0],
            valueSpec: {
              zoom: {}
            },
            style: t.style,
            styleSpec: t.styleSpec,
            objectElementValidators: {
              zoom: vn,
              value: p
            }
          }));
        } else r = r.concat(p({
          key: `${o}[0]`,
          value: n[0],
          valueSpec: {},
          style: t.style,
          styleSpec: t.styleSpec
        }, n));

        return un(qt(n[1])) ? r.concat([new mn(`${o}[1]`, n[1], "expressions are not allowed in function stops.")]) : r.concat(Hn({
          key: `${o}[1]`,
          value: n[1],
          valueSpec: e,
          style: t.style,
          styleSpec: t.styleSpec
        }));
      }

      function p(t, s) {
        const o = Jr(t.value),
              l = Ot(t.value),
              u = null !== t.value ? t.value : s;

        if (n) {
          if (o !== n) return [new mn(t.key, u, `${o} stop domain type must match previous stop domain type ${n}`)];
        } else n = o;

        if ("number" !== o && "string" !== o && "boolean" !== o && "number" != typeof l && "string" != typeof l && "boolean" != typeof l) return [new mn(t.key, u, "stop domain value must be a number, string, or boolean")];

        if ("number" !== o && "categorical" !== r) {
          let n = `number expected, ${o} found`;
          return Yr(e) && void 0 === r && (n += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new mn(t.key, u, n)];
        }

        return "categorical" !== r || "number" !== o || "number" == typeof l && isFinite(l) && Math.floor(l) === l ? "categorical" !== r && "number" === o && "number" == typeof l && "number" == typeof i && void 0 !== i && l < i ? [new mn(t.key, u, "stop domain values must appear in ascending order")] : (i = l, "categorical" === r && l in a ? [new mn(t.key, u, "stop domain values must be unique")] : (a[l] = !0, [])) : [new mn(t.key, u, `integer expected, found ${String(l)}`)];
      }
    }

    function _n(t) {
      const e = ("property" === t.expressionContext ? fn : cn)(qt(t.value), t.valueSpec);
      if ("error" === e.result) return e.value.map(e => new mn(`${t.key}${e.key}`, t.value, e.message));
      const r = e.value.expression || e.value._styleExpression.expression;
      if ("property" === t.expressionContext && "text-font" === t.propertyKey && !r.outputDefined()) return [new mn(t.key, t.value, `Invalid data expression for "${t.propertyKey}". Output values must be contained as literals within the expression.`)];
      if ("property" === t.expressionContext && "layout" === t.propertyType && !Ye(r)) return [new mn(t.key, t.value, '"feature-state" data expressions are not supported with layout properties.')];
      if ("filter" === t.expressionContext) return wn(r, t);

      if (t.expressionContext && 0 === t.expressionContext.indexOf("cluster")) {
        if (!He(r, ["zoom", "feature-state"])) return [new mn(t.key, t.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
        if ("cluster-initial" === t.expressionContext && !Ke(r)) return [new mn(t.key, t.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
      }

      return [];
    }

    function wn(t, e) {
      const r = new Set(["zoom", "feature-state", "pitch", "distance-from-center"]);
      if (e.valueSpec && e.valueSpec.expression) for (const t of e.valueSpec.expression.parameters) r.delete(t);
      if (0 === r.size) return [];
      const n = [];
      return t instanceof ze && r.has(t.name) ? [new mn(e.key, e.value, `["${t.name}"] expression is not supported in a filter for a ${e.object.type} layer with id: ${e.object.id}`)] : (t.eachChild(t => {
        n.push(...wn(t, e));
      }), n);
    }

    function An(t) {
      const e = t.key,
            r = t.value,
            n = t.valueSpec,
            i = [];
      return Array.isArray(n.values) ? -1 === n.values.indexOf(Ot(r)) && i.push(new mn(e, r, `expected one of [${n.values.join(", ")}], ${JSON.stringify(r)} found`)) : -1 === Object.keys(n.values).indexOf(Ot(r)) && i.push(new mn(e, r, `expected one of [${Object.keys(n.values).join(", ")}], ${JSON.stringify(r)} found`)), i;
    }

    function kn(t) {
      if (!0 === t || !1 === t) return !0;
      if (!Array.isArray(t) || 0 === t.length) return !1;

      switch (t[0]) {
        case "has":
          return t.length >= 2 && "$id" !== t[1] && "$type" !== t[1];

        case "in":
          return t.length >= 3 && ("string" != typeof t[1] || Array.isArray(t[2]));

        case "!in":
        case "!has":
        case "none":
          return !1;

        case "==":
        case "!=":
        case ">":
        case ">=":
        case "<":
        case "<=":
          return 3 !== t.length || Array.isArray(t[1]) || Array.isArray(t[2]);

        case "any":
        case "all":
          for (const e of t.slice(1)) if (!kn(e) && "boolean" != typeof e) return !1;

          return !0;

        default:
          return !0;
      }
    }

    function Sn(t, e = "fill") {
      if (null == t) return {
        filter: () => !0,
        needGeometry: !1,
        needFeature: !1
      };
      kn(t) || (t = Cn(t));
      const r = t;
      let n = !0;

      try {
        n = function (t) {
          if (!Tn(t)) return t;
          let e = qt(t);
          return Mn(e), e = In(e), e;
        }(r);
      } catch (t) {
        console.warn(`Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.\nThis is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md\nand paste the contents of this message in the report.\nThank you!\nFilter Expression:\n${JSON.stringify(r, null, 2)}\n        `);
      }

      const i = $t[`filter_${e}`],
            s = cn(n, i);
      let a = null;
      if ("error" === s.result) throw new Error(s.value.map(t => `${t.key}: ${t.message}`).join(", "));

      a = (t, e, r) => s.value.evaluate(t, e, {}, r);

      let o = null,
          l = null;

      if (n !== r) {
        const t = cn(r, i);
        if ("error" === t.result) throw new Error(t.value.map(t => `${t.key}: ${t.message}`).join(", "));
        o = (e, r, n, i, s) => t.value.evaluate(e, r, {}, n, void 0, void 0, i, s), l = !Ke(t.value.expression);
      }

      return a = a, {
        filter: a,
        dynamicFilter: o || void 0,
        needGeometry: En(n),
        needFeature: !!l
      };
    }

    function In(t) {
      if (!Array.isArray(t)) return t;

      const e = function (t) {
        if (zn.has(t[0])) for (let e = 1; e < t.length; e++) if (Tn(t[e])) return !0;
        return t;
      }(t);

      return !0 === e ? e : e.map(t => In(t));
    }

    function Mn(t) {
      let e = !1;
      const r = [];

      if ("case" === t[0]) {
        for (let n = 1; n < t.length - 1; n += 2) e = e || Tn(t[n]), r.push(t[n + 1]);

        r.push(t[t.length - 1]);
      } else if ("match" === t[0]) {
        e = e || Tn(t[1]);

        for (let e = 2; e < t.length - 1; e += 2) r.push(t[e + 1]);

        r.push(t[t.length - 1]);
      } else if ("step" === t[0]) {
        e = e || Tn(t[1]);

        for (let e = 1; e < t.length - 1; e += 2) r.push(t[e + 1]);
      }

      e && (t.length = 0, t.push("any", ...r));

      for (let e = 1; e < t.length; e++) Mn(t[e]);
    }

    function Tn(t) {
      if (!Array.isArray(t)) return !1;
      if ("pitch" === (e = t[0]) || "distance-from-center" === e) return !0;
      var e;

      for (let e = 1; e < t.length; e++) if (Tn(t[e])) return !0;

      return !1;
    }

    const zn = new Set(["in", "==", "!=", ">", ">=", "<", "<=", "to-boolean"]);

    function Bn(t, e) {
      return t < e ? -1 : t > e ? 1 : 0;
    }

    function En(t) {
      if (!Array.isArray(t)) return !1;
      if ("within" === t[0]) return !0;

      for (let e = 1; e < t.length; e++) if (En(t[e])) return !0;

      return !1;
    }

    function Cn(t) {
      if (!t) return !0;
      const e = t[0];
      return t.length <= 1 ? "any" !== e : "==" === e ? Dn(t[1], t[2], "==") : "!=" === e ? Fn(Dn(t[1], t[2], "==")) : "<" === e || ">" === e || "<=" === e || ">=" === e ? Dn(t[1], t[2], e) : "any" === e ? (r = t.slice(1), ["any"].concat(r.map(Cn))) : "all" === e ? ["all"].concat(t.slice(1).map(Cn)) : "none" === e ? ["all"].concat(t.slice(1).map(Cn).map(Fn)) : "in" === e ? Pn(t[1], t.slice(2)) : "!in" === e ? Fn(Pn(t[1], t.slice(2))) : "has" === e ? Vn(t[1]) : "!has" === e ? Fn(Vn(t[1])) : "within" !== e || t;
      var r;
    }

    function Dn(t, e, r) {
      switch (t) {
        case "$type":
          return [`filter-type-${r}`, e];

        case "$id":
          return [`filter-id-${r}`, e];

        default:
          return [`filter-${r}`, t, e];
      }
    }

    function Pn(t, e) {
      if (0 === e.length) return !1;

      switch (t) {
        case "$type":
          return ["filter-type-in", ["literal", e]];

        case "$id":
          return ["filter-id-in", ["literal", e]];

        default:
          return e.length > 200 && !e.some(t => typeof t != typeof e[0]) ? ["filter-in-large", t, ["literal", e.sort(Bn)]] : ["filter-in-small", t, ["literal", e]];
      }
    }

    function Vn(t) {
      switch (t) {
        case "$type":
          return !0;

        case "$id":
          return ["filter-has-id"];

        default:
          return ["filter-has", t];
      }
    }

    function Fn(t) {
      return ["!", t];
    }

    function Ln(t) {
      return kn(qt(t.value)) ? _n(jt({}, t, {
        expressionContext: "filter",
        valueSpec: t.styleSpec[`filter_${t.layerType || "fill"}`]
      })) : Rn(t);
    }

    function Rn(t) {
      const e = t.value,
            r = t.key;
      if ("array" !== Jr(e)) return [new mn(r, e, `array expected, ${Jr(e)} found`)];
      const n = t.styleSpec;
      let i,
          s = [];
      if (e.length < 1) return [new mn(r, e, "filter array must have at least 1 element")];

      switch (s = s.concat(An({
        key: `${r}[0]`,
        value: e[0],
        valueSpec: n.filter_operator,
        style: t.style,
        styleSpec: t.styleSpec
      })), Ot(e[0])) {
        case "<":
        case "<=":
        case ">":
        case ">=":
          e.length >= 2 && "$type" === Ot(e[1]) && s.push(new mn(r, e, `"$type" cannot be use with operator "${e[0]}"`));

        case "==":
        case "!=":
          3 !== e.length && s.push(new mn(r, e, `filter array for operator "${e[0]}" must have 3 elements`));

        case "in":
        case "!in":
          e.length >= 2 && (i = Jr(e[1]), "string" !== i && s.push(new mn(`${r}[1]`, e[1], `string expected, ${i} found`)));

          for (let a = 2; a < e.length; a++) i = Jr(e[a]), "$type" === Ot(e[1]) ? s = s.concat(An({
            key: `${r}[${a}]`,
            value: e[a],
            valueSpec: n.geometry_type,
            style: t.style,
            styleSpec: t.styleSpec
          })) : "string" !== i && "number" !== i && "boolean" !== i && s.push(new mn(`${r}[${a}]`, e[a], `string, number, or boolean expected, ${i} found`));

          break;

        case "any":
        case "all":
        case "none":
          for (let n = 1; n < e.length; n++) s = s.concat(Rn({
            key: `${r}[${n}]`,
            value: e[n],
            style: t.style,
            styleSpec: t.styleSpec
          }));

          break;

        case "has":
        case "!has":
          i = Jr(e[1]), 2 !== e.length ? s.push(new mn(r, e, `filter array for "${e[0]}" operator must have 2 elements`)) : "string" !== i && s.push(new mn(`${r}[1]`, e[1], `string expected, ${i} found`));
          break;

        case "within":
          i = Jr(e[1]), 2 !== e.length ? s.push(new mn(r, e, `filter array for "${e[0]}" operator must have 2 elements`)) : "object" !== i && s.push(new mn(`${r}[1]`, e[1], `object expected, ${i} found`));
      }

      return s;
    }

    function Un(t, e) {
      const r = t.key,
            n = t.style,
            i = t.styleSpec,
            s = t.value,
            a = t.objectKey,
            o = i[`${e}_${t.layerType}`];
      if (!o) return [];
      const l = a.match(/^(.*)-transition$/);
      if ("paint" === e && l && o[l[1]] && o[l[1]].transition) return Hn({
        key: r,
        value: s,
        valueSpec: i.transition,
        style: n,
        styleSpec: i
      });
      const u = t.valueSpec || o[a];
      if (!u) return [new mn(r, s, `unknown property "${a}"`)];
      let c;
      if ("string" === Jr(s) && Yr(u) && !u.tokens && (c = /^{([^}]+)}$/.exec(s))) return [new mn(r, s, `"${a}" does not support interpolation syntax\nUse an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(c[1])} }\`.`)];
      const h = [];
      return "symbol" === t.layerType && ("text-field" === a && n && !n.glyphs && h.push(new mn(r, s, 'use of "text-field" requires a style "glyphs" property')), "text-font" === a && Qr(qt(s)) && "identity" === Ot(s.type) && h.push(new mn(r, s, '"text-font" does not support identity functions'))), h.concat(Hn({
        key: t.key,
        value: s,
        valueSpec: u,
        style: n,
        styleSpec: i,
        expressionContext: "property",
        propertyType: e,
        propertyKey: a
      }));
    }

    function $n(t) {
      return Un(t, "paint");
    }

    function jn(t) {
      return Un(t, "layout");
    }

    function On(t) {
      let e = [];
      const r = t.value,
            n = t.key,
            i = t.style,
            s = t.styleSpec;
      r.type || r.ref || e.push(new mn(n, r, 'either "type" or "ref" is required'));
      let a = Ot(r.type);
      const o = Ot(r.ref);

      if (r.id) {
        const s = Ot(r.id);

        for (let a = 0; a < t.arrayIndex; a++) {
          const t = i.layers[a];
          Ot(t.id) === s && e.push(new mn(n, r.id, `duplicate layer id "${r.id}", previously used at line ${t.id.__line__}`));
        }
      }

      if ("ref" in r) {
        let t;
        ["type", "source", "source-layer", "filter", "layout"].forEach(t => {
          t in r && e.push(new mn(n, r[t], `"${t}" is prohibited for ref layers`));
        }), i.layers.forEach(e => {
          Ot(e.id) === o && (t = e);
        }), t ? t.ref ? e.push(new mn(n, r.ref, "ref cannot reference another ref layer")) : a = Ot(t.type) : "string" == typeof o && e.push(new mn(n, r.ref, `ref layer "${o}" not found`));
      } else if ("background" !== a && "sky" !== a) if (r.source) {
        const t = i.sources && i.sources[r.source],
              s = t && Ot(t.type);
        t ? "vector" === s && "raster" === a ? e.push(new mn(n, r.source, `layer "${r.id}" requires a raster source`)) : "raster" === s && "raster" !== a ? e.push(new mn(n, r.source, `layer "${r.id}" requires a vector source`)) : "vector" !== s || r["source-layer"] ? "raster-dem" === s && "hillshade" !== a ? e.push(new mn(n, r.source, "raster-dem source can only be used with layer type 'hillshade'.")) : "line" !== a || !r.paint || !r.paint["line-gradient"] || "geojson" === s && t.lineMetrics || e.push(new mn(n, r, `layer "${r.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : e.push(new mn(n, r, `layer "${r.id}" must specify a "source-layer"`)) : e.push(new mn(n, r.source, `source "${r.source}" not found`));
      } else e.push(new mn(n, r, 'missing required property "source"'));

      return e = e.concat(gn({
        key: n,
        value: r,
        valueSpec: s.layer,
        style: t.style,
        styleSpec: t.styleSpec,
        objectElementValidators: {
          "*": () => [],
          type: () => Hn({
            key: `${n}.type`,
            value: r.type,
            valueSpec: s.layer.type,
            style: t.style,
            styleSpec: t.styleSpec,
            object: r,
            objectKey: "type"
          }),
          filter: t => Ln(jt({
            layerType: a
          }, t)),
          layout: t => gn({
            layer: r,
            key: t.key,
            value: t.value,
            valueSpec: {},
            style: t.style,
            styleSpec: t.styleSpec,
            objectElementValidators: {
              "*": t => jn(jt({
                layerType: a
              }, t))
            }
          }),
          paint: t => gn({
            layer: r,
            key: t.key,
            value: t.value,
            valueSpec: {},
            style: t.style,
            styleSpec: t.styleSpec,
            objectElementValidators: {
              "*": t => $n(jt({
                layerType: a
              }, t))
            }
          })
        }
      })), e;
    }

    function qn(t) {
      const e = t.value,
            r = t.key,
            n = Jr(e);
      return "string" !== n ? [new mn(r, e, `string expected, ${n} found`)] : [];
    }

    const Nn = {
      promoteId: function ({
        key: t,
        value: e
      }) {
        if ("string" === Jr(e)) return qn({
          key: t,
          value: e
        });
        {
          const r = [];

          for (const n in e) r.push(...qn({
            key: `${t}.${n}`,
            value: e[n]
          }));

          return r;
        }
      }
    };

    function Gn(t) {
      const e = t.value,
            r = t.key,
            n = t.styleSpec,
            i = t.style;
      if (!e.type) return [new mn(r, e, '"type" is required')];
      const s = Ot(e.type);
      let a;

      switch (s) {
        case "vector":
        case "raster":
        case "raster-dem":
          return a = gn({
            key: r,
            value: e,
            valueSpec: n[`source_${s.replace("-", "_")}`],
            style: t.style,
            styleSpec: n,
            objectElementValidators: Nn
          }), a;

        case "geojson":
          if (a = gn({
            key: r,
            value: e,
            valueSpec: n.source_geojson,
            style: i,
            styleSpec: n,
            objectElementValidators: Nn
          }), e.cluster) for (const t in e.clusterProperties) {
            const [n, i] = e.clusterProperties[t],
                  s = "string" == typeof n ? [n, ["accumulated"], ["get", t]] : n;
            a.push(..._n({
              key: `${r}.${t}.map`,
              value: i,
              expressionContext: "cluster-map"
            })), a.push(..._n({
              key: `${r}.${t}.reduce`,
              value: s,
              expressionContext: "cluster-reduce"
            }));
          }
          return a;

        case "video":
          return gn({
            key: r,
            value: e,
            valueSpec: n.source_video,
            style: i,
            styleSpec: n
          });

        case "image":
          return gn({
            key: r,
            value: e,
            valueSpec: n.source_image,
            style: i,
            styleSpec: n
          });

        case "canvas":
          return [new mn(r, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];

        default:
          return An({
            key: `${r}.type`,
            value: e.type,
            valueSpec: {
              values: ["vector", "raster", "raster-dem", "geojson", "video", "image"]
            },
            style: i,
            styleSpec: n
          });
      }
    }

    function Zn(t) {
      const e = t.value,
            r = t.styleSpec,
            n = r.light,
            i = t.style;
      let s = [];
      const a = Jr(e);
      if (void 0 === e) return s;
      if ("object" !== a) return s = s.concat([new mn("light", e, `object expected, ${a} found`)]), s;

      for (const t in e) {
        const a = t.match(/^(.*)-transition$/);
        s = s.concat(a && n[a[1]] && n[a[1]].transition ? Hn({
          key: t,
          value: e[t],
          valueSpec: r.transition,
          style: i,
          styleSpec: r
        }) : n[t] ? Hn({
          key: t,
          value: e[t],
          valueSpec: n[t],
          style: i,
          styleSpec: r
        }) : [new mn(t, e[t], `unknown property "${t}"`)]);
      }

      return s;
    }

    function Xn(t) {
      const e = t.value,
            r = t.key,
            n = t.style,
            i = t.styleSpec,
            s = i.terrain;
      let a = [];
      const o = Jr(e);
      if (void 0 === e) return a;
      if ("object" !== o) return a = a.concat([new mn("terrain", e, `object expected, ${o} found`)]), a;

      for (const t in e) {
        const r = t.match(/^(.*)-transition$/);
        a = a.concat(r && s[r[1]] && s[r[1]].transition ? Hn({
          key: t,
          value: e[t],
          valueSpec: i.transition,
          style: n,
          styleSpec: i
        }) : s[t] ? Hn({
          key: t,
          value: e[t],
          valueSpec: s[t],
          style: n,
          styleSpec: i
        }) : [new mn(t, e[t], `unknown property "${t}"`)]);
      }

      if (e.source) {
        const t = n.sources && n.sources[e.source],
              i = t && Ot(t.type);
        t ? "raster-dem" !== i && a.push(new mn(r, e.source, `terrain cannot be used with a source of type ${String(i)}, it only be used with a "raster-dem" source type`)) : a.push(new mn(r, e.source, `source "${e.source}" not found`));
      } else a.push(new mn(r, e, 'terrain is missing required property "source"'));

      return a;
    }

    function Kn(t) {
      const e = t.value,
            r = t.style,
            n = t.styleSpec,
            i = n.fog;
      let s = [];
      const a = Jr(e);
      if (void 0 === e) return s;
      if ("object" !== a) return s = s.concat([new mn("fog", e, `object expected, ${a} found`)]), s;

      for (const t in e) {
        const a = t.match(/^(.*)-transition$/);
        s = s.concat(a && i[a[1]] && i[a[1]].transition ? Hn({
          key: t,
          value: e[t],
          valueSpec: n.transition,
          style: r,
          styleSpec: n
        }) : i[t] ? Hn({
          key: t,
          value: e[t],
          valueSpec: i[t],
          style: r,
          styleSpec: n
        }) : [new mn(t, e[t], `unknown property "${t}"`)]);
      }

      return s;
    }

    const Yn = {
      "*": () => [],
      array: xn,
      boolean: function (t) {
        const e = t.value,
              r = t.key,
              n = Jr(e);
        return "boolean" !== n ? [new mn(r, e, `boolean expected, ${n} found`)] : [];
      },
      number: vn,
      color: function (t) {
        const e = t.key,
              r = t.value,
              n = Jr(r);
        return "string" !== n ? [new mn(e, r, `color expected, ${n} found`)] : null === ue.parseCSSColor(r) ? [new mn(e, r, `color expected, "${r}" found`)] : [];
      },
      enum: An,
      filter: Ln,
      function: bn,
      layer: On,
      object: gn,
      source: Gn,
      light: Zn,
      terrain: Xn,
      fog: Kn,
      string: qn,
      formatted: function (t) {
        return 0 === qn(t).length ? [] : _n(t);
      },
      resolvedImage: function (t) {
        return 0 === qn(t).length ? [] : _n(t);
      },
      projection: function (t) {
        const e = t.value,
              r = t.styleSpec,
              n = r.projection,
              i = t.style;
        let s = [];
        const a = Jr(e);
        if ("object" === a) for (const t in e) s = s.concat(Hn({
          key: t,
          value: e[t],
          valueSpec: n[t],
          style: i,
          styleSpec: r
        }));else "string" !== a && (s = s.concat([new mn("projection", e, `object or string expected, ${a} found`)]));
        return s;
      }
    };

    function Hn(t) {
      const e = t.value,
            r = t.valueSpec,
            n = t.styleSpec;
      return r.expression && Qr(Ot(e)) ? bn(t) : r.expression && un(qt(e)) ? _n(t) : r.type && Yn[r.type] ? Yn[r.type](t) : gn(jt({}, t, {
        valueSpec: r.type ? n[r.type] : r
      }));
    }

    function Wn(t) {
      const e = t.value,
            r = t.key,
            n = qn(t);
      return n.length || (-1 === e.indexOf("{fontstack}") && n.push(new mn(r, e, '"glyphs" url must include a "{fontstack}" token')), -1 === e.indexOf("{range}") && n.push(new mn(r, e, '"glyphs" url must include a "{range}" token'))), n;
    }

    function Jn(t, e = $t) {
      return ei(Hn({
        key: "",
        value: t,
        valueSpec: e.$root,
        styleSpec: e,
        style: t,
        objectElementValidators: {
          glyphs: Wn,
          "*": () => []
        }
      }));
    }

    const Qn = t => ei($n(t)),
          ti = t => ei(jn(t));

    function ei(t) {
      return t.slice().sort((t, e) => t.line && e.line ? t.line - e.line : 0);
    }

    function ri(t, e) {
      let r = !1;
      if (e && e.length) for (const n of e) t.fire(new Rt(new Error(n.message))), r = !0;
      return r;
    }

    var ni = ii;

    function ii(t, e, r) {
      var n = this.cells = [];

      if (t instanceof ArrayBuffer) {
        this.arrayBuffer = t;
        var i = new Int32Array(this.arrayBuffer);
        t = i[0], this.d = (e = i[1]) + 2 * (r = i[2]);

        for (var s = 0; s < this.d * this.d; s++) {
          var a = i[3 + s],
              o = i[3 + s + 1];
          n.push(a === o ? null : i.subarray(a, o));
        }

        var l = i[3 + n.length + 1];
        this.keys = i.subarray(i[3 + n.length], l), this.bboxes = i.subarray(l), this.insert = this._insertReadonly;
      } else {
        this.d = e + 2 * r;

        for (var u = 0; u < this.d * this.d; u++) n.push([]);

        this.keys = [], this.bboxes = [];
      }

      this.n = e, this.extent = t, this.padding = r, this.scale = e / t, this.uid = 0;
      var c = r / e * t;
      this.min = -c, this.max = t + c;
    }

    ii.prototype.insert = function (t, e, r, n, i) {
      this._forEachCell(e, r, n, i, this._insertCell, this.uid++), this.keys.push(t), this.bboxes.push(e), this.bboxes.push(r), this.bboxes.push(n), this.bboxes.push(i);
    }, ii.prototype._insertReadonly = function () {
      throw "Cannot insert into a GridIndex created from an ArrayBuffer.";
    }, ii.prototype._insertCell = function (t, e, r, n, i, s) {
      this.cells[i].push(s);
    }, ii.prototype.query = function (t, e, r, n, i) {
      var s = this.min,
          a = this.max;
      if (t <= s && e <= s && a <= r && a <= n && !i) return Array.prototype.slice.call(this.keys);
      var o = [];
      return this._forEachCell(t, e, r, n, this._queryCell, o, {}, i), o;
    }, ii.prototype._queryCell = function (t, e, r, n, i, s, a, o) {
      var l = this.cells[i];
      if (null !== l) for (var u = this.keys, c = this.bboxes, h = 0; h < l.length; h++) {
        var p = l[h];

        if (void 0 === a[p]) {
          var f = 4 * p;
          (o ? o(c[f + 0], c[f + 1], c[f + 2], c[f + 3]) : t <= c[f + 2] && e <= c[f + 3] && r >= c[f + 0] && n >= c[f + 1]) ? (a[p] = !0, s.push(u[p])) : a[p] = !1;
        }
      }
    }, ii.prototype._forEachCell = function (t, e, r, n, i, s, a, o) {
      for (var l = this._convertToCellCoord(t), u = this._convertToCellCoord(e), c = this._convertToCellCoord(r), h = this._convertToCellCoord(n), p = l; p <= c; p++) for (var f = u; f <= h; f++) {
        var d = this.d * f + p;
        if ((!o || o(this._convertFromCellCoord(p), this._convertFromCellCoord(f), this._convertFromCellCoord(p + 1), this._convertFromCellCoord(f + 1))) && i.call(this, t, e, r, n, d, s, a, o)) return;
      }
    }, ii.prototype._convertFromCellCoord = function (t) {
      return (t - this.padding) / this.scale;
    }, ii.prototype._convertToCellCoord = function (t) {
      return Math.max(0, Math.min(this.d - 1, Math.floor(t * this.scale) + this.padding));
    }, ii.prototype.toArrayBuffer = function () {
      if (this.arrayBuffer) return this.arrayBuffer;

      for (var t = this.cells, e = 3 + this.cells.length + 1 + 1, r = 0, n = 0; n < this.cells.length; n++) r += this.cells[n].length;

      var i = new Int32Array(e + r + this.keys.length + this.bboxes.length);
      i[0] = this.extent, i[1] = this.n, i[2] = this.padding;

      for (var s = e, a = 0; a < t.length; a++) {
        var o = t[a];
        i[3 + a] = s, i.set(o, s), s += o.length;
      }

      return i[3 + t.length] = s, i.set(this.keys, s), i[3 + t.length + 1] = s += this.keys.length, i.set(this.bboxes, s), s += this.bboxes.length, i.buffer;
    };
    const si = {};

    function ai(t, e, r = {}) {
      Object.defineProperty(t, "_classRegistryKey", {
        value: e,
        writeable: !1
      }), si[e] = {
        klass: t,
        omit: r.omit || []
      };
    }

    ai(Object, "Object"), ni.serialize = function (t, e) {
      const r = t.toArrayBuffer();
      return e && e.push(r), {
        buffer: r
      };
    }, ni.deserialize = function (t) {
      return new ni(t.buffer);
    }, Object.defineProperty(ni, "name", {
      value: "Grid"
    }), ai(ni, "Grid"), ai(ce, "Color"), ai(Error, "Error"), ai(kt, "AJAXError"), ai(de, "ResolvedImage"), ai(dn, "StylePropertyFunction"), ai(ln, "StyleExpression", {
      omit: ["_evaluator"]
    }), ai(pn, "ZoomDependentExpression"), ai(hn, "ZoomConstantExpression"), ai(ze, "CompoundExpression", {
      omit: ["_evaluate"]
    });

    for (const t in Or) si[Or[t]._classRegistryKey] || ai(Or[t], `Expression${t}`);

    function oi(t) {
      return t && "undefined" != typeof ArrayBuffer && (t instanceof ArrayBuffer || t.constructor && "ArrayBuffer" === t.constructor.name);
    }

    function li(t) {
      return a.ImageBitmap && t instanceof a.ImageBitmap;
    }

    function ui(t, e) {
      if (null == t || "boolean" == typeof t || "number" == typeof t || "string" == typeof t || t instanceof Boolean || t instanceof Number || t instanceof String || t instanceof Date || t instanceof RegExp) return t;
      if (oi(t) || li(t)) return e && e.push(t), t;

      if (ArrayBuffer.isView(t)) {
        const r = t;
        return e && e.push(r.buffer), r;
      }

      if (t instanceof a.ImageData) return e && e.push(t.data.buffer), t;

      if (Array.isArray(t)) {
        const r = [];

        for (const n of t) r.push(ui(n, e));

        return r;
      }

      if ("object" == typeof t) {
        const r = t.constructor,
              n = r._classRegistryKey;
        if (!n) throw new Error(`can't serialize object of unregistered class ${n}`);
        const i = r.serialize ? r.serialize(t, e) : {};

        if (!r.serialize) {
          for (const r in t) t.hasOwnProperty(r) && (si[n].omit.indexOf(r) >= 0 || (i[r] = ui(t[r], e)));

          t instanceof Error && (i.message = t.message);
        }

        if (i.$name) throw new Error("$name property is reserved for worker serialization logic.");
        return "Object" !== n && (i.$name = n), i;
      }

      throw new Error("can't serialize object of type " + typeof t);
    }

    function ci(t) {
      if (null == t || "boolean" == typeof t || "number" == typeof t || "string" == typeof t || t instanceof Boolean || t instanceof Number || t instanceof String || t instanceof Date || t instanceof RegExp || oi(t) || li(t) || ArrayBuffer.isView(t) || t instanceof a.ImageData) return t;
      if (Array.isArray(t)) return t.map(ci);

      if ("object" == typeof t) {
        const e = t.$name || "Object",
              {
          klass: r
        } = si[e];
        if (!r) throw new Error(`can't deserialize unregistered class ${e}`);
        if (r.deserialize) return r.deserialize(t);
        const n = Object.create(r.prototype);

        for (const e of Object.keys(t)) "$name" !== e && (n[e] = ci(t[e]));

        return n;
      }

      throw new Error("can't deserialize object of type " + typeof t);
    }

    class hi {
      constructor() {
        this.first = !0;
      }

      update(t, e) {
        const r = Math.floor(t);
        return this.first ? (this.first = !1, this.lastIntegerZoom = r, this.lastIntegerZoomTime = 0, this.lastZoom = t, this.lastFloorZoom = r, !0) : (this.lastFloorZoom > r ? (this.lastIntegerZoom = r + 1, this.lastIntegerZoomTime = e) : this.lastFloorZoom < r && (this.lastIntegerZoom = r, this.lastIntegerZoomTime = e), t !== this.lastZoom && (this.lastZoom = t, this.lastFloorZoom = r, !0));
      }

    }

    const pi = t => t >= 1536 && t <= 1791,
          fi = t => t >= 1872 && t <= 1919,
          di = t => t >= 2208 && t <= 2303,
          yi = t => t >= 11904 && t <= 12031,
          mi = t => t >= 12032 && t <= 12255,
          gi = t => t >= 12272 && t <= 12287,
          xi = t => t >= 12288 && t <= 12351,
          vi = t => t >= 12352 && t <= 12447,
          bi = t => t >= 12448 && t <= 12543,
          _i = t => t >= 12544 && t <= 12591,
          wi = t => t >= 12704 && t <= 12735,
          Ai = t => t >= 12736 && t <= 12783,
          ki = t => t >= 12784 && t <= 12799,
          Si = t => t >= 12800 && t <= 13055,
          Ii = t => t >= 13056 && t <= 13311,
          Mi = t => t >= 13312 && t <= 19903,
          Ti = t => t >= 19968 && t <= 40959,
          zi = t => t >= 40960 && t <= 42127,
          Bi = t => t >= 42128 && t <= 42191,
          Ei = t => t >= 44032 && t <= 55215,
          Ci = t => t >= 63744 && t <= 64255,
          Di = t => t >= 64336 && t <= 65023,
          Pi = t => t >= 65040 && t <= 65055,
          Vi = t => t >= 65072 && t <= 65103,
          Fi = t => t >= 65104 && t <= 65135,
          Li = t => t >= 65136 && t <= 65279,
          Ri = t => t >= 65280 && t <= 65519;

    function Ui(t) {
      for (const e of t) if (Oi(e.charCodeAt(0))) return !0;

      return !1;
    }

    function $i(t) {
      for (const e of t) if (!ji(e.charCodeAt(0))) return !1;

      return !0;
    }

    function ji(t) {
      return !(pi(t) || fi(t) || di(t) || Di(t) || Li(t));
    }

    function Oi(t) {
      return !(746 !== t && 747 !== t && (t < 4352 || !(wi(t) || _i(t) || Vi(t) && !(t >= 65097 && t <= 65103) || Ci(t) || Ii(t) || yi(t) || Ai(t) || !(!xi(t) || t >= 12296 && t <= 12305 || t >= 12308 && t <= 12319 || 12336 === t) || Mi(t) || Ti(t) || Si(t) || (t => t >= 12592 && t <= 12687)(t) || (t => t >= 43360 && t <= 43391)(t) || (t => t >= 55216 && t <= 55295)(t) || (t => t >= 4352 && t <= 4607)(t) || Ei(t) || vi(t) || gi(t) || (t => t >= 12688 && t <= 12703)(t) || mi(t) || ki(t) || bi(t) && 12540 !== t || !(!Ri(t) || 65288 === t || 65289 === t || 65293 === t || t >= 65306 && t <= 65310 || 65339 === t || 65341 === t || 65343 === t || t >= 65371 && t <= 65503 || 65507 === t || t >= 65512 && t <= 65519) || !(!Fi(t) || t >= 65112 && t <= 65118 || t >= 65123 && t <= 65126) || (t => t >= 5120 && t <= 5759)(t) || (t => t >= 6320 && t <= 6399)(t) || Pi(t) || (t => t >= 19904 && t <= 19967)(t) || zi(t) || Bi(t))));
    }

    function qi(t) {
      return !(Oi(t) || function (t) {
        return !!((t => t >= 128 && t <= 255)(t) && (167 === t || 169 === t || 174 === t || 177 === t || 188 === t || 189 === t || 190 === t || 215 === t || 247 === t) || (t => t >= 8192 && t <= 8303)(t) && (8214 === t || 8224 === t || 8225 === t || 8240 === t || 8241 === t || 8251 === t || 8252 === t || 8258 === t || 8263 === t || 8264 === t || 8265 === t || 8273 === t) || (t => t >= 8448 && t <= 8527)(t) || (t => t >= 8528 && t <= 8591)(t) || (t => t >= 8960 && t <= 9215)(t) && (t >= 8960 && t <= 8967 || t >= 8972 && t <= 8991 || t >= 8996 && t <= 9e3 || 9003 === t || t >= 9085 && t <= 9114 || t >= 9150 && t <= 9165 || 9167 === t || t >= 9169 && t <= 9179 || t >= 9186 && t <= 9215) || (t => t >= 9216 && t <= 9279)(t) && 9251 !== t || (t => t >= 9280 && t <= 9311)(t) || (t => t >= 9312 && t <= 9471)(t) || (t => t >= 9632 && t <= 9727)(t) || (t => t >= 9728 && t <= 9983)(t) && !(t >= 9754 && t <= 9759) || (t => t >= 11008 && t <= 11263)(t) && (t >= 11026 && t <= 11055 || t >= 11088 && t <= 11097 || t >= 11192 && t <= 11243) || xi(t) || bi(t) || (t => t >= 57344 && t <= 63743)(t) || Vi(t) || Fi(t) || Ri(t) || 8734 === t || 8756 === t || 8757 === t || t >= 9984 && t <= 10087 || t >= 10102 && t <= 10131 || 65532 === t || 65533 === t);
      }(t));
    }

    function Ni(t) {
      return t >= 1424 && t <= 2303 || Di(t) || Li(t);
    }

    function Gi(t, e) {
      return !(!e && Ni(t) || t >= 2304 && t <= 3583 || t >= 3840 && t <= 4255 || (t => t >= 6016 && t <= 6143)(t));
    }

    function Zi(t) {
      for (const e of t) if (Ni(e.charCodeAt(0))) return !0;

      return !1;
    }

    const Xi = "deferred",
          Ki = "loading",
          Yi = "loaded";
    let Hi = null,
        Wi = "unavailable",
        Ji = null;

    const Qi = function (t) {
      t && "string" == typeof t && t.indexOf("NetworkError") > -1 && (Wi = "error"), Hi && Hi(t);
    };

    function ts() {
      es.fire(new Lt("pluginStateChange", {
        pluginStatus: Wi,
        pluginURL: Ji
      }));
    }

    const es = new Ut(),
          rs = function () {
      return Wi;
    },
          ns = function () {
      if (Wi !== Xi || !Ji) throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
      Wi = Ki, ts(), Ji && Mt({
        url: Ji
      }, t => {
        t ? Qi(t) : (Wi = Yi, ts());
      });
    },
          is = {
      applyArabicShaping: null,
      processBidirectionalText: null,
      processStyledBidirectionalText: null,
      isLoaded: () => Wi === Yi || null != is.applyArabicShaping,
      isLoading: () => Wi === Ki,

      setState(t) {
        Wi = t.pluginStatus, Ji = t.pluginURL;
      },

      isParsed: () => null != is.applyArabicShaping && null != is.processBidirectionalText && null != is.processStyledBidirectionalText,
      getPluginURL: () => Ji
    };

    class ss {
      constructor(t, e) {
        this.zoom = t, e ? (this.now = e.now, this.fadeDuration = e.fadeDuration, this.zoomHistory = e.zoomHistory, this.transition = e.transition, this.pitch = e.pitch) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new hi(), this.transition = {}, this.pitch = 0);
      }

      isSupportedScript(t) {
        return function (t, e) {
          for (const r of t) if (!Gi(r.charCodeAt(0), e)) return !1;

          return !0;
        }(t, is.isLoaded());
      }

      crossFadingFactor() {
        return 0 === this.fadeDuration ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
      }

      getCrossfadeParameters() {
        const t = this.zoom,
              e = t - Math.floor(t),
              r = this.crossFadingFactor();
        return t > this.zoomHistory.lastIntegerZoom ? {
          fromScale: 2,
          toScale: 1,
          t: e + (1 - e) * r
        } : {
          fromScale: .5,
          toScale: 1,
          t: 1 - (1 - r) * e
        };
      }

    }

    class as {
      constructor(t, e) {
        this.property = t, this.value = e, this.expression = function (t, e) {
          if (Qr(t)) return new dn(t, e);

          if (un(t)) {
            const r = fn(t, e);
            if ("error" === r.result) throw new Error(r.value.map(t => `${t.key}: ${t.message}`).join(", "));
            return r.value;
          }

          {
            let r = t;
            return "string" == typeof t && "color" === e.type && (r = ce.parse(t)), {
              kind: "constant",
              evaluate: () => r
            };
          }
        }(void 0 === e ? t.specification.default : e, t.specification);
      }

      isDataDriven() {
        return "source" === this.expression.kind || "composite" === this.expression.kind;
      }

      possiblyEvaluate(t, e, r) {
        return this.property.possiblyEvaluate(this, t, e, r);
      }

    }

    class os {
      constructor(t) {
        this.property = t, this.value = new as(t, void 0);
      }

      transitioned(t, e) {
        return new us(this.property, this.value, e, b({}, t.transition, this.transition), t.now);
      }

      untransitioned() {
        return new us(this.property, this.value, null, {}, 0);
      }

    }

    class ls {
      constructor(t) {
        this._properties = t, this._values = Object.create(t.defaultTransitionablePropertyValues);
      }

      getValue(t) {
        return B(this._values[t].value.value);
      }

      setValue(t, e) {
        this._values.hasOwnProperty(t) || (this._values[t] = new os(this._values[t].property)), this._values[t].value = new as(this._values[t].property, null === e ? void 0 : B(e));
      }

      getTransition(t) {
        return B(this._values[t].transition);
      }

      setTransition(t, e) {
        this._values.hasOwnProperty(t) || (this._values[t] = new os(this._values[t].property)), this._values[t].transition = B(e) || void 0;
      }

      serialize() {
        const t = {};

        for (const e of Object.keys(this._values)) {
          const r = this.getValue(e);
          void 0 !== r && (t[e] = r);
          const n = this.getTransition(e);
          void 0 !== n && (t[`${e}-transition`] = n);
        }

        return t;
      }

      transitioned(t, e) {
        const r = new cs(this._properties);

        for (const n of Object.keys(this._values)) r._values[n] = this._values[n].transitioned(t, e._values[n]);

        return r;
      }

      untransitioned() {
        const t = new cs(this._properties);

        for (const e of Object.keys(this._values)) t._values[e] = this._values[e].untransitioned();

        return t;
      }

    }

    class us {
      constructor(t, e, r, n, i) {
        const s = n.delay || 0,
              a = n.duration || 0;
        i = i || 0, this.property = t, this.value = e, this.begin = i + s, this.end = this.begin + a, t.specification.transition && (n.delay || n.duration) && (this.prior = r);
      }

      possiblyEvaluate(t, e, r) {
        const n = t.now || 0,
              i = this.value.possiblyEvaluate(t, e, r),
              s = this.prior;

        if (s) {
          if (n > this.end) return this.prior = null, i;
          if (this.value.isDataDriven()) return this.prior = null, i;
          if (n < this.begin) return s.possiblyEvaluate(t, e, r);
          {
            const a = (n - this.begin) / (this.end - this.begin);
            return this.property.interpolate(s.possiblyEvaluate(t, e, r), i, p(a));
          }
        }

        return i;
      }

    }

    class cs {
      constructor(t) {
        this._properties = t, this._values = Object.create(t.defaultTransitioningPropertyValues);
      }

      possiblyEvaluate(t, e, r) {
        const n = new fs(this._properties);

        for (const i of Object.keys(this._values)) n._values[i] = this._values[i].possiblyEvaluate(t, e, r);

        return n;
      }

      hasTransition() {
        for (const t of Object.keys(this._values)) if (this._values[t].prior) return !0;

        return !1;
      }

    }

    class hs {
      constructor(t) {
        this._properties = t, this._values = Object.create(t.defaultPropertyValues);
      }

      getValue(t) {
        return B(this._values[t].value);
      }

      setValue(t, e) {
        this._values[t] = new as(this._values[t].property, null === e ? void 0 : B(e));
      }

      serialize() {
        const t = {};

        for (const e of Object.keys(this._values)) {
          const r = this.getValue(e);
          void 0 !== r && (t[e] = r);
        }

        return t;
      }

      possiblyEvaluate(t, e, r) {
        const n = new fs(this._properties);

        for (const i of Object.keys(this._values)) n._values[i] = this._values[i].possiblyEvaluate(t, e, r);

        return n;
      }

    }

    class ps {
      constructor(t, e, r) {
        this.property = t, this.value = e, this.parameters = r;
      }

      isConstant() {
        return "constant" === this.value.kind;
      }

      constantOr(t) {
        return "constant" === this.value.kind ? this.value.value : t;
      }

      evaluate(t, e, r, n) {
        return this.property.evaluate(this.value, this.parameters, t, e, r, n);
      }

    }

    class fs {
      constructor(t) {
        this._properties = t, this._values = Object.create(t.defaultPossiblyEvaluatedValues);
      }

      get(t) {
        return this._values[t];
      }

    }

    class ds {
      constructor(t) {
        this.specification = t;
      }

      possiblyEvaluate(t, e) {
        return t.expression.evaluate(e);
      }

      interpolate(t, e, r) {
        const n = nr[this.specification.type];
        return n ? n(t, e, r) : t;
      }

    }

    class ys {
      constructor(t, e) {
        this.specification = t, this.overrides = e;
      }

      possiblyEvaluate(t, e, r, n) {
        return new ps(this, "constant" === t.expression.kind || "camera" === t.expression.kind ? {
          kind: "constant",
          value: t.expression.evaluate(e, null, {}, r, n)
        } : t.expression, e);
      }

      interpolate(t, e, r) {
        if ("constant" !== t.value.kind || "constant" !== e.value.kind) return t;
        if (void 0 === t.value.value || void 0 === e.value.value) return new ps(this, {
          kind: "constant",
          value: void 0
        }, t.parameters);
        const n = nr[this.specification.type];
        return n ? new ps(this, {
          kind: "constant",
          value: n(t.value.value, e.value.value, r)
        }, t.parameters) : t;
      }

      evaluate(t, e, r, n, i, s) {
        return "constant" === t.kind ? t.value : t.evaluate(e, r, n, i, s);
      }

    }

    class ms extends ys {
      possiblyEvaluate(t, e, r, n) {
        if (void 0 === t.value) return new ps(this, {
          kind: "constant",
          value: void 0
        }, e);

        if ("constant" === t.expression.kind) {
          const i = t.expression.evaluate(e, null, {}, r, n),
                s = "resolvedImage" === t.property.specification.type && "string" != typeof i ? i.name : i,
                a = this._calculate(s, s, s, e);

          return new ps(this, {
            kind: "constant",
            value: a
          }, e);
        }

        if ("camera" === t.expression.kind) {
          const r = this._calculate(t.expression.evaluate({
            zoom: e.zoom - 1
          }), t.expression.evaluate({
            zoom: e.zoom
          }), t.expression.evaluate({
            zoom: e.zoom + 1
          }), e);

          return new ps(this, {
            kind: "constant",
            value: r
          }, e);
        }

        return new ps(this, t.expression, e);
      }

      evaluate(t, e, r, n, i, s) {
        if ("source" === t.kind) {
          const a = t.evaluate(e, r, n, i, s);
          return this._calculate(a, a, a, e);
        }

        return "composite" === t.kind ? this._calculate(t.evaluate({
          zoom: Math.floor(e.zoom) - 1
        }, r, n), t.evaluate({
          zoom: Math.floor(e.zoom)
        }, r, n), t.evaluate({
          zoom: Math.floor(e.zoom) + 1
        }, r, n), e) : t.value;
      }

      _calculate(t, e, r, n) {
        return n.zoom > n.zoomHistory.lastIntegerZoom ? {
          from: t,
          to: e,
          other: r
        } : {
          from: r,
          to: e,
          other: t
        };
      }

      interpolate(t) {
        return t;
      }

    }

    class gs {
      constructor(t) {
        this.specification = t;
      }

      possiblyEvaluate(t, e, r, n) {
        if (void 0 !== t.value) {
          if ("constant" === t.expression.kind) {
            const i = t.expression.evaluate(e, null, {}, r, n);
            return this._calculate(i, i, i, e);
          }

          return this._calculate(t.expression.evaluate(new ss(Math.floor(e.zoom - 1), e)), t.expression.evaluate(new ss(Math.floor(e.zoom), e)), t.expression.evaluate(new ss(Math.floor(e.zoom + 1), e)), e);
        }
      }

      _calculate(t, e, r, n) {
        return n.zoom > n.zoomHistory.lastIntegerZoom ? {
          from: t,
          to: e
        } : {
          from: r,
          to: e
        };
      }

      interpolate(t) {
        return t;
      }

    }

    class xs {
      constructor(t) {
        this.specification = t;
      }

      possiblyEvaluate(t, e, r, n) {
        return !!t.expression.evaluate(e, null, {}, r, n);
      }

      interpolate() {
        return !1;
      }

    }

    class vs {
      constructor(t) {
        this.properties = t, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];

        for (const e in t) {
          const r = t[e];
          r.specification.overridable && this.overridableProperties.push(e);
          const n = this.defaultPropertyValues[e] = new as(r, void 0),
                i = this.defaultTransitionablePropertyValues[e] = new os(r);
          this.defaultTransitioningPropertyValues[e] = i.untransitioned(), this.defaultPossiblyEvaluatedValues[e] = n.possiblyEvaluate({});
        }
      }

    }

    function bs(t, e) {
      return 256 * (t = y(Math.floor(t), 0, 255)) + y(Math.floor(e), 0, 255);
    }

    ai(ys, "DataDrivenProperty"), ai(ds, "DataConstantProperty"), ai(ms, "CrossFadedDataDrivenProperty"), ai(gs, "CrossFadedProperty"), ai(xs, "ColorRampProperty");
    const _s = {
      Int8: Int8Array,
      Uint8: Uint8Array,
      Int16: Int16Array,
      Uint16: Uint16Array,
      Int32: Int32Array,
      Uint32: Uint32Array,
      Float32: Float32Array
    };

    class ws {
      constructor(t, e) {
        this._structArray = t, this._pos1 = e * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
      }

    }

    class As {
      constructor() {
        this.isTransferred = !1, this.capacity = -1, this.resize(0);
      }

      static serialize(t, e) {
        return t._trim(), e && (t.isTransferred = !0, e.push(t.arrayBuffer)), {
          length: t.length,
          arrayBuffer: t.arrayBuffer
        };
      }

      static deserialize(t) {
        const e = Object.create(this.prototype);
        return e.arrayBuffer = t.arrayBuffer, e.length = t.length, e.capacity = t.arrayBuffer.byteLength / e.bytesPerElement, e._refreshViews(), e;
      }

      _trim() {
        this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
      }

      clear() {
        this.length = 0;
      }

      resize(t) {
        this.reserve(t), this.length = t;
      }

      reserve(t) {
        if (t > this.capacity) {
          this.capacity = Math.max(t, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
          const e = this.uint8;
          this._refreshViews(), e && this.uint8.set(e);
        }
      }

      _refreshViews() {
        throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
      }

      destroy() {
        this.int8 = this.uint8 = this.int16 = this.uint16 = this.int32 = this.uint32 = this.float32 = null, this.arrayBuffer = null;
      }

    }

    function ks(t, e = 1) {
      let r = 0,
          n = 0;
      return {
        members: t.map(t => {
          const i = _s[t.type].BYTES_PER_ELEMENT,
                s = r = Ss(r, Math.max(e, i)),
                a = t.components || 1;
          return n = Math.max(n, i), r += i * a, {
            name: t.name,
            type: t.type,
            components: a,
            offset: s
          };
        }),
        size: Ss(r, Math.max(n, e)),
        alignment: e
      };
    }

    function Ss(t, e) {
      return Math.ceil(t / e) * e;
    }

    class Is extends As {
      _refreshViews() {
        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
      }

      emplaceBack(t, e) {
        const r = this.length;
        return this.resize(r + 1), this.emplace(r, t, e);
      }

      emplace(t, e, r) {
        const n = 2 * t;
        return this.int16[n + 0] = e, this.int16[n + 1] = r, t;
      }

    }

    Is.prototype.bytesPerElement = 4, ai(Is, "StructArrayLayout2i4");

    class Ms extends As {
      _refreshViews() {
        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
      }

      emplaceBack(t, e, r) {
        const n = this.length;
        return this.resize(n + 1), this.emplace(n, t, e, r);
      }

      emplace(t, e, r, n) {
        const i = 3 * t;
        return this.int16[i + 0] = e, this.int16[i + 1] = r, this.int16[i + 2] = n, t;
      }

    }

    Ms.prototype.bytesPerElement = 6, ai(Ms, "StructArrayLayout3i6");

    class Ts extends As {
      _refreshViews() {
        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
      }

      emplaceBack(t, e, r, n) {
        const i = this.length;
        return this.resize(i + 1), this.emplace(i, t, e, r, n);
      }

      emplace(t, e, r, n, i) {
        const s = 4 * t;
        return this.int16[s + 0] = e, this.int16[s + 1] = r, this.int16[s + 2] = n, this.int16[s + 3] = i, t;
      }

    }

    Ts.prototype.bytesPerElement = 8, ai(Ts, "StructArrayLayout4i8");

    class zs extends As {
      _refreshViews() {
        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
      }

      emplaceBack(t, e, r, n, i, s, a) {
        const o = this.length;
        return this.resize(o + 1), this.emplace(o, t, e, r, n, i, s, a);
      }

      emplace(t, e, r, n, i, s, a, o) {
        const l = 6 * t,
              u = 12 * t,
              c = 3 * t;
        return this.int16[l + 0] = e, this.int16[l + 1] = r, this.uint8[u + 4] = n, this.uint8[u + 5] = i, this.uint8[u + 6] = s, this.uint8[u + 7] = a, this.float32[c + 2] = o, t;
      }

    }

    zs.prototype.bytesPerElement = 12, ai(zs, "StructArrayLayout2i4ub1f12");

    class Bs extends As {
      _refreshViews() {
        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
      }

      emplaceBack(t, e, r, n) {
        const i = this.length;
        return this.resize(i + 1), this.emplace(i, t, e, r, n);
      }

      emplace(t, e, r, n, i) {
        const s = 4 * t;
        return this.float32[s + 0] = e, this.float32[s + 1] = r, this.float32[s + 2] = n, this.float32[s + 3] = i, t;
      }

    }

    Bs.prototype.bytesPerElement = 16, ai(Bs, "StructArrayLayout4f16");

    class Es extends As {
      _refreshViews() {
        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
      }

      emplaceBack(t, e, r, n, i, s, a, o, l, u) {
        const c = this.length;
        return this.resize(c + 1), this.emplace(c, t, e, r, n, i, s, a, o, l, u);
      }

      emplace(t, e, r, n, i, s, a, o, l, u, c) {
        const h = 10 * t;
        return this.uint16[h + 0] = e, this.uint16[h + 1] = r, this.uint16[h + 2] = n, this.uint16[h + 3] = i, this.uint16[h + 4] = s, this.uint16[h + 5] = a, this.uint16[h + 6] = o, this.uint16[h + 7] = l, this.uint16[h + 8] = u, this.uint16[h + 9] = c, t;
      }

    }

    Es.prototype.bytesPerElement = 20, ai(Es, "StructArrayLayout10ui20");

    class Cs extends As {
      _refreshViews() {
        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
      }

      emplaceBack(t, e, r, n, i, s, a, o) {
        const l = this.length;
        return this.resize(l + 1), this.emplace(l, t, e, r, n, i, s, a, o);
      }

      emplace(t, e, r, n, i, s, a, o, l) {
        const u = 8 * t;
        return this.uint16[u + 0] = e, this.uint16[u + 1] = r, this.uint16[u + 2] = n, this.uint16[u + 3] = i, this.uint16[u + 4] = s, this.uint16[u + 5] = a, this.uint16[u + 6] = o, this.uint16[u + 7] = l, t;
      }

    }

    Cs.prototype.bytesPerElement = 16, ai(Cs, "StructArrayLayout8ui16");

    class Ds extends As {
      _refreshViews() {
        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
      }

      emplaceBack(t, e, r, n, i, s) {
        const a = this.length;
        return this.resize(a + 1), this.emplace(a, t, e, r, n, i, s);
      }

      emplace(t, e, r, n, i, s, a) {
        const o = 6 * t;
        return this.int16[o + 0] = e, this.int16[o + 1] = r, this.int16[o + 2] = n, this.int16[o + 3] = i, this.int16[o + 4] = s, this.int16[o + 5] = a, t;
      }

    }

    Ds.prototype.bytesPerElement = 12, ai(Ds, "StructArrayLayout6i12");

    class Ps extends As {
      _refreshViews() {
        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
      }

      emplaceBack(t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y) {
        const m = this.length;
        return this.resize(m + 1), this.emplace(m, t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y);
      }

      emplace(t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m) {
        const g = 16 * t;
        return this.int16[g + 0] = e, this.int16[g + 1] = r, this.int16[g + 2] = n, this.int16[g + 3] = i, this.uint16[g + 4] = s, this.uint16[g + 5] = a, this.uint16[g + 6] = o, this.uint16[g + 7] = l, this.int16[g + 8] = u, this.int16[g + 9] = c, this.int16[g + 10] = h, this.int16[g + 11] = p, this.int16[g + 12] = f, this.int16[g + 13] = d, this.int16[g + 14] = y, this.int16[g + 15] = m, t;
      }

    }

    Ps.prototype.bytesPerElement = 32, ai(Ps, "StructArrayLayout4i4ui4i4i32");

    class Vs extends As {
      _refreshViews() {
        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
      }

      emplaceBack(t, e, r) {
        const n = this.length;
        return this.resize(n + 1), this.emplace(n, t, e, r);
      }

      emplace(t, e, r, n) {
        const i = 3 * t;
        return this.float32[i + 0] = e, this.float32[i + 1] = r, this.float32[i + 2] = n, t;
      }

    }

    Vs.prototype.bytesPerElement = 12, ai(Vs, "StructArrayLayout3f12");

    class Fs extends As {
      _refreshViews() {
        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
      }

      emplaceBack(t) {
        const e = this.length;
        return this.resize(e + 1), this.emplace(e, t);
      }

      emplace(t, e) {
        return this.uint32[1 * t + 0] = e, t;
      }

    }

    Fs.prototype.bytesPerElement = 4, ai(Fs, "StructArrayLayout1ul4");

    class Ls extends As {
      _refreshViews() {
        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
      }

      emplaceBack(t, e, r, n, i, s, a, o, l, u, c, h, p) {
        const f = this.length;
        return this.resize(f + 1), this.emplace(f, t, e, r, n, i, s, a, o, l, u, c, h, p);
      }

      emplace(t, e, r, n, i, s, a, o, l, u, c, h, p, f) {
        const d = 20 * t,
              y = 10 * t;
        return this.int16[d + 0] = e, this.int16[d + 1] = r, this.int16[d + 2] = n, this.int16[d + 3] = i, this.int16[d + 4] = s, this.float32[y + 3] = a, this.float32[y + 4] = o, this.float32[y + 5] = l, this.float32[y + 6] = u, this.int16[d + 14] = c, this.uint32[y + 8] = h, this.uint16[d + 18] = p, this.uint16[d + 19] = f, t;
      }

    }

    Ls.prototype.bytesPerElement = 40, ai(Ls, "StructArrayLayout5i4f1i1ul2ui40");

    class Rs extends As {
      _refreshViews() {
        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
      }

      emplaceBack(t, e, r, n, i, s, a) {
        const o = this.length;
        return this.resize(o + 1), this.emplace(o, t, e, r, n, i, s, a);
      }

      emplace(t, e, r, n, i, s, a, o) {
        const l = 8 * t;
        return this.int16[l + 0] = e, this.int16[l + 1] = r, this.int16[l + 2] = n, this.int16[l + 4] = i, this.int16[l + 5] = s, this.int16[l + 6] = a, this.int16[l + 7] = o, t;
      }

    }

    Rs.prototype.bytesPerElement = 16, ai(Rs, "StructArrayLayout3i2i2i16");

    class Us extends As {
      _refreshViews() {
        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
      }

      emplaceBack(t, e, r, n, i) {
        const s = this.length;
        return this.resize(s + 1), this.emplace(s, t, e, r, n, i);
      }

      emplace(t, e, r, n, i, s) {
        const a = 4 * t,
              o = 8 * t;
        return this.float32[a + 0] = e, this.float32[a + 1] = r, this.float32[a + 2] = n, this.int16[o + 6] = i, this.int16[o + 7] = s, t;
      }

    }

    Us.prototype.bytesPerElement = 16, ai(Us, "StructArrayLayout2f1f2i16");

    class $s extends As {
      _refreshViews() {
        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
      }

      emplaceBack(t, e, r, n) {
        const i = this.length;
        return this.resize(i + 1), this.emplace(i, t, e, r, n);
      }

      emplace(t, e, r, n, i) {
        const s = 12 * t,
              a = 3 * t;
        return this.uint8[s + 0] = e, this.uint8[s + 1] = r, this.float32[a + 1] = n, this.float32[a + 2] = i, t;
      }

    }

    $s.prototype.bytesPerElement = 12, ai($s, "StructArrayLayout2ub2f12");

    class js extends As {
      _refreshViews() {
        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
      }

      emplaceBack(t, e, r) {
        const n = this.length;
        return this.resize(n + 1), this.emplace(n, t, e, r);
      }

      emplace(t, e, r, n) {
        const i = 3 * t;
        return this.uint16[i + 0] = e, this.uint16[i + 1] = r, this.uint16[i + 2] = n, t;
      }

    }

    js.prototype.bytesPerElement = 6, ai(js, "StructArrayLayout3ui6");

    class Os extends As {
      _refreshViews() {
        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
      }

      emplaceBack(t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m, g, x, v, b) {
        const _ = this.length;
        return this.resize(_ + 1), this.emplace(_, t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m, g, x, v, b);
      }

      emplace(t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m, g, x, v, b, _) {
        const w = 30 * t,
              A = 15 * t,
              k = 60 * t;
        return this.int16[w + 0] = e, this.int16[w + 1] = r, this.int16[w + 2] = n, this.float32[A + 2] = i, this.float32[A + 3] = s, this.uint16[w + 8] = a, this.uint16[w + 9] = o, this.uint32[A + 5] = l, this.uint32[A + 6] = u, this.uint32[A + 7] = c, this.uint16[w + 16] = h, this.uint16[w + 17] = p, this.uint16[w + 18] = f, this.float32[A + 10] = d, this.float32[A + 11] = y, this.uint8[k + 48] = m, this.uint8[k + 49] = g, this.uint8[k + 50] = x, this.uint32[A + 13] = v, this.int16[w + 28] = b, this.uint8[k + 58] = _, t;
      }

    }

    Os.prototype.bytesPerElement = 60, ai(Os, "StructArrayLayout3i2f2ui3ul3ui2f3ub1ul1i1ub60");

    class qs extends As {
      _refreshViews() {
        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
      }

      emplaceBack(t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m, g, x, v, b, _, w, A, k, S, I, M, T, z) {
        const B = this.length;
        return this.resize(B + 1), this.emplace(B, t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m, g, x, v, b, _, w, A, k, S, I, M, T, z);
      }

      emplace(t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m, g, x, v, b, _, w, A, k, S, I, M, T, z, B) {
        const E = 38 * t,
              C = 19 * t;
        return this.int16[E + 0] = e, this.int16[E + 1] = r, this.int16[E + 2] = n, this.float32[C + 2] = i, this.float32[C + 3] = s, this.int16[E + 8] = a, this.int16[E + 9] = o, this.int16[E + 10] = l, this.int16[E + 11] = u, this.int16[E + 12] = c, this.int16[E + 13] = h, this.uint16[E + 14] = p, this.uint16[E + 15] = f, this.uint16[E + 16] = d, this.uint16[E + 17] = y, this.uint16[E + 18] = m, this.uint16[E + 19] = g, this.uint16[E + 20] = x, this.uint16[E + 21] = v, this.uint16[E + 22] = b, this.uint16[E + 23] = _, this.uint16[E + 24] = w, this.uint16[E + 25] = A, this.uint16[E + 26] = k, this.uint16[E + 27] = S, this.uint16[E + 28] = I, this.uint32[C + 15] = M, this.float32[C + 16] = T, this.float32[C + 17] = z, this.float32[C + 18] = B, t;
      }

    }

    qs.prototype.bytesPerElement = 76, ai(qs, "StructArrayLayout3i2f6i15ui1ul3f76");

    class Ns extends As {
      _refreshViews() {
        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
      }

      emplaceBack(t) {
        const e = this.length;
        return this.resize(e + 1), this.emplace(e, t);
      }

      emplace(t, e) {
        return this.float32[1 * t + 0] = e, t;
      }

    }

    Ns.prototype.bytesPerElement = 4, ai(Ns, "StructArrayLayout1f4");

    class Gs extends As {
      _refreshViews() {
        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
      }

      emplaceBack(t, e, r, n, i, s, a) {
        const o = this.length;
        return this.resize(o + 1), this.emplace(o, t, e, r, n, i, s, a);
      }

      emplace(t, e, r, n, i, s, a, o) {
        const l = 7 * t;
        return this.float32[l + 0] = e, this.float32[l + 1] = r, this.float32[l + 2] = n, this.float32[l + 3] = i, this.float32[l + 4] = s, this.float32[l + 5] = a, this.float32[l + 6] = o, t;
      }

    }

    Gs.prototype.bytesPerElement = 28, ai(Gs, "StructArrayLayout7f28");

    class Zs extends As {
      _refreshViews() {
        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
      }

      emplaceBack(t, e, r, n, i) {
        const s = this.length;
        return this.resize(s + 1), this.emplace(s, t, e, r, n, i);
      }

      emplace(t, e, r, n, i, s) {
        const a = 5 * t;
        return this.float32[a + 0] = e, this.float32[a + 1] = r, this.float32[a + 2] = n, this.float32[a + 3] = i, this.float32[a + 4] = s, t;
      }

    }

    Zs.prototype.bytesPerElement = 20, ai(Zs, "StructArrayLayout5f20");

    class Xs extends As {
      _refreshViews() {
        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
      }

      emplaceBack(t, e, r, n) {
        const i = this.length;
        return this.resize(i + 1), this.emplace(i, t, e, r, n);
      }

      emplace(t, e, r, n, i) {
        const s = 6 * t;
        return this.uint32[3 * t + 0] = e, this.uint16[s + 2] = r, this.uint16[s + 3] = n, this.uint16[s + 4] = i, t;
      }

    }

    Xs.prototype.bytesPerElement = 12, ai(Xs, "StructArrayLayout1ul3ui12");

    class Ks extends As {
      _refreshViews() {
        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
      }

      emplaceBack(t, e) {
        const r = this.length;
        return this.resize(r + 1), this.emplace(r, t, e);
      }

      emplace(t, e, r) {
        const n = 2 * t;
        return this.uint16[n + 0] = e, this.uint16[n + 1] = r, t;
      }

    }

    Ks.prototype.bytesPerElement = 4, ai(Ks, "StructArrayLayout2ui4");

    class Ys extends As {
      _refreshViews() {
        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
      }

      emplaceBack(t) {
        const e = this.length;
        return this.resize(e + 1), this.emplace(e, t);
      }

      emplace(t, e) {
        return this.uint16[1 * t + 0] = e, t;
      }

    }

    Ys.prototype.bytesPerElement = 2, ai(Ys, "StructArrayLayout1ui2");

    class Hs extends As {
      _refreshViews() {
        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
      }

      emplaceBack(t, e) {
        const r = this.length;
        return this.resize(r + 1), this.emplace(r, t, e);
      }

      emplace(t, e, r) {
        const n = 2 * t;
        return this.float32[n + 0] = e, this.float32[n + 1] = r, t;
      }

    }

    Hs.prototype.bytesPerElement = 8, ai(Hs, "StructArrayLayout2f8");

    class Ws extends As {
      _refreshViews() {
        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
      }

      emplaceBack(t, e, r, n, i, s, a) {
        const o = this.length;
        return this.resize(o + 1), this.emplace(o, t, e, r, n, i, s, a);
      }

      emplace(t, e, r, n, i, s, a, o) {
        const l = 8 * t,
              u = 4 * t;
        return this.int16[l + 0] = e, this.int16[l + 1] = r, this.int16[l + 2] = n, this.int16[l + 3] = i, this.int16[l + 4] = s, this.int16[l + 5] = a, this.float32[u + 3] = o, t;
      }

    }

    Ws.prototype.bytesPerElement = 16, ai(Ws, "StructArrayLayout6i1f16");

    class Js extends ws {
      get a_pos_30() {
        return this._structArray.int16[this._pos2 + 0];
      }

      get a_pos_31() {
        return this._structArray.int16[this._pos2 + 1];
      }

      get a_pos_32() {
        return this._structArray.int16[this._pos2 + 2];
      }

      get a_pos_normal_30() {
        return this._structArray.int16[this._pos2 + 3];
      }

      get a_pos_normal_31() {
        return this._structArray.int16[this._pos2 + 4];
      }

      get a_pos_normal_32() {
        return this._structArray.int16[this._pos2 + 5];
      }

    }

    Js.prototype.size = 12;

    class Qs extends Ds {
      get(t) {
        return new Js(this, t);
      }

    }

    ai(Qs, "FillExtrusionExtArray");

    class ta extends ws {
      get projectedAnchorX() {
        return this._structArray.int16[this._pos2 + 0];
      }

      get projectedAnchorY() {
        return this._structArray.int16[this._pos2 + 1];
      }

      get projectedAnchorZ() {
        return this._structArray.int16[this._pos2 + 2];
      }

      get tileAnchorX() {
        return this._structArray.int16[this._pos2 + 3];
      }

      get tileAnchorY() {
        return this._structArray.int16[this._pos2 + 4];
      }

      get x1() {
        return this._structArray.float32[this._pos4 + 3];
      }

      get y1() {
        return this._structArray.float32[this._pos4 + 4];
      }

      get x2() {
        return this._structArray.float32[this._pos4 + 5];
      }

      get y2() {
        return this._structArray.float32[this._pos4 + 6];
      }

      get padding() {
        return this._structArray.int16[this._pos2 + 14];
      }

      get featureIndex() {
        return this._structArray.uint32[this._pos4 + 8];
      }

      get sourceLayerIndex() {
        return this._structArray.uint16[this._pos2 + 18];
      }

      get bucketIndex() {
        return this._structArray.uint16[this._pos2 + 19];
      }

    }

    ta.prototype.size = 40;

    class ea extends Ls {
      get(t) {
        return new ta(this, t);
      }

    }

    ai(ea, "CollisionBoxArray");

    class ra extends ws {
      get projectedAnchorX() {
        return this._structArray.int16[this._pos2 + 0];
      }

      get projectedAnchorY() {
        return this._structArray.int16[this._pos2 + 1];
      }

      get projectedAnchorZ() {
        return this._structArray.int16[this._pos2 + 2];
      }

      get tileAnchorX() {
        return this._structArray.float32[this._pos4 + 2];
      }

      get tileAnchorY() {
        return this._structArray.float32[this._pos4 + 3];
      }

      get glyphStartIndex() {
        return this._structArray.uint16[this._pos2 + 8];
      }

      get numGlyphs() {
        return this._structArray.uint16[this._pos2 + 9];
      }

      get vertexStartIndex() {
        return this._structArray.uint32[this._pos4 + 5];
      }

      get lineStartIndex() {
        return this._structArray.uint32[this._pos4 + 6];
      }

      get lineLength() {
        return this._structArray.uint32[this._pos4 + 7];
      }

      get segment() {
        return this._structArray.uint16[this._pos2 + 16];
      }

      get lowerSize() {
        return this._structArray.uint16[this._pos2 + 17];
      }

      get upperSize() {
        return this._structArray.uint16[this._pos2 + 18];
      }

      get lineOffsetX() {
        return this._structArray.float32[this._pos4 + 10];
      }

      get lineOffsetY() {
        return this._structArray.float32[this._pos4 + 11];
      }

      get writingMode() {
        return this._structArray.uint8[this._pos1 + 48];
      }

      get placedOrientation() {
        return this._structArray.uint8[this._pos1 + 49];
      }

      set placedOrientation(t) {
        this._structArray.uint8[this._pos1 + 49] = t;
      }

      get hidden() {
        return this._structArray.uint8[this._pos1 + 50];
      }

      set hidden(t) {
        this._structArray.uint8[this._pos1 + 50] = t;
      }

      get crossTileID() {
        return this._structArray.uint32[this._pos4 + 13];
      }

      set crossTileID(t) {
        this._structArray.uint32[this._pos4 + 13] = t;
      }

      get associatedIconIndex() {
        return this._structArray.int16[this._pos2 + 28];
      }

      get flipState() {
        return this._structArray.uint8[this._pos1 + 58];
      }

      set flipState(t) {
        this._structArray.uint8[this._pos1 + 58] = t;
      }

    }

    ra.prototype.size = 60;

    class na extends Os {
      get(t) {
        return new ra(this, t);
      }

    }

    ai(na, "PlacedSymbolArray");

    class ia extends ws {
      get projectedAnchorX() {
        return this._structArray.int16[this._pos2 + 0];
      }

      get projectedAnchorY() {
        return this._structArray.int16[this._pos2 + 1];
      }

      get projectedAnchorZ() {
        return this._structArray.int16[this._pos2 + 2];
      }

      get tileAnchorX() {
        return this._structArray.float32[this._pos4 + 2];
      }

      get tileAnchorY() {
        return this._structArray.float32[this._pos4 + 3];
      }

      get rightJustifiedTextSymbolIndex() {
        return this._structArray.int16[this._pos2 + 8];
      }

      get centerJustifiedTextSymbolIndex() {
        return this._structArray.int16[this._pos2 + 9];
      }

      get leftJustifiedTextSymbolIndex() {
        return this._structArray.int16[this._pos2 + 10];
      }

      get verticalPlacedTextSymbolIndex() {
        return this._structArray.int16[this._pos2 + 11];
      }

      get placedIconSymbolIndex() {
        return this._structArray.int16[this._pos2 + 12];
      }

      get verticalPlacedIconSymbolIndex() {
        return this._structArray.int16[this._pos2 + 13];
      }

      get key() {
        return this._structArray.uint16[this._pos2 + 14];
      }

      get textBoxStartIndex() {
        return this._structArray.uint16[this._pos2 + 15];
      }

      get textBoxEndIndex() {
        return this._structArray.uint16[this._pos2 + 16];
      }

      get verticalTextBoxStartIndex() {
        return this._structArray.uint16[this._pos2 + 17];
      }

      get verticalTextBoxEndIndex() {
        return this._structArray.uint16[this._pos2 + 18];
      }

      get iconBoxStartIndex() {
        return this._structArray.uint16[this._pos2 + 19];
      }

      get iconBoxEndIndex() {
        return this._structArray.uint16[this._pos2 + 20];
      }

      get verticalIconBoxStartIndex() {
        return this._structArray.uint16[this._pos2 + 21];
      }

      get verticalIconBoxEndIndex() {
        return this._structArray.uint16[this._pos2 + 22];
      }

      get featureIndex() {
        return this._structArray.uint16[this._pos2 + 23];
      }

      get numHorizontalGlyphVertices() {
        return this._structArray.uint16[this._pos2 + 24];
      }

      get numVerticalGlyphVertices() {
        return this._structArray.uint16[this._pos2 + 25];
      }

      get numIconVertices() {
        return this._structArray.uint16[this._pos2 + 26];
      }

      get numVerticalIconVertices() {
        return this._structArray.uint16[this._pos2 + 27];
      }

      get useRuntimeCollisionCircles() {
        return this._structArray.uint16[this._pos2 + 28];
      }

      get crossTileID() {
        return this._structArray.uint32[this._pos4 + 15];
      }

      set crossTileID(t) {
        this._structArray.uint32[this._pos4 + 15] = t;
      }

      get textOffset0() {
        return this._structArray.float32[this._pos4 + 16];
      }

      get textOffset1() {
        return this._structArray.float32[this._pos4 + 17];
      }

      get collisionCircleDiameter() {
        return this._structArray.float32[this._pos4 + 18];
      }

    }

    ia.prototype.size = 76;

    class sa extends qs {
      get(t) {
        return new ia(this, t);
      }

    }

    ai(sa, "SymbolInstanceArray");

    class aa extends Ns {
      getoffsetX(t) {
        return this.float32[1 * t + 0];
      }

    }

    ai(aa, "GlyphOffsetArray");

    class oa extends Ms {
      getx(t) {
        return this.int16[3 * t + 0];
      }

      gety(t) {
        return this.int16[3 * t + 1];
      }

      gettileUnitDistanceFromAnchor(t) {
        return this.int16[3 * t + 2];
      }

    }

    ai(oa, "SymbolLineVertexArray");

    class la extends ws {
      get featureIndex() {
        return this._structArray.uint32[this._pos4 + 0];
      }

      get sourceLayerIndex() {
        return this._structArray.uint16[this._pos2 + 2];
      }

      get bucketIndex() {
        return this._structArray.uint16[this._pos2 + 3];
      }

      get layoutVertexArrayOffset() {
        return this._structArray.uint16[this._pos2 + 4];
      }

    }

    la.prototype.size = 12;

    class ua extends Xs {
      get(t) {
        return new la(this, t);
      }

    }

    ai(ua, "FeatureIndexArray");

    class ca extends ws {
      get a_centroid_pos0() {
        return this._structArray.uint16[this._pos2 + 0];
      }

      get a_centroid_pos1() {
        return this._structArray.uint16[this._pos2 + 1];
      }

    }

    ca.prototype.size = 4;

    class ha extends Ks {
      get(t) {
        return new ca(this, t);
      }

    }

    ai(ha, "FillExtrusionCentroidArray");

    class pa extends ws {
      get a_pos_30() {
        return this._structArray.int16[this._pos2 + 0];
      }

      get a_pos_31() {
        return this._structArray.int16[this._pos2 + 1];
      }

      get a_pos_32() {
        return this._structArray.int16[this._pos2 + 2];
      }

      get a_pos_normal_30() {
        return this._structArray.int16[this._pos2 + 3];
      }

      get a_pos_normal_31() {
        return this._structArray.int16[this._pos2 + 4];
      }

      get a_pos_normal_32() {
        return this._structArray.int16[this._pos2 + 5];
      }

      get a_scale() {
        return this._structArray.float32[this._pos4 + 3];
      }

    }

    pa.prototype.size = 16;

    class fa extends Ws {
      get(t) {
        return new pa(this, t);
      }

    }

    ai(fa, "CircleGlobeExtArray");
    const da = ks([{
      name: "a_pattern_to",
      components: 4,
      type: "Uint16"
    }, {
      name: "a_pattern_from",
      components: 4,
      type: "Uint16"
    }, {
      name: "a_pixel_ratio_to",
      components: 1,
      type: "Uint16"
    }, {
      name: "a_pixel_ratio_from",
      components: 1,
      type: "Uint16"
    }]),
          ya = ks([{
      name: "a_dash_to",
      components: 4,
      type: "Uint16"
    }, {
      name: "a_dash_from",
      components: 4,
      type: "Uint16"
    }]);
    var ma = le(function (t) {
      t.exports = function (t, e) {
        var r, n, i, s, a, o, l, u;

        for (n = t.length - (r = 3 & t.length), i = e, a = 3432918353, o = 461845907, u = 0; u < n;) l = 255 & t.charCodeAt(u) | (255 & t.charCodeAt(++u)) << 8 | (255 & t.charCodeAt(++u)) << 16 | (255 & t.charCodeAt(++u)) << 24, ++u, i = 27492 + (65535 & (s = 5 * (65535 & (i = (i ^= l = (65535 & (l = (l = (65535 & l) * a + (((l >>> 16) * a & 65535) << 16) & 4294967295) << 15 | l >>> 17)) * o + (((l >>> 16) * o & 65535) << 16) & 4294967295) << 13 | i >>> 19)) + ((5 * (i >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (s >>> 16) & 65535) << 16);

        switch (l = 0, r) {
          case 3:
            l ^= (255 & t.charCodeAt(u + 2)) << 16;

          case 2:
            l ^= (255 & t.charCodeAt(u + 1)) << 8;

          case 1:
            i ^= l = (65535 & (l = (l = (65535 & (l ^= 255 & t.charCodeAt(u))) * a + (((l >>> 16) * a & 65535) << 16) & 4294967295) << 15 | l >>> 17)) * o + (((l >>> 16) * o & 65535) << 16) & 4294967295;
        }

        return i ^= t.length, i = 2246822507 * (65535 & (i ^= i >>> 16)) + ((2246822507 * (i >>> 16) & 65535) << 16) & 4294967295, i = 3266489909 * (65535 & (i ^= i >>> 13)) + ((3266489909 * (i >>> 16) & 65535) << 16) & 4294967295, (i ^= i >>> 16) >>> 0;
      };
    }),
        ga = le(function (t) {
      t.exports = function (t, e) {
        for (var r, n = t.length, i = e ^ n, s = 0; n >= 4;) r = 1540483477 * (65535 & (r = 255 & t.charCodeAt(s) | (255 & t.charCodeAt(++s)) << 8 | (255 & t.charCodeAt(++s)) << 16 | (255 & t.charCodeAt(++s)) << 24)) + ((1540483477 * (r >>> 16) & 65535) << 16), i = 1540483477 * (65535 & i) + ((1540483477 * (i >>> 16) & 65535) << 16) ^ (r = 1540483477 * (65535 & (r ^= r >>> 24)) + ((1540483477 * (r >>> 16) & 65535) << 16)), n -= 4, ++s;

        switch (n) {
          case 3:
            i ^= (255 & t.charCodeAt(s + 2)) << 16;

          case 2:
            i ^= (255 & t.charCodeAt(s + 1)) << 8;

          case 1:
            i = 1540483477 * (65535 & (i ^= 255 & t.charCodeAt(s))) + ((1540483477 * (i >>> 16) & 65535) << 16);
        }

        return i = 1540483477 * (65535 & (i ^= i >>> 13)) + ((1540483477 * (i >>> 16) & 65535) << 16), (i ^= i >>> 15) >>> 0;
      };
    }),
        xa = ma,
        va = ga;
    xa.murmur3 = ma, xa.murmur2 = va;

    class ba {
      constructor() {
        this.ids = [], this.positions = [], this.indexed = !1;
      }

      add(t, e, r, n) {
        this.ids.push(_a(t)), this.positions.push(e, r, n);
      }

      getPositions(t) {
        const e = _a(t);

        let r = 0,
            n = this.ids.length - 1;

        for (; r < n;) {
          const t = r + n >> 1;
          this.ids[t] >= e ? n = t : r = t + 1;
        }

        const i = [];

        for (; this.ids[r] === e;) i.push({
          index: this.positions[3 * r],
          start: this.positions[3 * r + 1],
          end: this.positions[3 * r + 2]
        }), r++;

        return i;
      }

      static serialize(t, e) {
        const r = new Float64Array(t.ids),
              n = new Uint32Array(t.positions);
        return wa(r, n, 0, r.length - 1), e && e.push(r.buffer, n.buffer), {
          ids: r,
          positions: n
        };
      }

      static deserialize(t) {
        const e = new ba();
        return e.ids = t.ids, e.positions = t.positions, e.indexed = !0, e;
      }

    }

    function _a(t) {
      const e = +t;
      return !isNaN(e) && Number.MIN_SAFE_INTEGER <= e && e <= Number.MAX_SAFE_INTEGER ? e : xa(String(t));
    }

    function wa(t, e, r, n) {
      for (; r < n;) {
        const i = t[r + n >> 1];
        let s = r - 1,
            a = n + 1;

        for (;;) {
          do {
            s++;
          } while (t[s] < i);

          do {
            a--;
          } while (t[a] > i);

          if (s >= a) break;
          Aa(t, s, a), Aa(e, 3 * s, 3 * a), Aa(e, 3 * s + 1, 3 * a + 1), Aa(e, 3 * s + 2, 3 * a + 2);
        }

        a - r < n - a ? (wa(t, e, r, a), r = a + 1) : (wa(t, e, a + 1, n), n = a);
      }
    }

    function Aa(t, e, r) {
      const n = t[e];
      t[e] = t[r], t[r] = n;
    }

    ai(ba, "FeaturePositionMap");

    class ka {
      constructor(t, e) {
        this.gl = t.gl, this.location = e;
      }

    }

    class Sa extends ka {
      constructor(t, e) {
        super(t, e), this.current = 0;
      }

      set(t) {
        this.current !== t && (this.current = t, this.gl.uniform1f(this.location, t));
      }

    }

    class Ia extends ka {
      constructor(t, e) {
        super(t, e), this.current = [0, 0, 0, 0];
      }

      set(t) {
        t[0] === this.current[0] && t[1] === this.current[1] && t[2] === this.current[2] && t[3] === this.current[3] || (this.current = t, this.gl.uniform4f(this.location, t[0], t[1], t[2], t[3]));
      }

    }

    class Ma extends ka {
      constructor(t, e) {
        super(t, e), this.current = ce.transparent;
      }

      set(t) {
        t.r === this.current.r && t.g === this.current.g && t.b === this.current.b && t.a === this.current.a || (this.current = t, this.gl.uniform4f(this.location, t.r, t.g, t.b, t.a));
      }

    }

    const Ta = new Float32Array(16),
          za = new Float32Array(9),
          Ba = new Float32Array(4);

    function Ea(t) {
      return [bs(255 * t.r, 255 * t.g), bs(255 * t.b, 255 * t.a)];
    }

    class Ca {
      constructor(t, e, r) {
        this.value = t, this.uniformNames = e.map(t => `u_${t}`), this.type = r;
      }

      setUniform(t, e, r) {
        t.set(r.constantOr(this.value));
      }

      getBinding(t, e, r) {
        return "color" === this.type ? new Ma(t, e) : new Sa(t, e);
      }

    }

    class Da {
      constructor(t, e) {
        this.uniformNames = e.map(t => `u_${t}`), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
      }

      setConstantPatternPositions(t, e) {
        this.pixelRatioFrom = e.pixelRatio || 1, this.pixelRatioTo = t.pixelRatio || 1, this.patternFrom = e.tl.concat(e.br), this.patternTo = t.tl.concat(t.br);
      }

      setUniform(t, e, r, n) {
        const i = "u_pattern_to" === n || "u_dash_to" === n ? this.patternTo : "u_pattern_from" === n || "u_dash_from" === n ? this.patternFrom : "u_pixel_ratio_to" === n ? this.pixelRatioTo : "u_pixel_ratio_from" === n ? this.pixelRatioFrom : null;
        i && t.set(i);
      }

      getBinding(t, e, r) {
        return "u_pattern_from" === r || "u_pattern_to" === r || "u_dash_from" === r || "u_dash_to" === r ? new Ia(t, e) : new Sa(t, e);
      }

    }

    class Pa {
      constructor(t, e, r, n) {
        this.expression = t, this.type = r, this.maxValue = 0, this.paintVertexAttributes = e.map(t => ({
          name: `a_${t}`,
          type: "Float32",
          components: "color" === r ? 2 : 1,
          offset: 0
        })), this.paintVertexArray = new n();
      }

      populatePaintArray(t, e, r, n, i, s) {
        const a = this.paintVertexArray.length,
              o = this.expression.evaluate(new ss(0), e, {}, i, n, s);
        this.paintVertexArray.resize(t), this._setPaintValue(a, t, o);
      }

      updatePaintArray(t, e, r, n, i) {
        const s = this.expression.evaluate({
          zoom: 0
        }, r, n, void 0, i);

        this._setPaintValue(t, e, s);
      }

      _setPaintValue(t, e, r) {
        if ("color" === this.type) {
          const n = Ea(r);

          for (let r = t; r < e; r++) this.paintVertexArray.emplace(r, n[0], n[1]);
        } else {
          for (let n = t; n < e; n++) this.paintVertexArray.emplace(n, r);

          this.maxValue = Math.max(this.maxValue, Math.abs(r));
        }
      }

      upload(t) {
        this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
      }

      destroy() {
        this.paintVertexBuffer && this.paintVertexBuffer.destroy();
      }

    }

    class Va {
      constructor(t, e, r, n, i, s) {
        this.expression = t, this.uniformNames = e.map(t => `u_${t}_t`), this.type = r, this.useIntegerZoom = n, this.zoom = i, this.maxValue = 0, this.paintVertexAttributes = e.map(t => ({
          name: `a_${t}`,
          type: "Float32",
          components: "color" === r ? 4 : 2,
          offset: 0
        })), this.paintVertexArray = new s();
      }

      populatePaintArray(t, e, r, n, i, s) {
        const a = this.expression.evaluate(new ss(this.zoom), e, {}, i, n, s),
              o = this.expression.evaluate(new ss(this.zoom + 1), e, {}, i, n, s),
              l = this.paintVertexArray.length;
        this.paintVertexArray.resize(t), this._setPaintValue(l, t, a, o);
      }

      updatePaintArray(t, e, r, n, i) {
        const s = this.expression.evaluate({
          zoom: this.zoom
        }, r, n, void 0, i),
              a = this.expression.evaluate({
          zoom: this.zoom + 1
        }, r, n, void 0, i);

        this._setPaintValue(t, e, s, a);
      }

      _setPaintValue(t, e, r, n) {
        if ("color" === this.type) {
          const i = Ea(r),
                s = Ea(n);

          for (let r = t; r < e; r++) this.paintVertexArray.emplace(r, i[0], i[1], s[0], s[1]);
        } else {
          for (let i = t; i < e; i++) this.paintVertexArray.emplace(i, r, n);

          this.maxValue = Math.max(this.maxValue, Math.abs(r), Math.abs(n));
        }
      }

      upload(t) {
        this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
      }

      destroy() {
        this.paintVertexBuffer && this.paintVertexBuffer.destroy();
      }

      setUniform(t, e) {
        const r = this.useIntegerZoom ? Math.floor(e.zoom) : e.zoom,
              n = y(this.expression.interpolationFactor(r, this.zoom, this.zoom + 1), 0, 1);
        t.set(n);
      }

      getBinding(t, e, r) {
        return new Sa(t, e);
      }

    }

    class Fa {
      constructor(t, e, r, n, i, s, a) {
        this.expression = t, this.type = r, this.useIntegerZoom = n, this.zoom = i, this.layerId = a, this.paintVertexAttributes = ("array" === r ? ya : da).members;

        for (let t = 0; t < e.length; ++t);

        this.zoomInPaintVertexArray = new s(), this.zoomOutPaintVertexArray = new s();
      }

      populatePaintArray(t, e, r) {
        const n = this.zoomInPaintVertexArray.length;
        this.zoomInPaintVertexArray.resize(t), this.zoomOutPaintVertexArray.resize(t), this._setPaintValues(n, t, e.patterns && e.patterns[this.layerId], r);
      }

      updatePaintArray(t, e, r, n, i, s) {
        this._setPaintValues(t, e, r.patterns && r.patterns[this.layerId], s);
      }

      _setPaintValues(t, e, r, n) {
        if (!n || !r) return;
        const {
          min: i,
          mid: s,
          max: a
        } = r,
              o = n[i],
              l = n[s],
              u = n[a];
        if (o && l && u) for (let r = t; r < e; r++) this._setPaintValue(this.zoomInPaintVertexArray, r, l, o), this._setPaintValue(this.zoomOutPaintVertexArray, r, l, u);
      }

      _setPaintValue(t, e, r, n) {
        t.emplace(e, r.tl[0], r.tl[1], r.br[0], r.br[1], n.tl[0], n.tl[1], n.br[0], n.br[1], r.pixelRatio, n.pixelRatio);
      }

      upload(t) {
        this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = t.createVertexBuffer(this.zoomInPaintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t.createVertexBuffer(this.zoomOutPaintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
      }

      destroy() {
        this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
      }

    }

    class La {
      constructor(t, e, r = () => !0) {
        this.binders = {}, this._buffers = [];
        const n = [];

        for (const i in t.paint._values) {
          if (!r(i)) continue;
          const s = t.paint.get(i);
          if (!(s instanceof ps && Yr(s.property.specification))) continue;
          const a = $a(i, t.type),
                o = s.value,
                l = s.property.specification.type,
                u = s.property.useIntegerZoom,
                c = s.property.specification["property-type"],
                h = "cross-faded" === c || "cross-faded-data-driven" === c,
                p = "line-dasharray" === String(i) && "constant" !== t.layout.get("line-cap").value.kind;
          if ("constant" !== o.kind || p) {
            if ("source" === o.kind || p || h) {
              const r = qa(i, l, "source");
              this.binders[i] = h ? new Fa(o, a, l, u, e, r, t.id) : new Pa(o, a, l, r), n.push(`/a_${i}`);
            } else {
              const t = qa(i, l, "composite");
              this.binders[i] = new Va(o, a, l, u, e, t), n.push(`/z_${i}`);
            }
          } else this.binders[i] = h ? new Da(o.value, a) : new Ca(o.value, a, l), n.push(`/u_${i}`);
        }

        this.cacheKey = n.sort().join("");
      }

      getMaxValue(t) {
        const e = this.binders[t];
        return e instanceof Pa || e instanceof Va ? e.maxValue : 0;
      }

      populatePaintArrays(t, e, r, n, i, s) {
        for (const a in this.binders) {
          const o = this.binders[a];
          (o instanceof Pa || o instanceof Va || o instanceof Fa) && o.populatePaintArray(t, e, r, n, i, s);
        }
      }

      setConstantPatternPositions(t, e) {
        for (const r in this.binders) {
          const n = this.binders[r];
          n instanceof Da && n.setConstantPatternPositions(t, e);
        }
      }

      updatePaintArrays(t, e, r, n, i, s) {
        let a = !1;

        for (const o in t) {
          const l = e.getPositions(o);

          for (const e of l) {
            const l = r.feature(e.index);

            for (const r in this.binders) {
              const u = this.binders[r];

              if ((u instanceof Pa || u instanceof Va || u instanceof Fa) && !0 === u.expression.isStateDependent) {
                const c = n.paint.get(r);
                u.expression = c.value, u.updatePaintArray(e.start, e.end, l, t[o], i, s), a = !0;
              }
            }
          }
        }

        return a;
      }

      defines() {
        const t = [];

        for (const e in this.binders) {
          const r = this.binders[e];
          (r instanceof Ca || r instanceof Da) && t.push(...r.uniformNames.map(t => `#define HAS_UNIFORM_${t}`));
        }

        return t;
      }

      getBinderAttributes() {
        const t = [];

        for (const e in this.binders) {
          const r = this.binders[e];
          if (r instanceof Pa || r instanceof Va || r instanceof Fa) for (let e = 0; e < r.paintVertexAttributes.length; e++) t.push(r.paintVertexAttributes[e].name);
        }

        return t;
      }

      getBinderUniforms() {
        const t = [];

        for (const e in this.binders) {
          const r = this.binders[e];
          if (r instanceof Ca || r instanceof Da || r instanceof Va) for (const e of r.uniformNames) t.push(e);
        }

        return t;
      }

      getPaintVertexBuffers() {
        return this._buffers;
      }

      getUniforms(t, e) {
        const r = [];

        for (const n in this.binders) {
          const i = this.binders[n];
          if (i instanceof Ca || i instanceof Da || i instanceof Va) for (const s of i.uniformNames) if (e[s]) {
            const a = i.getBinding(t, e[s], s);
            r.push({
              name: s,
              property: n,
              binding: a
            });
          }
        }

        return r;
      }

      setUniforms(t, e, r, n) {
        for (const {
          name: t,
          property: i,
          binding: s
        } of e) this.binders[i].setUniform(s, n, r.get(i), t);
      }

      updatePaintBuffers(t) {
        this._buffers = [];

        for (const e in this.binders) {
          const r = this.binders[e];

          if (t && r instanceof Fa) {
            const e = 2 === t.fromScale ? r.zoomInPaintVertexBuffer : r.zoomOutPaintVertexBuffer;
            e && this._buffers.push(e);
          } else (r instanceof Pa || r instanceof Va) && r.paintVertexBuffer && this._buffers.push(r.paintVertexBuffer);
        }
      }

      upload(t) {
        for (const e in this.binders) {
          const r = this.binders[e];
          (r instanceof Pa || r instanceof Va || r instanceof Fa) && r.upload(t);
        }

        this.updatePaintBuffers();
      }

      destroy() {
        for (const t in this.binders) {
          const e = this.binders[t];
          (e instanceof Pa || e instanceof Va || e instanceof Fa) && e.destroy();
        }
      }

    }

    class Ra {
      constructor(t, e, r = () => !0) {
        this.programConfigurations = {};

        for (const n of t) this.programConfigurations[n.id] = new La(n, e, r);

        this.needsUpload = !1, this._featureMap = new ba(), this._bufferOffset = 0;
      }

      populatePaintArrays(t, e, r, n, i, s, a) {
        for (const r in this.programConfigurations) this.programConfigurations[r].populatePaintArrays(t, e, n, i, s, a);

        void 0 !== e.id && this._featureMap.add(e.id, r, this._bufferOffset, t), this._bufferOffset = t, this.needsUpload = !0;
      }

      updatePaintArrays(t, e, r, n, i) {
        for (const s of r) this.needsUpload = this.programConfigurations[s.id].updatePaintArrays(t, this._featureMap, e, s, n, i) || this.needsUpload;
      }

      get(t) {
        return this.programConfigurations[t];
      }

      upload(t) {
        if (this.needsUpload) {
          for (const e in this.programConfigurations) this.programConfigurations[e].upload(t);

          this.needsUpload = !1;
        }
      }

      destroy() {
        for (const t in this.programConfigurations) this.programConfigurations[t].destroy();
      }

    }

    const Ua = {
      "text-opacity": ["opacity"],
      "icon-opacity": ["opacity"],
      "text-color": ["fill_color"],
      "icon-color": ["fill_color"],
      "text-halo-color": ["halo_color"],
      "icon-halo-color": ["halo_color"],
      "text-halo-blur": ["halo_blur"],
      "icon-halo-blur": ["halo_blur"],
      "text-halo-width": ["halo_width"],
      "icon-halo-width": ["halo_width"],
      "line-gap-width": ["gapwidth"],
      "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"],
      "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"],
      "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"],
      "line-dasharray": ["dash_to", "dash_from"]
    };

    function $a(t, e) {
      return Ua[t] || [t.replace(`${e}-`, "").replace(/-/g, "_")];
    }

    const ja = {
      "line-pattern": {
        source: Es,
        composite: Es
      },
      "fill-pattern": {
        source: Es,
        composite: Es
      },
      "fill-extrusion-pattern": {
        source: Es,
        composite: Es
      },
      "line-dasharray": {
        source: Cs,
        composite: Cs
      }
    },
          Oa = {
      color: {
        source: Hs,
        composite: Bs
      },
      number: {
        source: Ns,
        composite: Hs
      }
    };

    function qa(t, e, r) {
      const n = ja[t];
      return n && n[r] || Oa[e][r];
    }

    ai(Ca, "ConstantBinder"), ai(Da, "CrossFadedConstantBinder"), ai(Pa, "SourceExpressionBinder"), ai(Fa, "CrossFadedCompositeBinder"), ai(Va, "CompositeExpressionBinder"), ai(La, "ProgramConfiguration", {
      omit: ["_buffers"]
    }), ai(Ra, "ProgramConfigurationSet");
    const Na = "-transition";

    class Ga extends Ut {
      constructor(t, e) {
        if (super(), this.id = t.id, this.type = t.type, this._featureFilter = {
          filter: () => !0,
          needGeometry: !1,
          needFeature: !1
        }, this._filterCompiled = !1, "custom" !== t.type && (this.metadata = (t = t).metadata, this.minzoom = t.minzoom, this.maxzoom = t.maxzoom, "background" !== t.type && "sky" !== t.type && (this.source = t.source, this.sourceLayer = t["source-layer"], this.filter = t.filter), e.layout && (this._unevaluatedLayout = new hs(e.layout)), e.paint)) {
          this._transitionablePaint = new ls(e.paint);

          for (const e in t.paint) this.setPaintProperty(e, t.paint[e], {
            validate: !1
          });

          for (const e in t.layout) this.setLayoutProperty(e, t.layout[e], {
            validate: !1
          });

          this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new fs(e.paint);
        }
      }

      getCrossfadeParameters() {
        return this._crossfadeParameters;
      }

      getLayoutProperty(t) {
        return "visibility" === t ? this.visibility : this._unevaluatedLayout.getValue(t);
      }

      setLayoutProperty(t, e, r = {}) {
        null != e && this._validate(ti, `layers.${this.id}.layout.${t}`, t, e, r) || ("visibility" !== t ? this._unevaluatedLayout.setValue(t, e) : this.visibility = e);
      }

      getPaintProperty(t) {
        return M(t, Na) ? this._transitionablePaint.getTransition(t.slice(0, -Na.length)) : this._transitionablePaint.getValue(t);
      }

      setPaintProperty(t, e, r = {}) {
        if (null != e && this._validate(Qn, `layers.${this.id}.paint.${t}`, t, e, r)) return !1;
        if (M(t, Na)) return this._transitionablePaint.setTransition(t.slice(0, -Na.length), e || void 0), !1;
        {
          const r = this._transitionablePaint._values[t],
                n = "cross-faded-data-driven" === r.property.specification["property-type"],
                i = r.value.isDataDriven(),
                s = r.value;
          this._transitionablePaint.setValue(t, e), this._handleSpecialPaintPropertyUpdate(t);
          const a = this._transitionablePaint._values[t].value;
          return a.isDataDriven() || i || n || this._handleOverridablePaintPropertyUpdate(t, s, a);
        }
      }

      _handleSpecialPaintPropertyUpdate(t) {}

      getProgramIds() {
        return null;
      }

      getProgramConfiguration(t) {
        return null;
      }

      _handleOverridablePaintPropertyUpdate(t, e, r) {
        return !1;
      }

      isHidden(t) {
        return !!(this.minzoom && t < this.minzoom) || !!(this.maxzoom && t >= this.maxzoom) || "none" === this.visibility;
      }

      updateTransitions(t) {
        this._transitioningPaint = this._transitionablePaint.transitioned(t, this._transitioningPaint);
      }

      hasTransition() {
        return this._transitioningPaint.hasTransition();
      }

      recalculate(t, e) {
        t.getCrossfadeParameters && (this._crossfadeParameters = t.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t, void 0, e)), this.paint = this._transitioningPaint.possiblyEvaluate(t, void 0, e);
      }

      serialize() {
        const t = {
          id: this.id,
          type: this.type,
          source: this.source,
          "source-layer": this.sourceLayer,
          metadata: this.metadata,
          minzoom: this.minzoom,
          maxzoom: this.maxzoom,
          filter: this.filter,
          layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(),
          paint: this._transitionablePaint && this._transitionablePaint.serialize()
        };
        return this.visibility && (t.layout = t.layout || {}, t.layout.visibility = this.visibility), z(t, (t, e) => !(void 0 === t || "layout" === e && !Object.keys(t).length || "paint" === e && !Object.keys(t).length));
      }

      _validate(t, e, r, n, i = {}) {
        return (!i || !1 !== i.validate) && ri(this, t.call(Jn, {
          key: e,
          layerType: this.type,
          objectKey: r,
          value: n,
          styleSpec: $t,
          style: {
            glyphs: !0,
            sprite: !0
          }
        }));
      }

      is3D() {
        return !1;
      }

      isSky() {
        return !1;
      }

      isTileClipped() {
        return !1;
      }

      hasOffscreenPass() {
        return !1;
      }

      resize() {}

      isStateDependent() {
        for (const t in this.paint._values) {
          const e = this.paint.get(t);
          if (e instanceof ps && Yr(e.property.specification) && ("source" === e.value.kind || "composite" === e.value.kind) && e.value.isStateDependent) return !0;
        }

        return !1;
      }

      compileFilter() {
        this._filterCompiled || (this._featureFilter = Sn(this.filter), this._filterCompiled = !0);
      }

      invalidateCompiledFilter() {
        this._filterCompiled = !1;
      }

      dynamicFilter() {
        return this._featureFilter.dynamicFilter;
      }

      dynamicFilterNeedsFeature() {
        return this._featureFilter.needFeature;
      }

    }

    const Za = ks([{
      name: "a_pos",
      components: 2,
      type: "Int16"
    }], 4),
          Xa = ks([{
      name: "a_pos_3",
      components: 3,
      type: "Int16"
    }, {
      name: "a_pos_normal_3",
      components: 3,
      type: "Int16"
    }, {
      name: "a_scale",
      components: 1,
      type: "Float32"
    }]);

    class Ka {
      constructor(t = []) {
        this.segments = t;
      }

      prepareSegment(t, e, r, n) {
        let i = this.segments[this.segments.length - 1];
        return t > Ka.MAX_VERTEX_ARRAY_LENGTH && C(`Max vertices per segment is ${Ka.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t}`), (!i || i.vertexLength + t > Ka.MAX_VERTEX_ARRAY_LENGTH || i.sortKey !== n) && (i = {
          vertexOffset: e.length,
          primitiveOffset: r.length,
          vertexLength: 0,
          primitiveLength: 0
        }, void 0 !== n && (i.sortKey = n), this.segments.push(i)), i;
      }

      get() {
        return this.segments;
      }

      destroy() {
        for (const t of this.segments) for (const e in t.vaos) t.vaos[e].destroy();
      }

      static simpleSegment(t, e, r, n) {
        return new Ka([{
          vertexOffset: t,
          primitiveOffset: e,
          vertexLength: r,
          primitiveLength: n,
          vaos: {},
          sortKey: 0
        }]);
      }

    }

    Ka.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, ai(Ka, "SegmentVector");
    var Ya = 8192;

    class Ha {
      constructor(t, e) {
        t && (e ? this.setSouthWest(t).setNorthEast(e) : 4 === t.length ? this.setSouthWest([t[0], t[1]]).setNorthEast([t[2], t[3]]) : this.setSouthWest(t[0]).setNorthEast(t[1]));
      }

      setNorthEast(t) {
        return this._ne = t instanceof Ja ? new Ja(t.lng, t.lat) : Ja.convert(t), this;
      }

      setSouthWest(t) {
        return this._sw = t instanceof Ja ? new Ja(t.lng, t.lat) : Ja.convert(t), this;
      }

      extend(t) {
        const e = this._sw,
              r = this._ne;
        let n, i;
        if (t instanceof Ja) n = t, i = t;else {
          if (!(t instanceof Ha)) return Array.isArray(t) ? 4 === t.length || t.every(Array.isArray) ? this.extend(Ha.convert(t)) : this.extend(Ja.convert(t)) : this;
          if (n = t._sw, i = t._ne, !n || !i) return this;
        }
        return e || r ? (e.lng = Math.min(n.lng, e.lng), e.lat = Math.min(n.lat, e.lat), r.lng = Math.max(i.lng, r.lng), r.lat = Math.max(i.lat, r.lat)) : (this._sw = new Ja(n.lng, n.lat), this._ne = new Ja(i.lng, i.lat)), this;
      }

      getCenter() {
        return new Ja((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
      }

      getSouthWest() {
        return this._sw;
      }

      getNorthEast() {
        return this._ne;
      }

      getNorthWest() {
        return new Ja(this.getWest(), this.getNorth());
      }

      getSouthEast() {
        return new Ja(this.getEast(), this.getSouth());
      }

      getWest() {
        return this._sw.lng;
      }

      getSouth() {
        return this._sw.lat;
      }

      getEast() {
        return this._ne.lng;
      }

      getNorth() {
        return this._ne.lat;
      }

      toArray() {
        return [this._sw.toArray(), this._ne.toArray()];
      }

      toString() {
        return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
      }

      isEmpty() {
        return !(this._sw && this._ne);
      }

      contains(t) {
        const {
          lng: e,
          lat: r
        } = Ja.convert(t);
        let n = this._sw.lng <= e && e <= this._ne.lng;
        return this._sw.lng > this._ne.lng && (n = this._sw.lng >= e && e >= this._ne.lng), this._sw.lat <= r && r <= this._ne.lat && n;
      }

      static convert(t) {
        return !t || t instanceof Ha ? t : new Ha(t);
      }

    }

    const Wa = 6371008.8;

    class Ja {
      constructor(t, e) {
        if (isNaN(t) || isNaN(e)) throw new Error(`Invalid LngLat object: (${t}, ${e})`);
        if (this.lng = +t, this.lat = +e, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
      }

      wrap() {
        return new Ja(g(this.lng, -180, 180), this.lat);
      }

      toArray() {
        return [this.lng, this.lat];
      }

      toString() {
        return `LngLat(${this.lng}, ${this.lat})`;
      }

      distanceTo(t) {
        const e = Math.PI / 180,
              r = this.lat * e,
              n = t.lat * e,
              i = Math.sin(r) * Math.sin(n) + Math.cos(r) * Math.cos(n) * Math.cos((t.lng - this.lng) * e);
        return Wa * Math.acos(Math.min(i, 1));
      }

      toBounds(t = 0) {
        const e = 360 * t / 40075017,
              r = e / Math.cos(Math.PI / 180 * this.lat);
        return new Ha(new Ja(this.lng - r, this.lat - e), new Ja(this.lng + r, this.lat + e));
      }

      static convert(t) {
        if (t instanceof Ja) return t;
        if (Array.isArray(t) && (2 === t.length || 3 === t.length)) return new Ja(Number(t[0]), Number(t[1]));
        if (!Array.isArray(t) && "object" == typeof t && null !== t) return new Ja(Number("lng" in t ? t.lng : t.lon), Number(t.lat));
        throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
      }

    }

    const Qa = 2 * Math.PI * Wa;

    function to(t) {
      return Qa * Math.cos(t * Math.PI / 180);
    }

    function eo(t) {
      return (180 + t) / 360;
    }

    function ro(t) {
      return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t * Math.PI / 360))) / 360;
    }

    function no(t, e) {
      return t / to(e);
    }

    function io(t) {
      return 360 * t - 180;
    }

    function so(t) {
      return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t) * Math.PI / 180)) - 90;
    }

    function ao(t, e) {
      return t * to(so(e));
    }

    const oo = 85.051129;

    class lo {
      constructor(t, e, r = 0) {
        this.x = +t, this.y = +e, this.z = +r;
      }

      static fromLngLat(t, e = 0) {
        const r = Ja.convert(t);
        return new lo(eo(r.lng), ro(r.lat), no(e, r.lat));
      }

      toLngLat() {
        return new Ja(io(this.x), so(this.y));
      }

      toAltitude() {
        return ao(this.z, this.y);
      }

      meterInMercatorCoordinateUnits() {
        return 1 / Qa * (t = so(this.y), 1 / Math.cos(t * Math.PI / 180));
        var t;
      }

    }

    function uo(t, e, r, n, s, a, o, l, u) {
      const c = (e + n) / 2,
            h = (r + s) / 2,
            p = new i(c, h);
      l(p), function (t, e, r, n, i, s) {
        const a = r - i,
              o = n - s;
        return Math.abs((n - e) * a - (r - t) * o) / Math.hypot(a, o);
      }(p.x, p.y, a.x, a.y, o.x, o.y) >= u ? (uo(t, e, r, c, h, a, p, l, u), uo(t, c, h, n, s, p, o, l, u)) : t.push(o);
    }

    function co(t, e, r) {
      let n = t[0],
          i = n.x,
          s = n.y;
      e(n);
      const a = [n];

      for (let o = 1; o < t.length; o++) {
        const l = t[o],
              {
          x: u,
          y: c
        } = l;
        e(l), uo(a, i, s, u, c, n, l, e, r), i = u, s = c, n = l;
      }

      return a;
    }

    const ho = Math.pow(2, 14) - 1,
          po = -ho - 1;

    function fo(t, e) {
      const r = Math.round(t.x * e),
            n = Math.round(t.y * e);
      return t.x = y(r, po, ho), t.y = y(n, po, ho), (r < t.x || r > t.x + 1 || n < t.y || n > t.y + 1) && C("Geometry exceeds allowed extent, reduce your vector tile buffer size"), t;
    }

    function yo(t, e, r) {
      const n = t.loadGeometry(),
            i = t.extent,
            s = Ya / i;

      if (e && r && r.projection.isReprojectedInTileSpace) {
        const s = 1 << e.z,
              {
          scale: a,
          x: o,
          y: l,
          projection: u
        } = r,
              c = t => {
          const r = io((e.x + t.x / i) / s),
                n = so((e.y + t.y / i) / s),
                c = u.project(r, n);
          t.x = (c.x * a - o) * i, t.y = (c.y * a - l) * i;
        };

        for (let e = 0; e < n.length; e++) if (1 !== t.type) n[e] = co(n[e], c, 1);else {
          const t = [];

          for (const r of n[e]) r.x < 0 || r.x >= i || r.y < 0 || r.y >= i || (c(r), t.push(r));

          n[e] = t;
        }
      }

      for (const t of n) for (const e of t) fo(e, s);

      return n;
    }

    function mo(t, e) {
      return {
        type: t.type,
        id: t.id,
        properties: t.properties,
        geometry: e ? yo(t) : []
      };
    }

    function go(t, e, r, n, i) {
      t.emplaceBack(2 * e + (n + 1) / 2, 2 * r + (i + 1) / 2);
    }

    function xo(t, e, r, n) {
      const i = 16384;
      t.emplaceBack(e.x, e.y, e.z, r[0] * i, r[1] * i, r[2] * i, n);
    }

    class vo {
      constructor(t) {
        this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(t => t.id), this.index = t.index, this.hasPattern = !1, this.projection = t.projection, this.layoutVertexArray = new Is(), this.indexArray = new js(), this.segments = new Ka(), this.programConfigurations = new Ra(t.layers, t.zoom), this.stateDependentLayerIds = this.layers.filter(t => t.isStateDependent()).map(t => t.id);
      }

      populate(t, e, r, n) {
        const i = this.layers[0],
              s = [];
        let a = null;
        "circle" === i.type && (a = i.layout.get("circle-sort-key"));

        for (const {
          feature: e,
          id: i,
          index: o,
          sourceLayerIndex: l
        } of t) {
          const t = this.layers[0]._featureFilter.needGeometry,
                u = mo(e, t);
          if (!this.layers[0]._featureFilter.filter(new ss(this.zoom), u, r)) continue;
          const c = a ? a.evaluate(u, {}, r) : void 0,
                h = {
            id: i,
            properties: e.properties,
            type: e.type,
            sourceLayerIndex: l,
            index: o,
            geometry: t ? u.geometry : yo(e, r, n),
            patterns: {},
            sortKey: c
          };
          s.push(h);
        }

        a && s.sort((t, e) => t.sortKey - e.sortKey);
        let o = null;
        "globe" === n.projection.name && (this.globeExtVertexArray = new fa(), o = n.projection);

        for (const n of s) {
          const {
            geometry: i,
            index: s,
            sourceLayerIndex: a
          } = n,
                l = t[s].feature;
          this.addFeature(n, i, s, e.availableImages, r, o), e.featureIndex.insert(l, i, s, a, this.index);
        }
      }

      update(t, e, r, n) {
        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, r, n);
      }

      isEmpty() {
        return 0 === this.layoutVertexArray.length;
      }

      uploadPending() {
        return !this.uploaded || this.programConfigurations.needsUpload;
      }

      upload(t) {
        this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Za.members), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.globeExtVertexArray && (this.globeExtVertexBuffer = t.createVertexBuffer(this.globeExtVertexArray, Xa.members))), this.programConfigurations.upload(t), this.uploaded = !0;
      }

      destroy() {
        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy());
      }

      addFeature(t, e, r, n, i, s) {
        for (const r of e) for (const e of r) {
          const r = e.x,
                n = e.y;
          if (r < 0 || r >= Ya || n < 0 || n >= Ya) continue;

          if (s) {
            const t = s.projectTilePoint(r, n, i),
                  e = s.upVector(i, r, n),
                  a = so((n / Ya + i.y) / (1 << i.z)),
                  o = s.pixelsPerMeter(a, 1) / no(1, a),
                  l = this.globeExtVertexArray;
            xo(l, t, e, o), xo(l, t, e, o), xo(l, t, e, o), xo(l, t, e, o);
          }

          const a = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t.sortKey),
                o = a.vertexLength;
          go(this.layoutVertexArray, r, n, -1, -1), go(this.layoutVertexArray, r, n, 1, -1), go(this.layoutVertexArray, r, n, 1, 1), go(this.layoutVertexArray, r, n, -1, 1), this.indexArray.emplaceBack(o, o + 1, o + 2), this.indexArray.emplaceBack(o, o + 3, o + 2), a.vertexLength += 4, a.primitiveLength += 2;
        }

        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, {}, n, i);
      }

    }

    function bo(t, e) {
      for (let r = 0; r < t.length; r++) if (zo(e, t[r])) return !0;

      for (let r = 0; r < e.length; r++) if (zo(t, e[r])) return !0;

      return !!ko(t, e);
    }

    function _o(t, e, r) {
      return !!zo(t, e) || !!Io(e, t, r);
    }

    function wo(t, e) {
      if (1 === t.length) return To(e, t[0]);

      for (let r = 0; r < e.length; r++) {
        const n = e[r];

        for (let e = 0; e < n.length; e++) if (zo(t, n[e])) return !0;
      }

      for (let r = 0; r < t.length; r++) if (To(e, t[r])) return !0;

      for (let r = 0; r < e.length; r++) if (ko(t, e[r])) return !0;

      return !1;
    }

    function Ao(t, e, r) {
      if (t.length > 1) {
        if (ko(t, e)) return !0;

        for (let n = 0; n < e.length; n++) if (Io(e[n], t, r)) return !0;
      }

      for (let n = 0; n < t.length; n++) if (Io(t[n], e, r)) return !0;

      return !1;
    }

    function ko(t, e) {
      if (0 === t.length || 0 === e.length) return !1;

      for (let r = 0; r < t.length - 1; r++) {
        const n = t[r],
              i = t[r + 1];

        for (let t = 0; t < e.length - 1; t++) if (So(n, i, e[t], e[t + 1])) return !0;
      }

      return !1;
    }

    function So(t, e, r, n) {
      return D(t, r, n) !== D(e, r, n) && D(t, e, r) !== D(t, e, n);
    }

    function Io(t, e, r) {
      const n = r * r;
      if (1 === e.length) return t.distSqr(e[0]) < n;

      for (let r = 1; r < e.length; r++) if (Mo(t, e[r - 1], e[r]) < n) return !0;

      return !1;
    }

    function Mo(t, e, r) {
      const n = e.distSqr(r);
      if (0 === n) return t.distSqr(e);
      const i = ((t.x - e.x) * (r.x - e.x) + (t.y - e.y) * (r.y - e.y)) / n;
      return t.distSqr(i < 0 ? e : i > 1 ? r : r.sub(e)._mult(i)._add(e));
    }

    function To(t, e) {
      let r,
          n,
          i,
          s = !1;

      for (let a = 0; a < t.length; a++) {
        r = t[a];

        for (let t = 0, a = r.length - 1; t < r.length; a = t++) n = r[t], i = r[a], n.y > e.y != i.y > e.y && e.x < (i.x - n.x) * (e.y - n.y) / (i.y - n.y) + n.x && (s = !s);
      }

      return s;
    }

    function zo(t, e) {
      let r = !1;

      for (let n = 0, i = t.length - 1; n < t.length; i = n++) {
        const s = t[n],
              a = t[i];
        s.y > e.y != a.y > e.y && e.x < (a.x - s.x) * (e.y - s.y) / (a.y - s.y) + s.x && (r = !r);
      }

      return r;
    }

    function Bo(t, e, r, n, s) {
      for (const i of t) if (e <= i.x && r <= i.y && n >= i.x && s >= i.y) return !0;

      const a = [new i(e, r), new i(e, s), new i(n, s), new i(n, r)];
      if (t.length > 2) for (const e of a) if (zo(t, e)) return !0;

      for (let e = 0; e < t.length - 1; e++) if (Eo(t[e], t[e + 1], a)) return !0;

      return !1;
    }

    function Eo(t, e, r) {
      const n = r[0],
            i = r[2];
      if (t.x < n.x && e.x < n.x || t.x > i.x && e.x > i.x || t.y < n.y && e.y < n.y || t.y > i.y && e.y > i.y) return !1;
      const s = D(t, e, r[0]);
      return s !== D(t, e, r[1]) || s !== D(t, e, r[2]) || s !== D(t, e, r[3]);
    }

    function Co(t, e, r) {
      const n = e.paint.get(t).value;
      return "constant" === n.kind ? n.value : r.programConfigurations.get(e.id).getMaxValue(t);
    }

    function Do(t) {
      return Math.sqrt(t[0] * t[0] + t[1] * t[1]);
    }

    function Po(t, e, r, n, s) {
      if (!e[0] && !e[1]) return t;

      const a = i.convert(e)._mult(s);

      "viewport" === r && a._rotate(-n);
      const o = [];

      for (let e = 0; e < t.length; e++) o.push(t[e].sub(a));

      return o;
    }

    function Vo(t, e, r, n) {
      const s = i.convert(t)._mult(n);

      return "viewport" === e && s._rotate(-r), s;
    }

    ai(vo, "CircleBucket", {
      omit: ["layers"]
    });
    const Fo = new vs({
      "circle-sort-key": new ys($t.layout_circle["circle-sort-key"])
    });
    var Lo = {
      paint: new vs({
        "circle-radius": new ys($t.paint_circle["circle-radius"]),
        "circle-color": new ys($t.paint_circle["circle-color"]),
        "circle-blur": new ys($t.paint_circle["circle-blur"]),
        "circle-opacity": new ys($t.paint_circle["circle-opacity"]),
        "circle-translate": new ds($t.paint_circle["circle-translate"]),
        "circle-translate-anchor": new ds($t.paint_circle["circle-translate-anchor"]),
        "circle-pitch-scale": new ds($t.paint_circle["circle-pitch-scale"]),
        "circle-pitch-alignment": new ds($t.paint_circle["circle-pitch-alignment"]),
        "circle-stroke-width": new ys($t.paint_circle["circle-stroke-width"]),
        "circle-stroke-color": new ys($t.paint_circle["circle-stroke-color"]),
        "circle-stroke-opacity": new ys($t.paint_circle["circle-stroke-opacity"])
      }),
      layout: Fo
    },
        Ro = 1e-6,
        Uo = "undefined" != typeof Float32Array ? Float32Array : Array;

    function $o() {
      var t = new Uo(9);
      return Uo != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[5] = 0, t[6] = 0, t[7] = 0), t[0] = 1, t[4] = 1, t[8] = 1, t;
    }

    function jo(t) {
      return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
    }

    function Oo(t, e, r) {
      var n = e[0],
          i = e[1],
          s = e[2],
          a = e[3],
          o = e[4],
          l = e[5],
          u = e[6],
          c = e[7],
          h = e[8],
          p = e[9],
          f = e[10],
          d = e[11],
          y = e[12],
          m = e[13],
          g = e[14],
          x = e[15],
          v = r[0],
          b = r[1],
          _ = r[2],
          w = r[3];
      return t[0] = v * n + b * o + _ * h + w * y, t[1] = v * i + b * l + _ * p + w * m, t[2] = v * s + b * u + _ * f + w * g, t[3] = v * a + b * c + _ * d + w * x, t[4] = (v = r[4]) * n + (b = r[5]) * o + (_ = r[6]) * h + (w = r[7]) * y, t[5] = v * i + b * l + _ * p + w * m, t[6] = v * s + b * u + _ * f + w * g, t[7] = v * a + b * c + _ * d + w * x, t[8] = (v = r[8]) * n + (b = r[9]) * o + (_ = r[10]) * h + (w = r[11]) * y, t[9] = v * i + b * l + _ * p + w * m, t[10] = v * s + b * u + _ * f + w * g, t[11] = v * a + b * c + _ * d + w * x, t[12] = (v = r[12]) * n + (b = r[13]) * o + (_ = r[14]) * h + (w = r[15]) * y, t[13] = v * i + b * l + _ * p + w * m, t[14] = v * s + b * u + _ * f + w * g, t[15] = v * a + b * c + _ * d + w * x, t;
    }

    function qo(t, e, r) {
      var n,
          i,
          s,
          a,
          o,
          l,
          u,
          c,
          h,
          p,
          f,
          d,
          y = r[0],
          m = r[1],
          g = r[2];
      return e === t ? (t[12] = e[0] * y + e[4] * m + e[8] * g + e[12], t[13] = e[1] * y + e[5] * m + e[9] * g + e[13], t[14] = e[2] * y + e[6] * m + e[10] * g + e[14], t[15] = e[3] * y + e[7] * m + e[11] * g + e[15]) : (i = e[1], s = e[2], a = e[3], o = e[4], l = e[5], u = e[6], c = e[7], h = e[8], p = e[9], f = e[10], d = e[11], t[0] = n = e[0], t[1] = i, t[2] = s, t[3] = a, t[4] = o, t[5] = l, t[6] = u, t[7] = c, t[8] = h, t[9] = p, t[10] = f, t[11] = d, t[12] = n * y + o * m + h * g + e[12], t[13] = i * y + l * m + p * g + e[13], t[14] = s * y + u * m + f * g + e[14], t[15] = a * y + c * m + d * g + e[15]), t;
    }

    function No(t, e, r) {
      var n = r[0],
          i = r[1],
          s = r[2];
      return t[0] = e[0] * n, t[1] = e[1] * n, t[2] = e[2] * n, t[3] = e[3] * n, t[4] = e[4] * i, t[5] = e[5] * i, t[6] = e[6] * i, t[7] = e[7] * i, t[8] = e[8] * s, t[9] = e[9] * s, t[10] = e[10] * s, t[11] = e[11] * s, t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t;
    }

    function Go(t, e, r) {
      var n = Math.sin(r),
          i = Math.cos(r),
          s = e[4],
          a = e[5],
          o = e[6],
          l = e[7],
          u = e[8],
          c = e[9],
          h = e[10],
          p = e[11];
      return e !== t && (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[4] = s * i + u * n, t[5] = a * i + c * n, t[6] = o * i + h * n, t[7] = l * i + p * n, t[8] = u * i - s * n, t[9] = c * i - a * n, t[10] = h * i - o * n, t[11] = p * i - l * n, t;
    }

    function Zo(t, e, r) {
      var n = Math.sin(r),
          i = Math.cos(r),
          s = e[0],
          a = e[1],
          o = e[2],
          l = e[3],
          u = e[8],
          c = e[9],
          h = e[10],
          p = e[11];
      return e !== t && (t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[0] = s * i - u * n, t[1] = a * i - c * n, t[2] = o * i - h * n, t[3] = l * i - p * n, t[8] = s * n + u * i, t[9] = a * n + c * i, t[10] = o * n + h * i, t[11] = l * n + p * i, t;
    }

    Math.hypot || (Math.hypot = function () {
      for (var t = 0, e = arguments.length; e--;) t += arguments[e] * arguments[e];

      return Math.sqrt(t);
    });
    var Xo = Oo;

    function Ko() {
      var t = new Uo(3);
      return Uo != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t;
    }

    function Yo(t) {
      var e = new Uo(3);
      return e[0] = t[0], e[1] = t[1], e[2] = t[2], e;
    }

    function Ho(t) {
      return Math.hypot(t[0], t[1], t[2]);
    }

    function Wo(t, e, r) {
      var n = new Uo(3);
      return n[0] = t, n[1] = e, n[2] = r, n;
    }

    function Jo(t, e, r) {
      return t[0] = e[0] + r[0], t[1] = e[1] + r[1], t[2] = e[2] + r[2], t;
    }

    function Qo(t, e, r) {
      return t[0] = e[0] - r[0], t[1] = e[1] - r[1], t[2] = e[2] - r[2], t;
    }

    function tl(t, e, r) {
      return t[0] = e[0] * r[0], t[1] = e[1] * r[1], t[2] = e[2] * r[2], t;
    }

    function el(t, e, r) {
      return t[0] = Math.min(e[0], r[0]), t[1] = Math.min(e[1], r[1]), t[2] = Math.min(e[2], r[2]), t;
    }

    function rl(t, e, r) {
      return t[0] = Math.max(e[0], r[0]), t[1] = Math.max(e[1], r[1]), t[2] = Math.max(e[2], r[2]), t;
    }

    function nl(t, e, r) {
      return t[0] = e[0] * r, t[1] = e[1] * r, t[2] = e[2] * r, t;
    }

    function il(t, e, r, n) {
      return t[0] = e[0] + r[0] * n, t[1] = e[1] + r[1] * n, t[2] = e[2] + r[2] * n, t;
    }

    function sl(t, e) {
      var r = e[0],
          n = e[1],
          i = e[2],
          s = r * r + n * n + i * i;
      return s > 0 && (s = 1 / Math.sqrt(s)), t[0] = e[0] * s, t[1] = e[1] * s, t[2] = e[2] * s, t;
    }

    function al(t, e) {
      return t[0] * e[0] + t[1] * e[1] + t[2] * e[2];
    }

    function ol(t, e, r) {
      var n = e[0],
          i = e[1],
          s = e[2],
          a = r[0],
          o = r[1],
          l = r[2];
      return t[0] = i * l - s * o, t[1] = s * a - n * l, t[2] = n * o - i * a, t;
    }

    function ll(t, e, r) {
      var n = e[0],
          i = e[1],
          s = e[2],
          a = r[3] * n + r[7] * i + r[11] * s + r[15];
      return t[0] = (r[0] * n + r[4] * i + r[8] * s + r[12]) / (a = a || 1), t[1] = (r[1] * n + r[5] * i + r[9] * s + r[13]) / a, t[2] = (r[2] * n + r[6] * i + r[10] * s + r[14]) / a, t;
    }

    function ul(t, e, r) {
      var n = r[0],
          i = r[1],
          s = r[2],
          a = e[0],
          o = e[1],
          l = e[2],
          u = i * l - s * o,
          c = s * a - n * l,
          h = n * o - i * a,
          p = i * h - s * c,
          f = s * u - n * h,
          d = n * c - i * u,
          y = 2 * r[3];
      return c *= y, h *= y, f *= 2, d *= 2, t[0] = a + (u *= y) + (p *= 2), t[1] = o + c + f, t[2] = l + h + d, t;
    }

    var cl,
        hl = Qo,
        pl = tl,
        fl = Ho;

    function dl(t, e, r) {
      var n = e[0],
          i = e[1],
          s = e[2],
          a = e[3];
      return t[0] = r[0] * n + r[4] * i + r[8] * s + r[12] * a, t[1] = r[1] * n + r[5] * i + r[9] * s + r[13] * a, t[2] = r[2] * n + r[6] * i + r[10] * s + r[14] * a, t[3] = r[3] * n + r[7] * i + r[11] * s + r[15] * a, t;
    }

    function yl() {
      var t = new Uo(4);
      return Uo != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t[3] = 1, t;
    }

    function ml(t) {
      return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t;
    }

    function gl(t, e, r) {
      r *= .5;
      var n = e[0],
          i = e[1],
          s = e[2],
          a = e[3],
          o = Math.sin(r),
          l = Math.cos(r);
      return t[0] = n * l + a * o, t[1] = i * l + s * o, t[2] = s * l - i * o, t[3] = a * l - n * o, t;
    }

    Ko(), cl = new Uo(4), Uo != Float32Array && (cl[0] = 0, cl[1] = 0, cl[2] = 0, cl[3] = 0), Ko(), Wo(1, 0, 0), Wo(0, 1, 0), yl(), yl(), $o();

    class xl {
      constructor(t, e) {
        this.points = t, this.planes = e;
      }

      static fromInvProjectionMatrix(t, e, r, n) {
        const i = Math.pow(2, r),
              s = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map(r => {
          const s = dl([], r, t),
                a = 1 / s[3] / e * i;
          return function (t, e, r) {
            return t[0] = e[0] * r[0], t[1] = e[1] * r[1], t[2] = e[2] * r[2], t[3] = e[3] * r[3], t;
          }(s, s, [a, a, n ? 1 / s[3] : a, a]);
        }),
              a = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map(t => {
          const e = sl([], ol([], hl([], s[t[0]], s[t[1]]), hl([], s[t[2]], s[t[1]]))),
                r = -al(e, s[t[1]]);
          return e.concat(r);
        });
        return new xl(s, a);
      }

    }

    class vl {
      constructor(t, e) {
        this.min = t, this.max = e, this.center = nl([], Jo([], this.min, this.max), .5);
      }

      quadrant(t) {
        const e = [t % 2 == 0, t < 2],
              r = Yo(this.min),
              n = Yo(this.max);

        for (let t = 0; t < e.length; t++) r[t] = e[t] ? this.min[t] : this.center[t], n[t] = e[t] ? this.center[t] : this.max[t];

        return n[2] = this.max[2], new vl(r, n);
      }

      distanceX(t) {
        return Math.max(Math.min(this.max[0], t[0]), this.min[0]) - t[0];
      }

      distanceY(t) {
        return Math.max(Math.min(this.max[1], t[1]), this.min[1]) - t[1];
      }

      distanceZ(t) {
        return Math.max(Math.min(this.max[2], t[2]), this.min[2]) - t[2];
      }

      getCorners() {
        const t = this.min,
              e = this.max;
        return [[t[0], t[1], t[2]], [e[0], t[1], t[2]], [e[0], e[1], t[2]], [t[0], e[1], t[2]], [t[0], t[1], e[2]], [e[0], t[1], e[2]], [e[0], e[1], e[2]], [t[0], e[1], e[2]]];
      }

      intersects(t) {
        const e = this.getCorners();
        let r = !0;

        for (let n = 0; n < t.planes.length; n++) {
          const i = t.planes[n];
          let s = 0;

          for (let t = 0; t < e.length; t++) s += al(i, e[t]) + i[3] >= 0;

          if (0 === s) return 0;
          s !== e.length && (r = !1);
        }

        if (r) return 2;

        for (let e = 0; e < 3; e++) {
          let r = Number.MAX_VALUE,
              n = -Number.MAX_VALUE;

          for (let i = 0; i < t.points.length; i++) {
            const s = t.points[i][e] - this.min[e];
            r = Math.min(r, s), n = Math.max(n, s);
          }

          if (n < 0 || r > this.max[e] - this.min[e]) return 0;
        }

        return 1;
      }

    }

    function bl(t, e, r, n, i, s, a, o, l) {
      if (s && t.queryGeometry.isAboveHorizon) return !1;
      s && (l *= t.pixelToTileUnitsFactor);

      for (const u of e) for (const e of u) {
        const u = e.add(o),
              c = i && r.elevation ? r.elevation.exaggeration() * i.getElevationAt(u.x, u.y, !0) : 0,
              h = s ? u : _l(u, c, n),
              p = s ? t.tilespaceRays.map(t => kl(t, c)) : t.queryGeometry.screenGeometry,
              f = dl([], [e.x, e.y, c, 1], n);
        if (!a && s ? l *= f[3] / r.cameraToCenterDistance : a && !s && (l *= r.cameraToCenterDistance / f[3]), _o(p, h, l)) return !0;
      }

      return !1;
    }

    function _l(t, e, r) {
      const n = dl([], [t.x, t.y, e, 1], r);
      return new i(n[0] / n[3], n[1] / n[3]);
    }

    const wl = Wo(0, 0, 0),
          Al = Wo(0, 0, 1);

    function kl(t, e) {
      const r = Ko();
      return wl[2] = e, t.intersectsPlane(wl, Al, r), new i(r[0], r[1]);
    }

    class Sl extends vo {}

    function Il(t, {
      width: e,
      height: r
    }, n, i) {
      if (i) {
        if (i instanceof Uint8ClampedArray) i = new Uint8Array(i.buffer);else if (i.length !== e * r * n) throw new RangeError("mismatched image size");
      } else i = new Uint8Array(e * r * n);

      return t.width = e, t.height = r, t.data = i, t;
    }

    function Ml(t, e, r) {
      const {
        width: n,
        height: i
      } = e;
      n === t.width && i === t.height || (Tl(t, e, {
        x: 0,
        y: 0
      }, {
        x: 0,
        y: 0
      }, {
        width: Math.min(t.width, n),
        height: Math.min(t.height, i)
      }, r), t.width = n, t.height = i, t.data = e.data);
    }

    function Tl(t, e, r, n, i, s) {
      if (0 === i.width || 0 === i.height) return e;
      if (i.width > t.width || i.height > t.height || r.x > t.width - i.width || r.y > t.height - i.height) throw new RangeError("out of range source coordinates for image copy");
      if (i.width > e.width || i.height > e.height || n.x > e.width - i.width || n.y > e.height - i.height) throw new RangeError("out of range destination coordinates for image copy");
      const a = t.data,
            o = e.data;

      for (let l = 0; l < i.height; l++) {
        const u = ((r.y + l) * t.width + r.x) * s,
              c = ((n.y + l) * e.width + n.x) * s;

        for (let t = 0; t < i.width * s; t++) o[c + t] = a[u + t];
      }

      return e;
    }

    ai(Sl, "HeatmapBucket", {
      omit: ["layers"]
    });

    class zl {
      constructor(t, e) {
        Il(this, t, 1, e);
      }

      resize(t) {
        Ml(this, new zl(t), 1);
      }

      clone() {
        return new zl({
          width: this.width,
          height: this.height
        }, new Uint8Array(this.data));
      }

      static copy(t, e, r, n, i) {
        Tl(t, e, r, n, i, 1);
      }

    }

    class Bl {
      constructor(t, e) {
        Il(this, t, 4, e);
      }

      resize(t) {
        Ml(this, new Bl(t), 4);
      }

      replace(t, e) {
        e ? this.data.set(t) : this.data = t instanceof Uint8ClampedArray ? new Uint8Array(t.buffer) : t;
      }

      clone() {
        return new Bl({
          width: this.width,
          height: this.height
        }, new Uint8Array(this.data));
      }

      static copy(t, e, r, n, i) {
        Tl(t, e, r, n, i, 4);
      }

    }

    ai(zl, "AlphaImage"), ai(Bl, "RGBAImage");
    var El = {
      paint: new vs({
        "heatmap-radius": new ys($t.paint_heatmap["heatmap-radius"]),
        "heatmap-weight": new ys($t.paint_heatmap["heatmap-weight"]),
        "heatmap-intensity": new ds($t.paint_heatmap["heatmap-intensity"]),
        "heatmap-color": new xs($t.paint_heatmap["heatmap-color"]),
        "heatmap-opacity": new ds($t.paint_heatmap["heatmap-opacity"])
      })
    };

    function Cl(t) {
      const e = {},
            r = t.resolution || 256,
            n = t.clips ? t.clips.length : 1,
            i = t.image || new Bl({
        width: r,
        height: n
      }),
            s = (r, n, s) => {
        e[t.evaluationKey] = s;
        const a = t.expression.evaluate(e);
        i.data[r + n + 0] = Math.floor(255 * a.r / a.a), i.data[r + n + 1] = Math.floor(255 * a.g / a.a), i.data[r + n + 2] = Math.floor(255 * a.b / a.a), i.data[r + n + 3] = Math.floor(255 * a.a);
      };

      if (t.clips) for (let e = 0, i = 0; e < n; ++e, i += 4 * r) for (let n = 0, a = 0; n < r; n++, a += 4) {
        const o = n / (r - 1),
              {
          start: l,
          end: u
        } = t.clips[e];
        s(i, a, l * (1 - o) + u * o);
      } else for (let t = 0, e = 0; t < r; t++, e += 4) s(0, e, t / (r - 1));
      return i;
    }

    var Dl = {
      paint: new vs({
        "hillshade-illumination-direction": new ds($t.paint_hillshade["hillshade-illumination-direction"]),
        "hillshade-illumination-anchor": new ds($t.paint_hillshade["hillshade-illumination-anchor"]),
        "hillshade-exaggeration": new ds($t.paint_hillshade["hillshade-exaggeration"]),
        "hillshade-shadow-color": new ds($t.paint_hillshade["hillshade-shadow-color"]),
        "hillshade-highlight-color": new ds($t.paint_hillshade["hillshade-highlight-color"]),
        "hillshade-accent-color": new ds($t.paint_hillshade["hillshade-accent-color"])
      })
    };
    const Pl = ks([{
      name: "a_pos",
      components: 2,
      type: "Int16"
    }], 4),
          {
      members: Vl
    } = Pl;
    var Fl = Rl,
        Ll = Rl;

    function Rl(t, e, r) {
      r = r || 2;
      var n,
          i,
          s,
          a,
          o,
          l,
          u,
          c = e && e.length,
          h = c ? e[0] * r : t.length,
          p = Ul(t, 0, h, r, !0),
          f = [];
      if (!p || p.next === p.prev) return f;

      if (c && (p = function (t, e, r, n) {
        var i,
            s,
            a,
            o = [];

        for (i = 0, s = e.length; i < s; i++) (a = Ul(t, e[i] * n, i < s - 1 ? e[i + 1] * n : t.length, n, !1)) === a.next && (a.steiner = !0), o.push(Hl(a));

        for (o.sort(Zl), i = 0; i < o.length; i++) r = $l(r = Xl(o[i], r), r.next);

        return r;
      }(t, e, p, r)), t.length > 80 * r) {
        n = s = t[0], i = a = t[1];

        for (var d = r; d < h; d += r) (o = t[d]) < n && (n = o), (l = t[d + 1]) < i && (i = l), o > s && (s = o), l > a && (a = l);

        u = 0 !== (u = Math.max(s - n, a - i)) ? 1 / u : 0;
      }

      return jl(p, f, r, n, i, u), f;
    }

    function Ul(t, e, r, n, i) {
      var s, a;
      if (i === uu(t, e, r, n) > 0) for (s = e; s < r; s += n) a = au(s, t[s], t[s + 1], a);else for (s = r - n; s >= e; s -= n) a = au(s, t[s], t[s + 1], a);
      return a && tu(a, a.next) && (ou(a), a = a.next), a;
    }

    function $l(t, e) {
      if (!t) return t;
      e || (e = t);
      var r,
          n = t;

      do {
        if (r = !1, n.steiner || !tu(n, n.next) && 0 !== Ql(n.prev, n, n.next)) n = n.next;else {
          if (ou(n), (n = e = n.prev) === n.next) break;
          r = !0;
        }
      } while (r || n !== e);

      return e;
    }

    function jl(t, e, r, n, i, s, a) {
      if (t) {
        !a && s && function (t, e, r, n) {
          var i = t;

          do {
            null === i.z && (i.z = Yl(i.x, i.y, e, r, n)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next;
          } while (i !== t);

          i.prevZ.nextZ = null, i.prevZ = null, function (t) {
            var e,
                r,
                n,
                i,
                s,
                a,
                o,
                l,
                u = 1;

            do {
              for (r = t, t = null, s = null, a = 0; r;) {
                for (a++, n = r, o = 0, e = 0; e < u && (o++, n = n.nextZ); e++);

                for (l = u; o > 0 || l > 0 && n;) 0 !== o && (0 === l || !n || r.z <= n.z) ? (i = r, r = r.nextZ, o--) : (i = n, n = n.nextZ, l--), s ? s.nextZ = i : t = i, i.prevZ = s, s = i;

                r = n;
              }

              s.nextZ = null, u *= 2;
            } while (a > 1);
          }(i);
        }(t, n, i, s);

        for (var o, l, u = t; t.prev !== t.next;) if (o = t.prev, l = t.next, s ? ql(t, n, i, s) : Ol(t)) e.push(o.i / r), e.push(t.i / r), e.push(l.i / r), ou(t), t = l.next, u = l.next;else if ((t = l) === u) {
          a ? 1 === a ? jl(t = Nl($l(t), e, r), e, r, n, i, s, 2) : 2 === a && Gl(t, e, r, n, i, s) : jl($l(t), e, r, n, i, s, 1);
          break;
        }
      }
    }

    function Ol(t) {
      var e = t.prev,
          r = t,
          n = t.next;
      if (Ql(e, r, n) >= 0) return !1;

      for (var i = t.next.next; i !== t.prev;) {
        if (Wl(e.x, e.y, r.x, r.y, n.x, n.y, i.x, i.y) && Ql(i.prev, i, i.next) >= 0) return !1;
        i = i.next;
      }

      return !0;
    }

    function ql(t, e, r, n) {
      var i = t.prev,
          s = t,
          a = t.next;
      if (Ql(i, s, a) >= 0) return !1;

      for (var o = i.x > s.x ? i.x > a.x ? i.x : a.x : s.x > a.x ? s.x : a.x, l = i.y > s.y ? i.y > a.y ? i.y : a.y : s.y > a.y ? s.y : a.y, u = Yl(i.x < s.x ? i.x < a.x ? i.x : a.x : s.x < a.x ? s.x : a.x, i.y < s.y ? i.y < a.y ? i.y : a.y : s.y < a.y ? s.y : a.y, e, r, n), c = Yl(o, l, e, r, n), h = t.prevZ, p = t.nextZ; h && h.z >= u && p && p.z <= c;) {
        if (h !== t.prev && h !== t.next && Wl(i.x, i.y, s.x, s.y, a.x, a.y, h.x, h.y) && Ql(h.prev, h, h.next) >= 0) return !1;
        if (h = h.prevZ, p !== t.prev && p !== t.next && Wl(i.x, i.y, s.x, s.y, a.x, a.y, p.x, p.y) && Ql(p.prev, p, p.next) >= 0) return !1;
        p = p.nextZ;
      }

      for (; h && h.z >= u;) {
        if (h !== t.prev && h !== t.next && Wl(i.x, i.y, s.x, s.y, a.x, a.y, h.x, h.y) && Ql(h.prev, h, h.next) >= 0) return !1;
        h = h.prevZ;
      }

      for (; p && p.z <= c;) {
        if (p !== t.prev && p !== t.next && Wl(i.x, i.y, s.x, s.y, a.x, a.y, p.x, p.y) && Ql(p.prev, p, p.next) >= 0) return !1;
        p = p.nextZ;
      }

      return !0;
    }

    function Nl(t, e, r) {
      var n = t;

      do {
        var i = n.prev,
            s = n.next.next;
        !tu(i, s) && eu(i, n, n.next, s) && iu(i, s) && iu(s, i) && (e.push(i.i / r), e.push(n.i / r), e.push(s.i / r), ou(n), ou(n.next), n = t = s), n = n.next;
      } while (n !== t);

      return $l(n);
    }

    function Gl(t, e, r, n, i, s) {
      var a = t;

      do {
        for (var o = a.next.next; o !== a.prev;) {
          if (a.i !== o.i && Jl(a, o)) {
            var l = su(a, o);
            return a = $l(a, a.next), l = $l(l, l.next), jl(a, e, r, n, i, s), void jl(l, e, r, n, i, s);
          }

          o = o.next;
        }

        a = a.next;
      } while (a !== t);
    }

    function Zl(t, e) {
      return t.x - e.x;
    }

    function Xl(t, e) {
      var r = function (t, e) {
        var r,
            n = e,
            i = t.x,
            s = t.y,
            a = -1 / 0;

        do {
          if (s <= n.y && s >= n.next.y && n.next.y !== n.y) {
            var o = n.x + (s - n.y) * (n.next.x - n.x) / (n.next.y - n.y);

            if (o <= i && o > a) {
              if (a = o, o === i) {
                if (s === n.y) return n;
                if (s === n.next.y) return n.next;
              }

              r = n.x < n.next.x ? n : n.next;
            }
          }

          n = n.next;
        } while (n !== e);

        if (!r) return null;
        if (i === a) return r;
        var l,
            u = r,
            c = r.x,
            h = r.y,
            p = 1 / 0;
        n = r;

        do {
          i >= n.x && n.x >= c && i !== n.x && Wl(s < h ? i : a, s, c, h, s < h ? a : i, s, n.x, n.y) && (l = Math.abs(s - n.y) / (i - n.x), iu(n, t) && (l < p || l === p && (n.x > r.x || n.x === r.x && Kl(r, n))) && (r = n, p = l)), n = n.next;
        } while (n !== u);

        return r;
      }(t, e);

      if (!r) return e;
      var n = su(r, t),
          i = $l(r, r.next);
      return $l(n, n.next), e === r ? i : e;
    }

    function Kl(t, e) {
      return Ql(t.prev, t, e.prev) < 0 && Ql(e.next, t, t.next) < 0;
    }

    function Yl(t, e, r, n, i) {
      return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - r) * i) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * i) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1;
    }

    function Hl(t) {
      var e = t,
          r = t;

      do {
        (e.x < r.x || e.x === r.x && e.y < r.y) && (r = e), e = e.next;
      } while (e !== t);

      return r;
    }

    function Wl(t, e, r, n, i, s, a, o) {
      return (i - a) * (e - o) - (t - a) * (s - o) >= 0 && (t - a) * (n - o) - (r - a) * (e - o) >= 0 && (r - a) * (s - o) - (i - a) * (n - o) >= 0;
    }

    function Jl(t, e) {
      return t.next.i !== e.i && t.prev.i !== e.i && !function (t, e) {
        var r = t;

        do {
          if (r.i !== t.i && r.next.i !== t.i && r.i !== e.i && r.next.i !== e.i && eu(r, r.next, t, e)) return !0;
          r = r.next;
        } while (r !== t);

        return !1;
      }(t, e) && (iu(t, e) && iu(e, t) && function (t, e) {
        var r = t,
            n = !1,
            i = (t.x + e.x) / 2,
            s = (t.y + e.y) / 2;

        do {
          r.y > s != r.next.y > s && r.next.y !== r.y && i < (r.next.x - r.x) * (s - r.y) / (r.next.y - r.y) + r.x && (n = !n), r = r.next;
        } while (r !== t);

        return n;
      }(t, e) && (Ql(t.prev, t, e.prev) || Ql(t, e.prev, e)) || tu(t, e) && Ql(t.prev, t, t.next) > 0 && Ql(e.prev, e, e.next) > 0);
    }

    function Ql(t, e, r) {
      return (e.y - t.y) * (r.x - e.x) - (e.x - t.x) * (r.y - e.y);
    }

    function tu(t, e) {
      return t.x === e.x && t.y === e.y;
    }

    function eu(t, e, r, n) {
      var i = nu(Ql(t, e, r)),
          s = nu(Ql(t, e, n)),
          a = nu(Ql(r, n, t)),
          o = nu(Ql(r, n, e));
      return i !== s && a !== o || !(0 !== i || !ru(t, r, e)) || !(0 !== s || !ru(t, n, e)) || !(0 !== a || !ru(r, t, n)) || !(0 !== o || !ru(r, e, n));
    }

    function ru(t, e, r) {
      return e.x <= Math.max(t.x, r.x) && e.x >= Math.min(t.x, r.x) && e.y <= Math.max(t.y, r.y) && e.y >= Math.min(t.y, r.y);
    }

    function nu(t) {
      return t > 0 ? 1 : t < 0 ? -1 : 0;
    }

    function iu(t, e) {
      return Ql(t.prev, t, t.next) < 0 ? Ql(t, e, t.next) >= 0 && Ql(t, t.prev, e) >= 0 : Ql(t, e, t.prev) < 0 || Ql(t, t.next, e) < 0;
    }

    function su(t, e) {
      var r = new lu(t.i, t.x, t.y),
          n = new lu(e.i, e.x, e.y),
          i = t.next,
          s = e.prev;
      return t.next = e, e.prev = t, r.next = i, i.prev = r, n.next = r, r.prev = n, s.next = n, n.prev = s, n;
    }

    function au(t, e, r, n) {
      var i = new lu(t, e, r);
      return n ? (i.next = n.next, i.prev = n, n.next.prev = i, n.next = i) : (i.prev = i, i.next = i), i;
    }

    function ou(t) {
      t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ);
    }

    function lu(t, e, r) {
      this.i = t, this.x = e, this.y = r, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1;
    }

    function uu(t, e, r, n) {
      for (var i = 0, s = e, a = r - n; s < r; s += n) i += (t[a] - t[s]) * (t[s + 1] + t[a + 1]), a = s;

      return i;
    }

    function cu(t, e, r, n, i) {
      hu(t, e, r || 0, n || t.length - 1, i || fu);
    }

    function hu(t, e, r, n, i) {
      for (; n > r;) {
        if (n - r > 600) {
          var s = n - r + 1,
              a = e - r + 1,
              o = Math.log(s),
              l = .5 * Math.exp(2 * o / 3),
              u = .5 * Math.sqrt(o * l * (s - l) / s) * (a - s / 2 < 0 ? -1 : 1);
          hu(t, e, Math.max(r, Math.floor(e - a * l / s + u)), Math.min(n, Math.floor(e + (s - a) * l / s + u)), i);
        }

        var c = t[e],
            h = r,
            p = n;

        for (pu(t, r, e), i(t[n], c) > 0 && pu(t, r, n); h < p;) {
          for (pu(t, h, p), h++, p--; i(t[h], c) < 0;) h++;

          for (; i(t[p], c) > 0;) p--;
        }

        0 === i(t[r], c) ? pu(t, r, p) : pu(t, ++p, n), p <= e && (r = p + 1), e <= p && (n = p - 1);
      }
    }

    function pu(t, e, r) {
      var n = t[e];
      t[e] = t[r], t[r] = n;
    }

    function fu(t, e) {
      return t < e ? -1 : t > e ? 1 : 0;
    }

    function du(t, e) {
      const r = t.length;
      if (r <= 1) return [t];
      const n = [];
      let i, s;

      for (let e = 0; e < r; e++) {
        const r = P(t[e]);
        0 !== r && (t[e].area = Math.abs(r), void 0 === s && (s = r < 0), s === r < 0 ? (i && n.push(i), i = [t[e]]) : i.push(t[e]));
      }

      if (i && n.push(i), e > 1) for (let t = 0; t < n.length; t++) n[t].length <= e || (cu(n[t], e, 1, n[t].length - 1, yu), n[t] = n[t].slice(0, e));
      return n;
    }

    function yu(t, e) {
      return e.area - t.area;
    }

    function mu(t, e, r) {
      const n = r.patternDependencies;
      let i = !1;

      for (const r of e) {
        const e = r.paint.get(`${t}-pattern`);
        e.isConstant() || (i = !0);
        const s = e.constantOr(null);
        s && (i = !0, n[s.to] = !0, n[s.from] = !0);
      }

      return i;
    }

    function gu(t, e, r, n, i) {
      const s = i.patternDependencies;

      for (const a of e) {
        const e = a.paint.get(`${t}-pattern`).value;

        if ("constant" !== e.kind) {
          let t = e.evaluate({
            zoom: n - 1
          }, r, {}, i.availableImages),
              o = e.evaluate({
            zoom: n
          }, r, {}, i.availableImages),
              l = e.evaluate({
            zoom: n + 1
          }, r, {}, i.availableImages);
          t = t && t.name ? t.name : t, o = o && o.name ? o.name : o, l = l && l.name ? l.name : l, s[t] = !0, s[o] = !0, s[l] = !0, r.patterns[a.id] = {
            min: t,
            mid: o,
            max: l
          };
        }
      }

      return r;
    }

    Rl.deviation = function (t, e, r, n) {
      var i = e && e.length,
          s = Math.abs(uu(t, 0, i ? e[0] * r : t.length, r));
      if (i) for (var a = 0, o = e.length; a < o; a++) s -= Math.abs(uu(t, e[a] * r, a < o - 1 ? e[a + 1] * r : t.length, r));
      var l = 0;

      for (a = 0; a < n.length; a += 3) {
        var u = n[a] * r,
            c = n[a + 1] * r,
            h = n[a + 2] * r;
        l += Math.abs((t[u] - t[h]) * (t[c + 1] - t[u + 1]) - (t[u] - t[c]) * (t[h + 1] - t[u + 1]));
      }

      return 0 === s && 0 === l ? 0 : Math.abs((l - s) / s);
    }, Rl.flatten = function (t) {
      for (var e = t[0][0].length, r = {
        vertices: [],
        holes: [],
        dimensions: e
      }, n = 0, i = 0; i < t.length; i++) {
        for (var s = 0; s < t[i].length; s++) for (var a = 0; a < e; a++) r.vertices.push(t[i][s][a]);

        i > 0 && r.holes.push(n += t[i - 1].length);
      }

      return r;
    }, Fl.default = Ll;

    class xu {
      constructor(t) {
        this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(t => t.id), this.index = t.index, this.hasPattern = !1, this.patternFeatures = [], this.layoutVertexArray = new Is(), this.indexArray = new js(), this.indexArray2 = new Ks(), this.programConfigurations = new Ra(t.layers, t.zoom), this.segments = new Ka(), this.segments2 = new Ka(), this.stateDependentLayerIds = this.layers.filter(t => t.isStateDependent()).map(t => t.id), this.projection = t.projection;
      }

      populate(t, e, r, n) {
        this.hasPattern = mu("fill", this.layers, e);
        const i = this.layers[0].layout.get("fill-sort-key"),
              s = [];

        for (const {
          feature: a,
          id: o,
          index: l,
          sourceLayerIndex: u
        } of t) {
          const t = this.layers[0]._featureFilter.needGeometry,
                c = mo(a, t);
          if (!this.layers[0]._featureFilter.filter(new ss(this.zoom), c, r)) continue;
          const h = i ? i.evaluate(c, {}, r, e.availableImages) : void 0,
                p = {
            id: o,
            properties: a.properties,
            type: a.type,
            sourceLayerIndex: u,
            index: l,
            geometry: t ? c.geometry : yo(a, r, n),
            patterns: {},
            sortKey: h
          };
          s.push(p);
        }

        i && s.sort((t, e) => t.sortKey - e.sortKey);

        for (const n of s) {
          const {
            geometry: i,
            index: s,
            sourceLayerIndex: a
          } = n;

          if (this.hasPattern) {
            const t = gu("fill", this.layers, n, this.zoom, e);
            this.patternFeatures.push(t);
          } else this.addFeature(n, i, s, r, {}, e.availableImages);

          e.featureIndex.insert(t[s].feature, i, s, a, this.index);
        }
      }

      update(t, e, r, n) {
        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, r, n);
      }

      addFeatures(t, e, r, n, i) {
        for (const t of this.patternFeatures) this.addFeature(t, t.geometry, t.index, e, r, n);
      }

      isEmpty() {
        return 0 === this.layoutVertexArray.length;
      }

      uploadPending() {
        return !this.uploaded || this.programConfigurations.needsUpload;
      }

      upload(t) {
        this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Vl), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.indexBuffer2 = t.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t), this.uploaded = !0;
      }

      destroy() {
        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
      }

      addFeature(t, e, r, n, i, s = []) {
        for (const t of du(e, 500)) {
          let e = 0;

          for (const r of t) e += r.length;

          const r = this.segments.prepareSegment(e, this.layoutVertexArray, this.indexArray),
                n = r.vertexLength,
                i = [],
                s = [];

          for (const e of t) {
            if (0 === e.length) continue;
            e !== t[0] && s.push(i.length / 2);
            const r = this.segments2.prepareSegment(e.length, this.layoutVertexArray, this.indexArray2),
                  n = r.vertexLength;
            this.layoutVertexArray.emplaceBack(e[0].x, e[0].y), this.indexArray2.emplaceBack(n + e.length - 1, n), i.push(e[0].x), i.push(e[0].y);

            for (let t = 1; t < e.length; t++) this.layoutVertexArray.emplaceBack(e[t].x, e[t].y), this.indexArray2.emplaceBack(n + t - 1, n + t), i.push(e[t].x), i.push(e[t].y);

            r.vertexLength += e.length, r.primitiveLength += e.length;
          }

          const a = Fl(i, s);

          for (let t = 0; t < a.length; t += 3) this.indexArray.emplaceBack(n + a[t], n + a[t + 1], n + a[t + 2]);

          r.vertexLength += e, r.primitiveLength += a.length / 3;
        }

        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, i, s, n);
      }

    }

    ai(xu, "FillBucket", {
      omit: ["layers", "patternFeatures"]
    });
    const vu = new vs({
      "fill-sort-key": new ys($t.layout_fill["fill-sort-key"])
    });
    var bu = {
      paint: new vs({
        "fill-antialias": new ds($t.paint_fill["fill-antialias"]),
        "fill-opacity": new ys($t.paint_fill["fill-opacity"]),
        "fill-color": new ys($t.paint_fill["fill-color"]),
        "fill-outline-color": new ys($t.paint_fill["fill-outline-color"]),
        "fill-translate": new ds($t.paint_fill["fill-translate"]),
        "fill-translate-anchor": new ds($t.paint_fill["fill-translate-anchor"]),
        "fill-pattern": new ms($t.paint_fill["fill-pattern"])
      }),
      layout: vu
    };

    const _u = ks([{
      name: "a_pos_normal_ed",
      components: 4,
      type: "Int16"
    }]),
          wu = ks([{
      name: "a_centroid_pos",
      components: 2,
      type: "Uint16"
    }]),
          Au = ks([{
      name: "a_pos_3",
      components: 3,
      type: "Int16"
    }, {
      name: "a_pos_normal_3",
      components: 3,
      type: "Int16"
    }]),
          {
      members: ku
    } = _u;

    var Su = Iu;

    function Iu(t, e, r, n, i) {
      this.properties = {}, this.extent = r, this.type = 0, this._pbf = t, this._geometry = -1, this._keys = n, this._values = i, t.readFields(Mu, this, e);
    }

    function Mu(t, e, r) {
      1 == t ? e.id = r.readVarint() : 2 == t ? function (t, e) {
        for (var r = t.readVarint() + t.pos; t.pos < r;) {
          var n = e._keys[t.readVarint()],
              i = e._values[t.readVarint()];

          e.properties[n] = i;
        }
      }(r, e) : 3 == t ? e.type = r.readVarint() : 4 == t && (e._geometry = r.pos);
    }

    function Tu(t) {
      for (var e, r, n = 0, i = 0, s = t.length, a = s - 1; i < s; a = i++) n += ((r = t[a]).x - (e = t[i]).x) * (e.y + r.y);

      return n;
    }

    Iu.types = ["Unknown", "Point", "LineString", "Polygon"], Iu.prototype.loadGeometry = function () {
      var t = this._pbf;
      t.pos = this._geometry;

      for (var e, r = t.readVarint() + t.pos, n = 1, s = 0, a = 0, o = 0, l = []; t.pos < r;) {
        if (s <= 0) {
          var u = t.readVarint();
          n = 7 & u, s = u >> 3;
        }

        if (s--, 1 === n || 2 === n) a += t.readSVarint(), o += t.readSVarint(), 1 === n && (e && l.push(e), e = []), e.push(new i(a, o));else {
          if (7 !== n) throw new Error("unknown command " + n);
          e && e.push(e[0].clone());
        }
      }

      return e && l.push(e), l;
    }, Iu.prototype.bbox = function () {
      var t = this._pbf;
      t.pos = this._geometry;

      for (var e = t.readVarint() + t.pos, r = 1, n = 0, i = 0, s = 0, a = 1 / 0, o = -1 / 0, l = 1 / 0, u = -1 / 0; t.pos < e;) {
        if (n <= 0) {
          var c = t.readVarint();
          r = 7 & c, n = c >> 3;
        }

        if (n--, 1 === r || 2 === r) (i += t.readSVarint()) < a && (a = i), i > o && (o = i), (s += t.readSVarint()) < l && (l = s), s > u && (u = s);else if (7 !== r) throw new Error("unknown command " + r);
      }

      return [a, l, o, u];
    }, Iu.prototype.toGeoJSON = function (t, e, r) {
      var n,
          i,
          s = this.extent * Math.pow(2, r),
          a = this.extent * t,
          o = this.extent * e,
          l = this.loadGeometry(),
          u = Iu.types[this.type];

      function c(t) {
        for (var e = 0; e < t.length; e++) {
          var r = t[e];
          t[e] = [360 * (r.x + a) / s - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (r.y + o) / s) * Math.PI / 180)) - 90];
        }
      }

      switch (this.type) {
        case 1:
          var h = [];

          for (n = 0; n < l.length; n++) h[n] = l[n][0];

          c(l = h);
          break;

        case 2:
          for (n = 0; n < l.length; n++) c(l[n]);

          break;

        case 3:
          for (l = function (t) {
            var e = t.length;
            if (e <= 1) return [t];

            for (var r, n, i = [], s = 0; s < e; s++) {
              var a = Tu(t[s]);
              0 !== a && (void 0 === n && (n = a < 0), n === a < 0 ? (r && i.push(r), r = [t[s]]) : r.push(t[s]));
            }

            return r && i.push(r), i;
          }(l), n = 0; n < l.length; n++) for (i = 0; i < l[n].length; i++) c(l[n][i]);

      }

      1 === l.length ? l = l[0] : u = "Multi" + u;
      var p = {
        type: "Feature",
        geometry: {
          type: u,
          coordinates: l
        },
        properties: this.properties
      };
      return "id" in this && (p.id = this.id), p;
    };
    var zu = Bu;

    function Bu(t, e) {
      this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t, this._keys = [], this._values = [], this._features = [], t.readFields(Eu, this, e), this.length = this._features.length;
    }

    function Eu(t, e, r) {
      15 === t ? e.version = r.readVarint() : 1 === t ? e.name = r.readString() : 5 === t ? e.extent = r.readVarint() : 2 === t ? e._features.push(r.pos) : 3 === t ? e._keys.push(r.readString()) : 4 === t && e._values.push(function (t) {
        for (var e = null, r = t.readVarint() + t.pos; t.pos < r;) {
          var n = t.readVarint() >> 3;
          e = 1 === n ? t.readString() : 2 === n ? t.readFloat() : 3 === n ? t.readDouble() : 4 === n ? t.readVarint64() : 5 === n ? t.readVarint() : 6 === n ? t.readSVarint() : 7 === n ? t.readBoolean() : null;
        }

        return e;
      }(r));
    }

    function Cu(t, e, r) {
      if (3 === t) {
        var n = new zu(r, r.readVarint() + r.pos);
        n.length && (e[n.name] = n);
      }
    }

    Bu.prototype.feature = function (t) {
      if (t < 0 || t >= this._features.length) throw new Error("feature index out of bounds");
      this._pbf.pos = this._features[t];

      var e = this._pbf.readVarint() + this._pbf.pos;

      return new Su(this._pbf, e, this.extent, this._keys, this._values);
    };

    var Du = {
      VectorTile: function (t, e) {
        this.layers = t.readFields(Cu, {}, e);
      },
      VectorTileFeature: Su,
      VectorTileLayer: zu
    };

    function Pu(t, e, r, n) {
      const s = [],
            a = 0 === n ? (t, e, r, n, s, a) => {
        t.push(new i(a, r + (a - e) / (n - e) * (s - r)));
      } : (t, e, r, n, s, a) => {
        t.push(new i(e + (a - r) / (s - r) * (n - e), a));
      };

      for (const i of t) {
        const t = [];

        for (const s of i) {
          if (s.length <= 2) continue;
          const i = [];

          for (let t = 0; t < s.length - 1; t++) {
            const o = s[t].x,
                  l = s[t].y,
                  u = s[t + 1].x,
                  c = s[t + 1].y,
                  h = 0 === n ? o : l,
                  p = 0 === n ? u : c;
            h < e ? p > e && a(i, o, l, u, c, e) : h > r ? p < r && a(i, o, l, u, c, r) : i.push(s[t]), p < e && h >= e && a(i, o, l, u, c, e), p > r && h <= r && a(i, o, l, u, c, r);
          }

          let o = s[s.length - 1];
          const l = 0 === n ? o.x : o.y;
          l >= e && l <= r && i.push(o), i.length && (o = i[i.length - 1], i[0].x === o.x && i[0].y === o.y || i.push(i[0]), t.push(i));
        }

        t.length && s.push(t);
      }

      return s;
    }

    const Vu = Du.VectorTileFeature.types,
          Fu = Math.pow(2, 13);

    function Lu(t, e, r, n, i, s, a, o) {
      t.emplaceBack((e << 1) + a, (r << 1) + s, (Math.floor(n * Fu) << 1) + i, Math.round(o));
    }

    function Ru(t, e, r) {
      const n = 16384;
      t.emplaceBack(e.x, e.y, e.z, r[0] * n, r[1] * n, r[2] * n);
    }

    class Uu {
      constructor() {
        this.acc = new i(0, 0), this.polyCount = [];
      }

      startRing(t) {
        this.currentPolyCount = {
          edges: 0,
          top: 0
        }, this.polyCount.push(this.currentPolyCount), this.min || (this.min = new i(t.x, t.y), this.max = new i(t.x, t.y));
      }

      append(t, e) {
        this.currentPolyCount.edges++, this.acc._add(t);
        const r = this.min,
              n = this.max;
        t.x < r.x ? r.x = t.x : t.x > n.x && (n.x = t.x), t.y < r.y ? r.y = t.y : t.y > n.y && (n.y = t.y), ((0 === t.x || t.x === Ya) && t.x === e.x) != ((0 === t.y || t.y === Ya) && t.y === e.y) && this.processBorderOverlap(t, e), e.x < 0 != t.x < 0 && this.addBorderIntersection(0, rr(e.y, t.y, (0 - e.x) / (t.x - e.x))), e.x > Ya != t.x > Ya && this.addBorderIntersection(1, rr(e.y, t.y, (Ya - e.x) / (t.x - e.x))), e.y < 0 != t.y < 0 && this.addBorderIntersection(2, rr(e.x, t.x, (0 - e.y) / (t.y - e.y))), e.y > Ya != t.y > Ya && this.addBorderIntersection(3, rr(e.x, t.x, (Ya - e.y) / (t.y - e.y)));
      }

      addBorderIntersection(t, e) {
        this.borders || (this.borders = [[Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE]]);
        const r = this.borders[t];
        e < r[0] && (r[0] = e), e > r[1] && (r[1] = e);
      }

      processBorderOverlap(t, e) {
        if (t.x === e.x) {
          if (t.y === e.y) return;
          const r = 0 === t.x ? 0 : 1;
          this.addBorderIntersection(r, e.y), this.addBorderIntersection(r, t.y);
        } else {
          const r = 0 === t.y ? 2 : 3;
          this.addBorderIntersection(r, e.x), this.addBorderIntersection(r, t.x);
        }
      }

      centroid() {
        const t = this.polyCount.reduce((t, e) => t + e.edges, 0);
        return 0 !== t ? this.acc.div(t)._round() : new i(0, 0);
      }

      span() {
        return new i(this.max.x - this.min.x, this.max.y - this.min.y);
      }

      intersectsCount() {
        return this.borders.reduce((t, e) => t + +(e[0] !== Number.MAX_VALUE), 0);
      }

    }

    class $u {
      constructor(t) {
        this.zoom = t.zoom, this.canonical = t.canonical, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(t => t.id), this.index = t.index, this.hasPattern = !1, this.projection = t.projection, this.layoutVertexArray = new Ts(), this.centroidVertexArray = new ha(), this.indexArray = new js(), this.programConfigurations = new Ra(t.layers, t.zoom), this.segments = new Ka(), this.stateDependentLayerIds = this.layers.filter(t => t.isStateDependent()).map(t => t.id), this.enableTerrain = t.enableTerrain;
      }

      populate(t, e, r, n) {
        this.features = [], this.hasPattern = mu("fill-extrusion", this.layers, e), this.featuresOnBorder = [], this.borders = [[], [], [], []], this.borderDoneWithNeighborZ = [-1, -1, -1, -1], this.tileToMeter = function (t) {
          const e = Math.exp(Math.PI * (1 - t.y / (1 << t.z) * 2));
          return 80150034 * e / (e * e + 1) / Ya / (1 << t.z);
        }(r);

        for (const {
          feature: i,
          id: s,
          index: a,
          sourceLayerIndex: o
        } of t) {
          const t = this.layers[0]._featureFilter.needGeometry,
                l = mo(i, t);
          if (!this.layers[0]._featureFilter.filter(new ss(this.zoom), l, r)) continue;
          const u = {
            id: s,
            sourceLayerIndex: o,
            index: a,
            geometry: t ? l.geometry : yo(i, r, n),
            properties: i.properties,
            type: i.type,
            patterns: {}
          },
                c = this.layoutVertexArray.length;
          this.hasPattern ? this.features.push(gu("fill-extrusion", this.layers, u, this.zoom, e)) : this.addFeature(u, u.geometry, a, r, {}, e.availableImages, n), e.featureIndex.insert(i, u.geometry, a, o, this.index, c);
        }

        this.sortBorders();
      }

      addFeatures(t, e, r, n, i) {
        for (const t of this.features) {
          const {
            geometry: s
          } = t;
          this.addFeature(t, s, t.index, e, r, n, i);
        }

        this.sortBorders();
      }

      update(t, e, r, n) {
        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, r, n);
      }

      isEmpty() {
        return 0 === this.layoutVertexArray.length;
      }

      uploadPending() {
        return !this.uploaded || this.programConfigurations.needsUpload;
      }

      upload(t) {
        this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, ku), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.layoutVertexExtArray && (this.layoutVertexExtBuffer = t.createVertexBuffer(this.layoutVertexExtArray, Au.members, !0))), this.programConfigurations.upload(t), this.uploaded = !0;
      }

      uploadCentroid(t) {
        0 !== this.centroidVertexArray.length && (this.centroidVertexBuffer ? this.needsCentroidUpdate && this.centroidVertexBuffer.updateData(this.centroidVertexArray) : this.centroidVertexBuffer = t.createVertexBuffer(this.centroidVertexArray, wu.members, !0), this.needsCentroidUpdate = !1);
      }

      destroy() {
        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.centroidVertexBuffer && this.centroidVertexBuffer.destroy(), this.layoutVertexExtBuffer && this.layoutVertexExtBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
      }

      addFeature(t, e, r, n, s, a, o) {
        const l = [new i(0, 0), new i(Ya, Ya)],
              u = o.projection,
              c = "globe" === u.name,
              h = this.enableTerrain && !c ? new Uu() : null;
        c && !this.layoutVertexExtArray && (this.layoutVertexExtArray = new Qs());
        const p = du(e, 500);

        for (let t = p.length - 1; t >= 0; t--) {
          const e = p[t];
          (0 === e.length || (f = e[0]).every(t => t.x <= 0) || f.every(t => t.x >= Ya) || f.every(t => t.y <= 0) || f.every(t => t.y >= Ya)) && p.splice(t, 1);
        }

        var f;
        let d;

        if (c) {
          const t = 11.25,
                e = 1 << n.z,
                r = io(n.x / e),
                s = io((n.x + 1) / e),
                a = so(n.y / e),
                o = so((n.y + 1) / e);

          d = function (t, e, r, n, s = 0, a) {
            const o = [];
            if (!t.length || !r || !n) return o;

            const l = (t, e) => {
              for (const r of t) o.push({
                polygon: r,
                bounds: e
              });
            },
                  u = Math.ceil(Math.log2(r)),
                  c = Math.ceil(Math.log2(n)),
                  h = u - c,
                  p = [];

            for (let t = 0; t < Math.abs(h); t++) p.push(h > 0 ? 0 : 1);

            for (let t = 0; t < Math.min(u, c); t++) p.push(0), p.push(1);

            let f = t;
            if (f = Pu(f, e[0].y - s, e[1].y + s, 1), f = Pu(f, e[0].x - s, e[1].x + s, 0), !f.length) return o;
            const d = [];

            for (p.length ? d.push({
              polygons: f,
              bounds: e,
              depth: 0
            }) : l(f, e); d.length;) {
              const t = d.pop(),
                    e = t.depth,
                    r = p[e],
                    n = t.bounds[0],
                    o = t.bounds[1],
                    u = 0 === r ? n.x : n.y,
                    c = 0 === r ? o.x : o.y,
                    h = a ? a(r, u, c) : .5 * (u + c),
                    f = Pu(t.polygons, u - s, h + s, r),
                    y = Pu(t.polygons, h - s, c + s, r);

              if (f.length) {
                const t = [n, new i(0 === r ? h : o.x, 1 === r ? h : o.y)];
                p.length > e + 1 ? d.push({
                  polygons: f,
                  bounds: t,
                  depth: e + 1
                }) : l(f, t);
              }

              if (y.length) {
                const t = [new i(0 === r ? h : n.x, 1 === r ? h : n.y), o];
                p.length > e + 1 ? d.push({
                  polygons: y,
                  bounds: t,
                  depth: e + 1
                }) : l(y, t);
              }
            }

            return o;
          }(p, l, Math.ceil((s - r) / t), Math.ceil((a - o) / t), 1, (t, r, i) => {
            if (0 === t) return .5 * (r + i);
            {
              const t = so((n.y + r / Ya) / e);
              return (ro(.5 * (so((n.y + i / Ya) / e) + t)) * e - n.y) * Ya;
            }
          });
        } else {
          d = [];

          for (const t of p) d.push({
            polygon: t,
            bounds: l
          });
        }

        for (const e of d) {
          const r = e.polygon;
          let i = 0,
              s = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray);

          for (let t = 0; t < r.length; t++) {
            const a = r[t];
            if (0 === a.length) continue;
            i += a.length;
            let o = 0;
            h && h.startRing(a[0]);

            for (let t = 0; t < a.length; t++) {
              const r = a[t];

              if (t >= 1) {
                const i = a[t - 1];

                if (!ju(r, i, e.bounds)) {
                  h && h.append(r, i), s.vertexLength + 4 > Ka.MAX_VERTEX_ARRAY_LENGTH && (s = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));

                  const t = r.sub(i)._perp(),
                        e = t.x / (Math.abs(t.x) + Math.abs(t.y)),
                        a = t.y > 0 ? 1 : 0,
                        l = i.dist(r);

                  o + l > 32768 && (o = 0), Lu(this.layoutVertexArray, r.x, r.y, e, a, 0, 0, o), Lu(this.layoutVertexArray, r.x, r.y, e, a, 0, 1, o), o += l, Lu(this.layoutVertexArray, i.x, i.y, e, a, 0, 0, o), Lu(this.layoutVertexArray, i.x, i.y, e, a, 0, 1, o);
                  const p = s.vertexLength;

                  if (this.indexArray.emplaceBack(p, p + 2, p + 1), this.indexArray.emplaceBack(p + 1, p + 2, p + 3), s.vertexLength += 4, s.primitiveLength += 2, c) {
                    const t = this.layoutVertexExtArray,
                          e = u.projectTilePoint(r.x, r.y, n),
                          s = u.projectTilePoint(i.x, i.y, n),
                          a = u.upVector(n, r.x, r.y),
                          o = u.upVector(n, i.x, i.y);
                    Ru(t, e, a), Ru(t, e, a), Ru(t, s, o), Ru(t, s, o);
                  }
                }
              }
            }
          }

          if (s.vertexLength + i > Ka.MAX_VERTEX_ARRAY_LENGTH && (s = this.segments.prepareSegment(i, this.layoutVertexArray, this.indexArray)), "Polygon" !== Vu[t.type]) continue;
          const a = [],
                o = [],
                l = s.vertexLength;

          for (let t = 0; t < r.length; t++) {
            const e = r[t];

            if (0 !== e.length) {
              e !== r[0] && o.push(a.length / 2);

              for (let t = 0; t < e.length; t++) {
                const r = e[t];
                Lu(this.layoutVertexArray, r.x, r.y, 0, 0, 1, 1, 0), a.push(r.x), a.push(r.y), h && h.currentPolyCount.top++, c && Ru(this.layoutVertexExtArray, u.projectTilePoint(r.x, r.y, n), u.upVector(n, r.x, r.y));
              }
            }
          }

          const p = Fl(a, o);

          for (let t = 0; t < p.length; t += 3) this.indexArray.emplaceBack(l + p[t], l + p[t + 2], l + p[t + 1]);

          s.primitiveLength += p.length / 3, s.vertexLength += i;
        }

        if (h && h.polyCount.length > 0) {
          if (h.borders) {
            h.vertexArrayOffset = this.centroidVertexArray.length;
            const t = h.borders,
                  e = this.featuresOnBorder.push(h) - 1;

            for (let r = 0; r < 4; r++) t[r][0] !== Number.MAX_VALUE && this.borders[r].push(e);
          }

          this.encodeCentroid(h.borders ? void 0 : h.centroid(), h);
        }

        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, s, a, n);
      }

      sortBorders() {
        for (let t = 0; t < 4; t++) this.borders[t].sort((e, r) => this.featuresOnBorder[e].borders[t][0] - this.featuresOnBorder[r].borders[t][0]);
      }

      encodeCentroid(t, e, r = !0) {
        let n, i;
        if (t) {
          if (0 !== t.y) {
            const r = e.span()._mult(this.tileToMeter);

            n = (Math.max(t.x, 1) << 3) + Math.min(7, Math.round(r.x / 10)), i = (Math.max(t.y, 1) << 3) + Math.min(7, Math.round(r.y / 10));
          } else n = Math.ceil(7 * (t.x + 450)), i = 0;
        } else n = 0, i = +r;
        let s = r ? this.centroidVertexArray.length : e.vertexArrayOffset;

        for (const t of e.polyCount) {
          r && this.centroidVertexArray.resize(this.centroidVertexArray.length + 4 * t.edges + t.top);

          for (let e = 0; e < 2 * t.edges; e++) this.centroidVertexArray.emplace(s++, 0, i), this.centroidVertexArray.emplace(s++, n, i);

          for (let e = 0; e < t.top; e++) this.centroidVertexArray.emplace(s++, n, i);
        }
      }

    }

    function ju(t, e, r) {
      return t.x === e.x && (t.x < r[0].x || t.x > r[1].x) || t.y === e.y && (t.y < r[0].y || t.y > r[1].y);
    }

    ai($u, "FillExtrusionBucket", {
      omit: ["layers", "features"]
    }), ai(Uu, "PartMetadata");
    var Ou = {
      paint: new vs({
        "fill-extrusion-opacity": new ds($t["paint_fill-extrusion"]["fill-extrusion-opacity"]),
        "fill-extrusion-color": new ys($t["paint_fill-extrusion"]["fill-extrusion-color"]),
        "fill-extrusion-translate": new ds($t["paint_fill-extrusion"]["fill-extrusion-translate"]),
        "fill-extrusion-translate-anchor": new ds($t["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]),
        "fill-extrusion-pattern": new ms($t["paint_fill-extrusion"]["fill-extrusion-pattern"]),
        "fill-extrusion-height": new ys($t["paint_fill-extrusion"]["fill-extrusion-height"]),
        "fill-extrusion-base": new ys($t["paint_fill-extrusion"]["fill-extrusion-base"]),
        "fill-extrusion-vertical-gradient": new ds($t["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"])
      })
    };

    function qu(t, e) {
      return t.x * e.x + t.y * e.y;
    }

    function Nu(t, e) {
      if (1 === t.length) {
        let r = 0;
        const n = e[r++];
        let i;

        for (; !i || n.equals(i);) if (i = e[r++], !i) return 1 / 0;

        for (; r < e.length; r++) {
          const s = e[r],
                a = t[0],
                o = i.sub(n),
                l = s.sub(n),
                u = a.sub(n),
                c = qu(o, o),
                h = qu(o, l),
                p = qu(l, l),
                f = qu(u, o),
                d = qu(u, l),
                y = c * p - h * h,
                m = (p * f - h * d) / y,
                g = (c * d - h * f) / y,
                x = n.z * (1 - m - g) + i.z * m + s.z * g;
          if (isFinite(x)) return x;
        }

        return 1 / 0;
      }

      {
        let t = 1 / 0;

        for (const r of e) t = Math.min(t, r.z);

        return t;
      }
    }

    function Gu(t) {
      const e = new i(t[0], t[1]);
      return e.z = t[2], e;
    }

    function Zu(t, e, r, n, i, s, a, o) {
      const l = a * i.getElevationAt(t, e, !0, !0),
            u = 0 !== s[0],
            c = u ? 0 === s[1] ? a * (s[0] / 7 - 450) : a * function (t, e, r) {
        const n = Math.floor(e[0] / 8),
              i = Math.floor(e[1] / 8),
              s = 10 * (e[0] - 8 * n),
              a = 10 * (e[1] - 8 * i),
              o = t.getElevationAt(n, i, !0, !0),
              l = t.getMeterToDEM(r),
              u = Math.floor(.5 * (s * l - 1)),
              c = Math.floor(.5 * (a * l - 1)),
              h = t.tileCoordToPixel(n, i),
              p = 2 * u + 1,
              f = 2 * c + 1,
              d = function (t, e, r, n, i) {
          return [t.getElevationAtPixel(e, r, !0), t.getElevationAtPixel(e + i, r, !0), t.getElevationAtPixel(e, r + i, !0), t.getElevationAtPixel(e + n, r + i, !0)];
        }(t, h.x - u, h.y - c, p, f),
              y = Math.abs(d[0] - d[1]),
              m = Math.abs(d[2] - d[3]),
              g = Math.abs(d[0] - d[2]) + Math.abs(d[1] - d[3]),
              x = Math.min(.25, .5 * l * (y + m) / p),
              v = Math.min(.25, .5 * l * g / f);

        return o + Math.max(x * s, v * a);
      }(i, s, o) : l;
      return {
        base: l + (0 === r) ? -1 : r,
        top: u ? Math.max(c + n, l + r + 2) : l + n
      };
    }

    const Xu = ks([{
      name: "a_pos_normal",
      components: 2,
      type: "Int16"
    }, {
      name: "a_data",
      components: 4,
      type: "Uint8"
    }, {
      name: "a_linesofar",
      components: 1,
      type: "Float32"
    }], 4),
          {
      members: Ku
    } = Xu,
          Yu = ks([{
      name: "a_packed",
      components: 3,
      type: "Float32"
    }]),
          {
      members: Hu
    } = Yu,
          Wu = Du.VectorTileFeature.types,
          Ju = Math.cos(Math.PI / 180 * 37.5);

    class Qu {
      constructor(t) {
        this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(t => t.id), this.index = t.index, this.projection = t.projection, this.hasPattern = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach(t => {
          this.gradients[t.id] = {};
        }), this.layoutVertexArray = new zs(), this.layoutVertexArray2 = new Vs(), this.indexArray = new js(), this.programConfigurations = new Ra(t.layers, t.zoom), this.segments = new Ka(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter(t => t.isStateDependent()).map(t => t.id);
      }

      populate(t, e, r, n) {
        this.hasPattern = mu("line", this.layers, e);
        const i = this.layers[0].layout.get("line-sort-key"),
              s = [];

        for (const {
          feature: e,
          id: a,
          index: o,
          sourceLayerIndex: l
        } of t) {
          const t = this.layers[0]._featureFilter.needGeometry,
                u = mo(e, t);
          if (!this.layers[0]._featureFilter.filter(new ss(this.zoom), u, r)) continue;
          const c = i ? i.evaluate(u, {}, r) : void 0,
                h = {
            id: a,
            properties: e.properties,
            type: e.type,
            sourceLayerIndex: l,
            index: o,
            geometry: t ? u.geometry : yo(e, r, n),
            patterns: {},
            sortKey: c
          };
          s.push(h);
        }

        i && s.sort((t, e) => t.sortKey - e.sortKey);
        const {
          lineAtlas: a,
          featureIndex: o
        } = e,
              l = this.addConstantDashes(a);

        for (const n of s) {
          const {
            geometry: i,
            index: s,
            sourceLayerIndex: u
          } = n;

          if (l && this.addFeatureDashes(n, a), this.hasPattern) {
            const t = gu("line", this.layers, n, this.zoom, e);
            this.patternFeatures.push(t);
          } else this.addFeature(n, i, s, r, a.positions, e.availableImages);

          o.insert(t[s].feature, i, s, u, this.index);
        }
      }

      addConstantDashes(t) {
        let e = !1;

        for (const r of this.layers) {
          const n = r.paint.get("line-dasharray").value,
                i = r.layout.get("line-cap").value;
          if ("constant" !== n.kind || "constant" !== i.kind) e = !0;else {
            const e = i.value,
                  r = n.value;
            if (!r) continue;
            t.addDash(r.from, e), t.addDash(r.to, e), r.other && t.addDash(r.other, e);
          }
        }

        return e;
      }

      addFeatureDashes(t, e) {
        const r = this.zoom;

        for (const n of this.layers) {
          const i = n.paint.get("line-dasharray").value,
                s = n.layout.get("line-cap").value;
          if ("constant" === i.kind && "constant" === s.kind) continue;
          let a, o, l, u, c, h;

          if ("constant" === i.kind) {
            const t = i.value;
            if (!t) continue;
            a = t.other || t.to, o = t.to, l = t.from;
          } else a = i.evaluate({
            zoom: r - 1
          }, t), o = i.evaluate({
            zoom: r
          }, t), l = i.evaluate({
            zoom: r + 1
          }, t);

          "constant" === s.kind ? u = c = h = s.value : (u = s.evaluate({
            zoom: r - 1
          }, t), c = s.evaluate({
            zoom: r
          }, t), h = s.evaluate({
            zoom: r + 1
          }, t)), e.addDash(a, u), e.addDash(o, c), e.addDash(l, h);
          const p = e.getKey(a, u),
                f = e.getKey(o, c),
                d = e.getKey(l, h);
          t.patterns[n.id] = {
            min: p,
            mid: f,
            max: d
          };
        }
      }

      update(t, e, r, n) {
        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, r, n);
      }

      addFeatures(t, e, r, n, i) {
        for (const t of this.patternFeatures) this.addFeature(t, t.geometry, t.index, e, r, n);
      }

      isEmpty() {
        return 0 === this.layoutVertexArray.length;
      }

      uploadPending() {
        return !this.uploaded || this.programConfigurations.needsUpload;
      }

      upload(t) {
        this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t.createVertexBuffer(this.layoutVertexArray2, Hu)), this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Ku), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0;
      }

      destroy() {
        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
      }

      lineFeatureClips(t) {
        if (t.properties && t.properties.hasOwnProperty("mapbox_clip_start") && t.properties.hasOwnProperty("mapbox_clip_end")) return {
          start: +t.properties.mapbox_clip_start,
          end: +t.properties.mapbox_clip_end
        };
      }

      addFeature(t, e, r, n, i, s) {
        const a = this.layers[0].layout,
              o = a.get("line-join").evaluate(t, {}),
              l = a.get("line-cap").evaluate(t, {}),
              u = a.get("line-miter-limit"),
              c = a.get("line-round-limit");
        this.lineClips = this.lineFeatureClips(t);

        for (const r of e) this.addLine(r, t, o, l, u, c);

        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, i, s, n);
      }

      addLine(t, e, r, n, i, s) {
        if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineSoFar = 0, this.lineClips) {
          this.lineClipsArray.push(this.lineClips);

          for (let e = 0; e < t.length - 1; e++) this.totalDistance += t[e].dist(t[e + 1]);

          this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
        }

        const a = "Polygon" === Wu[e.type];
        let o = t.length;

        for (; o >= 2 && t[o - 1].equals(t[o - 2]);) o--;

        let l = 0;

        for (; l < o - 1 && t[l].equals(t[l + 1]);) l++;

        if (o < (a ? 3 : 2)) return;
        "bevel" === r && (i = 1.05);
        const u = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0,
              c = this.segments.prepareSegment(10 * o, this.layoutVertexArray, this.indexArray);
        let h, p, f, d, y;
        this.e1 = this.e2 = -1, a && (h = t[o - 2], y = t[l].sub(h)._unit()._perp());

        for (let e = l; e < o; e++) {
          if (f = e === o - 1 ? a ? t[l + 1] : void 0 : t[e + 1], f && t[e].equals(f)) continue;
          y && (d = y), h && (p = h), h = t[e], y = f ? f.sub(h)._unit()._perp() : d, d = d || y;
          let m = d.add(y);
          0 === m.x && 0 === m.y || m._unit();

          const g = d.x * y.x + d.y * y.y,
                x = m.x * y.x + m.y * y.y,
                v = 0 !== x ? 1 / x : 1 / 0,
                b = 2 * Math.sqrt(2 - 2 * x),
                _ = x < Ju && p && f,
                w = d.x * y.y - d.y * y.x > 0;

          if (_ && e > l) {
            const t = h.dist(p);

            if (t > 2 * u) {
              const e = h.sub(h.sub(p)._mult(u / t)._round());
              this.updateDistance(p, e), this.addCurrentVertex(e, d, 0, 0, c), p = e;
            }
          }

          const A = p && f;
          let k = A ? r : a ? "butt" : n;
          if (A && "round" === k && (v < s ? k = "miter" : v <= 2 && (k = "fakeround")), "miter" === k && v > i && (k = "bevel"), "bevel" === k && (v > 2 && (k = "flipbevel"), v < i && (k = "miter")), p && this.updateDistance(p, h), "miter" === k) m._mult(v), this.addCurrentVertex(h, m, 0, 0, c);else if ("flipbevel" === k) {
            if (v > 100) m = y.mult(-1);else {
              const t = v * d.add(y).mag() / d.sub(y).mag();

              m._perp()._mult(t * (w ? -1 : 1));
            }
            this.addCurrentVertex(h, m, 0, 0, c), this.addCurrentVertex(h, m.mult(-1), 0, 0, c);
          } else if ("bevel" === k || "fakeround" === k) {
            const t = -Math.sqrt(v * v - 1),
                  e = w ? t : 0,
                  r = w ? 0 : t;

            if (p && this.addCurrentVertex(h, d, e, r, c), "fakeround" === k) {
              const t = Math.round(180 * b / Math.PI / 20);

              for (let e = 1; e < t; e++) {
                let r = e / t;

                if (.5 !== r) {
                  const t = r - .5;
                  r += r * t * (r - 1) * ((1.0904 + g * (g * (3.55645 - 1.43519 * g) - 3.2452)) * t * t + (.848013 + g * (.215638 * g - 1.06021)));
                }

                const n = y.sub(d)._mult(r)._add(d)._unit()._mult(w ? -1 : 1);

                this.addHalfVertex(h, n.x, n.y, !1, w, 0, c);
              }
            }

            f && this.addCurrentVertex(h, y, -e, -r, c);
          } else if ("butt" === k) this.addCurrentVertex(h, m, 0, 0, c);else if ("square" === k) {
            const t = p ? 1 : -1;
            p || this.addCurrentVertex(h, m, t, t, c), this.addCurrentVertex(h, m, 0, 0, c), p && this.addCurrentVertex(h, m, t, t, c);
          } else "round" === k && (p && (this.addCurrentVertex(h, d, 0, 0, c), this.addCurrentVertex(h, d, 1, 1, c, !0)), f && (this.addCurrentVertex(h, y, -1, -1, c, !0), this.addCurrentVertex(h, y, 0, 0, c)));

          if (_ && e < o - 1) {
            const t = h.dist(f);

            if (t > 2 * u) {
              const e = h.add(f.sub(h)._mult(u / t)._round());
              this.updateDistance(h, e), this.addCurrentVertex(e, y, 0, 0, c), h = e;
            }
          }
        }
      }

      addCurrentVertex(t, e, r, n, i, s = !1) {
        const a = e.y * n - e.x,
              o = -e.y - e.x * n;
        this.addHalfVertex(t, e.x + e.y * r, e.y - e.x * r, s, !1, r, i), this.addHalfVertex(t, a, o, s, !0, -n, i);
      }

      addHalfVertex({
        x: t,
        y: e
      }, r, n, i, s, a, o) {
        this.layoutVertexArray.emplaceBack((t << 1) + (i ? 1 : 0), (e << 1) + (s ? 1 : 0), Math.round(63 * r) + 128, Math.round(63 * n) + 128, 1 + (0 === a ? 0 : a < 0 ? -1 : 1), 0, this.lineSoFar), this.lineClips && this.layoutVertexArray2.emplaceBack(this.scaledDistance, this.lineClipsArray.length, this.lineSoFar);
        const l = o.vertexLength++;
        this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, l), o.primitiveLength++), s ? this.e2 = l : this.e1 = l;
      }

      updateScaledDistance() {
        if (this.lineClips) {
          const t = this.totalDistance / (this.lineClips.end - this.lineClips.start);
          this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = t * this.lineClips.start + this.distance;
        } else this.lineSoFar = this.distance;
      }

      updateDistance(t, e) {
        this.distance += t.dist(e), this.updateScaledDistance();
      }

    }

    ai(Qu, "LineBucket", {
      omit: ["layers", "patternFeatures"]
    });
    const tc = new vs({
      "line-cap": new ys($t.layout_line["line-cap"]),
      "line-join": new ys($t.layout_line["line-join"]),
      "line-miter-limit": new ds($t.layout_line["line-miter-limit"]),
      "line-round-limit": new ds($t.layout_line["line-round-limit"]),
      "line-sort-key": new ys($t.layout_line["line-sort-key"])
    });
    var ec = {
      paint: new vs({
        "line-opacity": new ys($t.paint_line["line-opacity"]),
        "line-color": new ys($t.paint_line["line-color"]),
        "line-translate": new ds($t.paint_line["line-translate"]),
        "line-translate-anchor": new ds($t.paint_line["line-translate-anchor"]),
        "line-width": new ys($t.paint_line["line-width"]),
        "line-gap-width": new ys($t.paint_line["line-gap-width"]),
        "line-offset": new ys($t.paint_line["line-offset"]),
        "line-blur": new ys($t.paint_line["line-blur"]),
        "line-dasharray": new ms($t.paint_line["line-dasharray"]),
        "line-pattern": new ms($t.paint_line["line-pattern"]),
        "line-gradient": new xs($t.paint_line["line-gradient"])
      }),
      layout: tc
    };
    const rc = new class extends ys {
      possiblyEvaluate(t, e) {
        return e = new ss(Math.floor(e.zoom), {
          now: e.now,
          fadeDuration: e.fadeDuration,
          zoomHistory: e.zoomHistory,
          transition: e.transition
        }), super.possiblyEvaluate(t, e);
      }

      evaluate(t, e, r, n) {
        return e = b({}, e, {
          zoom: Math.floor(e.zoom)
        }), super.evaluate(t, e, r, n);
      }

    }(ec.paint.properties["line-width"].specification);

    function nc(t, e) {
      return e > 0 ? e + 2 * t : t;
    }

    rc.useIntegerZoom = !0;
    const ic = ks([{
      name: "a_pos_offset",
      components: 4,
      type: "Int16"
    }, {
      name: "a_tex_size",
      components: 4,
      type: "Uint16"
    }, {
      name: "a_pixeloffset",
      components: 4,
      type: "Int16"
    }, {
      name: "a_z_tile_anchor",
      components: 4,
      type: "Int16"
    }], 4),
          sc = ks([{
      name: "a_projected_pos",
      components: 3,
      type: "Float32"
    }], 4);
    ks([{
      name: "a_fade_opacity",
      components: 1,
      type: "Uint32"
    }], 4);
    const ac = ks([{
      name: "a_placed",
      components: 2,
      type: "Uint8"
    }, {
      name: "a_shift",
      components: 2,
      type: "Float32"
    }]),
          oc = ks([{
      name: "a_size_scale",
      components: 1,
      type: "Float32"
    }, {
      name: "a_padding",
      components: 2,
      type: "Float32"
    }]);
    ks([{
      type: "Int16",
      name: "projectedAnchorX"
    }, {
      type: "Int16",
      name: "projectedAnchorY"
    }, {
      type: "Int16",
      name: "projectedAnchorZ"
    }, {
      type: "Int16",
      name: "tileAnchorX"
    }, {
      type: "Int16",
      name: "tileAnchorY"
    }, {
      type: "Float32",
      name: "x1"
    }, {
      type: "Float32",
      name: "y1"
    }, {
      type: "Float32",
      name: "x2"
    }, {
      type: "Float32",
      name: "y2"
    }, {
      type: "Int16",
      name: "padding"
    }, {
      type: "Uint32",
      name: "featureIndex"
    }, {
      type: "Uint16",
      name: "sourceLayerIndex"
    }, {
      type: "Uint16",
      name: "bucketIndex"
    }]);
    const lc = ks([{
      name: "a_pos",
      components: 3,
      type: "Int16"
    }, {
      name: "a_anchor_pos",
      components: 2,
      type: "Int16"
    }, {
      name: "a_extrude",
      components: 2,
      type: "Int16"
    }], 4),
          uc = ks([{
      name: "a_pos_2f",
      components: 2,
      type: "Float32"
    }, {
      name: "a_radius",
      components: 1,
      type: "Float32"
    }, {
      name: "a_flags",
      components: 2,
      type: "Int16"
    }], 4);
    ks([{
      name: "triangle",
      components: 3,
      type: "Uint16"
    }]), ks([{
      type: "Int16",
      name: "projectedAnchorX"
    }, {
      type: "Int16",
      name: "projectedAnchorY"
    }, {
      type: "Int16",
      name: "projectedAnchorZ"
    }, {
      type: "Float32",
      name: "tileAnchorX"
    }, {
      type: "Float32",
      name: "tileAnchorY"
    }, {
      type: "Uint16",
      name: "glyphStartIndex"
    }, {
      type: "Uint16",
      name: "numGlyphs"
    }, {
      type: "Uint32",
      name: "vertexStartIndex"
    }, {
      type: "Uint32",
      name: "lineStartIndex"
    }, {
      type: "Uint32",
      name: "lineLength"
    }, {
      type: "Uint16",
      name: "segment"
    }, {
      type: "Uint16",
      name: "lowerSize"
    }, {
      type: "Uint16",
      name: "upperSize"
    }, {
      type: "Float32",
      name: "lineOffsetX"
    }, {
      type: "Float32",
      name: "lineOffsetY"
    }, {
      type: "Uint8",
      name: "writingMode"
    }, {
      type: "Uint8",
      name: "placedOrientation"
    }, {
      type: "Uint8",
      name: "hidden"
    }, {
      type: "Uint32",
      name: "crossTileID"
    }, {
      type: "Int16",
      name: "associatedIconIndex"
    }, {
      type: "Uint8",
      name: "flipState"
    }]), ks([{
      type: "Int16",
      name: "projectedAnchorX"
    }, {
      type: "Int16",
      name: "projectedAnchorY"
    }, {
      type: "Int16",
      name: "projectedAnchorZ"
    }, {
      type: "Float32",
      name: "tileAnchorX"
    }, {
      type: "Float32",
      name: "tileAnchorY"
    }, {
      type: "Int16",
      name: "rightJustifiedTextSymbolIndex"
    }, {
      type: "Int16",
      name: "centerJustifiedTextSymbolIndex"
    }, {
      type: "Int16",
      name: "leftJustifiedTextSymbolIndex"
    }, {
      type: "Int16",
      name: "verticalPlacedTextSymbolIndex"
    }, {
      type: "Int16",
      name: "placedIconSymbolIndex"
    }, {
      type: "Int16",
      name: "verticalPlacedIconSymbolIndex"
    }, {
      type: "Uint16",
      name: "key"
    }, {
      type: "Uint16",
      name: "textBoxStartIndex"
    }, {
      type: "Uint16",
      name: "textBoxEndIndex"
    }, {
      type: "Uint16",
      name: "verticalTextBoxStartIndex"
    }, {
      type: "Uint16",
      name: "verticalTextBoxEndIndex"
    }, {
      type: "Uint16",
      name: "iconBoxStartIndex"
    }, {
      type: "Uint16",
      name: "iconBoxEndIndex"
    }, {
      type: "Uint16",
      name: "verticalIconBoxStartIndex"
    }, {
      type: "Uint16",
      name: "verticalIconBoxEndIndex"
    }, {
      type: "Uint16",
      name: "featureIndex"
    }, {
      type: "Uint16",
      name: "numHorizontalGlyphVertices"
    }, {
      type: "Uint16",
      name: "numVerticalGlyphVertices"
    }, {
      type: "Uint16",
      name: "numIconVertices"
    }, {
      type: "Uint16",
      name: "numVerticalIconVertices"
    }, {
      type: "Uint16",
      name: "useRuntimeCollisionCircles"
    }, {
      type: "Uint32",
      name: "crossTileID"
    }, {
      type: "Float32",
      components: 2,
      name: "textOffset"
    }, {
      type: "Float32",
      name: "collisionCircleDiameter"
    }]), ks([{
      type: "Float32",
      name: "offsetX"
    }]), ks([{
      type: "Int16",
      name: "x"
    }, {
      type: "Int16",
      name: "y"
    }, {
      type: "Int16",
      name: "tileUnitDistanceFromAnchor"
    }]);
    var cc = 24;
    const hc = 128;

    function pc(t, e) {
      const {
        expression: r
      } = e;
      if ("constant" === r.kind) return {
        kind: "constant",
        layoutSize: r.evaluate(new ss(t + 1))
      };
      if ("source" === r.kind) return {
        kind: "source"
      };
      {
        const {
          zoomStops: e,
          interpolationType: n
        } = r;
        let i = 0;

        for (; i < e.length && e[i] <= t;) i++;

        i = Math.max(0, i - 1);
        let s = i;

        for (; s < e.length && e[s] < t + 1;) s++;

        s = Math.min(e.length - 1, s);
        const a = e[i],
              o = e[s];
        return "composite" === r.kind ? {
          kind: "composite",
          minZoom: a,
          maxZoom: o,
          interpolationType: n
        } : {
          kind: "camera",
          minZoom: a,
          maxZoom: o,
          minSize: r.evaluate(new ss(a)),
          maxSize: r.evaluate(new ss(o)),
          interpolationType: n
        };
      }
    }

    function fc(t, {
      uSize: e,
      uSizeT: r
    }, {
      lowerSize: n,
      upperSize: i
    }) {
      return "source" === t.kind ? n / hc : "composite" === t.kind ? rr(n / hc, i / hc, r) : e;
    }

    function dc(t, e) {
      let r = 0,
          n = 0;
      if ("constant" === t.kind) n = t.layoutSize;else if ("source" !== t.kind) {
        const {
          interpolationType: i,
          minZoom: s,
          maxZoom: a
        } = t,
              o = i ? y(_r.interpolationFactor(i, e, s, a), 0, 1) : 0;
        "camera" === t.kind ? n = rr(t.minSize, t.maxSize, o) : r = o;
      }
      return {
        uSizeT: r,
        uSize: n
      };
    }

    var yc = Object.freeze({
      __proto__: null,
      getSizeData: pc,
      evaluateSizeForFeature: fc,
      evaluateSizeForZoom: dc,
      SIZE_PACK_FACTOR: hc
    });

    function mc(t, e, r) {
      return t.sections.forEach(t => {
        t.text = function (t, e, r) {
          const n = e.layout.get("text-transform").evaluate(r, {});
          return "uppercase" === n ? t = t.toLocaleUpperCase() : "lowercase" === n && (t = t.toLocaleLowerCase()), is.applyArabicShaping && (t = is.applyArabicShaping(t)), t;
        }(t.text, e, r);
      }), t;
    }

    const gc = {
      "!": "︕",
      "#": "＃",
      $: "＄",
      "%": "％",
      "&": "＆",
      "(": "︵",
      ")": "︶",
      "*": "＊",
      "+": "＋",
      ",": "︐",
      "-": "︲",
      ".": "・",
      "/": "／",
      ":": "︓",
      ";": "︔",
      "<": "︿",
      "=": "＝",
      ">": "﹀",
      "?": "︖",
      "@": "＠",
      "[": "﹇",
      "\\": "＼",
      "]": "﹈",
      "^": "＾",
      _: "︳",
      "`": "｀",
      "{": "︷",
      "|": "―",
      "}": "︸",
      "~": "～",
      "¢": "￠",
      "£": "￡",
      "¥": "￥",
      "¦": "￤",
      "¬": "￢",
      "¯": "￣",
      "–": "︲",
      "—": "︱",
      "‘": "﹃",
      "’": "﹄",
      "“": "﹁",
      "”": "﹂",
      "…": "︙",
      "‧": "・",
      "₩": "￦",
      "、": "︑",
      "。": "︒",
      "〈": "︿",
      "〉": "﹀",
      "《": "︽",
      "》": "︾",
      "「": "﹁",
      "」": "﹂",
      "『": "﹃",
      "』": "﹄",
      "【": "︻",
      "】": "︼",
      "〔": "︹",
      "〕": "︺",
      "〖": "︗",
      "〗": "︘",
      "！": "︕",
      "（": "︵",
      "）": "︶",
      "，": "︐",
      "－": "︲",
      "．": "・",
      "：": "︓",
      "；": "︔",
      "＜": "︿",
      "＞": "﹀",
      "？": "︖",
      "［": "﹇",
      "］": "﹈",
      "＿": "︳",
      "｛": "︷",
      "｜": "―",
      "｝": "︸",
      "｟": "︵",
      "｠": "︶",
      "｡": "︒",
      "｢": "﹁",
      "｣": "﹂"
    };

    function xc(t) {
      return "︶" === t || "﹈" === t || "︸" === t || "﹄" === t || "﹂" === t || "︾" === t || "︼" === t || "︺" === t || "︘" === t || "﹀" === t || "︐" === t || "︓" === t || "︔" === t || "｀" === t || "￣" === t || "︑" === t || "︒" === t;
    }

    function vc(t) {
      return "︵" === t || "﹇" === t || "︷" === t || "﹃" === t || "﹁" === t || "︽" === t || "︻" === t || "︹" === t || "︗" === t || "︿" === t;
    }

    var bc = function (t, e, r, n, i) {
      var s,
          a,
          o = 8 * i - n - 1,
          l = (1 << o) - 1,
          u = l >> 1,
          c = -7,
          h = r ? i - 1 : 0,
          p = r ? -1 : 1,
          f = t[e + h];

      for (h += p, s = f & (1 << -c) - 1, f >>= -c, c += o; c > 0; s = 256 * s + t[e + h], h += p, c -= 8);

      for (a = s & (1 << -c) - 1, s >>= -c, c += n; c > 0; a = 256 * a + t[e + h], h += p, c -= 8);

      if (0 === s) s = 1 - u;else {
        if (s === l) return a ? NaN : 1 / 0 * (f ? -1 : 1);
        a += Math.pow(2, n), s -= u;
      }
      return (f ? -1 : 1) * a * Math.pow(2, s - n);
    },
        _c = function (t, e, r, n, i, s) {
      var a,
          o,
          l,
          u = 8 * s - i - 1,
          c = (1 << u) - 1,
          h = c >> 1,
          p = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
          f = n ? 0 : s - 1,
          d = n ? 1 : -1,
          y = e < 0 || 0 === e && 1 / e < 0 ? 1 : 0;

      for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (o = isNaN(e) ? 1 : 0, a = c) : (a = Math.floor(Math.log(e) / Math.LN2), e * (l = Math.pow(2, -a)) < 1 && (a--, l *= 2), (e += a + h >= 1 ? p / l : p * Math.pow(2, 1 - h)) * l >= 2 && (a++, l /= 2), a + h >= c ? (o = 0, a = c) : a + h >= 1 ? (o = (e * l - 1) * Math.pow(2, i), a += h) : (o = e * Math.pow(2, h - 1) * Math.pow(2, i), a = 0)); i >= 8; t[r + f] = 255 & o, f += d, o /= 256, i -= 8);

      for (a = a << i | o, u += i; u > 0; t[r + f] = 255 & a, f += d, a /= 256, u -= 8);

      t[r + f - d] |= 128 * y;
    },
        wc = Ac;

    function Ac(t) {
      this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t) ? t : new Uint8Array(t || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
    }

    Ac.Varint = 0, Ac.Fixed64 = 1, Ac.Bytes = 2, Ac.Fixed32 = 5;
    var kc = 4294967296,
        Sc = 1 / kc,
        Ic = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf8");

    function Mc(t) {
      return t.type === Ac.Bytes ? t.readVarint() + t.pos : t.pos + 1;
    }

    function Tc(t, e, r) {
      return r ? 4294967296 * e + (t >>> 0) : 4294967296 * (e >>> 0) + (t >>> 0);
    }

    function zc(t, e, r) {
      var n = e <= 16383 ? 1 : e <= 2097151 ? 2 : e <= 268435455 ? 3 : Math.floor(Math.log(e) / (7 * Math.LN2));
      r.realloc(n);

      for (var i = r.pos - 1; i >= t; i--) r.buf[i + n] = r.buf[i];
    }

    function Bc(t, e) {
      for (var r = 0; r < t.length; r++) e.writeVarint(t[r]);
    }

    function Ec(t, e) {
      for (var r = 0; r < t.length; r++) e.writeSVarint(t[r]);
    }

    function Cc(t, e) {
      for (var r = 0; r < t.length; r++) e.writeFloat(t[r]);
    }

    function Dc(t, e) {
      for (var r = 0; r < t.length; r++) e.writeDouble(t[r]);
    }

    function Pc(t, e) {
      for (var r = 0; r < t.length; r++) e.writeBoolean(t[r]);
    }

    function Vc(t, e) {
      for (var r = 0; r < t.length; r++) e.writeFixed32(t[r]);
    }

    function Fc(t, e) {
      for (var r = 0; r < t.length; r++) e.writeSFixed32(t[r]);
    }

    function Lc(t, e) {
      for (var r = 0; r < t.length; r++) e.writeFixed64(t[r]);
    }

    function Rc(t, e) {
      for (var r = 0; r < t.length; r++) e.writeSFixed64(t[r]);
    }

    function Uc(t, e) {
      return (t[e] | t[e + 1] << 8 | t[e + 2] << 16) + 16777216 * t[e + 3];
    }

    function $c(t, e, r) {
      t[r] = e, t[r + 1] = e >>> 8, t[r + 2] = e >>> 16, t[r + 3] = e >>> 24;
    }

    function jc(t, e) {
      return (t[e] | t[e + 1] << 8 | t[e + 2] << 16) + (t[e + 3] << 24);
    }

    function Oc(t, e, r) {
      e.glyphs = [], 1 === t && r.readMessage(qc, e);
    }

    function qc(t, e, r) {
      if (3 === t) {
        const {
          id: t,
          bitmap: n,
          width: i,
          height: s,
          left: a,
          top: o,
          advance: l
        } = r.readMessage(Nc, {});
        e.glyphs.push({
          id: t,
          bitmap: new zl({
            width: i + 6,
            height: s + 6
          }, n),
          metrics: {
            width: i,
            height: s,
            left: a,
            top: o,
            advance: l
          }
        });
      } else 4 === t ? e.ascender = r.readSVarint() : 5 === t && (e.descender = r.readSVarint());
    }

    function Nc(t, e, r) {
      1 === t ? e.id = r.readVarint() : 2 === t ? e.bitmap = r.readBytes() : 3 === t ? e.width = r.readVarint() : 4 === t ? e.height = r.readVarint() : 5 === t ? e.left = r.readSVarint() : 6 === t ? e.top = r.readSVarint() : 7 === t && (e.advance = r.readVarint());
    }

    function Gc(t) {
      let e = 0,
          r = 0;

      for (const n of t) e += n.w * n.h, r = Math.max(r, n.w);

      t.sort((t, e) => e.h - t.h);
      const n = [{
        x: 0,
        y: 0,
        w: Math.max(Math.ceil(Math.sqrt(e / .95)), r),
        h: 1 / 0
      }];
      let i = 0,
          s = 0;

      for (const e of t) for (let t = n.length - 1; t >= 0; t--) {
        const r = n[t];

        if (!(e.w > r.w || e.h > r.h)) {
          if (e.x = r.x, e.y = r.y, s = Math.max(s, e.y + e.h), i = Math.max(i, e.x + e.w), e.w === r.w && e.h === r.h) {
            const e = n.pop();
            t < n.length && (n[t] = e);
          } else e.h === r.h ? (r.x += e.w, r.w -= e.w) : e.w === r.w ? (r.y += e.h, r.h -= e.h) : (n.push({
            x: r.x + e.w,
            y: r.y,
            w: r.w - e.w,
            h: e.h
          }), r.y += e.h, r.h -= e.h);

          break;
        }
      }

      return {
        w: i,
        h: s,
        fill: e / (i * s) || 0
      };
    }

    Ac.prototype = {
      destroy: function () {
        this.buf = null;
      },
      readFields: function (t, e, r) {
        for (r = r || this.length; this.pos < r;) {
          var n = this.readVarint(),
              i = n >> 3,
              s = this.pos;
          this.type = 7 & n, t(i, e, this), this.pos === s && this.skip(n);
        }

        return e;
      },
      readMessage: function (t, e) {
        return this.readFields(t, e, this.readVarint() + this.pos);
      },
      readFixed32: function () {
        var t = Uc(this.buf, this.pos);
        return this.pos += 4, t;
      },
      readSFixed32: function () {
        var t = jc(this.buf, this.pos);
        return this.pos += 4, t;
      },
      readFixed64: function () {
        var t = Uc(this.buf, this.pos) + Uc(this.buf, this.pos + 4) * kc;
        return this.pos += 8, t;
      },
      readSFixed64: function () {
        var t = Uc(this.buf, this.pos) + jc(this.buf, this.pos + 4) * kc;
        return this.pos += 8, t;
      },
      readFloat: function () {
        var t = bc(this.buf, this.pos, !0, 23, 4);
        return this.pos += 4, t;
      },
      readDouble: function () {
        var t = bc(this.buf, this.pos, !0, 52, 8);
        return this.pos += 8, t;
      },
      readVarint: function (t) {
        var e,
            r,
            n = this.buf;
        return e = 127 & (r = n[this.pos++]), r < 128 ? e : (e |= (127 & (r = n[this.pos++])) << 7, r < 128 ? e : (e |= (127 & (r = n[this.pos++])) << 14, r < 128 ? e : (e |= (127 & (r = n[this.pos++])) << 21, r < 128 ? e : function (t, e, r) {
          var n,
              i,
              s = r.buf;
          if (n = (112 & (i = s[r.pos++])) >> 4, i < 128) return Tc(t, n, e);
          if (n |= (127 & (i = s[r.pos++])) << 3, i < 128) return Tc(t, n, e);
          if (n |= (127 & (i = s[r.pos++])) << 10, i < 128) return Tc(t, n, e);
          if (n |= (127 & (i = s[r.pos++])) << 17, i < 128) return Tc(t, n, e);
          if (n |= (127 & (i = s[r.pos++])) << 24, i < 128) return Tc(t, n, e);
          if (n |= (1 & (i = s[r.pos++])) << 31, i < 128) return Tc(t, n, e);
          throw new Error("Expected varint not more than 10 bytes");
        }(e |= (15 & (r = n[this.pos])) << 28, t, this))));
      },
      readVarint64: function () {
        return this.readVarint(!0);
      },
      readSVarint: function () {
        var t = this.readVarint();
        return t % 2 == 1 ? (t + 1) / -2 : t / 2;
      },
      readBoolean: function () {
        return Boolean(this.readVarint());
      },
      readString: function () {
        var t = this.readVarint() + this.pos,
            e = this.pos;
        return this.pos = t, t - e >= 12 && Ic ? function (t, e, r) {
          return Ic.decode(t.subarray(e, r));
        }(this.buf, e, t) : function (t, e, r) {
          for (var n = "", i = e; i < r;) {
            var s,
                a,
                o,
                l = t[i],
                u = null,
                c = l > 239 ? 4 : l > 223 ? 3 : l > 191 ? 2 : 1;
            if (i + c > r) break;
            1 === c ? l < 128 && (u = l) : 2 === c ? 128 == (192 & (s = t[i + 1])) && (u = (31 & l) << 6 | 63 & s) <= 127 && (u = null) : 3 === c ? (a = t[i + 2], 128 == (192 & (s = t[i + 1])) && 128 == (192 & a) && ((u = (15 & l) << 12 | (63 & s) << 6 | 63 & a) <= 2047 || u >= 55296 && u <= 57343) && (u = null)) : 4 === c && (a = t[i + 2], o = t[i + 3], 128 == (192 & (s = t[i + 1])) && 128 == (192 & a) && 128 == (192 & o) && ((u = (15 & l) << 18 | (63 & s) << 12 | (63 & a) << 6 | 63 & o) <= 65535 || u >= 1114112) && (u = null)), null === u ? (u = 65533, c = 1) : u > 65535 && (u -= 65536, n += String.fromCharCode(u >>> 10 & 1023 | 55296), u = 56320 | 1023 & u), n += String.fromCharCode(u), i += c;
          }

          return n;
        }(this.buf, e, t);
      },
      readBytes: function () {
        var t = this.readVarint() + this.pos,
            e = this.buf.subarray(this.pos, t);
        return this.pos = t, e;
      },
      readPackedVarint: function (t, e) {
        if (this.type !== Ac.Bytes) return t.push(this.readVarint(e));
        var r = Mc(this);

        for (t = t || []; this.pos < r;) t.push(this.readVarint(e));

        return t;
      },
      readPackedSVarint: function (t) {
        if (this.type !== Ac.Bytes) return t.push(this.readSVarint());
        var e = Mc(this);

        for (t = t || []; this.pos < e;) t.push(this.readSVarint());

        return t;
      },
      readPackedBoolean: function (t) {
        if (this.type !== Ac.Bytes) return t.push(this.readBoolean());
        var e = Mc(this);

        for (t = t || []; this.pos < e;) t.push(this.readBoolean());

        return t;
      },
      readPackedFloat: function (t) {
        if (this.type !== Ac.Bytes) return t.push(this.readFloat());
        var e = Mc(this);

        for (t = t || []; this.pos < e;) t.push(this.readFloat());

        return t;
      },
      readPackedDouble: function (t) {
        if (this.type !== Ac.Bytes) return t.push(this.readDouble());
        var e = Mc(this);

        for (t = t || []; this.pos < e;) t.push(this.readDouble());

        return t;
      },
      readPackedFixed32: function (t) {
        if (this.type !== Ac.Bytes) return t.push(this.readFixed32());
        var e = Mc(this);

        for (t = t || []; this.pos < e;) t.push(this.readFixed32());

        return t;
      },
      readPackedSFixed32: function (t) {
        if (this.type !== Ac.Bytes) return t.push(this.readSFixed32());
        var e = Mc(this);

        for (t = t || []; this.pos < e;) t.push(this.readSFixed32());

        return t;
      },
      readPackedFixed64: function (t) {
        if (this.type !== Ac.Bytes) return t.push(this.readFixed64());
        var e = Mc(this);

        for (t = t || []; this.pos < e;) t.push(this.readFixed64());

        return t;
      },
      readPackedSFixed64: function (t) {
        if (this.type !== Ac.Bytes) return t.push(this.readSFixed64());
        var e = Mc(this);

        for (t = t || []; this.pos < e;) t.push(this.readSFixed64());

        return t;
      },
      skip: function (t) {
        var e = 7 & t;
        if (e === Ac.Varint) for (; this.buf[this.pos++] > 127;);else if (e === Ac.Bytes) this.pos = this.readVarint() + this.pos;else if (e === Ac.Fixed32) this.pos += 4;else {
          if (e !== Ac.Fixed64) throw new Error("Unimplemented type: " + e);
          this.pos += 8;
        }
      },
      writeTag: function (t, e) {
        this.writeVarint(t << 3 | e);
      },
      realloc: function (t) {
        for (var e = this.length || 16; e < this.pos + t;) e *= 2;

        if (e !== this.length) {
          var r = new Uint8Array(e);
          r.set(this.buf), this.buf = r, this.length = e;
        }
      },
      finish: function () {
        return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
      },
      writeFixed32: function (t) {
        this.realloc(4), $c(this.buf, t, this.pos), this.pos += 4;
      },
      writeSFixed32: function (t) {
        this.realloc(4), $c(this.buf, t, this.pos), this.pos += 4;
      },
      writeFixed64: function (t) {
        this.realloc(8), $c(this.buf, -1 & t, this.pos), $c(this.buf, Math.floor(t * Sc), this.pos + 4), this.pos += 8;
      },
      writeSFixed64: function (t) {
        this.realloc(8), $c(this.buf, -1 & t, this.pos), $c(this.buf, Math.floor(t * Sc), this.pos + 4), this.pos += 8;
      },
      writeVarint: function (t) {
        (t = +t || 0) > 268435455 || t < 0 ? function (t, e) {
          var r, n;
          if (t >= 0 ? (r = t % 4294967296 | 0, n = t / 4294967296 | 0) : (n = ~(-t / 4294967296), 4294967295 ^ (r = ~(-t % 4294967296)) ? r = r + 1 | 0 : (r = 0, n = n + 1 | 0)), t >= 0x10000000000000000 || t < -0x10000000000000000) throw new Error("Given varint doesn't fit into 10 bytes");
          e.realloc(10), function (t, e, r) {
            r.buf[r.pos++] = 127 & t | 128, t >>>= 7, r.buf[r.pos++] = 127 & t | 128, t >>>= 7, r.buf[r.pos++] = 127 & t | 128, t >>>= 7, r.buf[r.pos++] = 127 & t | 128, r.buf[r.pos] = 127 & (t >>>= 7);
          }(r, 0, e), function (t, e) {
            var r = (7 & t) << 4;
            e.buf[e.pos++] |= r | ((t >>>= 3) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t)))));
          }(n, e);
        }(t, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = t >>> 7 & 127))));
      },
      writeSVarint: function (t) {
        this.writeVarint(t < 0 ? 2 * -t - 1 : 2 * t);
      },
      writeBoolean: function (t) {
        this.writeVarint(Boolean(t));
      },
      writeString: function (t) {
        t = String(t), this.realloc(4 * t.length), this.pos++;
        var e = this.pos;

        this.pos = function (t, e, r) {
          for (var n, i, s = 0; s < e.length; s++) {
            if ((n = e.charCodeAt(s)) > 55295 && n < 57344) {
              if (!i) {
                n > 56319 || s + 1 === e.length ? (t[r++] = 239, t[r++] = 191, t[r++] = 189) : i = n;
                continue;
              }

              if (n < 56320) {
                t[r++] = 239, t[r++] = 191, t[r++] = 189, i = n;
                continue;
              }

              n = i - 55296 << 10 | n - 56320 | 65536, i = null;
            } else i && (t[r++] = 239, t[r++] = 191, t[r++] = 189, i = null);

            n < 128 ? t[r++] = n : (n < 2048 ? t[r++] = n >> 6 | 192 : (n < 65536 ? t[r++] = n >> 12 | 224 : (t[r++] = n >> 18 | 240, t[r++] = n >> 12 & 63 | 128), t[r++] = n >> 6 & 63 | 128), t[r++] = 63 & n | 128);
          }

          return r;
        }(this.buf, t, this.pos);

        var r = this.pos - e;
        r >= 128 && zc(e, r, this), this.pos = e - 1, this.writeVarint(r), this.pos += r;
      },
      writeFloat: function (t) {
        this.realloc(4), _c(this.buf, t, this.pos, !0, 23, 4), this.pos += 4;
      },
      writeDouble: function (t) {
        this.realloc(8), _c(this.buf, t, this.pos, !0, 52, 8), this.pos += 8;
      },
      writeBytes: function (t) {
        var e = t.length;
        this.writeVarint(e), this.realloc(e);

        for (var r = 0; r < e; r++) this.buf[this.pos++] = t[r];
      },
      writeRawMessage: function (t, e) {
        this.pos++;
        var r = this.pos;
        t(e, this);
        var n = this.pos - r;
        n >= 128 && zc(r, n, this), this.pos = r - 1, this.writeVarint(n), this.pos += n;
      },
      writeMessage: function (t, e, r) {
        this.writeTag(t, Ac.Bytes), this.writeRawMessage(e, r);
      },
      writePackedVarint: function (t, e) {
        e.length && this.writeMessage(t, Bc, e);
      },
      writePackedSVarint: function (t, e) {
        e.length && this.writeMessage(t, Ec, e);
      },
      writePackedBoolean: function (t, e) {
        e.length && this.writeMessage(t, Pc, e);
      },
      writePackedFloat: function (t, e) {
        e.length && this.writeMessage(t, Cc, e);
      },
      writePackedDouble: function (t, e) {
        e.length && this.writeMessage(t, Dc, e);
      },
      writePackedFixed32: function (t, e) {
        e.length && this.writeMessage(t, Vc, e);
      },
      writePackedSFixed32: function (t, e) {
        e.length && this.writeMessage(t, Fc, e);
      },
      writePackedFixed64: function (t, e) {
        e.length && this.writeMessage(t, Lc, e);
      },
      writePackedSFixed64: function (t, e) {
        e.length && this.writeMessage(t, Rc, e);
      },
      writeBytesField: function (t, e) {
        this.writeTag(t, Ac.Bytes), this.writeBytes(e);
      },
      writeFixed32Field: function (t, e) {
        this.writeTag(t, Ac.Fixed32), this.writeFixed32(e);
      },
      writeSFixed32Field: function (t, e) {
        this.writeTag(t, Ac.Fixed32), this.writeSFixed32(e);
      },
      writeFixed64Field: function (t, e) {
        this.writeTag(t, Ac.Fixed64), this.writeFixed64(e);
      },
      writeSFixed64Field: function (t, e) {
        this.writeTag(t, Ac.Fixed64), this.writeSFixed64(e);
      },
      writeVarintField: function (t, e) {
        this.writeTag(t, Ac.Varint), this.writeVarint(e);
      },
      writeSVarintField: function (t, e) {
        this.writeTag(t, Ac.Varint), this.writeSVarint(e);
      },
      writeStringField: function (t, e) {
        this.writeTag(t, Ac.Bytes), this.writeString(e);
      },
      writeFloatField: function (t, e) {
        this.writeTag(t, Ac.Fixed32), this.writeFloat(e);
      },
      writeDoubleField: function (t, e) {
        this.writeTag(t, Ac.Fixed64), this.writeDouble(e);
      },
      writeBooleanField: function (t, e) {
        this.writeVarintField(t, Boolean(e));
      }
    };

    class Zc {
      constructor(t, {
        pixelRatio: e,
        version: r,
        stretchX: n,
        stretchY: i,
        content: s
      }) {
        this.paddedRect = t, this.pixelRatio = e, this.stretchX = n, this.stretchY = i, this.content = s, this.version = r;
      }

      get tl() {
        return [this.paddedRect.x + 1, this.paddedRect.y + 1];
      }

      get br() {
        return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1];
      }

      get displaySize() {
        return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio];
      }

    }

    class Xc {
      constructor(t, e) {
        const r = {},
              n = {};
        this.haveRenderCallbacks = [];
        const i = [];
        this.addImages(t, r, i), this.addImages(e, n, i);
        const {
          w: s,
          h: a
        } = Gc(i),
              o = new Bl({
          width: s || 1,
          height: a || 1
        });

        for (const e in t) {
          const n = t[e],
                i = r[e].paddedRect;
          Bl.copy(n.data, o, {
            x: 0,
            y: 0
          }, {
            x: i.x + 1,
            y: i.y + 1
          }, n.data);
        }

        for (const t in e) {
          const r = e[t],
                i = n[t].paddedRect,
                s = i.x + 1,
                a = i.y + 1,
                l = r.data.width,
                u = r.data.height;
          Bl.copy(r.data, o, {
            x: 0,
            y: 0
          }, {
            x: s,
            y: a
          }, r.data), Bl.copy(r.data, o, {
            x: 0,
            y: u - 1
          }, {
            x: s,
            y: a - 1
          }, {
            width: l,
            height: 1
          }), Bl.copy(r.data, o, {
            x: 0,
            y: 0
          }, {
            x: s,
            y: a + u
          }, {
            width: l,
            height: 1
          }), Bl.copy(r.data, o, {
            x: l - 1,
            y: 0
          }, {
            x: s - 1,
            y: a
          }, {
            width: 1,
            height: u
          }), Bl.copy(r.data, o, {
            x: 0,
            y: 0
          }, {
            x: s + l,
            y: a
          }, {
            width: 1,
            height: u
          });
        }

        this.image = o, this.iconPositions = r, this.patternPositions = n;
      }

      addImages(t, e, r) {
        for (const n in t) {
          const i = t[n],
                s = {
            x: 0,
            y: 0,
            w: i.data.width + 2,
            h: i.data.height + 2
          };
          r.push(s), e[n] = new Zc(s, i), i.hasRenderCallback && this.haveRenderCallbacks.push(n);
        }
      }

      patchUpdatedImages(t, e) {
        this.haveRenderCallbacks = this.haveRenderCallbacks.filter(e => t.hasImage(e)), t.dispatchRenderCallbacks(this.haveRenderCallbacks);

        for (const r in t.updatedImages) this.patchUpdatedImage(this.iconPositions[r], t.getImage(r), e), this.patchUpdatedImage(this.patternPositions[r], t.getImage(r), e);
      }

      patchUpdatedImage(t, e, r) {
        if (!t || !e) return;
        if (t.version === e.version) return;
        t.version = e.version;
        const [n, i] = t.tl;
        r.update(e.data, void 0, {
          x: n,
          y: i
        });
      }

    }

    ai(Zc, "ImagePosition"), ai(Xc, "ImageAtlas");
    const Kc = {
      horizontal: 1,
      vertical: 2,
      horizontalOnly: 3
    };

    class Yc {
      constructor() {
        this.scale = 1, this.fontStack = "", this.imageName = null;
      }

      static forText(t, e) {
        const r = new Yc();
        return r.scale = t || 1, r.fontStack = e, r;
      }

      static forImage(t) {
        const e = new Yc();
        return e.imageName = t, e;
      }

    }

    class Hc {
      constructor() {
        this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
      }

      static fromFeature(t, e) {
        const r = new Hc();

        for (let n = 0; n < t.sections.length; n++) {
          const i = t.sections[n];
          i.image ? r.addImageSection(i) : r.addTextSection(i, e);
        }

        return r;
      }

      length() {
        return this.text.length;
      }

      getSection(t) {
        return this.sections[this.sectionIndex[t]];
      }

      getSections() {
        return this.sections;
      }

      getSectionIndex(t) {
        return this.sectionIndex[t];
      }

      getCharCode(t) {
        return this.text.charCodeAt(t);
      }

      verticalizePunctuation(t) {
        this.text = function (t, e) {
          let r = "";

          for (let n = 0; n < t.length; n++) {
            const i = t.charCodeAt(n + 1) || null,
                  s = t.charCodeAt(n - 1) || null;
            r += !e && (i && qi(i) && !gc[t[n + 1]] || s && qi(s) && !gc[t[n - 1]]) || !gc[t[n]] ? t[n] : gc[t[n]];
          }

          return r;
        }(this.text, t);
      }

      trim() {
        let t = 0;

        for (let e = 0; e < this.text.length && Jc[this.text.charCodeAt(e)]; e++) t++;

        let e = this.text.length;

        for (let r = this.text.length - 1; r >= 0 && r >= t && Jc[this.text.charCodeAt(r)]; r--) e--;

        this.text = this.text.substring(t, e), this.sectionIndex = this.sectionIndex.slice(t, e);
      }

      substring(t, e) {
        const r = new Hc();
        return r.text = this.text.substring(t, e), r.sectionIndex = this.sectionIndex.slice(t, e), r.sections = this.sections, r;
      }

      toString() {
        return this.text;
      }

      getMaxScale() {
        return this.sectionIndex.reduce((t, e) => Math.max(t, this.sections[e].scale), 0);
      }

      addTextSection(t, e) {
        this.text += t.text, this.sections.push(Yc.forText(t.scale, t.fontStack || e));
        const r = this.sections.length - 1;

        for (let e = 0; e < t.text.length; ++e) this.sectionIndex.push(r);
      }

      addImageSection(t) {
        const e = t.image ? t.image.name : "";
        if (0 === e.length) return void C("Can't add FormattedSection with an empty image.");
        const r = this.getNextImageSectionCharCode();
        r ? (this.text += String.fromCharCode(r), this.sections.push(Yc.forImage(e)), this.sectionIndex.push(this.sections.length - 1)) : C("Reached maximum number of images 6401");
      }

      getNextImageSectionCharCode() {
        return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
      }

    }

    function Wc(t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y) {
      const m = Hc.fromFeature(t, i);
      let g;
      h === Kc.vertical && m.verticalizePunctuation(p);
      const {
        processBidirectionalText: x,
        processStyledBidirectionalText: v
      } = is;

      if (x && 1 === m.sections.length) {
        g = [];
        const t = x(m.toString(), sh(m, u, s, e, n, f, d));

        for (const e of t) {
          const t = new Hc();
          t.text = e, t.sections = m.sections;

          for (let r = 0; r < e.length; r++) t.sectionIndex.push(0);

          g.push(t);
        }
      } else if (v) {
        g = [];
        const t = v(m.text, m.sectionIndex, sh(m, u, s, e, n, f, d));

        for (const e of t) {
          const t = new Hc();
          t.text = e[0], t.sectionIndex = e[1], t.sections = m.sections, g.push(t);
        }
      } else g = function (t, e) {
        const r = [],
              n = t.text;
        let i = 0;

        for (const n of e) r.push(t.substring(i, n)), i = n;

        return i < n.length && r.push(t.substring(i, n.length)), r;
      }(m, sh(m, u, s, e, n, f, d));

      const b = [],
            _ = {
        positionedLines: b,
        text: m.toString(),
        top: c[1],
        bottom: c[1],
        left: c[0],
        right: c[0],
        writingMode: h,
        iconsInText: !1,
        verticalizable: !1,
        hasBaseline: !1
      };
      return function (t, e, r, n, i, s, a, o, l, u, c, h) {
        let p = 0,
            f = 0,
            d = 0;
        const y = "right" === o ? 1 : "left" === o ? 0 : .5;
        let m = !1;

        for (const t of i) {
          const r = t.getSections();

          for (const t of r) {
            if (t.imageName) continue;
            const r = e[t.fontStack];
            if (r && (m = void 0 !== r.ascender && void 0 !== r.descender, !m)) break;
          }

          if (!m) break;
        }

        let g = 0;

        for (const a of i) {
          a.trim();
          const i = a.getMaxScale(),
                o = (i - 1) * cc,
                v = {
            positionedGlyphs: [],
            lineOffset: 0
          };
          t.positionedLines[g] = v;
          const b = v.positionedGlyphs;
          let _ = 0;

          if (!a.length()) {
            f += s, ++g;
            continue;
          }

          let w = 0,
              A = 0;

          for (let s = 0; s < a.length(); s++) {
            const o = a.getSection(s),
                  d = a.getSectionIndex(s),
                  y = a.getCharCode(s);
            let g = o.scale,
                v = null,
                k = null,
                S = null,
                I = cc,
                M = 0;
            const T = !(l === Kc.horizontal || !c && !Oi(y) || c && (Jc[y] || (x = y, pi(x) || fi(x) || di(x) || Di(x) || Li(x))));

            if (o.imageName) {
              const e = n[o.imageName];
              if (!e) continue;
              S = o.imageName, t.iconsInText = t.iconsInText || !0, k = e.paddedRect;
              const r = e.displaySize;
              g = g * cc / h, v = {
                width: r[0],
                height: r[1],
                left: 1,
                top: -3,
                advance: T ? r[1] : r[0],
                localGlyph: !1
              }, M = m ? -v.height * g : i * cc - 17 - r[1] * g, I = v.advance;
              const s = (T ? r[0] : r[1]) * g - cc * i;
              s > 0 && s > _ && (_ = s);
            } else {
              const t = r[o.fontStack];
              if (!t) continue;
              t[y] && (k = t[y]);
              const n = e[o.fontStack];
              if (!n) continue;
              const s = n.glyphs[y];
              if (!s) continue;

              if (v = s.metrics, I = 8203 !== y ? cc : 0, m) {
                const t = void 0 !== n.ascender ? Math.abs(n.ascender) : 0,
                      e = void 0 !== n.descender ? Math.abs(n.descender) : 0,
                      r = (t + e) * g;
                w < r && (w = r, A = (t - e) / 2 * g), M = -t * g;
              } else M = (i - g) * cc - 17;
            }

            T ? (t.verticalizable = !0, b.push({
              glyph: y,
              imageName: S,
              x: p,
              y: f + M,
              vertical: T,
              scale: g,
              localGlyph: v.localGlyph,
              fontStack: o.fontStack,
              sectionIndex: d,
              metrics: v,
              rect: k
            }), p += I * g + u) : (b.push({
              glyph: y,
              imageName: S,
              x: p,
              y: f + M,
              vertical: T,
              scale: g,
              localGlyph: v.localGlyph,
              fontStack: o.fontStack,
              sectionIndex: d,
              metrics: v,
              rect: k
            }), p += v.advance * g + u);
          }

          0 !== b.length && (d = Math.max(p - u, d), m ? oh(b, y, _, A, s * i / 2) : oh(b, y, _, 0, s / 2)), p = 0;
          const k = s * i + _;
          v.lineOffset = Math.max(_, o), f += k, ++g;
        }

        var x;
        const v = f,
              {
          horizontalAlign: b,
          verticalAlign: _
        } = ah(a);
        (function (t, e, r, n, i, s) {
          const a = (e - r) * i,
                o = -s * n;

          for (const e of t) for (const t of e.positionedGlyphs) t.x += a, t.y += o;
        })(t.positionedLines, y, b, _, d, v), t.top += -_ * v, t.bottom = t.top + v, t.left += -b * d, t.right = t.left + d, t.hasBaseline = m;
      }(_, e, r, n, g, a, o, l, h, u, p, y), !function (t) {
        for (const e of t) if (0 !== e.positionedGlyphs.length) return !1;

        return !0;
      }(b) && _;
    }

    const Jc = {
      9: !0,
      10: !0,
      11: !0,
      12: !0,
      13: !0,
      32: !0
    },
          Qc = {
      10: !0,
      32: !0,
      38: !0,
      40: !0,
      41: !0,
      43: !0,
      45: !0,
      47: !0,
      173: !0,
      183: !0,
      8203: !0,
      8208: !0,
      8211: !0,
      8231: !0
    };

    function th(t, e, r, n, i, s) {
      if (e.imageName) {
        const t = n[e.imageName];
        return t ? t.displaySize[0] * e.scale * cc / s + i : 0;
      }

      {
        const n = r[e.fontStack],
              s = n && n.glyphs[t];
        return s ? s.metrics.advance * e.scale + i : 0;
      }
    }

    function eh(t, e, r, n) {
      const i = Math.pow(t - e, 2);
      return n ? t < e ? i / 2 : 2 * i : i + Math.abs(r) * r;
    }

    function rh(t, e, r) {
      let n = 0;
      return 10 === t && (n -= 1e4), r && (n += 150), 40 !== t && 65288 !== t || (n += 50), 41 !== e && 65289 !== e || (n += 50), n;
    }

    function nh(t, e, r, n, i, s) {
      let a = null,
          o = eh(e, r, i, s);

      for (const t of n) {
        const n = eh(e - t.x, r, i, s) + t.badness;
        n <= o && (a = t, o = n);
      }

      return {
        index: t,
        x: e,
        priorBreak: a,
        badness: o
      };
    }

    function ih(t) {
      return t ? ih(t.priorBreak).concat(t.index) : [];
    }

    function sh(t, e, r, n, i, s, a) {
      if ("point" !== s) return [];
      if (!t) return [];

      const o = [],
            l = function (t, e, r, n, i, s) {
        let a = 0;

        for (let r = 0; r < t.length(); r++) {
          const o = t.getSection(r);
          a += th(t.getCharCode(r), o, n, i, e, s);
        }

        return a / Math.max(1, Math.ceil(a / r));
      }(t, e, r, n, i, a),
            u = t.text.indexOf("​") >= 0;

      let c = 0;

      for (let r = 0; r < t.length(); r++) {
        const s = t.getSection(r),
              p = t.getCharCode(r);

        if (Jc[p] || (c += th(p, s, n, i, e, a)), r < t.length() - 1) {
          const e = !((h = p) < 11904 || !(wi(h) || _i(h) || Vi(h) || Ci(h) || Ii(h) || yi(h) || Ai(h) || xi(h) || Mi(h) || Ti(h) || Si(h) || Ri(h) || vi(h) || gi(h) || mi(h) || ki(h) || bi(h) || Pi(h) || Bi(h) || zi(h)));
          (Qc[p] || e || s.imageName) && o.push(nh(r + 1, c, l, o, rh(p, t.getCharCode(r + 1), e && u), !1));
        }
      }

      var h;
      return ih(nh(t.length(), c, l, o, 0, !0));
    }

    function ah(t) {
      let e = .5,
          r = .5;

      switch (t) {
        case "right":
        case "top-right":
        case "bottom-right":
          e = 1;
          break;

        case "left":
        case "top-left":
        case "bottom-left":
          e = 0;
      }

      switch (t) {
        case "bottom":
        case "bottom-right":
        case "bottom-left":
          r = 1;
          break;

        case "top":
        case "top-right":
        case "top-left":
          r = 0;
      }

      return {
        horizontalAlign: e,
        verticalAlign: r
      };
    }

    function oh(t, e, r, n, i) {
      if (!(e || r || n || i)) return;
      const s = t.length - 1,
            a = t[s],
            o = (a.x + a.metrics.advance * a.scale) * e;

      for (let e = 0; e <= s; e++) t[e].x -= o, t[e].y += r + n + i;
    }

    function lh(t, e, r) {
      const {
        horizontalAlign: n,
        verticalAlign: i
      } = ah(r),
            s = e[0] - t.displaySize[0] * n,
            a = e[1] - t.displaySize[1] * i;
      return {
        image: t,
        top: a,
        bottom: a + t.displaySize[1],
        left: s,
        right: s + t.displaySize[0]
      };
    }

    function uh(t, e, r, n, i, s) {
      const a = t.image;
      let o;

      if (a.content) {
        const t = a.content,
              e = a.pixelRatio || 1;
        o = [t[0] / e, t[1] / e, a.displaySize[0] - t[2] / e, a.displaySize[1] - t[3] / e];
      }

      const l = e.left * s,
            u = e.right * s;
      let c, h, p, f;
      "width" === r || "both" === r ? (f = i[0] + l - n[3], h = i[0] + u + n[1]) : (f = i[0] + (l + u - a.displaySize[0]) / 2, h = f + a.displaySize[0]);
      const d = e.top * s,
            y = e.bottom * s;
      return "height" === r || "both" === r ? (c = i[1] + d - n[0], p = i[1] + y + n[2]) : (c = i[1] + (d + y - a.displaySize[1]) / 2, p = c + a.displaySize[1]), {
        image: a,
        top: c,
        right: h,
        bottom: p,
        left: f,
        collisionPadding: o
      };
    }

    class ch extends i {
      constructor(t, e, r, n, i) {
        super(t, e), this.angle = n, this.z = r, void 0 !== i && (this.segment = i);
      }

      clone() {
        return new ch(this.x, this.y, this.z, this.angle, this.segment);
      }

    }

    function hh(t, e, r, n, i) {
      if (void 0 === e.segment) return !0;
      let s = e,
          a = e.segment + 1,
          o = 0;

      for (; o > -r / 2;) {
        if (a--, a < 0) return !1;
        o -= t[a].dist(s), s = t[a];
      }

      o += t[a].dist(t[a + 1]), a++;
      const l = [];
      let u = 0;

      for (; o < r / 2;) {
        const e = t[a],
              r = t[a + 1];
        if (!r) return !1;
        let s = t[a - 1].angleTo(e) - e.angleTo(r);

        for (s = Math.abs((s + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l.push({
          distance: o,
          angleDelta: s
        }), u += s; o - l[0].distance > n;) u -= l.shift().angleDelta;

        if (u > i) return !1;
        a++, o += e.dist(r);
      }

      return !0;
    }

    function ph(t) {
      let e = 0;

      for (let r = 0; r < t.length - 1; r++) e += t[r].dist(t[r + 1]);

      return e;
    }

    function fh(t, e, r) {
      return t ? .6 * e * r : 0;
    }

    function dh(t, e) {
      return Math.max(t ? t.right - t.left : 0, e ? e.right - e.left : 0);
    }

    function yh(t, e, r, n, i, s) {
      const a = fh(r, i, s),
            o = dh(r, n) * s;
      let l = 0;
      const u = ph(t) / 2;

      for (let r = 0; r < t.length - 1; r++) {
        const n = t[r],
              i = t[r + 1],
              s = n.dist(i);

        if (l + s > u) {
          const c = (u - l) / s,
                h = rr(n.x, i.x, c),
                p = rr(n.y, i.y, c),
                f = new ch(h, p, 0, i.angleTo(n), r);
          return !a || hh(t, f, o, a, e) ? f : void 0;
        }

        l += s;
      }
    }

    function mh(t, e, r, n, i, s, a, o, l) {
      const u = fh(n, s, a),
            c = dh(n, i),
            h = c * a,
            p = 0 === t[0].x || t[0].x === l || 0 === t[0].y || t[0].y === l;
      return e - h < e / 4 && (e = h + e / 4), gh(t, p ? e / 2 * o % e : (c / 2 + 2 * s) * a * o % e, e, u, r, h, p, !1, l);
    }

    function gh(t, e, r, n, i, s, a, o, l) {
      const u = s / 2,
            c = ph(t);
      let h = 0,
          p = e - r,
          f = [];

      for (let e = 0; e < t.length - 1; e++) {
        const a = t[e],
              o = t[e + 1],
              d = a.dist(o),
              y = o.angleTo(a);

        for (; p + r < h + d;) {
          p += r;
          const m = (p - h) / d,
                g = rr(a.x, o.x, m),
                x = rr(a.y, o.y, m);

          if (g >= 0 && g < l && x >= 0 && x < l && p - u >= 0 && p + u <= c) {
            const r = new ch(g, x, 0, y, e);
            r._round(), n && !hh(t, r, s, n, i) || f.push(r);
          }
        }

        h += d;
      }

      return o || f.length || a || (f = gh(t, h / 2, r, n, i, s, a, !0, l)), f;
    }

    function xh(t, e, r, n, s) {
      const a = [];

      for (let o = 0; o < t.length; o++) {
        const l = t[o];
        let u;

        for (let t = 0; t < l.length - 1; t++) {
          let o = l[t],
              c = l[t + 1];
          o.x < e && c.x < e || (o.x < e ? o = new i(e, o.y + (e - o.x) / (c.x - o.x) * (c.y - o.y))._round() : c.x < e && (c = new i(e, o.y + (e - o.x) / (c.x - o.x) * (c.y - o.y))._round()), o.y < r && c.y < r || (o.y < r ? o = new i(o.x + (r - o.y) / (c.y - o.y) * (c.x - o.x), r)._round() : c.y < r && (c = new i(o.x + (r - o.y) / (c.y - o.y) * (c.x - o.x), r)._round()), o.x >= n && c.x >= n || (o.x >= n ? o = new i(n, o.y + (n - o.x) / (c.x - o.x) * (c.y - o.y))._round() : c.x >= n && (c = new i(n, o.y + (n - o.x) / (c.x - o.x) * (c.y - o.y))._round()), o.y >= s && c.y >= s || (o.y >= s ? o = new i(o.x + (s - o.y) / (c.y - o.y) * (c.x - o.x), s)._round() : c.y >= s && (c = new i(o.x + (s - o.y) / (c.y - o.y) * (c.x - o.x), s)._round()), u && o.equals(u[u.length - 1]) || (u = [o], a.push(u)), u.push(c)))));
        }
      }

      return a;
    }

    ai(ch, "Anchor");
    const vh = 1e20;

    function bh(t, e, r, n, i, s, a, o, l) {
      for (let u = e; u < e + n; u++) _h(t, r * s + u, s, i, a, o, l);

      for (let u = r; u < r + i; u++) _h(t, u * s + e, 1, n, a, o, l);
    }

    function _h(t, e, r, n, i, s, a) {
      s[0] = 0, a[0] = -vh, a[1] = vh, i[0] = t[e];

      for (let o = 1, l = 0, u = 0; o < n; o++) {
        i[o] = t[e + o * r];
        const n = o * o;

        do {
          const t = s[l];
          u = (i[o] - i[t] + n - t * t) / (o - t) / 2;
        } while (u <= a[l] && --l > -1);

        l++, s[l] = o, a[l] = u, a[l + 1] = vh;
      }

      for (let o = 0, l = 0; o < n; o++) {
        for (; a[l + 1] < o;) l++;

        const n = s[l],
              u = o - n;
        t[e + o * r] = i[n] + u * u;
      }
    }

    const wh = {
      none: 0,
      ideographs: 1,
      all: 2
    };

    class Ah {
      constructor(t, e, r) {
        this.requestManager = t, this.localGlyphMode = e, this.localFontFamily = r, this.entries = {}, this.localGlyphs = {
          200: {},
          400: {},
          500: {},
          900: {}
        };
      }

      setURL(t) {
        this.url = t;
      }

      getGlyphs(t, e) {
        const r = [];

        for (const e in t) for (const n of t[e]) r.push({
          stack: e,
          id: n
        });

        x(r, ({
          stack: t,
          id: e
        }, r) => {
          let n = this.entries[t];
          n || (n = this.entries[t] = {
            glyphs: {},
            requests: {},
            ranges: {},
            ascender: void 0,
            descender: void 0
          });
          let i = n.glyphs[e];
          if (void 0 !== i) return void r(null, {
            stack: t,
            id: e,
            glyph: i
          });
          if (i = this._tinySDF(n, t, e), i) return n.glyphs[e] = i, void r(null, {
            stack: t,
            id: e,
            glyph: i
          });
          const s = Math.floor(e / 256);
          if (256 * s > 65535) return void r(new Error("glyphs > 65535 not supported"));
          if (n.ranges[s]) return void r(null, {
            stack: t,
            id: e,
            glyph: i
          });
          let a = n.requests[s];
          a || (a = n.requests[s] = [], Ah.loadGlyphRange(t, s, this.url, this.requestManager, (t, e) => {
            if (e) {
              n.ascender = e.ascender, n.descender = e.descender;

              for (const t in e.glyphs) this._doesCharSupportLocalGlyph(+t) || (n.glyphs[+t] = e.glyphs[+t]);

              n.ranges[s] = !0;
            }

            for (const r of a) r(t, e);

            delete n.requests[s];
          })), a.push((n, i) => {
            n ? r(n) : i && r(null, {
              stack: t,
              id: e,
              glyph: i.glyphs[e] || null
            });
          });
        }, (t, r) => {
          if (t) e(t);else if (r) {
            const t = {};

            for (const {
              stack: e,
              id: n,
              glyph: i
            } of r) void 0 === t[e] && (t[e] = {}), void 0 === t[e].glyphs && (t[e].glyphs = {}), t[e].glyphs[n] = i && {
              id: i.id,
              bitmap: i.bitmap.clone(),
              metrics: i.metrics
            }, t[e].ascender = this.entries[e].ascender, t[e].descender = this.entries[e].descender;

            e(null, t);
          }
        });
      }

      _doesCharSupportLocalGlyph(t) {
        return this.localGlyphMode !== wh.none && (this.localGlyphMode === wh.all ? !!this.localFontFamily : !!this.localFontFamily && (Ti(t) || Ei(t) || vi(t) || bi(t) || xi(t)));
      }

      _tinySDF(t, e, r) {
        const n = this.localFontFamily;
        if (!n || !this._doesCharSupportLocalGlyph(r)) return;
        let i = t.tinySDF;

        if (!i) {
          let r = "400";
          /bold/i.test(e) ? r = "900" : /medium/i.test(e) ? r = "500" : /light/i.test(e) && (r = "200"), i = t.tinySDF = new Ah.TinySDF({
            fontFamily: n,
            fontWeight: r,
            fontSize: 48,
            buffer: 6,
            radius: 16
          }), i.fontWeight = r;
        }

        if (this.localGlyphs[i.fontWeight][r]) return this.localGlyphs[i.fontWeight][r];
        const s = String.fromCharCode(r),
              {
          data: a,
          width: o,
          height: l,
          glyphWidth: u,
          glyphHeight: c,
          glyphLeft: h,
          glyphTop: p,
          glyphAdvance: f
        } = i.draw(s);
        return this.localGlyphs[i.fontWeight][r] = {
          id: r,
          bitmap: new zl({
            width: o,
            height: l
          }, a),
          metrics: {
            width: u / 2,
            height: c / 2,
            left: h / 2,
            top: p / 2 - 27,
            advance: f / 2,
            localGlyph: !0
          }
        };
      }

    }

    function kh(t, e, r, n) {
      const s = [],
            a = t.image,
            o = a.pixelRatio,
            l = a.paddedRect.w - 2,
            u = a.paddedRect.h - 2,
            c = t.right - t.left,
            h = t.bottom - t.top,
            p = a.stretchX || [[0, l]],
            f = a.stretchY || [[0, u]],
            d = (t, e) => t + e[1] - e[0],
            y = p.reduce(d, 0),
            m = f.reduce(d, 0),
            g = l - y,
            x = u - m;

      let v = 0,
          b = y,
          _ = 0,
          w = m,
          A = 0,
          k = g,
          S = 0,
          I = x;

      if (a.content && n) {
        const t = a.content;
        v = Sh(p, 0, t[0]), _ = Sh(f, 0, t[1]), b = Sh(p, t[0], t[2]), w = Sh(f, t[1], t[3]), A = t[0] - v, S = t[1] - _, k = t[2] - t[0] - b, I = t[3] - t[1] - w;
      }

      const M = (n, s, l, u) => {
        const p = Mh(n.stretch - v, b, c, t.left),
              f = Th(n.fixed - A, k, n.stretch, y),
              d = Mh(s.stretch - _, w, h, t.top),
              g = Th(s.fixed - S, I, s.stretch, m),
              x = Mh(l.stretch - v, b, c, t.left),
              M = Th(l.fixed - A, k, l.stretch, y),
              T = Mh(u.stretch - _, w, h, t.top),
              z = Th(u.fixed - S, I, u.stretch, m),
              B = new i(p, d),
              E = new i(x, d),
              C = new i(x, T),
              D = new i(p, T),
              P = new i(f / o, g / o),
              V = new i(M / o, z / o),
              F = e * Math.PI / 180;

        if (F) {
          const t = Math.sin(F),
                e = Math.cos(F),
                r = [e, -t, t, e];
          B._matMult(r), E._matMult(r), D._matMult(r), C._matMult(r);
        }

        const L = n.stretch + n.fixed,
              R = s.stretch + s.fixed;
        return {
          tl: B,
          tr: E,
          bl: D,
          br: C,
          tex: {
            x: a.paddedRect.x + 1 + L,
            y: a.paddedRect.y + 1 + R,
            w: l.stretch + l.fixed - L,
            h: u.stretch + u.fixed - R
          },
          writingMode: void 0,
          glyphOffset: [0, 0],
          sectionIndex: 0,
          pixelOffsetTL: P,
          pixelOffsetBR: V,
          minFontScaleX: k / o / c,
          minFontScaleY: I / o / h,
          isSDF: r
        };
      };

      if (n && (a.stretchX || a.stretchY)) {
        const t = Ih(p, g, y),
              e = Ih(f, x, m);

        for (let r = 0; r < t.length - 1; r++) {
          const n = t[r],
                i = t[r + 1];

          for (let t = 0; t < e.length - 1; t++) s.push(M(n, e[t], i, e[t + 1]));
        }
      } else s.push(M({
        fixed: 0,
        stretch: -1
      }, {
        fixed: 0,
        stretch: -1
      }, {
        fixed: 0,
        stretch: l + 1
      }, {
        fixed: 0,
        stretch: u + 1
      }));

      return s;
    }

    function Sh(t, e, r) {
      let n = 0;

      for (const i of t) n += Math.max(e, Math.min(r, i[1])) - Math.max(e, Math.min(r, i[0]));

      return n;
    }

    function Ih(t, e, r) {
      const n = [{
        fixed: -1,
        stretch: 0
      }];

      for (const [e, r] of t) {
        const t = n[n.length - 1];
        n.push({
          fixed: e - t.stretch,
          stretch: t.stretch
        }), n.push({
          fixed: e - t.stretch,
          stretch: t.stretch + (r - e)
        });
      }

      return n.push({
        fixed: e + 1,
        stretch: r
      }), n;
    }

    function Mh(t, e, r, n) {
      return t / e * r + n;
    }

    function Th(t, e, r, n) {
      return t - e * r / n;
    }

    function zh(t, e, r, n) {
      const i = e + t.positionedLines[n].lineOffset;
      return 0 === n ? r + i / 2 : r + (i + (e + t.positionedLines[n - 1].lineOffset)) / 2;
    }

    Ah.loadGlyphRange = function (t, e, r, n, i) {
      const s = 256 * e,
            a = s + 255,
            o = n.transformRequest(n.normalizeGlyphsURL(r).replace("{fontstack}", t).replace("{range}", `${s}-${a}`), At.Glyphs);
      Mt(o, (t, e) => {
        if (t) i(t);else if (e) {
          const t = {},
                r = function (t) {
            return new wc(t).readFields(Oc, {});
          }(e);

          for (const e of r.glyphs) t[e.id] = e;

          i(null, {
            glyphs: t,
            ascender: r.ascender,
            descender: r.descender
          });
        }
      });
    }, Ah.TinySDF = class {
      constructor({
        fontSize: t = 24,
        buffer: e = 3,
        radius: r = 8,
        cutoff: n = .25,
        fontFamily: i = "sans-serif",
        fontWeight: s = "normal",
        fontStyle: a = "normal"
      }) {
        this.buffer = e, this.cutoff = n, this.radius = r;

        const o = this.size = t + 4 * e,
              l = this._createCanvas(o),
              u = this.ctx = l.getContext("2d", {
          willReadFrequently: !0
        });

        u.font = `${a} ${s} ${t}px ${i}`, u.textBaseline = "alphabetic", u.textAlign = "left", u.fillStyle = "black", this.gridOuter = new Float64Array(o * o), this.gridInner = new Float64Array(o * o), this.f = new Float64Array(o), this.z = new Float64Array(o + 1), this.v = new Uint16Array(o);
      }

      _createCanvas(t) {
        const e = document.createElement("canvas");
        return e.width = e.height = t, e;
      }

      draw(t) {
        const {
          width: e,
          actualBoundingBoxAscent: r,
          actualBoundingBoxDescent: n,
          actualBoundingBoxLeft: i,
          actualBoundingBoxRight: s
        } = this.ctx.measureText(t),
              a = Math.floor(r),
              o = Math.min(this.size - this.buffer, Math.ceil(s - i)),
              l = Math.min(this.size - this.buffer, Math.ceil(r) + Math.ceil(n)),
              u = o + 2 * this.buffer,
              c = l + 2 * this.buffer,
              h = u * c,
              p = new Uint8ClampedArray(h),
              f = {
          data: p,
          width: u,
          height: c,
          glyphWidth: o,
          glyphHeight: l,
          glyphTop: a,
          glyphLeft: 0,
          glyphAdvance: e
        };
        if (0 === o || 0 === l) return f;
        const {
          ctx: d,
          buffer: y,
          gridInner: m,
          gridOuter: g
        } = this;
        d.clearRect(y, y, o, l), d.fillText(t, y, y + a + 1);
        const x = d.getImageData(y, y, o, l);
        g.fill(vh, 0, h), m.fill(0, 0, h);

        for (let t = 0; t < l; t++) for (let e = 0; e < o; e++) {
          const r = x.data[4 * (t * o + e) + 3] / 255;
          if (0 === r) continue;
          const n = (t + y) * u + e + y;
          if (1 === r) g[n] = 0, m[n] = vh;else {
            const t = .5 - r;
            g[n] = t > 0 ? t * t : 0, m[n] = t < 0 ? t * t : 0;
          }
        }

        bh(g, 0, 0, u, c, u, this.f, this.v, this.z), bh(m, y, y, o, l, u, this.f, this.v, this.z);

        for (let t = 0; t < h; t++) {
          const e = Math.sqrt(g[t]) - Math.sqrt(m[t]);
          p[t] = Math.round(255 - 255 * (e / this.radius + this.cutoff));
        }

        return f;
      }

    };

    class Bh {
      constructor(t = [], e = Eh) {
        if (this.data = t, this.length = this.data.length, this.compare = e, this.length > 0) for (let t = (this.length >> 1) - 1; t >= 0; t--) this._down(t);
      }

      push(t) {
        this.data.push(t), this.length++, this._up(this.length - 1);
      }

      pop() {
        if (0 === this.length) return;
        const t = this.data[0],
              e = this.data.pop();
        return this.length--, this.length > 0 && (this.data[0] = e, this._down(0)), t;
      }

      peek() {
        return this.data[0];
      }

      _up(t) {
        const {
          data: e,
          compare: r
        } = this,
              n = e[t];

        for (; t > 0;) {
          const i = t - 1 >> 1,
                s = e[i];
          if (r(n, s) >= 0) break;
          e[t] = s, t = i;
        }

        e[t] = n;
      }

      _down(t) {
        const {
          data: e,
          compare: r
        } = this,
              n = this.length >> 1,
              i = e[t];

        for (; t < n;) {
          let n = 1 + (t << 1),
              s = e[n];
          const a = n + 1;
          if (a < this.length && r(e[a], s) < 0 && (n = a, s = e[a]), r(s, i) >= 0) break;
          e[t] = s, t = n;
        }

        e[t] = i;
      }

    }

    function Eh(t, e) {
      return t < e ? -1 : t > e ? 1 : 0;
    }

    function Ch(t, e = 1, r = !1) {
      let n = 1 / 0,
          s = 1 / 0,
          a = -1 / 0,
          o = -1 / 0;
      const l = t[0];

      for (let t = 0; t < l.length; t++) {
        const e = l[t];
        (!t || e.x < n) && (n = e.x), (!t || e.y < s) && (s = e.y), (!t || e.x > a) && (a = e.x), (!t || e.y > o) && (o = e.y);
      }

      const u = Math.min(a - n, o - s);
      let c = u / 2;
      const h = new Bh([], Dh);
      if (0 === u) return new i(n, s);

      for (let e = n; e < a; e += u) for (let r = s; r < o; r += u) h.push(new Ph(e + c, r + c, c, t));

      let p = function (t) {
        let e = 0,
            r = 0,
            n = 0;
        const i = t[0];

        for (let t = 0, s = i.length, a = s - 1; t < s; a = t++) {
          const s = i[t],
                o = i[a],
                l = s.x * o.y - o.x * s.y;
          r += (s.x + o.x) * l, n += (s.y + o.y) * l, e += 3 * l;
        }

        return new Ph(r / e, n / e, 0, t);
      }(t),
          f = h.length;

      for (; h.length;) {
        const n = h.pop();
        (n.d > p.d || !p.d) && (p = n, r && console.log("found best %d after %d probes", Math.round(1e4 * n.d) / 1e4, f)), n.max - p.d <= e || (c = n.h / 2, h.push(new Ph(n.p.x - c, n.p.y - c, c, t)), h.push(new Ph(n.p.x + c, n.p.y - c, c, t)), h.push(new Ph(n.p.x - c, n.p.y + c, c, t)), h.push(new Ph(n.p.x + c, n.p.y + c, c, t)), f += 4);
      }

      return r && (console.log(`num probes: ${f}`), console.log(`best distance: ${p.d}`)), p.p;
    }

    function Dh(t, e) {
      return e.max - t.max;
    }

    function Ph(t, e, r, n) {
      this.p = new i(t, e), this.h = r, this.d = function (t, e) {
        let r = !1,
            n = 1 / 0;

        for (let i = 0; i < e.length; i++) {
          const s = e[i];

          for (let e = 0, i = s.length, a = i - 1; e < i; a = e++) {
            const i = s[e],
                  o = s[a];
            i.y > t.y != o.y > t.y && t.x < (o.x - i.x) * (t.y - i.y) / (o.y - i.y) + i.x && (r = !r), n = Math.min(n, Mo(t, i, o));
          }
        }

        return (r ? 1 : -1) * Math.sqrt(n);
      }(this.p, n), this.max = this.d + this.h * Math.SQRT2;
    }

    const Vh = Number.POSITIVE_INFINITY,
          Fh = Math.sqrt(2);

    function Lh(t, e) {
      return e[1] !== Vh ? function (t, e, r) {
        let n = 0,
            i = 0;

        switch (e = Math.abs(e), r = Math.abs(r), t) {
          case "top-right":
          case "top-left":
          case "top":
            i = r - 7;
            break;

          case "bottom-right":
          case "bottom-left":
          case "bottom":
            i = 7 - r;
        }

        switch (t) {
          case "top-right":
          case "bottom-right":
          case "right":
            n = -e;
            break;

          case "top-left":
          case "bottom-left":
          case "left":
            n = e;
        }

        return [n, i];
      }(t, e[0], e[1]) : function (t, e) {
        let r = 0,
            n = 0;
        e < 0 && (e = 0);
        const i = e / Fh;

        switch (t) {
          case "top-right":
          case "top-left":
            n = i - 7;
            break;

          case "bottom-right":
          case "bottom-left":
            n = 7 - i;
            break;

          case "bottom":
            n = 7 - e;
            break;

          case "top":
            n = e - 7;
        }

        switch (t) {
          case "top-right":
          case "bottom-right":
            r = -i;
            break;

          case "top-left":
          case "bottom-left":
            r = i;
            break;

          case "left":
            r = e;
            break;

          case "right":
            r = -e;
        }

        return [r, n];
      }(t, e[0]);
    }

    function Rh(t, e, r, n, i, s, a, o, l, u) {
      t.createArrays(), t.tilePixelRatio = Ya / (512 * t.overscaling), t.compareText = {}, t.iconsNeedLinear = !1;
      const c = t.layers[0].layout,
            h = t.layers[0]._unevaluatedLayout._values,
            p = {};

      if ("composite" === t.textSizeData.kind) {
        const {
          minZoom: e,
          maxZoom: r
        } = t.textSizeData;
        p.compositeTextSizes = [h["text-size"].possiblyEvaluate(new ss(e), o), h["text-size"].possiblyEvaluate(new ss(r), o)];
      }

      if ("composite" === t.iconSizeData.kind) {
        const {
          minZoom: e,
          maxZoom: r
        } = t.iconSizeData;
        p.compositeIconSizes = [h["icon-size"].possiblyEvaluate(new ss(e), o), h["icon-size"].possiblyEvaluate(new ss(r), o)];
      }

      p.layoutTextSize = h["text-size"].possiblyEvaluate(new ss(l + 1), o), p.layoutIconSize = h["icon-size"].possiblyEvaluate(new ss(l + 1), o), p.textMaxSize = h["text-size"].possiblyEvaluate(new ss(18), o);
      const f = "map" === c.get("text-rotation-alignment") && "point" !== c.get("symbol-placement"),
            d = c.get("text-size");

      for (const s of t.features) {
        const l = c.get("text-font").evaluate(s, {}, o).join(","),
              h = d.evaluate(s, {}, o),
              y = p.layoutTextSize.evaluate(s, {}, o),
              m = (p.layoutIconSize.evaluate(s, {}, o), {
          horizontal: {},
          vertical: void 0
        }),
              g = s.text;
        let x,
            v = [0, 0];

        if (g) {
          const n = g.toString(),
                a = c.get("text-letter-spacing").evaluate(s, {}, o) * cc,
                u = c.get("text-line-height").evaluate(s, {}, o) * cc,
                p = $i(n) ? a : 0,
                d = c.get("text-anchor").evaluate(s, {}, o),
                x = c.get("text-variable-anchor");

          if (!x) {
            const t = c.get("text-radial-offset").evaluate(s, {}, o);
            v = t ? Lh(d, [t * cc, Vh]) : c.get("text-offset").evaluate(s, {}, o).map(t => t * cc);
          }

          let b = f ? "center" : c.get("text-justify").evaluate(s, {}, o);

          const _ = c.get("symbol-placement"),
                w = "point" === _,
                A = "point" === _ ? c.get("text-max-width").evaluate(s, {}, o) * cc : 0,
                k = s => {
            t.allowVerticalPlacement && Ui(n) && (m.vertical = Wc(g, e, r, i, l, A, u, d, s, p, v, Kc.vertical, !0, _, y, h));
          };

          if (!f && x) {
            const t = "auto" === b ? x.map(t => Uh(t)) : [b];
            let n = !1;

            for (let s = 0; s < t.length; s++) {
              const a = t[s];
              if (!m.horizontal[a]) if (n) m.horizontal[a] = m.horizontal[0];else {
                const t = Wc(g, e, r, i, l, A, u, "center", a, p, v, Kc.horizontal, !1, _, y, h);
                t && (m.horizontal[a] = t, n = 1 === t.positionedLines.length);
              }
            }

            k("left");
          } else {
            if ("auto" === b && (b = Uh(d)), w || c.get("text-writing-mode").indexOf("horizontal") >= 0 || !Ui(n)) {
              const t = Wc(g, e, r, i, l, A, u, d, b, p, v, Kc.horizontal, !1, _, y, h);
              t && (m.horizontal[b] = t);
            }

            k("point" === _ ? "left" : b);
          }
        }

        let b = !1;

        if (s.icon && s.icon.name) {
          const e = n[s.icon.name];
          e && (x = lh(i[s.icon.name], c.get("icon-offset").evaluate(s, {}, o), c.get("icon-anchor").evaluate(s, {}, o)), b = e.sdf, void 0 === t.sdfIcons ? t.sdfIcons = e.sdf : t.sdfIcons !== e.sdf && C("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (e.pixelRatio !== t.pixelRatio || 0 !== c.get("icon-rotate").constantOr(1)) && (t.iconsNeedLinear = !0));
        }

        const _ = qh(m.horizontal) || m.vertical;

        t.iconsInText || (t.iconsInText = !!_ && _.iconsInText), (_ || x) && $h(t, s, m, x, n, p, y, 0, v, b, a, o, u);
      }

      s && t.generateCollisionDebugBuffers(l, t.collisionBoxArray);
    }

    function Uh(t) {
      switch (t) {
        case "right":
        case "top-right":
        case "bottom-right":
          return "right";

        case "left":
        case "top-left":
        case "bottom-left":
          return "left";
      }

      return "center";
    }

    function $h(t, e, r, n, i, s, a, o, l, c, h, p, f) {
      let d = s.textMaxSize.evaluate(e, {}, p);
      void 0 === d && (d = a);

      const y = t.layers[0].layout,
            m = y.get("icon-offset").evaluate(e, {}, p),
            g = qh(r.horizontal) || r.vertical,
            x = a / 24,
            v = t.tilePixelRatio * d / 24,
            b = (T = t.overscaling, t.zoom > 18 && T > 2 && (T >>= 1), Math.max(Ya / (512 * T), 1) * y.get("symbol-spacing")),
            _ = y.get("text-padding") * t.tilePixelRatio,
            w = y.get("icon-padding") * t.tilePixelRatio,
            A = u(y.get("text-max-angle")),
            k = "map" === y.get("text-rotation-alignment") && "point" !== y.get("symbol-placement"),
            S = "map" === y.get("icon-rotation-alignment") && "point" !== y.get("symbol-placement"),
            I = y.get("symbol-placement"),
            M = b / 2;

      var T;
      const z = y.get("icon-text-fit");
      let B;
      n && "none" !== z && (t.allowVerticalPlacement && r.vertical && (B = uh(n, r.vertical, z, y.get("icon-text-fit-padding"), m, x)), g && (n = uh(n, g, z, y.get("icon-text-fit-padding"), m, x)));

      const E = (a, o, u) => {
        if (o.x < 0 || o.x >= Ya || o.y < 0 || o.y >= Ya) return;
        const {
          x: d,
          y: y,
          z: g
        } = f.projectTilePoint(o.x, o.y, u),
              x = new ch(d, y, g, 0, void 0);
        !function (t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m, g, x, v, b, _, w, A, k) {
          const S = t.addToLineVertexArray(e, n);
          let I,
              M,
              T,
              z,
              B,
              E,
              D,
              P = 0,
              V = 0,
              F = 0,
              L = 0,
              R = -1,
              U = -1;
          const $ = {};
          let j = xa(""),
              O = 0,
              q = 0;

          if (void 0 === l._unevaluatedLayout.getValue("text-radial-offset") ? [O, q] = l.layout.get("text-offset").evaluate(b, {}, k).map(t => t * cc) : (O = l.layout.get("text-radial-offset").evaluate(b, {}, k) * cc, q = Vh), t.allowVerticalPlacement && i.vertical) {
            const t = i.vertical;
            if (d) E = Gh(t), o && (D = Gh(o));else {
              const n = l.layout.get("text-rotate").evaluate(b, {}, k) + 90;
              T = Nh(u, r, e, c, h, p, t, f, n, y), o && (z = Nh(u, r, e, c, h, p, o, g, n));
            }
          }

          if (s) {
            const n = l.layout.get("icon-rotate").evaluate(b, {}, k),
                  i = "none" !== l.layout.get("icon-text-fit"),
                  a = kh(s, n, w, i),
                  f = o ? kh(o, n, w, i) : void 0;
            M = Nh(u, r, e, c, h, p, s, g, n), P = 4 * a.length;
            const d = t.iconSizeData;
            let y = null;
            "source" === d.kind ? (y = [hc * l.layout.get("icon-size").evaluate(b, {}, k)], y[0] > jh && C(`${t.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)) : "composite" === d.kind && (y = [hc * _.compositeIconSizes[0].evaluate(b, {}, k), hc * _.compositeIconSizes[1].evaluate(b, {}, k)], (y[0] > jh || y[1] > jh) && C(`${t.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)), t.addSymbols(t.icon, a, y, v, x, b, !1, r, e, S.lineStartIndex, S.lineLength, -1, A, k), R = t.icon.placedSymbolArray.length - 1, f && (V = 4 * f.length, t.addSymbols(t.icon, f, y, v, x, b, Kc.vertical, r, e, S.lineStartIndex, S.lineLength, -1, A, k), U = t.icon.placedSymbolArray.length - 1);
          }

          for (const n in i.horizontal) {
            const s = i.horizontal[n];
            I || (j = xa(s.text), d ? B = Gh(s) : I = Nh(u, r, e, c, h, p, s, f, l.layout.get("text-rotate").evaluate(b, {}, k), y));
            const o = 1 === s.positionedLines.length;
            if (F += Oh(t, r, e, s, a, l, d, b, y, S, i.vertical ? Kc.horizontal : Kc.horizontalOnly, o ? Object.keys(i.horizontal) : [n], $, R, _, A, k), o) break;
          }

          i.vertical && (L += Oh(t, r, e, i.vertical, a, l, d, b, y, S, Kc.vertical, ["vertical"], $, U, _, A, k));
          let N = -1;

          const G = (t, e) => t ? Math.max(t, e) : e;

          N = G(B, N), N = G(E, N), N = G(D, N);
          const Z = N > -1 ? 1 : 0;
          t.glyphOffsetArray.length >= tp.MAX_GLYPHS && C("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), void 0 !== b.sortKey && t.addToSortKeyRanges(t.symbolInstances.length, b.sortKey), t.symbolInstances.emplaceBack(r.x, r.y, r.z, e.x, e.y, $.right >= 0 ? $.right : -1, $.center >= 0 ? $.center : -1, $.left >= 0 ? $.left : -1, $.vertical >= 0 ? $.vertical : -1, R, U, j, void 0 !== I ? I : t.collisionBoxArray.length, void 0 !== I ? I + 1 : t.collisionBoxArray.length, void 0 !== T ? T : t.collisionBoxArray.length, void 0 !== T ? T + 1 : t.collisionBoxArray.length, void 0 !== M ? M : t.collisionBoxArray.length, void 0 !== M ? M + 1 : t.collisionBoxArray.length, z || t.collisionBoxArray.length, z ? z + 1 : t.collisionBoxArray.length, c, F, L, P, V, Z, 0, O, q, N);
        }(t, o, x, a, r, n, i, B, t.layers[0], t.collisionBoxArray, e.index, e.sourceLayerIndex, t.index, _, k, l, 0, w, S, m, e, s, c, h, p);
      };

      if ("line" === I) for (const i of xh(e.geometry, 0, 0, Ya, Ya)) {
        const e = mh(i, b, A, r.vertical || g, n, 24, v, t.overscaling, Ya);

        for (const r of e) {
          const e = g;
          e && Zh(t, e.text, M, r) || E(i, r, p);
        }
      } else if ("line-center" === I) {
        for (const t of e.geometry) if (t.length > 1) {
          const e = yh(t, A, r.vertical || g, n, 24, v);
          e && E(t, e, p);
        }
      } else if ("Polygon" === e.type) for (const t of du(e.geometry, 0)) {
        const e = Ch(t, 16);
        E(t[0], new ch(e.x, e.y, 0, 0, void 0), p);
      } else if ("LineString" === e.type) for (const t of e.geometry) E(t, new ch(t[0].x, t[0].y, 0, 0, void 0), p);else if ("Point" === e.type) for (const t of e.geometry) for (const e of t) E([e], new ch(e.x, e.y, 0, 0, void 0), p);
    }

    const jh = 32640;

    function Oh(t, e, r, n, s, a, o, l, u, c, h, p, f, d, y, m, g) {
      const x = function (t, e, r, n, s, a, o, l) {
        const u = [];
        if (0 === e.positionedLines.length) return u;

        const c = n.layout.get("text-rotate").evaluate(a, {}) * Math.PI / 180,
              h = function (t) {
          const e = t[0],
                r = t[1],
                n = e * r;
          return n > 0 ? [e, -r] : n < 0 ? [-e, r] : 0 === e ? [r, e] : [r, -e];
        }(r);

        let p = Math.abs(e.top - e.bottom);

        for (const t of e.positionedLines) p -= t.lineOffset;

        const f = e.positionedLines.length,
              d = p / f;
        let y = e.top - r[1];

        for (let t = 0; t < f; ++t) {
          const n = e.positionedLines[t];
          y = zh(e, d, y, t);

          for (const t of n.positionedGlyphs) {
            if (!t.rect) continue;
            const n = t.rect || {};
            let a = 4,
                p = !0,
                f = 1,
                d = 0;

            if (t.imageName) {
              const e = o[t.imageName];
              if (!e) continue;

              if (e.sdf) {
                C("SDF images are not supported in formatted text and will be ignored.");
                continue;
              }

              p = !1, f = e.pixelRatio, a = 1 / f;
            }

            const m = (s || l) && t.vertical,
                  g = t.metrics.advance * t.scale / 2,
                  x = t.metrics,
                  v = t.rect;
            if (null === v) continue;
            l && e.verticalizable && (d = t.imageName ? g - t.metrics.width * t.scale / 2 : 0);
            const b = s ? [t.x + g, t.y] : [0, 0];
            let _ = [0, 0],
                w = [0, 0],
                A = !1;
            s || (m ? (w = [t.x + g + h[0], t.y + h[1] - d], A = !0) : _ = [t.x + g + r[0], t.y + r[1] - d]);
            const k = v.w * t.scale / (f * (t.localGlyph ? 2 : 1)),
                  S = v.h * t.scale / (f * (t.localGlyph ? 2 : 1));
            let I, M, T, z;

            if (m) {
              const e = t.y - y,
                    r = new i(-g, g - e),
                    n = -Math.PI / 2,
                    s = new i(...w);
              I = new i(-g + _[0], _[1]), I._rotateAround(n, r)._add(s), I.x += -e + g, I.y -= (x.left - a) * t.scale;
              const o = t.imageName ? x.advance * t.scale : cc * t.scale,
                    l = String.fromCharCode(t.glyph);
              xc(l) ? I.x += (1 - a) * t.scale : vc(l) ? I.x += o - x.height * t.scale + (-a - 1) * t.scale : I.x += t.imageName || x.width + 2 * a === v.w && x.height + 2 * a === v.h ? (o - S) / 2 : (o - (x.height + 2 * a) * t.scale) / 2, M = new i(I.x, I.y - k), T = new i(I.x + S, I.y), z = new i(I.x + S, I.y - k);
            } else {
              const e = (x.left - a) * t.scale - g + _[0],
                    r = (-x.top - a) * t.scale + _[1],
                    n = e + k,
                    s = r + S;
              I = new i(e, r), M = new i(n, r), T = new i(e, s), z = new i(n, s);
            }

            if (c) {
              let t;
              t = s ? new i(0, 0) : A ? new i(h[0], h[1]) : new i(r[0], r[1]), I._rotateAround(c, t), M._rotateAround(c, t), T._rotateAround(c, t), z._rotateAround(c, t);
            }

            const B = new i(0, 0),
                  E = new i(0, 0);
            u.push({
              tl: I,
              tr: M,
              bl: T,
              br: z,
              tex: n,
              writingMode: e.writingMode,
              glyphOffset: b,
              sectionIndex: t.sectionIndex,
              isSDF: p,
              pixelOffsetTL: B,
              pixelOffsetBR: E,
              minFontScaleX: 0,
              minFontScaleY: 0
            });
          }
        }

        return u;
      }(0, n, u, a, o, l, s, t.allowVerticalPlacement),
            v = t.textSizeData;

      let b = null;
      "source" === v.kind ? (b = [hc * a.layout.get("text-size").evaluate(l, {}, g)], b[0] > jh && C(`${t.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)) : "composite" === v.kind && (b = [hc * y.compositeTextSizes[0].evaluate(l, {}, g), hc * y.compositeTextSizes[1].evaluate(l, {}, g)], (b[0] > jh || b[1] > jh) && C(`${t.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)), t.addSymbols(t.text, x, b, u, o, l, h, e, r, c.lineStartIndex, c.lineLength, d, m, g);

      for (const e of p) f[e] = t.text.placedSymbolArray.length - 1;

      return 4 * x.length;
    }

    function qh(t) {
      for (const e in t) return t[e];

      return null;
    }

    function Nh(t, e, r, n, s, a, o, l, c, h) {
      let p = o.top,
          f = o.bottom,
          d = o.left,
          y = o.right;
      const m = o.collisionPadding;

      if (m && (d -= m[0], p -= m[1], y += m[2], f += m[3]), c) {
        const t = new i(d, p),
              e = new i(y, p),
              r = new i(d, f),
              n = new i(y, f),
              s = u(c);
        let a = new i(0, 0);
        h && (a = new i(h[0], h[1])), t._rotateAround(s, a), e._rotateAround(s, a), r._rotateAround(s, a), n._rotateAround(s, a), d = Math.min(t.x, e.x, r.x, n.x), y = Math.max(t.x, e.x, r.x, n.x), p = Math.min(t.y, e.y, r.y, n.y), f = Math.max(t.y, e.y, r.y, n.y);
      }

      return t.emplaceBack(e.x, e.y, e.z, r.x, r.y, d, p, y, f, l, n, s, a), t.length - 1;
    }

    function Gh(t) {
      t.collisionPadding && (t.top -= t.collisionPadding[1], t.bottom += t.collisionPadding[3]);
      const e = t.bottom - t.top;
      return e > 0 ? Math.max(10, e) : null;
    }

    function Zh(t, e, r, n) {
      const i = t.compareText;

      if (e in i) {
        const t = i[e];

        for (let e = t.length - 1; e >= 0; e--) if (n.dist(t[e]) < r) return !0;
      } else i[e] = [];

      return i[e].push(n), !1;
    }

    const Xh = Du.VectorTileFeature.types,
          Kh = [{
      name: "a_fade_opacity",
      components: 1,
      type: "Uint8",
      offset: 0
    }];

    function Yh(t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y) {
      const m = c ? Math.min(jh, Math.round(c[0])) : 0,
            g = c ? Math.min(jh, Math.round(c[1])) : 0;
      t.emplaceBack(e, r, Math.round(32 * a), Math.round(32 * o), l, u, (m << 1) + (h ? 1 : 0), g, 16 * p, 16 * f, 256 * d, 256 * y, n, i, s, 0);
    }

    function Hh(t, e, r) {
      t.emplaceBack(e.x, e.y, r), t.emplaceBack(e.x, e.y, r), t.emplaceBack(e.x, e.y, r), t.emplaceBack(e.x, e.y, r);
    }

    function Wh(t) {
      for (const e of t.sections) if (Zi(e.text)) return !0;

      return !1;
    }

    class Jh {
      constructor(t) {
        this.layoutVertexArray = new Ps(), this.indexArray = new js(), this.programConfigurations = t, this.segments = new Ka(), this.dynamicLayoutVertexArray = new Vs(), this.opacityVertexArray = new Fs(), this.placedSymbolArray = new na();
      }

      isEmpty() {
        return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length;
      }

      upload(t, e, r, n) {
        this.isEmpty() || (r && (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, ic.members), this.indexBuffer = t.createIndexBuffer(this.indexArray, e), this.dynamicLayoutVertexBuffer = t.createVertexBuffer(this.dynamicLayoutVertexArray, sc.members, !0), this.opacityVertexBuffer = t.createVertexBuffer(this.opacityVertexArray, Kh, !0), this.opacityVertexBuffer.itemSize = 1), (r || n) && this.programConfigurations.upload(t));
      }

      destroy() {
        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
      }

    }

    ai(Jh, "SymbolBuffers");

    class Qh {
      constructor(t, e, r) {
        this.layoutVertexArray = new t(), this.layoutAttributes = e, this.indexArray = new r(), this.segments = new Ka(), this.collisionVertexArray = new $s(), this.collisionVertexArrayExt = new Vs();
      }

      upload(t) {
        this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t.createVertexBuffer(this.collisionVertexArray, ac.members, !0), this.collisionVertexBufferExt = t.createVertexBuffer(this.collisionVertexArrayExt, oc.members, !0);
      }

      destroy() {
        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy(), this.collisionVertexBufferExt.destroy());
      }

    }

    ai(Qh, "CollisionBuffers");

    class tp {
      constructor(t) {
        this.collisionBoxArray = t.collisionBoxArray, this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(t => t.id), this.index = t.index, this.pixelRatio = t.pixelRatio, this.sourceLayerIndex = t.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.fullyClipped = !1, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = jo([]), this.placementViewportMatrix = jo([]);
        const e = this.layers[0]._unevaluatedLayout._values;
        this.textSizeData = pc(this.zoom, e["text-size"]), this.iconSizeData = pc(this.zoom, e["icon-size"]);
        const r = this.layers[0].layout,
              n = r.get("symbol-sort-key"),
              i = r.get("symbol-z-order");
        this.canOverlap = r.get("text-allow-overlap") || r.get("icon-allow-overlap") || r.get("text-ignore-placement") || r.get("icon-ignore-placement"), this.sortFeaturesByKey = "viewport-y" !== i && void 0 !== n.constantOr(1), this.sortFeaturesByY = ("viewport-y" === i || "auto" === i && !this.sortFeaturesByKey) && this.canOverlap, this.writingModes = r.get("text-writing-mode").map(t => Kc[t]), this.stateDependentLayerIds = this.layers.filter(t => t.isStateDependent()).map(t => t.id), this.sourceID = t.sourceID, this.projection = t.projection;
      }

      createArrays() {
        this.text = new Jh(new Ra(this.layers, this.zoom, t => /^text/.test(t))), this.icon = new Jh(new Ra(this.layers, this.zoom, t => /^icon/.test(t))), this.glyphOffsetArray = new aa(), this.lineVertexArray = new oa(), this.symbolInstances = new sa();
      }

      calculateGlyphDependencies(t, e, r, n, i) {
        for (let r = 0; r < t.length; r++) if (e[t.charCodeAt(r)] = !0, n && i) {
          const n = gc[t.charAt(r)];
          n && (e[n.charCodeAt(0)] = !0);
        }
      }

      populate(t, e, r, n) {
        const i = this.layers[0],
              s = i.layout,
              a = s.get("text-font"),
              o = s.get("text-field"),
              l = s.get("icon-image"),
              u = ("constant" !== o.value.kind || o.value.value instanceof fe && !o.value.value.isEmpty() || o.value.value.toString().length > 0) && ("constant" !== a.value.kind || a.value.value.length > 0),
              c = "constant" !== l.value.kind || !!l.value.value || Object.keys(l.parameters).length > 0,
              h = s.get("symbol-sort-key");
        if (this.features = [], !u && !c) return;
        const p = e.iconDependencies,
              f = e.glyphDependencies,
              d = e.availableImages,
              y = new ss(this.zoom);

        for (const {
          feature: e,
          id: o,
          index: l,
          sourceLayerIndex: m
        } of t) {
          const t = i._featureFilter.needGeometry,
                g = mo(e, t);
          if (!i._featureFilter.filter(y, g, r)) continue;
          let x, v;

          if (t || (g.geometry = yo(e, r, n)), u) {
            const t = i.getValueAndResolveTokens("text-field", g, r, d),
                  e = fe.factory(t);
            Wh(e) && (this.hasRTLText = !0), (!this.hasRTLText || "unavailable" === rs() || this.hasRTLText && is.isParsed()) && (x = mc(e, i, g));
          }

          if (c) {
            const t = i.getValueAndResolveTokens("icon-image", g, r, d);
            v = t instanceof de ? t : de.fromString(t);
          }

          if (!x && !v) continue;
          const b = this.sortFeaturesByKey ? h.evaluate(g, {}, r) : void 0;

          if (this.features.push({
            id: o,
            text: x,
            icon: v,
            index: l,
            sourceLayerIndex: m,
            geometry: g.geometry,
            properties: e.properties,
            type: Xh[e.type],
            sortKey: b
          }), v && (p[v.name] = !0), x) {
            const t = a.evaluate(g, {}, r).join(","),
                  e = "map" === s.get("text-rotation-alignment") && "point" !== s.get("symbol-placement");
            this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(Kc.vertical) >= 0;

            for (const r of x.sections) if (r.image) p[r.image.name] = !0;else {
              const n = Ui(x.toString()),
                    i = r.fontStack || t,
                    s = f[i] = f[i] || {};
              this.calculateGlyphDependencies(r.text, s, e, this.allowVerticalPlacement, n);
            }
          }
        }

        "line" === s.get("symbol-placement") && (this.features = function (t) {
          const e = {},
                r = {},
                n = [];
          let i = 0;

          function s(e) {
            n.push(t[e]), i++;
          }

          function a(t, e, i) {
            const s = r[t];
            return delete r[t], r[e] = s, n[s].geometry[0].pop(), n[s].geometry[0] = n[s].geometry[0].concat(i[0]), s;
          }

          function o(t, r, i) {
            const s = e[r];
            return delete e[r], e[t] = s, n[s].geometry[0].shift(), n[s].geometry[0] = i[0].concat(n[s].geometry[0]), s;
          }

          function l(t, e, r) {
            const n = r ? e[0][e[0].length - 1] : e[0][0];
            return `${t}:${n.x}:${n.y}`;
          }

          for (let u = 0; u < t.length; u++) {
            const c = t[u],
                  h = c.geometry,
                  p = c.text ? c.text.toString() : null;

            if (!p) {
              s(u);
              continue;
            }

            const f = l(p, h),
                  d = l(p, h, !0);

            if (f in r && d in e && r[f] !== e[d]) {
              const t = o(f, d, h),
                    i = a(f, d, n[t].geometry);
              delete e[f], delete r[d], r[l(p, n[i].geometry, !0)] = i, n[t].geometry = null;
            } else f in r ? a(f, d, h) : d in e ? o(f, d, h) : (s(u), e[f] = i - 1, r[d] = i - 1);
          }

          return n.filter(t => t.geometry);
        }(this.features)), this.sortFeaturesByKey && this.features.sort((t, e) => t.sortKey - e.sortKey);
      }

      update(t, e, r, n) {
        this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t, e, this.layers, r, n), this.icon.programConfigurations.updatePaintArrays(t, e, this.layers, r, n));
      }

      isEmpty() {
        return 0 === this.symbolInstances.length && !this.hasRTLText;
      }

      uploadPending() {
        return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
      }

      upload(t) {
        !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t), this.iconCollisionBox.upload(t)), this.text.upload(t, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0;
      }

      destroyDebugData() {
        this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
      }

      destroy() {
        this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
      }

      addToLineVertexArray(t, e) {
        const r = this.lineVertexArray.length,
              n = t.segment;

        if (void 0 !== n) {
          let r = t.dist(e[n + 1]),
              i = t.dist(e[n]);
          const s = {};

          for (let t = n + 1; t < e.length; t++) s[t] = {
            x: e[t].x,
            y: e[t].y,
            tileUnitDistanceFromAnchor: r
          }, t < e.length - 1 && (r += e[t + 1].dist(e[t]));

          for (let t = n || 0; t >= 0; t--) s[t] = {
            x: e[t].x,
            y: e[t].y,
            tileUnitDistanceFromAnchor: i
          }, t > 0 && (i += e[t - 1].dist(e[t]));

          for (let t = 0; t < e.length; t++) {
            const e = s[t];
            this.lineVertexArray.emplaceBack(e.x, e.y, e.tileUnitDistanceFromAnchor);
          }
        }

        return {
          lineStartIndex: r,
          lineLength: this.lineVertexArray.length - r
        };
      }

      addSymbols(t, e, r, n, i, s, a, o, l, u, c, h, p, f) {
        const d = t.indexArray,
              y = t.layoutVertexArray,
              m = t.segments.prepareSegment(4 * e.length, y, d, this.canOverlap ? s.sortKey : void 0),
              g = this.glyphOffsetArray.length,
              x = m.vertexLength,
              v = this.allowVerticalPlacement && a === Kc.vertical ? Math.PI / 2 : 0,
              b = s.text && s.text.sections;

        for (let n = 0; n < e.length; n++) {
          const {
            tl: i,
            tr: a,
            bl: u,
            br: c,
            tex: h,
            pixelOffsetTL: g,
            pixelOffsetBR: x,
            minFontScaleX: _,
            minFontScaleY: w,
            glyphOffset: A,
            isSDF: k,
            sectionIndex: S
          } = e[n],
                I = m.vertexLength,
                M = A[1];
          Yh(y, o.x, o.y, o.z, l.x, l.y, i.x, M + i.y, h.x, h.y, r, k, g.x, g.y, _, w), Yh(y, o.x, o.y, o.z, l.x, l.y, a.x, M + a.y, h.x + h.w, h.y, r, k, x.x, g.y, _, w), Yh(y, o.x, o.y, o.z, l.x, l.y, u.x, M + u.y, h.x, h.y + h.h, r, k, g.x, x.y, _, w), Yh(y, o.x, o.y, o.z, l.x, l.y, c.x, M + c.y, h.x + h.w, h.y + h.h, r, k, x.x, x.y, _, w), Hh(t.dynamicLayoutVertexArray, o, v), d.emplaceBack(I, I + 1, I + 2), d.emplaceBack(I + 1, I + 2, I + 3), m.vertexLength += 4, m.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(A[0]), n !== e.length - 1 && S === e[n + 1].sectionIndex || t.programConfigurations.populatePaintArrays(y.length, s, s.index, {}, p, f, b && b[S]);
        }

        t.placedSymbolArray.emplaceBack(o.x, o.y, o.z, l.x, l.y, g, this.glyphOffsetArray.length - g, x, u, c, l.segment, r ? r[0] : 0, r ? r[1] : 0, n[0], n[1], a, 0, !1, 0, h, 0);
      }

      _commitLayoutVertex(t, e, r, n, i, s, a) {
        t.emplaceBack(e, r, n, i, s, Math.round(a.x), Math.round(a.y));
      }

      _addCollisionDebugVertices(t, e, r, n, s, a, o) {
        const l = r.segments.prepareSegment(4, r.layoutVertexArray, r.indexArray),
              u = l.vertexLength,
              c = o.tileAnchorX,
              h = o.tileAnchorY;

        for (let t = 0; t < 4; t++) r.collisionVertexArray.emplaceBack(0, 0, 0, 0);

        r.collisionVertexArrayExt.emplaceBack(e, -t.padding, -t.padding), r.collisionVertexArrayExt.emplaceBack(e, t.padding, -t.padding), r.collisionVertexArrayExt.emplaceBack(e, t.padding, t.padding), r.collisionVertexArrayExt.emplaceBack(e, -t.padding, t.padding), this._commitLayoutVertex(r.layoutVertexArray, n, s, a, c, h, new i(t.x1, t.y1)), this._commitLayoutVertex(r.layoutVertexArray, n, s, a, c, h, new i(t.x2, t.y1)), this._commitLayoutVertex(r.layoutVertexArray, n, s, a, c, h, new i(t.x2, t.y2)), this._commitLayoutVertex(r.layoutVertexArray, n, s, a, c, h, new i(t.x1, t.y2)), l.vertexLength += 4;
        const p = r.indexArray;
        p.emplaceBack(u, u + 1), p.emplaceBack(u + 1, u + 2), p.emplaceBack(u + 2, u + 3), p.emplaceBack(u + 3, u), l.primitiveLength += 4;
      }

      _addTextDebugCollisionBoxes(t, e, r, n, i, s) {
        for (let a = n; a < i; a++) {
          const n = r.get(a),
                i = this.getSymbolInstanceTextSize(t, s, e, a);

          this._addCollisionDebugVertices(n, i, this.textCollisionBox, n.projectedAnchorX, n.projectedAnchorY, n.projectedAnchorZ, s);
        }
      }

      _addIconDebugCollisionBoxes(t, e, r, n, i, s) {
        for (let a = n; a < i; a++) {
          const n = r.get(a),
                i = this.getSymbolInstanceIconSize(t, e, a);

          this._addCollisionDebugVertices(n, i, this.iconCollisionBox, n.projectedAnchorX, n.projectedAnchorY, n.projectedAnchorZ, s);
        }
      }

      generateCollisionDebugBuffers(t, e) {
        this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new Qh(Rs, lc.members, Ks), this.iconCollisionBox = new Qh(Rs, lc.members, Ks);
        const r = dc(this.iconSizeData, t),
              n = dc(this.textSizeData, t);

        for (let i = 0; i < this.symbolInstances.length; i++) {
          const s = this.symbolInstances.get(i);
          this._addTextDebugCollisionBoxes(n, t, e, s.textBoxStartIndex, s.textBoxEndIndex, s), this._addTextDebugCollisionBoxes(n, t, e, s.verticalTextBoxStartIndex, s.verticalTextBoxEndIndex, s), this._addIconDebugCollisionBoxes(r, t, e, s.iconBoxStartIndex, s.iconBoxEndIndex, s), this._addIconDebugCollisionBoxes(r, t, e, s.verticalIconBoxStartIndex, s.verticalIconBoxEndIndex, s);
        }
      }

      getSymbolInstanceTextSize(t, e, r, n) {
        const i = this.text.placedSymbolArray.get(e.rightJustifiedTextSymbolIndex >= 0 ? e.rightJustifiedTextSymbolIndex : e.centerJustifiedTextSymbolIndex >= 0 ? e.centerJustifiedTextSymbolIndex : e.leftJustifiedTextSymbolIndex >= 0 ? e.leftJustifiedTextSymbolIndex : e.verticalPlacedTextSymbolIndex >= 0 ? e.verticalPlacedTextSymbolIndex : n),
              s = fc(this.textSizeData, t, i) / cc;
        return this.tilePixelRatio * s;
      }

      getSymbolInstanceIconSize(t, e, r) {
        const n = this.icon.placedSymbolArray.get(r),
              i = fc(this.iconSizeData, t, n);
        return this.tilePixelRatio * i;
      }

      _commitDebugCollisionVertexUpdate(t, e, r) {
        t.emplaceBack(e, -r, -r), t.emplaceBack(e, r, -r), t.emplaceBack(e, r, r), t.emplaceBack(e, -r, r);
      }

      _updateTextDebugCollisionBoxes(t, e, r, n, i, s) {
        for (let a = n; a < i; a++) {
          const n = r.get(a),
                i = this.getSymbolInstanceTextSize(t, s, e, a);

          this._commitDebugCollisionVertexUpdate(this.textCollisionBox.collisionVertexArrayExt, i, n.padding);
        }
      }

      _updateIconDebugCollisionBoxes(t, e, r, n, i) {
        for (let s = n; s < i; s++) {
          const n = r.get(s),
                i = this.getSymbolInstanceIconSize(t, e, s);

          this._commitDebugCollisionVertexUpdate(this.iconCollisionBox.collisionVertexArrayExt, i, n.padding);
        }
      }

      updateCollisionDebugBuffers(t, e) {
        if (!this.hasDebugData()) return;
        this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexArrayExt.clear(), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexArrayExt.clear();
        const r = dc(this.iconSizeData, t),
              n = dc(this.textSizeData, t);

        for (let i = 0; i < this.symbolInstances.length; i++) {
          const s = this.symbolInstances.get(i);
          this._updateTextDebugCollisionBoxes(n, t, e, s.textBoxStartIndex, s.textBoxEndIndex, s), this._updateTextDebugCollisionBoxes(n, t, e, s.verticalTextBoxStartIndex, s.verticalTextBoxEndIndex, s), this._updateIconDebugCollisionBoxes(r, t, e, s.iconBoxStartIndex, s.iconBoxEndIndex), this._updateIconDebugCollisionBoxes(r, t, e, s.verticalIconBoxStartIndex, s.verticalIconBoxEndIndex);
        }

        this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexBufferExt && this.textCollisionBox.collisionVertexBufferExt.updateData(this.textCollisionBox.collisionVertexArrayExt), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexBufferExt && this.iconCollisionBox.collisionVertexBufferExt.updateData(this.iconCollisionBox.collisionVertexArrayExt);
      }

      _deserializeCollisionBoxesForSymbol(t, e, r, n, i, s, a, o, l) {
        const u = {};

        for (let n = e; n < r; n++) {
          const e = t.get(n);
          u.textBox = {
            x1: e.x1,
            y1: e.y1,
            x2: e.x2,
            y2: e.y2,
            padding: e.padding,
            projectedAnchorX: e.projectedAnchorX,
            projectedAnchorY: e.projectedAnchorY,
            projectedAnchorZ: e.projectedAnchorZ,
            tileAnchorX: e.tileAnchorX,
            tileAnchorY: e.tileAnchorY
          }, u.textFeatureIndex = e.featureIndex;
          break;
        }

        for (let e = n; e < i; e++) {
          const r = t.get(e);
          u.verticalTextBox = {
            x1: r.x1,
            y1: r.y1,
            x2: r.x2,
            y2: r.y2,
            padding: r.padding,
            projectedAnchorX: r.projectedAnchorX,
            projectedAnchorY: r.projectedAnchorY,
            projectedAnchorZ: r.projectedAnchorZ,
            tileAnchorX: r.tileAnchorX,
            tileAnchorY: r.tileAnchorY
          }, u.verticalTextFeatureIndex = r.featureIndex;
          break;
        }

        for (let e = s; e < a; e++) {
          const r = t.get(e);
          u.iconBox = {
            x1: r.x1,
            y1: r.y1,
            x2: r.x2,
            y2: r.y2,
            padding: r.padding,
            projectedAnchorX: r.projectedAnchorX,
            projectedAnchorY: r.projectedAnchorY,
            projectedAnchorZ: r.projectedAnchorZ,
            tileAnchorX: r.tileAnchorX,
            tileAnchorY: r.tileAnchorY
          }, u.iconFeatureIndex = r.featureIndex;
          break;
        }

        for (let e = o; e < l; e++) {
          const r = t.get(e);
          u.verticalIconBox = {
            x1: r.x1,
            y1: r.y1,
            x2: r.x2,
            y2: r.y2,
            padding: r.padding,
            projectedAnchorX: r.projectedAnchorX,
            projectedAnchorY: r.projectedAnchorY,
            projectedAnchorZ: r.projectedAnchorZ,
            tileAnchorX: r.tileAnchorX,
            tileAnchorY: r.tileAnchorY
          }, u.verticalIconFeatureIndex = r.featureIndex;
          break;
        }

        return u;
      }

      deserializeCollisionBoxes(t) {
        this.collisionArrays = [];

        for (let e = 0; e < this.symbolInstances.length; e++) {
          const r = this.symbolInstances.get(e);
          this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t, r.textBoxStartIndex, r.textBoxEndIndex, r.verticalTextBoxStartIndex, r.verticalTextBoxEndIndex, r.iconBoxStartIndex, r.iconBoxEndIndex, r.verticalIconBoxStartIndex, r.verticalIconBoxEndIndex));
        }
      }

      hasTextData() {
        return this.text.segments.get().length > 0;
      }

      hasIconData() {
        return this.icon.segments.get().length > 0;
      }

      hasDebugData() {
        return this.textCollisionBox && this.iconCollisionBox;
      }

      hasTextCollisionBoxData() {
        return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
      }

      hasIconCollisionBoxData() {
        return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
      }

      addIndicesForPlacedSymbol(t, e) {
        const r = t.placedSymbolArray.get(e),
              n = r.vertexStartIndex + 4 * r.numGlyphs;

        for (let e = r.vertexStartIndex; e < n; e += 4) t.indexArray.emplaceBack(e, e + 1, e + 2), t.indexArray.emplaceBack(e + 1, e + 2, e + 3);
      }

      getSortedSymbolIndexes(t) {
        if (this.sortedAngle === t && void 0 !== this.symbolInstanceIndexes) return this.symbolInstanceIndexes;
        const e = Math.sin(t),
              r = Math.cos(t),
              n = [],
              i = [],
              s = [];

        for (let t = 0; t < this.symbolInstances.length; ++t) {
          s.push(t);
          const a = this.symbolInstances.get(t);
          n.push(0 | Math.round(e * a.tileAnchorX + r * a.tileAnchorY)), i.push(a.featureIndex);
        }

        return s.sort((t, e) => n[t] - n[e] || i[e] - i[t]), s;
      }

      addToSortKeyRanges(t, e) {
        const r = this.sortKeyRanges[this.sortKeyRanges.length - 1];
        r && r.sortKey === e ? r.symbolInstanceEnd = t + 1 : this.sortKeyRanges.push({
          sortKey: e,
          symbolInstanceStart: t,
          symbolInstanceEnd: t + 1
        });
      }

      sortFeatures(t) {
        if (this.sortFeaturesByY && this.sortedAngle !== t && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
          this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t), this.sortedAngle = t, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];

          for (const t of this.symbolInstanceIndexes) {
            const e = this.symbolInstances.get(t);
            this.featureSortOrder.push(e.featureIndex), [e.rightJustifiedTextSymbolIndex, e.centerJustifiedTextSymbolIndex, e.leftJustifiedTextSymbolIndex].forEach((t, e, r) => {
              t >= 0 && r.indexOf(t) === e && this.addIndicesForPlacedSymbol(this.text, t);
            }), e.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, e.verticalPlacedTextSymbolIndex), e.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e.placedIconSymbolIndex), e.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e.verticalPlacedIconSymbolIndex);
          }

          this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
        }
      }

    }

    ai(tp, "SymbolBucket", {
      omit: ["layers", "collisionBoxArray", "features", "compareText"]
    }), tp.MAX_GLYPHS = 65535, tp.addDynamicAttributes = Hh;
    const ep = new vs({
      "symbol-placement": new ds($t.layout_symbol["symbol-placement"]),
      "symbol-spacing": new ds($t.layout_symbol["symbol-spacing"]),
      "symbol-avoid-edges": new ds($t.layout_symbol["symbol-avoid-edges"]),
      "symbol-sort-key": new ys($t.layout_symbol["symbol-sort-key"]),
      "symbol-z-order": new ds($t.layout_symbol["symbol-z-order"]),
      "icon-allow-overlap": new ds($t.layout_symbol["icon-allow-overlap"]),
      "icon-ignore-placement": new ds($t.layout_symbol["icon-ignore-placement"]),
      "icon-optional": new ds($t.layout_symbol["icon-optional"]),
      "icon-rotation-alignment": new ds($t.layout_symbol["icon-rotation-alignment"]),
      "icon-size": new ys($t.layout_symbol["icon-size"]),
      "icon-text-fit": new ds($t.layout_symbol["icon-text-fit"]),
      "icon-text-fit-padding": new ds($t.layout_symbol["icon-text-fit-padding"]),
      "icon-image": new ys($t.layout_symbol["icon-image"]),
      "icon-rotate": new ys($t.layout_symbol["icon-rotate"]),
      "icon-padding": new ds($t.layout_symbol["icon-padding"]),
      "icon-keep-upright": new ds($t.layout_symbol["icon-keep-upright"]),
      "icon-offset": new ys($t.layout_symbol["icon-offset"]),
      "icon-anchor": new ys($t.layout_symbol["icon-anchor"]),
      "icon-pitch-alignment": new ds($t.layout_symbol["icon-pitch-alignment"]),
      "text-pitch-alignment": new ds($t.layout_symbol["text-pitch-alignment"]),
      "text-rotation-alignment": new ds($t.layout_symbol["text-rotation-alignment"]),
      "text-field": new ys($t.layout_symbol["text-field"]),
      "text-font": new ys($t.layout_symbol["text-font"]),
      "text-size": new ys($t.layout_symbol["text-size"]),
      "text-max-width": new ys($t.layout_symbol["text-max-width"]),
      "text-line-height": new ys($t.layout_symbol["text-line-height"]),
      "text-letter-spacing": new ys($t.layout_symbol["text-letter-spacing"]),
      "text-justify": new ys($t.layout_symbol["text-justify"]),
      "text-radial-offset": new ys($t.layout_symbol["text-radial-offset"]),
      "text-variable-anchor": new ds($t.layout_symbol["text-variable-anchor"]),
      "text-anchor": new ys($t.layout_symbol["text-anchor"]),
      "text-max-angle": new ds($t.layout_symbol["text-max-angle"]),
      "text-writing-mode": new ds($t.layout_symbol["text-writing-mode"]),
      "text-rotate": new ys($t.layout_symbol["text-rotate"]),
      "text-padding": new ds($t.layout_symbol["text-padding"]),
      "text-keep-upright": new ds($t.layout_symbol["text-keep-upright"]),
      "text-transform": new ys($t.layout_symbol["text-transform"]),
      "text-offset": new ys($t.layout_symbol["text-offset"]),
      "text-allow-overlap": new ds($t.layout_symbol["text-allow-overlap"]),
      "text-ignore-placement": new ds($t.layout_symbol["text-ignore-placement"]),
      "text-optional": new ds($t.layout_symbol["text-optional"])
    });
    var rp = {
      paint: new vs({
        "icon-opacity": new ys($t.paint_symbol["icon-opacity"]),
        "icon-color": new ys($t.paint_symbol["icon-color"]),
        "icon-halo-color": new ys($t.paint_symbol["icon-halo-color"]),
        "icon-halo-width": new ys($t.paint_symbol["icon-halo-width"]),
        "icon-halo-blur": new ys($t.paint_symbol["icon-halo-blur"]),
        "icon-translate": new ds($t.paint_symbol["icon-translate"]),
        "icon-translate-anchor": new ds($t.paint_symbol["icon-translate-anchor"]),
        "text-opacity": new ys($t.paint_symbol["text-opacity"]),
        "text-color": new ys($t.paint_symbol["text-color"], {
          runtimeType: Ht,
          getOverride: t => t.textColor,
          hasOverride: t => !!t.textColor
        }),
        "text-halo-color": new ys($t.paint_symbol["text-halo-color"]),
        "text-halo-width": new ys($t.paint_symbol["text-halo-width"]),
        "text-halo-blur": new ys($t.paint_symbol["text-halo-blur"]),
        "text-translate": new ds($t.paint_symbol["text-translate"]),
        "text-translate-anchor": new ds($t.paint_symbol["text-translate-anchor"])
      }),
      layout: ep
    };

    class np {
      constructor(t) {
        this.type = t.property.overrides ? t.property.overrides.runtimeType : Zt, this.defaultValue = t;
      }

      evaluate(t) {
        if (t.formattedSection) {
          const e = this.defaultValue.property.overrides;
          if (e && e.hasOverride(t.formattedSection)) return e.getOverride(t.formattedSection);
        }

        return t.feature && t.featureState ? this.defaultValue.evaluate(t.feature, t.featureState) : this.defaultValue.property.specification.default;
      }

      eachChild(t) {
        this.defaultValue.isConstant() || t(this.defaultValue.value._styleExpression.expression);
      }

      outputDefined() {
        return !1;
      }

      serialize() {
        return null;
      }

    }

    ai(np, "FormatSectionOverride", {
      omit: ["defaultValue"]
    });

    class ip extends Ga {
      constructor(t) {
        super(t, rp);
      }

      recalculate(t, e) {
        super.recalculate(t, e), "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment")), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment"));
        const r = this.layout.get("text-writing-mode");

        if (r) {
          const t = [];

          for (const e of r) t.indexOf(e) < 0 && t.push(e);

          this.layout._values["text-writing-mode"] = t;
        } else this.layout._values["text-writing-mode"] = "point" === this.layout.get("symbol-placement") ? ["horizontal"] : ["horizontal", "vertical"];

        this._setPaintOverrides();
      }

      getValueAndResolveTokens(t, e, r, n) {
        const i = this.layout.get(t).evaluate(e, {}, r, n),
              s = this._unevaluatedLayout._values[t];
        return s.isDataDriven() || un(s.value) || !i ? i : function (t, e) {
          return e.replace(/{([^{}]+)}/g, (e, r) => r in t ? String(t[r]) : "");
        }(e.properties, i);
      }

      createBucket(t) {
        return new tp(t);
      }

      queryRadius() {
        return 0;
      }

      queryIntersectsFeature() {
        return !1;
      }

      _setPaintOverrides() {
        for (const t of rp.paint.overridableProperties) {
          if (!ip.hasPaintOverride(this.layout, t)) continue;
          const e = this.paint.get(t),
                r = new np(e),
                n = new ln(r, e.property.specification);
          let i = null;
          i = "constant" === e.value.kind || "source" === e.value.kind ? new hn("source", n) : new pn("composite", n, e.value.zoomStops, e.value._interpolationType), this.paint._values[t] = new ps(e.property, i, e.parameters);
        }
      }

      _handleOverridablePaintPropertyUpdate(t, e, r) {
        return !(!this.layout || e.isDataDriven() || r.isDataDriven()) && ip.hasPaintOverride(this.layout, t);
      }

      static hasPaintOverride(t, e) {
        const r = t.get("text-field"),
              n = rp.paint.properties[e];
        let i = !1;

        const s = t => {
          for (const e of t) if (n.overrides && n.overrides.hasOverride(e)) return void (i = !0);
        };

        if ("constant" === r.value.kind && r.value.value instanceof fe) s(r.value.value.sections);else if ("source" === r.value.kind) {
          const t = e => {
            i || (e instanceof ve && ge(e.value) === te ? s(e.value.sections) : e instanceof Ae ? s(e.sections) : e.eachChild(t));
          },
                e = r.value;

          e._styleExpression && t(e._styleExpression.expression);
        }
        return i;
      }

      getProgramConfiguration(t) {
        return new La(this, t);
      }

    }

    var sp = {
      paint: new vs({
        "background-color": new ds($t.paint_background["background-color"]),
        "background-pattern": new gs($t.paint_background["background-pattern"]),
        "background-opacity": new ds($t.paint_background["background-opacity"])
      })
    },
        ap = {
      paint: new vs({
        "raster-opacity": new ds($t.paint_raster["raster-opacity"]),
        "raster-hue-rotate": new ds($t.paint_raster["raster-hue-rotate"]),
        "raster-brightness-min": new ds($t.paint_raster["raster-brightness-min"]),
        "raster-brightness-max": new ds($t.paint_raster["raster-brightness-max"]),
        "raster-saturation": new ds($t.paint_raster["raster-saturation"]),
        "raster-contrast": new ds($t.paint_raster["raster-contrast"]),
        "raster-resampling": new ds($t.paint_raster["raster-resampling"]),
        "raster-fade-duration": new ds($t.paint_raster["raster-fade-duration"])
      })
    };

    class op extends Ga {
      constructor(t) {
        super(t, {}), this.implementation = t;
      }

      is3D() {
        return "3d" === this.implementation.renderingMode;
      }

      hasOffscreenPass() {
        return void 0 !== this.implementation.prerender;
      }

      recalculate() {}

      updateTransitions() {}

      hasTransition() {
        return !1;
      }

      serialize() {}

      onAdd(t) {
        this.implementation.onAdd && this.implementation.onAdd(t, t.painter.context.gl);
      }

      onRemove(t) {
        this.implementation.onRemove && this.implementation.onRemove(t, t.painter.context.gl);
      }

    }

    var lp = {
      paint: new vs({
        "sky-type": new ds($t.paint_sky["sky-type"]),
        "sky-atmosphere-sun": new ds($t.paint_sky["sky-atmosphere-sun"]),
        "sky-atmosphere-sun-intensity": new ds($t.paint_sky["sky-atmosphere-sun-intensity"]),
        "sky-gradient-center": new ds($t.paint_sky["sky-gradient-center"]),
        "sky-gradient-radius": new ds($t.paint_sky["sky-gradient-radius"]),
        "sky-gradient": new xs($t.paint_sky["sky-gradient"]),
        "sky-atmosphere-halo-color": new ds($t.paint_sky["sky-atmosphere-halo-color"]),
        "sky-atmosphere-color": new ds($t.paint_sky["sky-atmosphere-color"]),
        "sky-opacity": new ds($t.paint_sky["sky-opacity"])
      })
    };

    function up(t, e, r) {
      const n = [0, 0, 1],
            i = ml([]);
      return function (t, e, r) {
        r *= .5;
        var n = e[0],
            i = e[1],
            s = e[2],
            a = e[3],
            o = Math.sin(r),
            l = Math.cos(r);
        t[0] = n * l - s * o, t[1] = i * l + a * o, t[2] = s * l + n * o, t[3] = a * l - i * o;
      }(i, i, r ? -u(t) + Math.PI : u(t)), gl(i, i, -u(e)), ul(n, n, i), sl(n, n);
    }

    const cp = {
      circle: class extends Ga {
        constructor(t) {
          super(t, Lo);
        }

        createBucket(t) {
          return new vo(t);
        }

        queryRadius(t) {
          const e = t;
          return Co("circle-radius", this, e) + Co("circle-stroke-width", this, e) + Do(this.paint.get("circle-translate"));
        }

        queryIntersectsFeature(t, e, r, n, i, s, a, o) {
          const l = Vo(this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), s.angle, t.pixelToTileUnitsFactor),
                u = this.paint.get("circle-radius").evaluate(e, r) + this.paint.get("circle-stroke-width").evaluate(e, r);
          return bl(t, n, s, a, o, "map" === this.paint.get("circle-pitch-alignment"), "map" === this.paint.get("circle-pitch-scale"), l, u);
        }

        getProgramIds() {
          return ["circle"];
        }

        getProgramConfiguration(t) {
          return new La(this, t);
        }

      },
      heatmap: class extends Ga {
        createBucket(t) {
          return new Sl(t);
        }

        constructor(t) {
          super(t, El), this._updateColorRamp();
        }

        _handleSpecialPaintPropertyUpdate(t) {
          "heatmap-color" === t && this._updateColorRamp();
        }

        _updateColorRamp() {
          this.colorRamp = Cl({
            expression: this._transitionablePaint._values["heatmap-color"].value.expression,
            evaluationKey: "heatmapDensity",
            image: this.colorRamp
          }), this.colorRampTexture = null;
        }

        resize() {
          this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
        }

        queryRadius(t) {
          return Co("heatmap-radius", this, t);
        }

        queryIntersectsFeature(t, e, r, n, s, a, o, l) {
          const u = this.paint.get("heatmap-radius").evaluate(e, r);
          return bl(t, n, a, o, l, !0, !0, new i(0, 0), u);
        }

        hasOffscreenPass() {
          return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility;
        }

        getProgramIds() {
          return ["heatmap", "heatmapTexture"];
        }

        getProgramConfiguration(t) {
          return new La(this, t);
        }

      },
      hillshade: class extends Ga {
        constructor(t) {
          super(t, Dl);
        }

        hasOffscreenPass() {
          return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility;
        }

        getProgramIds() {
          return ["hillshade", "hillshadePrepare"];
        }

      },
      fill: class extends Ga {
        constructor(t) {
          super(t, bu);
        }

        getProgramIds() {
          const t = this.paint.get("fill-pattern"),
                e = t && t.constantOr(1),
                r = [e ? "fillPattern" : "fill"];
          return this.paint.get("fill-antialias") && r.push(e && !this.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline"), r;
        }

        getProgramConfiguration(t) {
          return new La(this, t);
        }

        recalculate(t, e) {
          super.recalculate(t, e);
          const r = this.paint._values["fill-outline-color"];
          "constant" === r.value.kind && void 0 === r.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
        }

        createBucket(t) {
          return new xu(t);
        }

        queryRadius() {
          return Do(this.paint.get("fill-translate"));
        }

        queryIntersectsFeature(t, e, r, n, i, s) {
          return !t.queryGeometry.isAboveHorizon && wo(Po(t.tilespaceGeometry, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), s.angle, t.pixelToTileUnitsFactor), n);
        }

        isTileClipped() {
          return !0;
        }

      },
      "fill-extrusion": class extends Ga {
        constructor(t) {
          super(t, Ou);
        }

        createBucket(t) {
          return new $u(t);
        }

        queryRadius() {
          return Do(this.paint.get("fill-extrusion-translate"));
        }

        is3D() {
          return !0;
        }

        getProgramIds() {
          return [this.paint.get("fill-extrusion-pattern").constantOr(1) ? "fillExtrusionPattern" : "fillExtrusion"];
        }

        getProgramConfiguration(t) {
          return new La(this, t);
        }

        queryIntersectsFeature(t, e, r, n, s, a, o, l, u) {
          const c = Vo(this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), a.angle, t.pixelToTileUnitsFactor),
                h = this.paint.get("fill-extrusion-height").evaluate(e, r),
                p = this.paint.get("fill-extrusion-base").evaluate(e, r),
                f = [0, 0],
                d = l && a.elevation,
                y = a.elevation ? a.elevation.exaggeration() : 1,
                m = t.tile.getBucket(this);

          if (d && m instanceof $u) {
            const t = m.centroidVertexArray,
                  e = u + 1;

            if (e < t.length) {
              const r = t.get(e);
              f[0] = r.a_centroid_pos0, f[1] = r.a_centroid_pos1;
            }
          }

          if (0 === f[0] && 1 === f[1]) return !1;

          const g = function (t, e, r, n, s, a, o, l, u) {
            return a ? function (t, e, r, n, i, s, a, o, l) {
              const u = [],
                    c = [],
                    h = [0, 0, 0, 1];

              for (const p of t) {
                const t = [],
                      f = [];

                for (const u of p) {
                  const c = u.x + n.x,
                        p = u.y + n.y,
                        d = Zu(c, p, e, r, s, a, o, l);
                  h[0] = c, h[1] = p, h[2] = d.base, h[3] = 1, dl(h, h, i), h[3] = Math.max(h[3], 1e-5);
                  const y = Gu([h[0] / h[3], h[1] / h[3], h[2] / h[3]]);
                  h[0] = c, h[1] = p, h[2] = d.top, h[3] = 1, dl(h, h, i), h[3] = Math.max(h[3], 1e-5);
                  const m = Gu([h[0] / h[3], h[1] / h[3], h[2] / h[3]]);
                  t.push(y), f.push(m);
                }

                u.push(t), c.push(f);
              }

              return [u, c];
            }(t, e, r, n, s, a, o, l, u) : function (t, e, r, n, s) {
              const a = [],
                    o = [],
                    l = s[8] * e,
                    u = s[9] * e,
                    c = s[10] * e,
                    h = s[11] * e,
                    p = s[8] * r,
                    f = s[9] * r,
                    d = s[10] * r,
                    y = s[11] * r;

              for (const e of t) {
                const t = [],
                      r = [];

                for (const a of e) {
                  const e = a.x + n.x,
                        o = a.y + n.y,
                        m = s[0] * e + s[4] * o + s[12],
                        g = s[1] * e + s[5] * o + s[13],
                        x = s[2] * e + s[6] * o + s[14],
                        v = s[3] * e + s[7] * o + s[15],
                        b = m + l,
                        _ = g + u,
                        w = x + c,
                        A = Math.max(v + h, 1e-5),
                        k = m + p,
                        S = g + f,
                        I = x + d,
                        M = Math.max(v + y, 1e-5),
                        T = new i(b / A, _ / A);

                  T.z = w / A, t.push(T);
                  const z = new i(k / M, S / M);
                  z.z = I / M, r.push(z);
                }

                a.push(t), o.push(r);
              }

              return [a, o];
            }(t, e, r, n, s);
          }(n, p, h, c, o, d ? l : null, f, y, a.center.lat),
                x = t.queryGeometry;

          return function (t, e, r) {
            let n = 1 / 0;
            wo(r, e) && (n = Nu(r, e[0]));

            for (let i = 0; i < e.length; i++) {
              const s = e[i],
                    a = t[i];

              for (let t = 0; t < s.length - 1; t++) {
                const e = s[t],
                      i = [e, s[t + 1], a[t + 1], a[t], e];
                bo(r, i) && (n = Math.min(n, Nu(r, i)));
              }
            }

            return n !== 1 / 0 && n;
          }(g[0], g[1], x.isPointQuery() ? x.screenBounds : x.screenGeometry);
        }

      },
      line: class extends Ga {
        constructor(t) {
          super(t, ec), this.gradientVersion = 0;
        }

        _handleSpecialPaintPropertyUpdate(t) {
          if ("line-gradient" === t) {
            const t = this._transitionablePaint._values["line-gradient"].value.expression;
            this.stepInterpolant = t._styleExpression && t._styleExpression.expression instanceof er, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
          }
        }

        gradientExpression() {
          return this._transitionablePaint._values["line-gradient"].value.expression;
        }

        recalculate(t, e) {
          super.recalculate(t, e), this.paint._values["line-floorwidth"] = rc.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t);
        }

        createBucket(t) {
          return new Qu(t);
        }

        getProgramIds() {
          return [this.paint.get("line-pattern").constantOr(1) ? "linePattern" : "line"];
        }

        getProgramConfiguration(t) {
          return new La(this, t);
        }

        queryRadius(t) {
          const e = t,
                r = nc(Co("line-width", this, e), Co("line-gap-width", this, e)),
                n = Co("line-offset", this, e);
          return r / 2 + Math.abs(n) + Do(this.paint.get("line-translate"));
        }

        queryIntersectsFeature(t, e, r, n, s, a) {
          if (t.queryGeometry.isAboveHorizon) return !1;
          const o = Po(t.tilespaceGeometry, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), a.angle, t.pixelToTileUnitsFactor),
                l = t.pixelToTileUnitsFactor / 2 * nc(this.paint.get("line-width").evaluate(e, r), this.paint.get("line-gap-width").evaluate(e, r)),
                u = this.paint.get("line-offset").evaluate(e, r);
          return u && (n = function (t, e) {
            const r = [],
                  n = new i(0, 0);

            for (let i = 0; i < t.length; i++) {
              const s = t[i],
                    a = [];

              for (let t = 0; t < s.length; t++) {
                const r = s[t - 1],
                      i = s[t],
                      o = s[t + 1],
                      l = 0 === t ? n : i.sub(r)._unit()._perp(),
                      u = t === s.length - 1 ? n : o.sub(i)._unit()._perp(),
                      c = l._add(u)._unit();

                c._mult(1 / (c.x * u.x + c.y * u.y)), a.push(c._mult(e)._add(i));
              }

              r.push(a);
            }

            return r;
          }(n, u * t.pixelToTileUnitsFactor)), function (t, e, r) {
            for (let n = 0; n < e.length; n++) {
              const i = e[n];
              if (t.length >= 3) for (let e = 0; e < i.length; e++) if (zo(t, i[e])) return !0;
              if (Ao(t, i, r)) return !0;
            }

            return !1;
          }(o, n, l);
        }

        isTileClipped() {
          return !0;
        }

      },
      symbol: ip,
      background: class extends Ga {
        constructor(t) {
          super(t, sp);
        }

        getProgramIds() {
          return [this.paint.get("background-pattern") ? "backgroundPattern" : "background"];
        }

      },
      raster: class extends Ga {
        constructor(t) {
          super(t, ap);
        }

        getProgramIds() {
          return ["raster"];
        }

      },
      sky: class extends Ga {
        constructor(t) {
          super(t, lp), this._updateColorRamp();
        }

        _handleSpecialPaintPropertyUpdate(t) {
          "sky-gradient" === t ? this._updateColorRamp() : "sky-atmosphere-sun" !== t && "sky-atmosphere-halo-color" !== t && "sky-atmosphere-color" !== t && "sky-atmosphere-sun-intensity" !== t || (this._skyboxInvalidated = !0);
        }

        _updateColorRamp() {
          this.colorRamp = Cl({
            expression: this._transitionablePaint._values["sky-gradient"].value.expression,
            evaluationKey: "skyRadialProgress"
          }), this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null);
        }

        needsSkyboxCapture(t) {
          if (this._skyboxInvalidated || !this.skyboxTexture || !this.skyboxGeometry) return !0;

          if (!this.paint.get("sky-atmosphere-sun")) {
            const e = t.style.light.properties.get("position");
            return this._lightPosition.azimuthal !== e.azimuthal || this._lightPosition.polar !== e.polar;
          }

          return !1;
        }

        getCenter(t, e) {
          if ("atmosphere" === this.paint.get("sky-type")) {
            const r = this.paint.get("sky-atmosphere-sun"),
                  n = !r,
                  i = t.style.light,
                  s = i.properties.get("position");
            return n && "viewport" === i.properties.get("anchor") && C("The sun direction is attached to a light with viewport anchor, lighting may behave unexpectedly."), n ? up(s.azimuthal, 90 - s.polar, e) : up(r[0], 90 - r[1], e);
          }

          const r = this.paint.get("sky-gradient-center");
          return up(r[0], 90 - r[1], e);
        }

        is3D() {
          return !1;
        }

        isSky() {
          return !0;
        }

        markSkyboxValid(t) {
          this._skyboxInvalidated = !1, this._lightPosition = t.style.light.properties.get("position");
        }

        hasOffscreenPass() {
          return !0;
        }

        getProgramIds() {
          const t = this.paint.get("sky-type");
          return "atmosphere" === t ? ["skyboxCapture", "skybox"] : "gradient" === t ? ["skyboxGradient"] : null;
        }

      }
    };

    class hp {
      constructor(t, e, r, n) {
        this.context = t, this.format = r, this.texture = t.gl.createTexture(), this.update(e, n);
      }

      update(t, e, r) {
        const {
          width: n,
          height: i
        } = t,
              {
          context: s
        } = this,
              {
          gl: o
        } = s,
              {
          HTMLImageElement: l,
          HTMLCanvasElement: u,
          HTMLVideoElement: c,
          ImageData: h,
          ImageBitmap: p
        } = a;

        if (o.bindTexture(o.TEXTURE_2D, this.texture), s.pixelStoreUnpackFlipY.set(!1), s.pixelStoreUnpack.set(1), s.pixelStoreUnpackPremultiplyAlpha.set(this.format === o.RGBA && (!e || !1 !== e.premultiply)), r || this.size && this.size[0] === n && this.size[1] === i) {
          const {
            x: e,
            y: s
          } = r || {
            x: 0,
            y: 0
          };
          t instanceof l || t instanceof u || t instanceof c || t instanceof h || p && t instanceof p ? o.texSubImage2D(o.TEXTURE_2D, 0, e, s, o.RGBA, o.UNSIGNED_BYTE, t) : o.texSubImage2D(o.TEXTURE_2D, 0, e, s, n, i, o.RGBA, o.UNSIGNED_BYTE, t.data);
        } else this.size = [n, i], t instanceof l || t instanceof u || t instanceof c || t instanceof h || p && t instanceof p ? o.texImage2D(o.TEXTURE_2D, 0, this.format, this.format, o.UNSIGNED_BYTE, t) : o.texImage2D(o.TEXTURE_2D, 0, this.format, n, i, 0, this.format, o.UNSIGNED_BYTE, t.data);

        this.useMipmap = Boolean(e && e.useMipmap && this.isSizePowerOfTwo()), this.useMipmap && o.generateMipmap(o.TEXTURE_2D);
      }

      bind(t, e) {
        const {
          context: r
        } = this,
              {
          gl: n
        } = r;
        n.bindTexture(n.TEXTURE_2D, this.texture), t !== this.filter && (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, t), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, this.useMipmap ? t === n.NEAREST ? n.NEAREST_MIPMAP_NEAREST : n.LINEAR_MIPMAP_NEAREST : t), this.filter = t), e !== this.wrap && (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, e), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, e), this.wrap = e);
      }

      isSizePowerOfTwo() {
        return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
      }

      destroy() {
        const {
          gl: t
        } = this.context;
        t.deleteTexture(this.texture), this.texture = null;
      }

    }

    class pp {
      constructor(t, e) {
        this.width = t, this.height = e, this.nextRow = 0, this.image = new zl({
          width: t,
          height: e
        }), this.positions = {}, this.uploaded = !1;
      }

      getDash(t, e) {
        const r = this.getKey(t, e);
        return this.positions[r];
      }

      trim() {
        const t = this.width,
              e = this.height = k(this.nextRow);
        this.image.resize({
          width: t,
          height: e
        });
      }

      getKey(t, e) {
        return t.join(",") + e;
      }

      getDashRanges(t, e, r) {
        const n = [];
        let i = t.length % 2 == 1 ? -t[t.length - 1] * r : 0,
            s = t[0] * r,
            a = !0;
        n.push({
          left: i,
          right: s,
          isDash: a,
          zeroLength: 0 === t[0]
        });
        let o = t[0];

        for (let e = 1; e < t.length; e++) {
          a = !a;
          const l = t[e];
          i = o * r, o += l, s = o * r, n.push({
            left: i,
            right: s,
            isDash: a,
            zeroLength: 0 === l
          });
        }

        return n;
      }

      addRoundDash(t, e, r) {
        const n = e / 2;

        for (let e = -r; e <= r; e++) {
          const i = this.width * (this.nextRow + r + e);
          let s = 0,
              a = t[s];

          for (let o = 0; o < this.width; o++) {
            o / a.right > 1 && (a = t[++s]);
            const l = Math.abs(o - a.left),
                  u = Math.abs(o - a.right),
                  c = Math.min(l, u);
            let h;
            const p = e / r * (n + 1);

            if (a.isDash) {
              const t = n - Math.abs(p);
              h = Math.sqrt(c * c + t * t);
            } else h = n - Math.sqrt(c * c + p * p);

            this.image.data[i + o] = Math.max(0, Math.min(255, h + 128));
          }
        }
      }

      addRegularDash(t, e) {
        for (let e = t.length - 1; e >= 0; --e) {
          const r = t[e],
                n = t[e + 1];
          r.zeroLength ? t.splice(e, 1) : n && n.isDash === r.isDash && (n.left = r.left, t.splice(e, 1));
        }

        const r = t[0],
              n = t[t.length - 1];
        r.isDash === n.isDash && (r.left = n.left - this.width, n.right = r.right + this.width);
        const i = this.width * this.nextRow;
        let s = 0,
            a = t[s];

        for (let r = 0; r < this.width; r++) {
          r / a.right > 1 && (a = t[++s]);
          const n = Math.abs(r - a.left),
                o = Math.abs(r - a.right),
                l = Math.min(n, o);
          this.image.data[i + r] = Math.max(0, Math.min(255, (a.isDash ? l : -l) + e + 128));
        }
      }

      addDash(t, e) {
        const r = this.getKey(t, e);
        if (this.positions[r]) return this.positions[r];
        const n = "round" === e,
              i = n ? 7 : 0,
              s = 2 * i + 1;
        if (this.nextRow + s > this.height) return C("LineAtlas out of space"), null;
        0 === t.length && t.push(1);
        let a = 0;

        for (let e = 0; e < t.length; e++) t[e] < 0 && (C("Negative value is found in line dasharray, replacing values with 0"), t[e] = 0), a += t[e];

        if (0 !== a) {
          const r = this.width / a,
                s = this.getDashRanges(t, this.width, r);
          n ? this.addRoundDash(s, r, i) : this.addRegularDash(s, "square" === e ? .5 * r : 0);
        }

        const o = this.nextRow + i;
        this.nextRow += s;
        const l = {
          tl: [o, i],
          br: [a, 0]
        };
        return this.positions[r] = l, l;
      }

    }

    ai(pp, "LineAtlas");

    class fp {
      constructor(t) {
        this._callback = t, this._triggered = !1, "undefined" != typeof MessageChannel && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
          this._triggered = !1, this._callback();
        });
      }

      trigger() {
        this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout(() => {
          this._triggered = !1, this._callback();
        }, 0));
      }

      remove() {
        this._channel = void 0, this._callback = () => {};
      }

    }

    const dp = a.performance;

    function yp(t) {
      const e = t ? t.url.toString() : void 0;
      return dp.getEntriesByName(e);
    }

    class mp {
      constructor() {
        this.tasks = {}, this.taskQueue = [], I(["process"], this), this.invoker = new fp(this.process), this.nextId = 0;
      }

      add(t, e) {
        const r = this.nextId++,
              n = function ({
          type: t,
          isSymbolTile: e,
          zoom: r
        }) {
          return r = r || 0, "message" === t ? 0 : "maybePrepare" !== t || e ? "parseTile" !== t || e ? "parseTile" === t && e ? 300 - r : "maybePrepare" === t && e ? 400 - r : 500 : 200 - r : 100 - r;
        }(e);

        if (0 === n) {
          V();

          try {
            t();
          } finally {}

          return {
            cancel: () => {}
          };
        }

        return this.tasks[r] = {
          fn: t,
          metadata: e,
          priority: n,
          id: r
        }, this.taskQueue.push(r), this.invoker.trigger(), {
          cancel: () => {
            delete this.tasks[r];
          }
        };
      }

      process() {
        V();

        try {
          if (this.taskQueue = this.taskQueue.filter(t => !!this.tasks[t]), !this.taskQueue.length) return;
          const t = this.pick();
          if (null === t) return;
          const e = this.tasks[t];
          if (delete this.tasks[t], this.taskQueue.length && this.invoker.trigger(), !e) return;
          e.fn();
        } finally {}
      }

      pick() {
        let t = null,
            e = 1 / 0;

        for (let r = 0; r < this.taskQueue.length; r++) {
          const n = this.tasks[this.taskQueue[r]];
          n.priority < e && (e = n.priority, t = r);
        }

        if (null === t) return null;
        const r = this.taskQueue[t];
        return this.taskQueue.splice(t, 1), r;
      }

      remove() {
        this.invoker.remove();
      }

    }

    const gp = ks([{
      type: "Float32",
      name: "a_globe_pos",
      components: 3
    }, {
      type: "Float32",
      name: "a_merc_pos",
      components: 2
    }, {
      type: "Float32",
      name: "a_uv",
      components: 2
    }]),
          xp = ks([{
      type: "Float32",
      name: "a_pos",
      components: 3
    }, {
      type: "Float32",
      name: "a_uv",
      components: 2
    }]),
          {
      members: vp
    } = gp,
          bp = ks([{
      name: "a_pos_3",
      components: 3,
      type: "Int16"
    }]);

    var _p = ks([{
      name: "a_pos",
      type: "Int16",
      components: 2
    }]);

    const wp = Ya / Math.PI / 2,
          Ap = -wp,
          kp = wp,
          Sp = [new vl([Ap, Ap, Ap], [kp, kp, kp]), new vl([Ap, Ap, Ap], [0, 0, kp]), new vl([0, Ap, Ap], [kp, 0, kp]), new vl([Ap, 0, Ap], [0, kp, kp]), new vl([0, 0, Ap], [kp, kp, kp])];

    class Ip {
      constructor(t, e, r) {
        this.a = hl([], t, r), this.b = hl([], e, r), this.center = r;
        const n = sl([], this.a),
              i = sl([], this.b);
        this.angle = Math.acos(al(n, i));
      }

    }

    function Mp(t, e) {
      if (0 === t.angle) return null;
      let r;
      return r = 0 === t.a[e] ? 1 / t.angle * .5 * Math.PI : 1 / t.angle * Math.atan(t.b[e] / t.a[e] / Math.sin(t.angle) - 1 / Math.tan(t.angle)), r < 0 || r > 1 ? null : function (t, e, r, n) {
        const i = Math.sin(r);
        return t * (Math.sin((1 - n) * r) / i) + e * (Math.sin(n * r) / i);
      }(t.a[e], t.b[e], t.angle, y(r, 0, 1)) + t.center[e];
    }

    function Tp(t) {
      if (t.z <= 1) return Sp[t.z + 2 * t.y + t.x];
      const [e, r] = Bp(t),
            n = [Cp(e[0], e[1]), Cp(e[0], r[1]), Cp(r[0], e[1]), Cp(r[0], r[1])],
            i = [kp, kp, kp],
            s = [Ap, Ap, Ap];

      for (const t of n) i[0] = Math.min(i[0], t[0]), i[1] = Math.min(i[1], t[1]), i[2] = Math.min(i[2], t[2]), s[0] = Math.max(s[0], t[0]), s[1] = Math.max(s[1], t[1]), s[2] = Math.max(s[2], t[2]);

      return new vl(i, s);
    }

    function zp(t, e, r) {
      const n = e / t.worldSize,
            i = (t, e) => {
        nl(t, t, n), nl(e, e, n);
      },
            s = Number.MAX_VALUE,
            a = [-s, -s, -s],
            o = [s, s, s],
            l = Lp(t);

      if (r.z <= 1) {
        const t = Tp(r).getCorners();

        for (let e = 0; e < t.length; e++) ll(t[e], t[e], l), el(o, o, t[e]), rl(a, a, t[e]);

        return i(o, a), new vl(o, a);
      }

      const [c, h] = Bp(r),
            p = new Ha();
      p.setSouthWest([c[1], h[0]]), p.setNorthEast([h[1], c[0]]);
      const f = [Cp(p.getSouth(), p.getWest()), Cp(p.getSouth(), p.getEast()), Cp(p.getNorth(), p.getEast()), Cp(p.getNorth(), p.getWest())];

      for (let t = 0; t < f.length; t++) ll(f[t], f[t], l), el(o, o, f[t]), rl(a, a, f[t]);

      if (p.contains(t.center)) return a[2] = 0, i(o, a), new vl(o, a);
      const d = [l[12], l[13], l[14]],
            m = t.center.lng,
            g = y(t.center.lat, -85.051129, oo),
            x = [eo(m), ro(g)],
            v = p.getCenter().lng,
            b = y(p.getCenter().lat, -85.051129, oo),
            _ = [eo(v), ro(b)];
      let w = new Array(3),
          A = 0;
      const k = x[0] - _[0],
            S = x[1] - _[1];
      if (Math.abs(k) > Math.abs(S)) A = k >= 0 ? 1 : 3, w = d;else {
        A = S >= 0 ? 0 : 2;
        const t = [l[4], l[5], l[6]];
        let e;
        e = S >= 0 ? -Math.sin(u(p.getSouth())) * wp : -Math.sin(u(p.getNorth())) * wp, w = il(w, d, t, e);
      }
      const I = f[A],
            M = f[(A + 1) % 4],
            T = new Ip(I, M, w),
            z = [Mp(T, 0) || I[0], Mp(T, 1) || I[1], Mp(T, 2) || I[2]];
      return o[2] = Math.min(I[2], M[2]), el(o, o, z), rl(a, a, z), i(o, a), new vl(o, a);
    }

    function Bp(t) {
      const e = 1 << t.z,
            r = t.x / e,
            n = (t.x + 1) / e,
            i = (t.y + 1) / e;
      return [[so(t.y / e), io(r)], [so(i), io(n)]];
    }

    function Ep(t, e, r, n = wp) {
      return r = u(r), [t * Math.sin(r) * n, -e * n, t * Math.cos(r) * n];
    }

    function Cp(t, e, r) {
      return Ep(Math.cos(u(t)), Math.sin(u(t)), e, r);
    }

    function Dp(t, e, r) {
      const n = Math.pow(2, r.z),
            i = (t / Ya + r.x) / n;
      return Cp(so((e / Ya + r.y) / n), io(i));
    }

    function Pp(t) {
      return 16383 / Math.max(...hl([], t.max, t.min));
    }

    function Vp(t) {
      const e = jo(new Float64Array(16)),
            r = Pp(t);
      var n, i;
      return No(e, e, [r, r, r]), qo(e, e, ((n = [])[0] = -(i = t.min)[0], n[1] = -i[1], n[2] = -i[2], n)), e;
    }

    function Fp(t, e, r, n, i) {
      const s = function (t) {
        const e = Ya / (2 * Math.PI);
        return t / (2 * Math.PI) / e;
      }(r),
            a = [t, e, -r / (2 * Math.PI)],
            o = jo(new Float64Array(16));

      return qo(o, o, a), No(o, o, [s, s, s]), Go(o, o, u(-i)), Zo(o, o, u(-n)), o;
    }

    function Lp(t) {
      const {
        x: e,
        y: r
      } = t.point,
            {
        lng: n,
        lat: i
      } = t._center;
      return Fp(e, r, t.worldSize, n, i);
    }

    const Rp = u(85),
          Up = Math.cos(Rp),
          $p = Math.sin(Rp);

    function jp(t, e, r) {
      var n = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r);
      return [t * n - 2 * Math.PI * 6378137 / 2, e * n - 2 * Math.PI * 6378137 / 2];
    }

    class Op {
      constructor(t, e, r) {
        this.z = t, this.x = e, this.y = r, this.key = Gp(0, t, t, e, r);
      }

      equals(t) {
        return this.z === t.z && this.x === t.x && this.y === t.y;
      }

      url(t, e) {
        const r = function (t, e, r) {
          var n = jp(256 * t, 256 * (e = Math.pow(2, r) - e - 1), r),
              i = jp(256 * (t + 1), 256 * (e + 1), r);
          return n[0] + "," + n[1] + "," + i[0] + "," + i[1];
        }(this.x, this.y, this.z),
              n = function (t, e, r) {
          let n,
              i = "";

          for (let s = t; s > 0; s--) n = 1 << s - 1, i += (e & n ? 1 : 0) + (r & n ? 2 : 0);

          return i;
        }(this.z, this.x, this.y);

        return t[(this.x + this.y) % t.length].replace("{prefix}", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace("{z}", String(this.z)).replace("{x}", String(this.x)).replace("{y}", String("tms" === e ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace("{quadkey}", n).replace("{bbox-epsg-3857}", r);
      }

      toString() {
        return `${this.z}/${this.x}/${this.y}`;
      }

    }

    class qp {
      constructor(t, e) {
        this.wrap = t, this.canonical = e, this.key = Gp(t, e.z, e.z, e.x, e.y);
      }

    }

    class Np {
      constructor(t, e, r, n, i) {
        this.overscaledZ = t, this.wrap = e, this.canonical = new Op(r, +n, +i), this.key = 0 === e && t === r ? this.canonical.key : Gp(e, t, r, n, i);
      }

      equals(t) {
        return this.overscaledZ === t.overscaledZ && this.wrap === t.wrap && this.canonical.equals(t.canonical);
      }

      scaledTo(t) {
        const e = this.canonical.z - t;
        return t > this.canonical.z ? new Np(t, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Np(t, this.wrap, t, this.canonical.x >> e, this.canonical.y >> e);
      }

      calculateScaledKey(t, e = !0) {
        if (this.overscaledZ === t && e) return this.key;
        if (t > this.canonical.z) return Gp(this.wrap * +e, t, this.canonical.z, this.canonical.x, this.canonical.y);
        {
          const r = this.canonical.z - t;
          return Gp(this.wrap * +e, t, t, this.canonical.x >> r, this.canonical.y >> r);
        }
      }

      isChildOf(t) {
        if (t.wrap !== this.wrap) return !1;
        const e = this.canonical.z - t.canonical.z;
        return 0 === t.overscaledZ || t.overscaledZ < this.overscaledZ && t.canonical.x === this.canonical.x >> e && t.canonical.y === this.canonical.y >> e;
      }

      children(t) {
        if (this.overscaledZ >= t) return [new Np(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
        const e = this.canonical.z + 1,
              r = 2 * this.canonical.x,
              n = 2 * this.canonical.y;
        return [new Np(e, this.wrap, e, r, n), new Np(e, this.wrap, e, r + 1, n), new Np(e, this.wrap, e, r, n + 1), new Np(e, this.wrap, e, r + 1, n + 1)];
      }

      isLessThan(t) {
        return this.wrap < t.wrap || !(this.wrap > t.wrap) && (this.overscaledZ < t.overscaledZ || !(this.overscaledZ > t.overscaledZ) && (this.canonical.x < t.canonical.x || !(this.canonical.x > t.canonical.x) && this.canonical.y < t.canonical.y));
      }

      wrapped() {
        return new Np(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
      }

      unwrapTo(t) {
        return new Np(this.overscaledZ, t, this.canonical.z, this.canonical.x, this.canonical.y);
      }

      overscaleFactor() {
        return Math.pow(2, this.overscaledZ - this.canonical.z);
      }

      toUnwrapped() {
        return new qp(this.wrap, this.canonical);
      }

      toString() {
        return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
      }

    }

    function Gp(t, e, r, n, i) {
      const s = 1 << Math.min(r, 22);
      let a = s * (i % s) + n % s;
      return t && r < 22 && (a += s * s * ((t < 0 ? -2 * t - 1 : 2 * t) % (1 << 2 * (22 - r)))), 16 * (32 * a + r) + (e - r);
    }

    function Zp(t, e) {
      if (!e.isReprojectedInTileSpace) return {
        scale: 1 << t.z,
        x: t.x,
        y: t.y,
        x2: t.x + 1,
        y2: t.y + 1,
        projection: e
      };
      const r = Math.pow(2, -t.z),
            n = t.x * r,
            i = (t.x + 1) * r,
            s = t.y * r,
            a = (t.y + 1) * r,
            o = io(n),
            l = io(i),
            u = so(s),
            c = so(a),
            h = e.project(o, u),
            p = e.project(l, u),
            f = e.project(l, c),
            d = e.project(o, c);
      let y = Math.min(h.x, p.x, f.x, d.x),
          m = Math.min(h.y, p.y, f.y, d.y),
          g = Math.max(h.x, p.x, f.x, d.x),
          x = Math.max(h.y, p.y, f.y, d.y);
      const v = r / 16;

      function b(t, r, n, i, s, a) {
        const o = (n + s) / 2,
              l = (i + a) / 2,
              u = e.project(io(o), so(l)),
              c = Math.max(0, y - u.x, m - u.y, u.x - g, u.y - x);
        y = Math.min(y, u.x), g = Math.max(g, u.x), m = Math.min(m, u.y), x = Math.max(x, u.y), c > v && (b(t, u, n, i, o, l), b(u, r, o, l, s, a));
      }

      b(h, p, n, s, i, s), b(p, f, i, s, i, a), b(f, d, i, a, n, a), b(d, h, n, a, n, s), y -= v, m -= v, g += v, x += v;

      const _ = 1 / Math.max(g - y, x - m);

      return {
        scale: _,
        x: y * _,
        y: m * _,
        x2: g * _,
        y2: x * _,
        projection: e
      };
    }

    ai(Op, "CanonicalTileID"), ai(Np, "OverscaledTileID", {
      omit: ["projMatrix"]
    });

    class Xp {
      constructor(t) {
        this._stringToNumber = {}, this._numberToString = [];

        for (let e = 0; e < t.length; e++) {
          const r = t[e];
          this._stringToNumber[r] = e, this._numberToString[e] = r;
        }
      }

      encode(t) {
        return this._stringToNumber[t];
      }

      decode(t) {
        return this._numberToString[t];
      }

    }

    const Kp = ["tile", "layer", "source", "sourceLayer", "state"];

    class Yp {
      constructor(t, e, r, n, i) {
        this.type = "Feature", this._vectorTileFeature = t, this._z = e, this._x = r, this._y = n, this.properties = t.properties, this.id = i;
      }

      get geometry() {
        return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._x, this._y, this._z).geometry), this._geometry;
      }

      set geometry(t) {
        this._geometry = t;
      }

      toJSON() {
        const t = {
          type: "Feature",
          geometry: this.geometry,
          properties: this.properties
        };
        void 0 !== this.id && (t.id = this.id);

        for (const e of Kp) void 0 !== this[e] && (t[e] = this[e]);

        return t;
      }

    }

    const Hp = 32,
          Wp = 33,
          Jp = new Uint16Array(8184);

    for (let t = 0; t < 2046; t++) {
      let e = t + 2,
          r = 0,
          n = 0,
          i = 0,
          s = 0,
          a = 0,
          o = 0;

      for (1 & e ? i = s = a = Hp : r = n = o = Hp; (e >>= 1) > 1;) {
        const t = r + i >> 1,
              l = n + s >> 1;
        1 & e ? (i = r, s = n, r = a, n = o) : (r = i, n = s, i = a, s = o), a = t, o = l;
      }

      const l = 4 * t;
      Jp[l + 0] = r, Jp[l + 1] = n, Jp[l + 2] = i, Jp[l + 3] = s;
    }

    const Qp = new Uint16Array(2178),
          tf = new Uint8Array(1089),
          ef = new Uint16Array(1089);

    function rf(t) {
      return 0 === t ? -.03125 : 32 === t ? .03125 : 0;
    }

    var nf = ks([{
      name: "a_pos",
      type: "Int16",
      components: 2
    }, {
      name: "a_texture_pos",
      type: "Int16",
      components: 2
    }]);
    const sf = {
      type: 2,
      extent: Ya,
      loadGeometry: () => [[new i(0, 0), new i(8193, 0), new i(8193, 8193), new i(0, 8193), new i(0, 0)]]
    };

    class af {
      constructor(t, e, r, n, i) {
        this.tileID = t, this.uid = w(), this.uses = 0, this.tileSize = e, this.tileZoom = r, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.isRaster = i, this.expiredRequestCount = 0, this.state = "loading", n && n.transform && (this.projection = n.transform.projection);
      }

      registerFadeDuration(t) {
        const e = t + this.timeAdded;
        e < N.now() || this.fadeEndTime && e < this.fadeEndTime || (this.fadeEndTime = e);
      }

      wasRequested() {
        return "errored" === this.state || "loaded" === this.state || "reloading" === this.state;
      }

      get tileTransform() {
        return this._tileTransform || (this._tileTransform = Zp(this.tileID.canonical, this.projection)), this._tileTransform;
      }

      loadVectorData(t, e, r) {
        if (this.unloadVectorData(), this.state = "loaded", t) {
          t.featureIndex && (this.latestFeatureIndex = t.featureIndex, t.rawTileData ? (this.latestRawTileData = t.rawTileData, this.latestFeatureIndex.rawTileData = t.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = t.collisionBoxArray, this.buckets = function (t, e) {
            const r = {};
            if (!e) return r;

            for (const n of t) {
              const t = n.layerIds.map(t => e.getLayer(t)).filter(Boolean);

              if (0 !== t.length) {
                n.layers = t, n.stateDependentLayerIds && (n.stateDependentLayers = n.stateDependentLayerIds.map(e => t.filter(t => t.id === e)[0]));

                for (const e of t) r[e.id] = n;
              }
            }

            return r;
          }(t.buckets, e.style), this.hasSymbolBuckets = !1;

          for (const t in this.buckets) {
            const e = this.buckets[t];

            if (e instanceof tp) {
              if (this.hasSymbolBuckets = !0, !r) break;
              e.justReloaded = !0;
            }
          }

          if (this.hasRTLText = !1, this.hasSymbolBuckets) for (const t in this.buckets) {
            const e = this.buckets[t];

            if (e instanceof tp && e.hasRTLText) {
              this.hasRTLText = !0, is.isLoading() || is.isLoaded() || "deferred" !== rs() || ns();
              break;
            }
          }
          this.queryPadding = 0;

          for (const t in this.buckets) {
            const r = this.buckets[t];
            this.queryPadding = Math.max(this.queryPadding, e.style.getLayer(t).queryRadius(r));
          }

          t.imageAtlas && (this.imageAtlas = t.imageAtlas), t.glyphAtlasImage && (this.glyphAtlasImage = t.glyphAtlasImage), t.lineAtlas && (this.lineAtlas = t.lineAtlas);
        } else this.collisionBoxArray = new ea();
      }

      unloadVectorData() {
        if (this.hasData()) {
          for (const t in this.buckets) this.buckets[t].destroy();

          this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.lineAtlasTexture && this.lineAtlasTexture.destroy(), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugIndexBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), this.latestFeatureIndex = null, this.state = "unloaded";
        }
      }

      getBucket(t) {
        return this.buckets[t.id];
      }

      upload(t) {
        for (const e in this.buckets) {
          const r = this.buckets[e];
          r.uploadPending() && r.upload(t);
        }

        const e = t.gl;
        this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new hp(t, this.imageAtlas.image, e.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new hp(t, this.glyphAtlasImage, e.ALPHA), this.glyphAtlasImage = null), this.lineAtlas && !this.lineAtlas.uploaded && (this.lineAtlasTexture = new hp(t, this.lineAtlas.image, e.ALPHA), this.lineAtlas.uploaded = !0);
      }

      prepare(t) {
        this.imageAtlas && this.imageAtlas.patchUpdatedImages(t, this.imageAtlasTexture);
      }

      queryRenderedFeatures(t, e, r, n, i, s, a, o) {
        return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({
          tileResult: n,
          pixelPosMatrix: a,
          transform: s,
          params: i,
          tileTransform: this.tileTransform
        }, t, e, r) : {};
      }

      querySourceFeatures(t, e) {
        const r = this.latestFeatureIndex;
        if (!r || !r.rawTileData) return;
        const n = r.loadVTLayers(),
              i = e ? e.sourceLayer : "",
              s = n._geojsonTileLayer || n[i];
        if (!s) return;
        const a = Sn(e && e.filter),
              {
          z: o,
          x: l,
          y: u
        } = this.tileID.canonical,
              c = {
          z: o,
          x: l,
          y: u
        };

        for (let e = 0; e < s.length; e++) {
          const n = s.feature(e);

          if (a.needGeometry) {
            const t = mo(n, !0);
            if (!a.filter(new ss(this.tileID.overscaledZ), t, this.tileID.canonical)) continue;
          } else if (!a.filter(new ss(this.tileID.overscaledZ), n)) continue;

          const h = r.getId(n, i),
                p = new Yp(n, o, l, u, h);
          p.tile = c, t.push(p);
        }
      }

      hasData() {
        return "loaded" === this.state || "reloading" === this.state || "expired" === this.state;
      }

      patternsLoaded() {
        return !!this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
      }

      setExpiryData(t) {
        const e = this.expirationTime;

        if (t.cacheControl) {
          const e = F(t.cacheControl);
          e["max-age"] && (this.expirationTime = Date.now() + 1e3 * e["max-age"]);
        } else t.expires && (this.expirationTime = new Date(t.expires).getTime());

        if (this.expirationTime) {
          const t = Date.now();
          let r = !1;
          if (this.expirationTime > t) r = !1;else if (e) {
            if (this.expirationTime < e) r = !0;else {
              const n = this.expirationTime - e;
              n ? this.expirationTime = t + Math.max(n, 3e4) : r = !0;
            }
          } else r = !0;
          r ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
        }
      }

      getExpiryTimeout() {
        if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1);
      }

      setFeatureState(t, e) {
        if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || 0 === Object.keys(t).length || !e) return;
        const r = this.latestFeatureIndex.loadVTLayers(),
              n = e.style.listImages();

        for (const i in this.buckets) {
          if (!e.style.hasLayer(i)) continue;
          const s = this.buckets[i],
                a = s.layers[0].sourceLayer || "_geojsonTileLayer",
                o = r[a],
                l = t[a];
          if (!o || !l || 0 === Object.keys(l).length) continue;

          if (s.update(l, o, n, this.imageAtlas && this.imageAtlas.patternPositions || {}), s instanceof Qu || s instanceof xu) {
            const t = e.style._getSourceCache(s.layers[0].source);

            e._terrain && e._terrain.enabled && t && s.programConfigurations.needsUpload && e._terrain._clearRenderCacheForTile(t.id, this.tileID);
          }

          const u = e && e.style && e.style.getLayer(i);
          u && (this.queryPadding = Math.max(this.queryPadding, u.queryRadius(s)));
        }
      }

      holdingForFade() {
        return void 0 !== this.symbolFadeHoldUntil;
      }

      symbolFadeFinished() {
        return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < N.now();
      }

      clearFadeHold() {
        this.symbolFadeHoldUntil = void 0;
      }

      setHoldDuration(t) {
        this.symbolFadeHoldUntil = N.now() + t;
      }

      setTexture(t, e) {
        const r = e.context,
              n = r.gl;
        this.texture = e.getTileTexture(t.width), this.texture ? this.texture.update(t, {
          useMipmap: !0
        }) : (this.texture = new hp(r, t, n.RGBA, {
          useMipmap: !0
        }), this.texture.bind(n.LINEAR, n.CLAMP_TO_EDGE), r.extTextureFilterAnisotropic && n.texParameterf(n.TEXTURE_2D, r.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, r.extTextureFilterAnisotropicMax));
      }

      setDependencies(t, e) {
        const r = {};

        for (const t of e) r[t] = !0;

        this.dependencies[t] = r;
      }

      hasDependency(t, e) {
        for (const r of t) {
          const t = this.dependencies[r];
          if (t) for (const r of e) if (t[r]) return !0;
        }

        return !1;
      }

      clearQueryDebugViz() {}

      _makeDebugTileBoundsBuffers(t, e) {
        if (!e || "mercator" === e.name || this._tileDebugBuffer) return;
        const r = yo(sf, this.tileID.canonical, this.tileTransform)[0],
              n = new Is(),
              i = new Ys();

        for (let t = 0; t < r.length; t++) {
          const {
            x: e,
            y: s
          } = r[t];
          n.emplaceBack(e, s), i.emplaceBack(t);
        }

        i.emplaceBack(0), this._tileDebugIndexBuffer = t.createIndexBuffer(i), this._tileDebugBuffer = t.createVertexBuffer(n, _p.members), this._tileDebugSegments = Ka.simpleSegment(0, 0, n.length, i.length);
      }

      _makeTileBoundsBuffers(t, e) {
        if (this._tileBoundsBuffer || !e || "mercator" === e.name) return;
        const r = yo(sf, this.tileID.canonical, this.tileTransform)[0];
        let n, i;

        if (this.isRaster) {
          const t = function (t, e) {
            const r = Zp(t, e),
                  n = Math.pow(2, t.z);

            for (let i = 0; i < Wp; i++) for (let s = 0; s < Wp; s++) {
              const a = io((t.x + (s + rf(s)) / Hp) / n),
                    o = so((t.y + (i + rf(i)) / Hp) / n),
                    l = e.project(a, o),
                    u = i * Wp + s;
              Qp[2 * u + 0] = Math.round((l.x * r.scale - r.x) * Ya), Qp[2 * u + 1] = Math.round((l.y * r.scale - r.y) * Ya);
            }

            tf.fill(0), ef.fill(0);

            for (let t = 2045; t >= 0; t--) {
              const e = 4 * t,
                    r = Jp[e + 0],
                    n = Jp[e + 1],
                    i = Jp[e + 2],
                    s = Jp[e + 3],
                    a = r + i >> 1,
                    o = n + s >> 1,
                    l = a + o - n,
                    u = o + r - a,
                    c = n * Wp + r,
                    h = s * Wp + i,
                    p = o * Wp + a,
                    f = Math.hypot((Qp[2 * c + 0] + Qp[2 * h + 0]) / 2 - Qp[2 * p + 0], (Qp[2 * c + 1] + Qp[2 * h + 1]) / 2 - Qp[2 * p + 1]) >= 16;

              if (tf[p] = tf[p] || (f ? 1 : 0), t < 1022) {
                const t = (n + u >> 1) * Wp + (r + l >> 1),
                      e = (s + u >> 1) * Wp + (i + l >> 1);
                tf[p] = tf[p] || tf[t] || tf[e];
              }
            }

            const i = new Ts(),
                  s = new js();
            let a = 0;

            function o(t, e) {
              const r = e * Wp + t;
              return 0 === ef[r] && (i.emplaceBack(Qp[2 * r + 0], Qp[2 * r + 1], t * Ya / Hp, e * Ya / Hp), ef[r] = ++a), ef[r] - 1;
            }

            function l(t, e, r, n, i, a) {
              const u = t + r >> 1,
                    c = e + n >> 1;
              if (Math.abs(t - i) + Math.abs(e - a) > 1 && tf[c * Wp + u]) l(i, a, t, e, u, c), l(r, n, i, a, u, c);else {
                const l = o(t, e),
                      u = o(r, n),
                      c = o(i, a);
                s.emplaceBack(l, u, c);
              }
            }

            return l(0, 0, Hp, Hp, Hp, 0), l(Hp, Hp, 0, 0, 0, Hp), {
              vertices: i,
              indices: s
            };
          }(this.tileID.canonical, e);

          n = t.vertices, i = t.indices;
        } else {
          n = new Ts(), i = new js();

          for (const {
            x: t,
            y: e
          } of r) n.emplaceBack(t, e, 0, 0);

          const t = Fl(n.int16, void 0, 4);

          for (let e = 0; e < t.length; e += 3) i.emplaceBack(t[e], t[e + 1], t[e + 2]);
        }

        this._tileBoundsBuffer = t.createVertexBuffer(n, nf.members), this._tileBoundsIndexBuffer = t.createIndexBuffer(i), this._tileBoundsSegments = Ka.simpleSegment(0, 0, n.length, i.length);
      }

      _makeGlobeTileDebugBuffers(t, e) {
        if (this._globeTileDebugBorderBuffer || this._globeTileDebugTextBuffer || !e || "globe" !== e.name) return;
        const r = this.tileID.canonical,
              n = Vp(Tp(r));
        this._makeGlobeTileDebugBorderBuffer(t, r, n), this._makeGlobeTileDebugTextBuffer(t, r, n);
      }

      _makeGlobeTileDebugBorderBuffer(t, e, r) {
        const n = new Is(),
              i = new Ys(),
              s = new Ms(),
              a = (t, a, o, l, u) => {
          const c = (o - t) / (u - 1),
                h = (l - a) / (u - 1),
                p = n.length;

          for (let o = 0; o < u; o++) {
            const l = t + o * c,
                  u = a + o * h;
            n.emplaceBack(l, u);
            const f = Dp(l, u, e),
                  d = ll(f, f, r);
            s.emplaceBack(d[0], d[1], d[2]), i.emplaceBack(p + o);
          }
        },
              o = Ya;

        a(0, 0, o, 0, 16), a(o, 0, o, o, 16), a(o, o, 0, o, 16), a(0, o, 0, 0, 16), this._tileDebugIndexBuffer = t.createIndexBuffer(i), this._tileDebugBuffer = t.createVertexBuffer(n, _p.members), this._globeTileDebugBorderBuffer = t.createVertexBuffer(s, bp.members), this._tileDebugSegments = Ka.simpleSegment(0, 0, n.length, i.length);
      }

      _makeGlobeTileDebugTextBuffer(t, e, r) {
        const n = new Is(),
              i = new js(),
              s = new Ms(),
              a = 25;
        i.reserve(32), n.reserve(a), s.reserve(a);

        const o = (t, e) => a * t + e;

        for (let t = 0; t < a; t++) {
          const i = 2048 * t;

          for (let t = 0; t < a; t++) {
            const a = 2048 * t;
            n.emplaceBack(a, i);
            const o = Dp(a, i, e),
                  l = ll(o, o, r);
            s.emplaceBack(l[0], l[1], l[2]);
          }
        }

        for (let t = 0; t < 4; t++) for (let e = 0; e < 4; e++) {
          const r = o(t, e),
                n = o(t, e + 1),
                s = o(t + 1, e),
                a = o(t + 1, e + 1);
          i.emplaceBack(r, n, s), i.emplaceBack(s, n, a);
        }

        this._tileDebugTextIndexBuffer = t.createIndexBuffer(i), this._tileDebugTextBuffer = t.createVertexBuffer(n, _p.members), this._globeTileDebugTextBuffer = t.createVertexBuffer(s, bp.members), this._tileDebugTextSegments = Ka.simpleSegment(0, 0, a, 32);
      }

    }

    class of {
      constructor() {
        this.state = {}, this.stateChanges = {}, this.deletedStates = {};
      }

      updateState(t, e, r) {
        const n = String(e);

        if (this.stateChanges[t] = this.stateChanges[t] || {}, this.stateChanges[t][n] = this.stateChanges[t][n] || {}, b(this.stateChanges[t][n], r), null === this.deletedStates[t]) {
          this.deletedStates[t] = {};

          for (const e in this.state[t]) e !== n && (this.deletedStates[t][e] = null);
        } else if (this.deletedStates[t] && null === this.deletedStates[t][n]) {
          this.deletedStates[t][n] = {};

          for (const e in this.state[t][n]) r[e] || (this.deletedStates[t][n][e] = null);
        } else for (const e in r) this.deletedStates[t] && this.deletedStates[t][n] && null === this.deletedStates[t][n][e] && delete this.deletedStates[t][n][e];
      }

      removeFeatureState(t, e, r) {
        if (null === this.deletedStates[t]) return;
        const n = String(e);
        if (this.deletedStates[t] = this.deletedStates[t] || {}, r && void 0 !== e) null !== this.deletedStates[t][n] && (this.deletedStates[t][n] = this.deletedStates[t][n] || {}, this.deletedStates[t][n][r] = null);else if (void 0 !== e) {
          if (this.stateChanges[t] && this.stateChanges[t][n]) for (r in this.deletedStates[t][n] = {}, this.stateChanges[t][n]) this.deletedStates[t][n][r] = null;else this.deletedStates[t][n] = null;
        } else this.deletedStates[t] = null;
      }

      getState(t, e) {
        const r = String(e),
              n = b({}, (this.state[t] || {})[r], (this.stateChanges[t] || {})[r]);
        if (null === this.deletedStates[t]) return {};

        if (this.deletedStates[t]) {
          const r = this.deletedStates[t][e];
          if (null === r) return {};

          for (const t in r) delete n[t];
        }

        return n;
      }

      initializeTileState(t, e) {
        t.setFeatureState(this.state, e);
      }

      coalesceChanges(t, e) {
        const r = {};

        for (const t in this.stateChanges) {
          this.state[t] = this.state[t] || {};
          const e = {};

          for (const r in this.stateChanges[t]) this.state[t][r] || (this.state[t][r] = {}), b(this.state[t][r], this.stateChanges[t][r]), e[r] = this.state[t][r];

          r[t] = e;
        }

        for (const t in this.deletedStates) {
          this.state[t] = this.state[t] || {};
          const e = {};
          if (null === this.deletedStates[t]) for (const r in this.state[t]) e[r] = {}, this.state[t][r] = {};else for (const r in this.deletedStates[t]) {
            if (null === this.deletedStates[t][r]) this.state[t][r] = {};else for (const e of Object.keys(this.deletedStates[t][r])) delete this.state[t][r][e];
            e[r] = this.state[t][r];
          }
          r[t] = r[t] || {}, b(r[t], e);
        }

        if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(r).length) for (const n in t) t[n].setFeatureState(r, e);
      }

    }

    class lf {
      constructor(t) {
        this.size = t, this.minimums = [], this.maximums = [], this.leaves = [];
      }

      getElevation(t, e) {
        const r = this.toIdx(t, e);
        return {
          min: this.minimums[r],
          max: this.maximums[r]
        };
      }

      isLeaf(t, e) {
        return this.leaves[this.toIdx(t, e)];
      }

      toIdx(t, e) {
        return e * this.size + t;
      }

    }

    function uf(t, e, r, n) {
      let i = 0,
          s = Number.MAX_VALUE;

      for (let a = 0; a < 3; a++) if (Math.abs(n[a]) < 1e-15) {
        if (r[a] < t[a] || r[a] > e[a]) return null;
      } else {
        const o = 1 / n[a];
        let l = (t[a] - r[a]) * o,
            u = (e[a] - r[a]) * o;

        if (l > u) {
          const t = l;
          l = u, u = t;
        }

        if (l > i && (i = l), u < s && (s = u), i > s) return null;
      }

      return i;
    }

    function cf(t, e, r, n, i, s, a, o, l, u, c) {
      const h = n - t,
            p = i - e,
            f = s - r,
            d = a - t,
            y = o - e,
            m = l - r,
            g = c[1] * m - c[2] * y,
            x = c[2] * d - c[0] * m,
            v = c[0] * y - c[1] * d,
            b = h * g + p * x + f * v;
      if (Math.abs(b) < 1e-15) return null;

      const _ = 1 / b,
            w = u[0] - t,
            A = u[1] - e,
            k = u[2] - r,
            S = (w * g + A * x + k * v) * _;

      if (S < 0 || S > 1) return null;
      const I = A * f - k * p,
            M = k * h - w * f,
            T = w * p - A * h,
            z = (c[0] * I + c[1] * M + c[2] * T) * _;
      return z < 0 || S + z > 1 ? null : (d * I + y * M + m * T) * _;
    }

    function hf(t, e, r) {
      return (t - e) / (r - e);
    }

    function pf(t, e, r, n, i, s, a, o, l) {
      const u = 1 << r,
            c = s - n,
            h = a - i,
            p = (t + 1) / u * c + n,
            f = (e + 0) / u * h + i,
            d = (e + 1) / u * h + i;
      o[0] = (t + 0) / u * c + n, o[1] = f, l[0] = p, l[1] = d;
    }

    class ff {
      constructor(t) {
        if (this.maximums = [], this.minimums = [], this.leaves = [], this.childOffsets = [], this.nodeCount = 0, this.dem = t, this._siblingOffset = [[0, 0], [1, 0], [0, 1], [1, 1]], !this.dem) return;

        const e = function (t) {
          const e = Math.ceil(Math.log2(t.dim / 8)),
                r = [];
          let n = Math.ceil(Math.pow(2, e));

          const i = 1 / n,
                s = (t, e, r, n, i) => {
            const s = n ? 1 : 0,
                  a = (t + 1) * r - s,
                  o = e * r,
                  l = (e + 1) * r - s;
            i[0] = t * r, i[1] = o, i[2] = a, i[3] = l;
          };

          let a = new lf(n);
          const o = [];

          for (let e = 0; e < n * n; e++) {
            s(e % n, Math.floor(e / n), i, !1, o);
            const r = yf(o[0], o[1], t),
                  l = yf(o[2], o[1], t),
                  u = yf(o[2], o[3], t),
                  c = yf(o[0], o[3], t);
            a.minimums.push(Math.min(r, l, u, c)), a.maximums.push(Math.max(r, l, u, c)), a.leaves.push(1);
          }

          for (r.push(a), n /= 2; n >= 1; n /= 2) {
            const t = r[r.length - 1];
            a = new lf(n);

            for (let e = 0; e < n * n; e++) {
              s(e % n, Math.floor(e / n), 2, !0, o);
              const r = t.getElevation(o[0], o[1]),
                    i = t.getElevation(o[2], o[1]),
                    l = t.getElevation(o[2], o[3]),
                    u = t.getElevation(o[0], o[3]),
                    c = t.isLeaf(o[0], o[1]),
                    h = t.isLeaf(o[2], o[1]),
                    p = t.isLeaf(o[2], o[3]),
                    f = t.isLeaf(o[0], o[3]),
                    d = Math.min(r.min, i.min, l.min, u.min),
                    y = Math.max(r.max, i.max, l.max, u.max),
                    m = c && h && p && f;
              a.maximums.push(y), a.minimums.push(d), a.leaves.push(y - d <= 5 && m ? 1 : 0);
            }

            r.push(a);
          }

          return r;
        }(this.dem),
              r = e.length - 1,
              n = e[r];

        this._addNode(n.minimums[0], n.maximums[0], n.leaves[0]), this._construct(e, 0, 0, r, 0);
      }

      raycastRoot(t, e, r, n, i, s, a = 1) {
        return uf([t, e, -100], [r, n, this.maximums[0] * a], i, s);
      }

      raycast(t, e, r, n, i, s, a = 1) {
        if (!this.nodeCount) return null;
        const o = this.raycastRoot(t, e, r, n, i, s, a);
        if (null == o) return null;
        const l = [],
              u = [],
              c = [],
              h = [],
              p = [{
          idx: 0,
          t: o,
          nodex: 0,
          nodey: 0,
          depth: 0
        }];

        for (; p.length > 0;) {
          const {
            idx: o,
            t: f,
            nodex: d,
            nodey: y,
            depth: m
          } = p.pop();

          if (this.leaves[o]) {
            pf(d, y, m, t, e, r, n, c, h);

            const o = 1 << m,
                  l = (d + 0) / o,
                  u = (d + 1) / o,
                  p = (y + 0) / o,
                  g = (y + 1) / o,
                  x = yf(l, p, this.dem) * a,
                  v = yf(u, p, this.dem) * a,
                  b = yf(u, g, this.dem) * a,
                  _ = yf(l, g, this.dem) * a,
                  w = cf(c[0], c[1], x, h[0], c[1], v, h[0], h[1], b, i, s),
                  A = cf(h[0], h[1], b, c[0], h[1], _, c[0], c[1], x, i, s),
                  k = Math.min(null !== w ? w : Number.MAX_VALUE, null !== A ? A : Number.MAX_VALUE);

            if (k !== Number.MAX_VALUE) return k;
            {
              const t = il([], i, s, f);
              if (df(x, v, _, b, hf(t[0], c[0], h[0]), hf(t[1], c[1], h[1])) >= t[2]) return f;
            }
            continue;
          }

          let g = 0;

          for (let p = 0; p < this._siblingOffset.length; p++) {
            pf((d << 1) + this._siblingOffset[p][0], (y << 1) + this._siblingOffset[p][1], m + 1, t, e, r, n, c, h), c[2] = -100, h[2] = this.maximums[this.childOffsets[o] + p] * a;
            const f = uf(c, h, i, s);

            if (null != f) {
              const t = f;
              l[p] = t;
              let e = !1;

              for (let r = 0; r < g && !e; r++) t >= l[u[r]] && (u.splice(r, 0, p), e = !0);

              e || (u[g] = p), g++;
            }
          }

          for (let t = 0; t < g; t++) {
            const e = u[t];
            p.push({
              idx: this.childOffsets[o] + e,
              t: l[e],
              nodex: (d << 1) + this._siblingOffset[e][0],
              nodey: (y << 1) + this._siblingOffset[e][1],
              depth: m + 1
            });
          }
        }

        return null;
      }

      _addNode(t, e, r) {
        return this.minimums.push(t), this.maximums.push(e), this.leaves.push(r), this.childOffsets.push(0), this.nodeCount++;
      }

      _construct(t, e, r, n, i) {
        if (1 === t[n].isLeaf(e, r)) return;
        this.childOffsets[i] || (this.childOffsets[i] = this.nodeCount);
        const s = n - 1,
              a = t[s];
        let o = 0,
            l = 0;

        for (let t = 0; t < this._siblingOffset.length; t++) {
          const n = 2 * e + this._siblingOffset[t][0],
                i = 2 * r + this._siblingOffset[t][1],
                s = a.getElevation(n, i),
                u = a.isLeaf(n, i),
                c = this._addNode(s.min, s.max, u);

          u && (o |= 1 << t), l || (l = c);
        }

        for (let n = 0; n < this._siblingOffset.length; n++) o & 1 << n || this._construct(t, 2 * e + this._siblingOffset[n][0], 2 * r + this._siblingOffset[n][1], s, l + n);
      }

    }

    function df(t, e, r, n, i, s) {
      return rr(rr(t, r, s), rr(e, n, s), i);
    }

    function yf(t, e, r) {
      const n = r.dim,
            i = y(t * n - .5, 0, n - 1),
            s = y(e * n - .5, 0, n - 1),
            a = Math.floor(i),
            o = Math.floor(s),
            l = Math.min(a + 1, n - 1),
            u = Math.min(o + 1, n - 1);
      return df(r.get(a, o), r.get(l, o), r.get(a, u), r.get(l, u), i - a, s - o);
    }

    const mf = {
      mapbox: [6553.6, 25.6, .1, 1e4],
      terrarium: [256, 1, 1 / 256, 32768]
    };

    class gf {
      get tree() {
        return this._tree || this._buildQuadTree(), this._tree;
      }

      constructor(t, e, r, n = !1, i = !1) {
        if (this.uid = t, e.height !== e.width) throw new RangeError("DEM tiles must be square");
        if (r && "mapbox" !== r && "terrarium" !== r) return C(`"${r}" is not a valid encoding type. Valid types include "mapbox" and "terrarium".`);
        this.stride = e.height;
        const s = this.dim = e.height - 2,
              a = new Uint32Array(e.data.buffer);

        if (this.pixels = new Uint8Array(e.data.buffer), this.encoding = r || "mapbox", this.borderReady = n, !n) {
          for (let t = 0; t < s; t++) a[this._idx(-1, t)] = a[this._idx(0, t)], a[this._idx(s, t)] = a[this._idx(s - 1, t)], a[this._idx(t, -1)] = a[this._idx(t, 0)], a[this._idx(t, s)] = a[this._idx(t, s - 1)];

          a[this._idx(-1, -1)] = a[this._idx(0, 0)], a[this._idx(s, -1)] = a[this._idx(s - 1, 0)], a[this._idx(-1, s)] = a[this._idx(0, s - 1)], a[this._idx(s, s)] = a[this._idx(s - 1, s - 1)], i && this._buildQuadTree();
        }
      }

      _buildQuadTree() {
        this._tree = new ff(this);
      }

      get(t, e, r = !1) {
        r && (t = y(t, -1, this.dim), e = y(e, -1, this.dim));

        const n = 4 * this._idx(t, e);

        return ("terrarium" === this.encoding ? this._unpackTerrarium : this._unpackMapbox)(this.pixels[n], this.pixels[n + 1], this.pixels[n + 2]);
      }

      static getUnpackVector(t) {
        return mf[t];
      }

      get unpackVector() {
        return mf[this.encoding];
      }

      _idx(t, e) {
        if (t < -1 || t >= this.dim + 1 || e < -1 || e >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
        return (e + 1) * this.stride + (t + 1);
      }

      _unpackMapbox(t, e, r) {
        return (256 * t * 256 + 256 * e + r) / 10 - 1e4;
      }

      _unpackTerrarium(t, e, r) {
        return 256 * t + e + r / 256 - 32768;
      }

      static pack(t, e) {
        const r = [0, 0, 0, 0],
              n = gf.getUnpackVector(e);
        let i = Math.floor((t + n[3]) / n[2]);
        return r[2] = i % 256, i = Math.floor(i / 256), r[1] = i % 256, i = Math.floor(i / 256), r[0] = i, r;
      }

      getPixels() {
        return new Bl({
          width: this.stride,
          height: this.stride
        }, this.pixels);
      }

      backfillBorder(t, e, r) {
        if (this.dim !== t.dim) throw new Error("dem dimension mismatch");
        let n = e * this.dim,
            i = e * this.dim + this.dim,
            s = r * this.dim,
            a = r * this.dim + this.dim;

        switch (e) {
          case -1:
            n = i - 1;
            break;

          case 1:
            i = n + 1;
        }

        switch (r) {
          case -1:
            s = a - 1;
            break;

          case 1:
            a = s + 1;
        }

        const o = -e * this.dim,
              l = -r * this.dim;

        for (let e = s; e < a; e++) for (let r = n; r < i; r++) {
          const n = 4 * this._idx(r, e),
                i = 4 * this._idx(r + o, e + l);

          this.pixels[n + 0] = t.pixels[i + 0], this.pixels[n + 1] = t.pixels[i + 1], this.pixels[n + 2] = t.pixels[i + 2], this.pixels[n + 3] = t.pixels[i + 3];
        }
      }

      onDeserialize() {
        this._tree && (this._tree.dem = this);
      }

    }

    ai(gf, "DEMData"), ai(ff, "DemMinMaxQuadTree", {
      omit: ["dem"]
    });

    class xf {
      constructor(t, e) {
        this.max = t, this.onRemove = e, this.reset();
      }

      reset() {
        for (const t in this.data) for (const e of this.data[t]) e.timeout && clearTimeout(e.timeout), this.onRemove(e.value);

        return this.data = {}, this.order = [], this;
      }

      add(t, e, r) {
        const n = t.wrapped().key;
        void 0 === this.data[n] && (this.data[n] = []);
        const i = {
          value: e,
          timeout: void 0
        };

        if (void 0 !== r && (i.timeout = setTimeout(() => {
          this.remove(t, i);
        }, r)), this.data[n].push(i), this.order.push(n), this.order.length > this.max) {
          const t = this._getAndRemoveByKey(this.order[0]);

          t && this.onRemove(t);
        }

        return this;
      }

      has(t) {
        return t.wrapped().key in this.data;
      }

      getAndRemove(t) {
        return this.has(t) ? this._getAndRemoveByKey(t.wrapped().key) : null;
      }

      _getAndRemoveByKey(t) {
        const e = this.data[t].shift();
        return e.timeout && clearTimeout(e.timeout), 0 === this.data[t].length && delete this.data[t], this.order.splice(this.order.indexOf(t), 1), e.value;
      }

      getByKey(t) {
        const e = this.data[t];
        return e ? e[0].value : null;
      }

      get(t) {
        return this.has(t) ? this.data[t.wrapped().key][0].value : null;
      }

      remove(t, e) {
        if (!this.has(t)) return this;
        const r = t.wrapped().key,
              n = void 0 === e ? 0 : this.data[r].indexOf(e),
              i = this.data[r][n];
        return this.data[r].splice(n, 1), i.timeout && clearTimeout(i.timeout), 0 === this.data[r].length && delete this.data[r], this.onRemove(i.value), this.order.splice(this.order.indexOf(r), 1), this;
      }

      setMaxSize(t) {
        for (this.max = t; this.order.length > this.max;) {
          const t = this._getAndRemoveByKey(this.order[0]);

          t && this.onRemove(t);
        }

        return this;
      }

      filter(t) {
        const e = [];

        for (const r in this.data) for (const n of this.data[r]) t(n.value) || e.push(n);

        for (const t of e) this.remove(t.value.tileID, t);
      }

    }

    class vf {
      constructor(t, e, r) {
        this.func = t, this.mask = e, this.range = r;
      }

    }

    vf.ReadOnly = !1, vf.ReadWrite = !0, vf.disabled = new vf(519, vf.ReadOnly, [0, 1]);
    const bf = 7680;

    class _f {
      constructor(t, e, r, n, i, s) {
        this.test = t, this.ref = e, this.mask = r, this.fail = n, this.depthFail = i, this.pass = s;
      }

    }

    _f.disabled = new _f({
      func: 519,
      mask: 0
    }, 0, 0, bf, bf, bf);

    class wf {
      constructor(t, e, r) {
        this.blendFunction = t, this.blendColor = e, this.mask = r;
      }

    }

    wf.Replace = [1, 0], wf.disabled = new wf(wf.Replace, ce.transparent, [!1, !1, !1, !1]), wf.unblended = new wf(wf.Replace, ce.transparent, [!0, !0, !0, !0]), wf.alphaBlended = new wf([1, 771], ce.transparent, [!0, !0, !0, !0]);
    const Af = 1029,
          kf = 2305;

    class Sf {
      constructor(t, e, r) {
        this.enable = t, this.mode = e, this.frontFace = r;
      }

    }

    Sf.disabled = new Sf(!1, Af, kf), Sf.backCCW = new Sf(!0, Af, kf), Sf.backCW = new Sf(!0, Af, 2304), Sf.frontCW = new Sf(!0, 1028, 2304), Sf.frontCCW = new Sf(!0, 1028, kf);

    class If extends Ut {
      constructor(t, e, r) {
        super(), this.id = t, this._onlySymbols = r, e.on("data", t => {
          "source" === t.dataType && "metadata" === t.sourceDataType && (this._sourceLoaded = !0), this._sourceLoaded && !this._paused && "source" === t.dataType && "content" === t.sourceDataType && (this.reload(), this.transform && this.update(this.transform));
        }), e.on("error", () => {
          this._sourceErrored = !0;
        }), this._source = e, this._tiles = {}, this._cache = new xf(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._minTileCacheSize = e.minTileCacheSize, this._maxTileCacheSize = e.maxTileCacheSize, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new of(), this._isRaster = "raster" === this._source.type || "raster-dem" === this._source.type || "custom" === this._source.type && "raster" === this._source._dataType;
      }

      onAdd(t) {
        this.map = t, this._minTileCacheSize = void 0 === this._minTileCacheSize && t ? t._minTileCacheSize : this._minTileCacheSize, this._maxTileCacheSize = void 0 === this._maxTileCacheSize && t ? t._maxTileCacheSize : this._maxTileCacheSize;
      }

      loaded() {
        if (this._sourceErrored) return !0;
        if (!this._sourceLoaded) return !1;
        if (!this._source.loaded()) return !1;

        for (const t in this._tiles) {
          const e = this._tiles[t];
          if ("loaded" !== e.state && "errored" !== e.state) return !1;
        }

        return !0;
      }

      getSource() {
        return this._source;
      }

      pause() {
        this._paused = !0;
      }

      resume() {
        if (!this._paused) return;
        const t = this._shouldReloadOnResume;
        this._paused = !1, this._shouldReloadOnResume = !1, t && this.reload(), this.transform && this.update(this.transform);
      }

      _loadTile(t, e) {
        return t.isSymbolTile = this._onlySymbols, this._source.loadTile(t, e);
      }

      _unloadTile(t) {
        if (this._source.unloadTile) return this._source.unloadTile(t, () => {});
      }

      _abortTile(t) {
        if (this._source.abortTile) return this._source.abortTile(t, () => {});
      }

      serialize() {
        return this._source.serialize();
      }

      prepare(t) {
        if (this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null), this._source.prepareTile) for (const e in this._tiles) {
          const r = this._tiles[e];
          this._source.prepareTile(r) && this.map.painter.terrain && this.map.painter.terrain._clearRenderCacheForTile(this.id, r.tileID), r.upload(t), r.prepare(this.map.style.imageManager);
        } else for (const e in this._tiles) {
          const r = this._tiles[e];
          r.upload(t), r.prepare(this.map.style.imageManager);
        }
      }

      getIds() {
        return v(this._tiles).map(t => t.tileID).sort(Mf).map(t => t.key);
      }

      getRenderableIds(t) {
        const e = [];

        for (const r in this._tiles) this._isIdRenderable(+r, t) && e.push(this._tiles[r]);

        return t ? e.sort((t, e) => {
          const r = t.tileID,
                n = e.tileID,
                s = new i(r.canonical.x, r.canonical.y)._rotate(this.transform.angle),
                a = new i(n.canonical.x, n.canonical.y)._rotate(this.transform.angle);

          return r.overscaledZ - n.overscaledZ || a.y - s.y || a.x - s.x;
        }).map(t => t.tileID.key) : e.map(t => t.tileID).sort(Mf).map(t => t.key);
      }

      hasRenderableParent(t) {
        const e = this.findLoadedParent(t, 0);
        return !!e && this._isIdRenderable(e.tileID.key);
      }

      _isIdRenderable(t, e) {
        return this._tiles[t] && this._tiles[t].hasData() && !this._coveredTiles[t] && (e || !this._tiles[t].holdingForFade());
      }

      reload() {
        if (this._paused) this._shouldReloadOnResume = !0;else {
          this._cache.reset();

          for (const t in this._tiles) "errored" !== this._tiles[t].state && this._reloadTile(+t, "reloading");
        }
      }

      _reloadTile(t, e) {
        const r = this._tiles[t];
        r && ("loading" !== r.state && (r.state = e), this._loadTile(r, this._tileLoaded.bind(this, r, t, e)));
      }

      _tileLoaded(t, e, r, n) {
        if (n) {
          if (t.state = "errored", 404 !== n.status) this._source.fire(new Rt(n, {
            tile: t
          }));else if ("raster-dem" === this._source.type && this.usedForTerrain && this.map.painter.terrain) {
            const t = this.map.painter.terrain;
            this.update(this.transform, t.getScaledDemTileSize(), !0), t.resetTileLookupCache(this.id);
          } else this.update(this.transform);
        } else t.timeAdded = N.now(), "expired" === r && (t.refreshedUponExpiration = !0), this._setTileReloadTimer(e, t), "raster-dem" === this._source.type && t.dem && this._backfillDEM(t), this._state.initializeTileState(t, this.map ? this.map.painter : null), this._source.fire(new Lt("data", {
          dataType: "source",
          tile: t,
          coord: t.tileID,
          sourceCacheId: this.id
        }));
      }

      _backfillDEM(t) {
        const e = this.getRenderableIds();

        for (let n = 0; n < e.length; n++) {
          const i = e[n];

          if (t.neighboringTiles && t.neighboringTiles[i]) {
            const e = this.getTileByID(i);
            r(t, e), r(e, t);
          }
        }

        function r(t, e) {
          if (!t.dem || t.dem.borderReady) return;
          t.needsHillshadePrepare = !0, t.needsDEMTextureUpload = !0;
          let r = e.tileID.canonical.x - t.tileID.canonical.x;
          const n = e.tileID.canonical.y - t.tileID.canonical.y,
                i = Math.pow(2, t.tileID.canonical.z),
                s = e.tileID.key;
          0 === r && 0 === n || Math.abs(n) > 1 || (Math.abs(r) > 1 && (1 === Math.abs(r + i) ? r += i : 1 === Math.abs(r - i) && (r -= i)), e.dem && t.dem && (t.dem.backfillBorder(e.dem, r, n), t.neighboringTiles && t.neighboringTiles[s] && (t.neighboringTiles[s].backfilled = !0)));
        }
      }

      getTile(t) {
        return this.getTileByID(t.key);
      }

      getTileByID(t) {
        return this._tiles[t];
      }

      _retainLoadedChildren(t, e, r, n) {
        for (const i in this._tiles) {
          let s = this._tiles[i];
          if (n[i] || !s.hasData() || s.tileID.overscaledZ <= e || s.tileID.overscaledZ > r) continue;
          let a = s.tileID;

          for (; s && s.tileID.overscaledZ > e + 1;) {
            const t = s.tileID.scaledTo(s.tileID.overscaledZ - 1);
            s = this._tiles[t.key], s && s.hasData() && (a = t);
          }

          let o = a;

          for (; o.overscaledZ > e;) if (o = o.scaledTo(o.overscaledZ - 1), t[o.key]) {
            n[a.key] = a;
            break;
          }
        }
      }

      findLoadedParent(t, e) {
        if (t.key in this._loadedParentTiles) {
          const r = this._loadedParentTiles[t.key];
          return r && r.tileID.overscaledZ >= e ? r : null;
        }

        for (let r = t.overscaledZ - 1; r >= e; r--) {
          const e = t.scaledTo(r),
                n = this._getLoadedTile(e);

          if (n) return n;
        }
      }

      _getLoadedTile(t) {
        const e = this._tiles[t.key];
        return e && e.hasData() ? e : this._cache.getByKey(this._source.reparseOverscaled ? t.wrapped().key : t.canonical.key);
      }

      updateCacheSize(t, e) {
        e = e || this._source.tileSize;
        const r = Math.ceil(t.width / e) + 1,
              n = Math.ceil(t.height / e) + 1,
              i = Math.floor(r * n * 5),
              s = "number" == typeof this._minTileCacheSize ? Math.max(this._minTileCacheSize, i) : i,
              a = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, s) : s;

        this._cache.setMaxSize(a);
      }

      handleWrapJump(t) {
        const e = Math.round((t - (void 0 === this._prevLng ? t : this._prevLng)) / 360);

        if (this._prevLng = t, e) {
          const t = {};

          for (const r in this._tiles) {
            const n = this._tiles[r];
            n.tileID = n.tileID.unwrapTo(n.tileID.wrap + e), t[n.tileID.key] = n;
          }

          this._tiles = t;

          for (const t in this._timers) clearTimeout(this._timers[t]), delete this._timers[t];

          for (const t in this._tiles) this._setTileReloadTimer(+t, this._tiles[t]);
        }
      }

      update(t, e, r) {
        if (this.transform = t, !this._sourceLoaded || this._paused || this.transform.freezeTileCoverage) return;
        if (this.usedForTerrain && !r) return;
        let n;
        this.updateCacheSize(t, e), "globe" !== this.transform.projection.name && this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? n = t.getVisibleUnwrappedCoordinates(this._source.tileID).map(t => new Np(t.canonical.z, t.wrap, t.canonical.z, t.canonical.x, t.canonical.y)) : (n = t.coveringTiles({
          tileSize: e || this._source.tileSize,
          minzoom: this._source.minzoom,
          maxzoom: this._source.maxzoom,
          roundZoom: this._source.roundZoom && !r,
          reparseOverscaled: this._source.reparseOverscaled,
          isTerrainDEM: this.usedForTerrain
        }), this._source.hasTile && (n = n.filter(t => this._source.hasTile(t)))) : n = [];

        const i = this._updateRetainedTiles(n);

        if (Tf(this._source.type) && 0 !== n.length) {
          const t = {},
                e = {},
                r = Object.keys(i);

          for (const n of r) {
            const r = i[n],
                  s = this._tiles[n];
            if (!s || s.fadeEndTime && s.fadeEndTime <= N.now()) continue;
            const a = this.findLoadedParent(r, Math.max(r.overscaledZ - If.maxOverzooming, this._source.minzoom));
            a && (this._addTile(a.tileID), t[a.tileID.key] = a.tileID), e[n] = r;
          }

          const s = n[n.length - 1].overscaledZ;

          for (const t in this._tiles) {
            const r = this._tiles[t];
            if (i[t] || !r.hasData()) continue;
            let n = r.tileID;

            for (; n.overscaledZ > s;) {
              n = n.scaledTo(n.overscaledZ - 1);
              const s = this._tiles[n.key];

              if (s && s.hasData() && e[n.key]) {
                i[t] = r.tileID;
                break;
              }
            }
          }

          for (const e in t) i[e] || (this._coveredTiles[e] = !0, i[e] = t[e]);
        }

        for (const t in i) this._tiles[t].clearFadeHold();

        const s = function (t, e) {
          const r = [];

          for (const n in t) n in e || r.push(n);

          return r;
        }(this._tiles, i);

        for (const t of s) {
          const e = this._tiles[t];
          e.hasSymbolBuckets && !e.holdingForFade() ? e.setHoldDuration(this.map._fadeDuration) : e.hasSymbolBuckets && !e.symbolFadeFinished() || this._removeTile(+t);
        }

        this._updateLoadedParentTileCache(), this._onlySymbols && this._source.afterUpdate && this._source.afterUpdate();
      }

      releaseSymbolFadeTiles() {
        for (const t in this._tiles) this._tiles[t].holdingForFade() && this._removeTile(+t);
      }

      _updateRetainedTiles(t) {
        const e = {};
        if (0 === t.length) return e;
        const r = {},
              n = t.reduce((t, e) => Math.min(t, e.overscaledZ), 1 / 0),
              i = t[0].overscaledZ,
              s = Math.max(i - If.maxOverzooming, this._source.minzoom),
              a = Math.max(i + If.maxUnderzooming, this._source.minzoom),
              o = {};

        for (const r of t) {
          const t = this._addTile(r);

          e[r.key] = r, t.hasData() || n < this._source.maxzoom && (o[r.key] = r);
        }

        this._retainLoadedChildren(o, n, a, e);

        for (const n of t) {
          let t = this._tiles[n.key];
          if (t.hasData()) continue;

          if (n.canonical.z >= this._source.maxzoom) {
            const t = n.children(this._source.maxzoom)[0],
                  r = this.getTile(t);

            if (r && r.hasData()) {
              e[t.key] = t;
              continue;
            }
          } else {
            const t = n.children(this._source.maxzoom);
            if (e[t[0].key] && e[t[1].key] && e[t[2].key] && e[t[3].key]) continue;
          }

          let i = t.wasRequested();

          for (let a = n.overscaledZ - 1; a >= s; --a) {
            const s = n.scaledTo(a);
            if (r[s.key]) break;
            if (r[s.key] = !0, t = this.getTile(s), !t && i && (t = this._addTile(s)), t && (e[s.key] = s, i = t.wasRequested(), t.hasData())) break;
          }
        }

        return e;
      }

      _updateLoadedParentTileCache() {
        this._loadedParentTiles = {};

        for (const t in this._tiles) {
          const e = [];
          let r,
              n = this._tiles[t].tileID;

          for (; n.overscaledZ > 0;) {
            if (n.key in this._loadedParentTiles) {
              r = this._loadedParentTiles[n.key];
              break;
            }

            e.push(n.key);
            const t = n.scaledTo(n.overscaledZ - 1);
            if (r = this._getLoadedTile(t), r) break;
            n = t;
          }

          for (const t of e) this._loadedParentTiles[t] = r;
        }
      }

      _addTile(t) {
        let e = this._tiles[t.key];
        if (e) return this._source.prepareTile && this._source.prepareTile(e), e;
        e = this._cache.getAndRemove(t), e && (this._setTileReloadTimer(t.key, e), e.tileID = t, this._state.initializeTileState(e, this.map ? this.map.painter : null), this._cacheTimers[t.key] && (clearTimeout(this._cacheTimers[t.key]), delete this._cacheTimers[t.key], this._setTileReloadTimer(t.key, e)));
        const r = Boolean(e);

        if (!r) {
          const r = this.map ? this.map.painter : null;
          e = new af(t, this._source.tileSize * t.overscaleFactor(), this.transform.tileZoom, r, this._isRaster), this._source.prepareTile && this._source.prepareTile(e) || this._loadTile(e, this._tileLoaded.bind(this, e, t.key, e.state));
        }

        return e ? (e.uses++, this._tiles[t.key] = e, r || this._source.fire(new Lt("dataloading", {
          tile: e,
          coord: e.tileID,
          dataType: "source"
        })), e) : null;
      }

      _setTileReloadTimer(t, e) {
        t in this._timers && (clearTimeout(this._timers[t]), delete this._timers[t]);
        const r = e.getExpiryTimeout();
        r && (this._timers[t] = setTimeout(() => {
          this._reloadTile(t, "expired"), delete this._timers[t];
        }, r));
      }

      _removeTile(t) {
        const e = this._tiles[t];
        e && (e.uses--, delete this._tiles[t], this._timers[t] && (clearTimeout(this._timers[t]), delete this._timers[t]), e.uses > 0 || (e.hasData() && "reloading" !== e.state ? this._cache.add(e.tileID, e, e.getExpiryTimeout()) : (e.aborted = !0, this._abortTile(e), this._unloadTile(e))));
      }

      clearTiles() {
        this._shouldReloadOnResume = !1, this._paused = !1;

        for (const t in this._tiles) this._removeTile(+t);

        this._source._clear && this._source._clear(), this._cache.reset(), this.map && this.usedForTerrain && this.map.painter.terrain && this.map.painter.terrain.resetTileLookupCache(this.id);
      }

      tilesIn(t, e, r) {
        const n = [],
              i = this.transform;
        if (!i) return n;

        for (const s in this._tiles) {
          const a = this._tiles[s];
          if (r && a.clearQueryDebugViz(), a.holdingForFade()) continue;
          const o = t.containsTile(a, i, e);
          o && n.push(o);
        }

        return n;
      }

      getVisibleCoordinates(t) {
        const e = this.getRenderableIds(t).map(t => this._tiles[t].tileID);

        for (const t of e) t.projMatrix = this.transform.calculateProjMatrix(t.toUnwrapped());

        return e;
      }

      hasTransition() {
        if (this._source.hasTransition()) return !0;
        if (Tf(this._source.type)) for (const t in this._tiles) {
          const e = this._tiles[t];
          if (void 0 !== e.fadeEndTime && e.fadeEndTime >= N.now()) return !0;
        }
        return !1;
      }

      setFeatureState(t, e, r) {
        this._state.updateState(t = t || "_geojsonTileLayer", e, r);
      }

      removeFeatureState(t, e, r) {
        this._state.removeFeatureState(t = t || "_geojsonTileLayer", e, r);
      }

      getFeatureState(t, e) {
        return this._state.getState(t = t || "_geojsonTileLayer", e);
      }

      setDependencies(t, e, r) {
        const n = this._tiles[t];
        n && n.setDependencies(e, r);
      }

      reloadTilesForDependencies(t, e) {
        for (const r in this._tiles) this._tiles[r].hasDependency(t, e) && this._reloadTile(+r, "reloading");

        this._cache.filter(r => !r.hasDependency(t, e));
      }

      _preloadTiles(t, e) {
        const r = new Map(),
              n = Array.isArray(t) ? t : [t],
              i = this.map.painter.terrain,
              s = this.usedForTerrain && i ? i.getScaledDemTileSize() : this._source.tileSize;

        for (const t of n) {
          const e = t.coveringTiles({
            tileSize: s,
            minzoom: this._source.minzoom,
            maxzoom: this._source.maxzoom,
            roundZoom: this._source.roundZoom && !this.usedForTerrain,
            reparseOverscaled: this._source.reparseOverscaled,
            isTerrainDEM: this.usedForTerrain
          });

          for (const t of e) r.set(t.key, t);

          this.usedForTerrain && t.updateElevation(!1);
        }

        x(Array.from(r.values()), (t, e) => {
          const r = new af(t, this._source.tileSize * t.overscaleFactor(), this.transform.tileZoom, this.map.painter, this._isRaster);

          this._loadTile(r, t => {
            "raster-dem" === this._source.type && r.dem && this._backfillDEM(r), e(t, r);
          });
        }, e);
      }

    }

    function Mf(t, e) {
      const r = Math.abs(2 * t.wrap) - +(t.wrap < 0),
            n = Math.abs(2 * e.wrap) - +(e.wrap < 0);
      return t.overscaledZ - e.overscaledZ || n - r || e.canonical.y - t.canonical.y || e.canonical.x - t.canonical.x;
    }

    function Tf(t) {
      return "raster" === t || "image" === t || "video" === t;
    }

    If.maxOverzooming = 10, If.maxUnderzooming = 3;

    class zf {
      constructor(t, e, r) {
        this._demTile = t, this._dem = this._demTile.dem, this._scale = e, this._offset = r;
      }

      static create(t, e, r) {
        const n = r || t.findDEMTileFor(e);
        if (!n || !n.dem) return;
        const i = n.dem,
              s = n.tileID,
              a = 1 << e.canonical.z - s.canonical.z;
        return new zf(n, n.tileSize / Ya / a, [(e.canonical.x / a - s.canonical.x) * i.dim, (e.canonical.y / a - s.canonical.y) * i.dim]);
      }

      tileCoordToPixel(t, e) {
        const r = e * this._scale + this._offset[1],
              n = Math.floor(t * this._scale + this._offset[0]),
              s = Math.floor(r);
        return new i(n, s);
      }

      getElevationAt(t, e, r, n) {
        const i = t * this._scale + this._offset[0],
              s = e * this._scale + this._offset[1],
              a = Math.floor(i),
              o = Math.floor(s),
              l = this._dem;
        return n = !!n, r ? rr(rr(l.get(a, o, n), l.get(a, o + 1, n), s - o), rr(l.get(a + 1, o, n), l.get(a + 1, o + 1, n), s - o), i - a) : l.get(a, o, n);
      }

      getElevationAtPixel(t, e, r) {
        return this._dem.get(t, e, !!r);
      }

      getMeterToDEM(t) {
        return (1 << this._demTile.tileID.canonical.z) * no(1, t) * this._dem.stride;
      }

    }

    class Bf {
      constructor(t, e) {
        this.tileID = t, this.x = t.canonical.x, this.y = t.canonical.y, this.z = t.canonical.z, this.grid = new ni(Ya, 16, 0), this.featureIndexArray = new ua(), this.promoteId = e;
      }

      insert(t, e, r, n, i, s = 0) {
        const a = this.featureIndexArray.length;
        this.featureIndexArray.emplaceBack(r, n, i, s);
        const o = this.grid;

        for (let t = 0; t < e.length; t++) {
          const r = e[t],
                n = [1 / 0, 1 / 0, -1 / 0, -1 / 0];

          for (let t = 0; t < r.length; t++) {
            const e = r[t];
            n[0] = Math.min(n[0], e.x), n[1] = Math.min(n[1], e.y), n[2] = Math.max(n[2], e.x), n[3] = Math.max(n[3], e.y);
          }

          n[0] < Ya && n[1] < Ya && n[2] >= 0 && n[3] >= 0 && o.insert(a, n[0], n[1], n[2], n[3]);
        }
      }

      loadVTLayers() {
        if (!this.vtLayers) {
          this.vtLayers = new Du.VectorTile(new wc(this.rawTileData)).layers, this.sourceLayerCoder = new Xp(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"]), this.vtFeatures = {};

          for (const t in this.vtLayers) this.vtFeatures[t] = [];
        }

        return this.vtLayers;
      }

      query(t, e, r, n) {
        this.loadVTLayers();
        const i = t.params || {},
              s = Sn(i.filter),
              a = t.tileResult,
              o = t.transform,
              l = a.bufferedTilespaceBounds,
              u = this.grid.query(l.min.x, l.min.y, l.max.x, l.max.y, (t, e, r, n) => Bo(a.bufferedTilespaceGeometry, t, e, r, n));
        u.sort(Cf);
        let c = null;
        o.elevation && u.length > 0 && (c = zf.create(o.elevation, this.tileID));
        const h = {};
        let p;

        for (let o = 0; o < u.length; o++) {
          const l = u[o];
          if (l === p) continue;
          p = l;
          const f = this.featureIndexArray.get(l);
          let d = null;
          this.loadMatchingFeature(h, f, s, i.layers, i.availableImages, e, r, n, (e, r, n, i = 0) => (d || (d = yo(e, this.tileID.canonical, t.tileTransform)), r.queryIntersectsFeature(a, e, n, d, this.z, t.transform, t.pixelPosMatrix, c, i)));
        }

        return h;
      }

      loadMatchingFeature(t, e, r, n, i, s, a, o, l) {
        const {
          featureIndex: u,
          bucketIndex: c,
          sourceLayerIndex: h,
          layoutVertexArrayOffset: p
        } = e,
              f = this.bucketLayerIDs[c];
        if (n && !function (t, e) {
          for (let r = 0; r < t.length; r++) if (e.indexOf(t[r]) >= 0) return !0;

          return !1;
        }(n, f)) return;
        const d = this.sourceLayerCoder.decode(h),
              y = this.vtLayers[d].feature(u);

        if (r.needGeometry) {
          const t = mo(y, !0);
          if (!r.filter(new ss(this.tileID.overscaledZ), t, this.tileID.canonical)) return;
        } else if (!r.filter(new ss(this.tileID.overscaledZ), y)) return;

        const m = this.getId(y, d);

        for (let e = 0; e < f.length; e++) {
          const r = f[e];
          if (n && n.indexOf(r) < 0) continue;
          const c = s[r];
          if (!c) continue;
          let h = {};
          void 0 !== m && o && (h = o.getState(c.sourceLayer || "_geojsonTileLayer", m));
          const d = b({}, a[r]);
          d.paint = Ef(d.paint, c.paint, y, h, i), d.layout = Ef(d.layout, c.layout, y, h, i);
          const g = !l || l(y, c, h, p);
          if (!g) continue;
          const x = new Yp(y, this.z, this.x, this.y, m);
          x.layer = d;
          let v = t[r];
          void 0 === v && (v = t[r] = []), v.push({
            featureIndex: u,
            feature: x,
            intersectionZ: g
          });
        }
      }

      lookupSymbolFeatures(t, e, r, n, i, s, a, o) {
        const l = {};
        this.loadVTLayers();
        const u = Sn(i);

        for (const i of t) this.loadMatchingFeature(l, {
          bucketIndex: r,
          sourceLayerIndex: n,
          featureIndex: i,
          layoutVertexArrayOffset: 0
        }, u, s, a, o, e);

        return l;
      }

      loadFeature(t) {
        const {
          featureIndex: e,
          sourceLayerIndex: r
        } = t;
        this.loadVTLayers();
        const n = this.sourceLayerCoder.decode(r),
              i = this.vtFeatures[n];
        if (i[e]) return i[e];
        const s = this.vtLayers[n].feature(e);
        return i[e] = s, s;
      }

      hasLayer(t) {
        for (const e of this.bucketLayerIDs) for (const r of e) if (t === r) return !0;

        return !1;
      }

      getId(t, e) {
        let r = t.id;
        return this.promoteId && (r = t.properties["string" == typeof this.promoteId ? this.promoteId : this.promoteId[e]], "boolean" == typeof r && (r = Number(r))), r;
      }

    }

    function Ef(t, e, r, n, i) {
      return T(t, (t, s) => {
        const a = e instanceof fs ? e.get(s) : null;
        return a && a.evaluate ? a.evaluate(r, n, i) : a;
      });
    }

    function Cf(t, e) {
      return e - t;
    }

    ai(Bf, "FeatureIndex", {
      omit: ["rawTileData", "sourceLayerCoder"]
    });

    class Df {
      constructor(t) {
        const e = {},
              r = [];

        for (const n in t) {
          const i = t[n],
                s = e[n] = {};

          for (const t in i.glyphs) {
            const e = i.glyphs[+t];
            if (!e || 0 === e.bitmap.width || 0 === e.bitmap.height) continue;
            const n = e.metrics.localGlyph ? 2 : 1,
                  a = {
              x: 0,
              y: 0,
              w: e.bitmap.width + 2 * n,
              h: e.bitmap.height + 2 * n
            };
            r.push(a), s[t] = a;
          }
        }

        const {
          w: n,
          h: i
        } = Gc(r),
              s = new zl({
          width: n || 1,
          height: i || 1
        });

        for (const r in t) {
          const n = t[r];

          for (const t in n.glyphs) {
            const i = n.glyphs[+t];
            if (!i || 0 === i.bitmap.width || 0 === i.bitmap.height) continue;
            const a = e[r][t],
                  o = i.metrics.localGlyph ? 2 : 1;
            zl.copy(i.bitmap, s, {
              x: 0,
              y: 0
            }, {
              x: a.x + o,
              y: a.y + o
            }, i.bitmap);
          }
        }

        this.image = s, this.positions = e;
      }

    }

    ai(Df, "GlyphAtlas");

    class Pf {
      constructor(t) {
        this.tileID = new Np(t.tileID.overscaledZ, t.tileID.wrap, t.tileID.canonical.z, t.tileID.canonical.x, t.tileID.canonical.y), this.tileZoom = t.tileZoom, this.uid = t.uid, this.zoom = t.zoom, this.canonical = t.tileID.canonical, this.pixelRatio = t.pixelRatio, this.tileSize = t.tileSize, this.source = t.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t.showCollisionBoxes, this.collectResourceTiming = !!t.collectResourceTiming, this.returnDependencies = !!t.returnDependencies, this.promoteId = t.promoteId, this.enableTerrain = !!t.enableTerrain, this.isSymbolTile = t.isSymbolTile, this.tileTransform = Zp(t.tileID.canonical, t.projection), this.projection = t.projection;
      }

      parse(t, e, r, n, i) {
        this.status = "parsing", this.data = t, this.collisionBoxArray = new ea();
        const s = new Xp(Object.keys(t.layers).sort()),
              a = new Bf(this.tileID, this.promoteId);
        a.bucketLayerIDs = [];
        const o = {},
              l = new pp(256, 256),
              u = {
          featureIndex: a,
          iconDependencies: {},
          patternDependencies: {},
          glyphDependencies: {},
          lineAtlas: l,
          availableImages: r
        },
              c = e.familiesBySource[this.source];

        for (const e in c) {
          const n = t.layers[e];
          if (!n) continue;
          let i = !1,
              l = !1;

          for (const t of c[e]) "symbol" === t[0].type ? i = !0 : l = !0;

          if (!0 === this.isSymbolTile && !i) continue;
          if (!1 === this.isSymbolTile && !l) continue;
          1 === n.version && C(`Vector tile source "${this.source}" layer "${e}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
          const h = s.encode(e),
                p = [];

          for (let t = 0; t < n.length; t++) {
            const r = n.feature(t),
                  i = a.getId(r, e);
            p.push({
              feature: r,
              id: i,
              index: t,
              sourceLayerIndex: h
            });
          }

          for (const t of c[e]) {
            const e = t[0];
            void 0 !== this.isSymbolTile && "symbol" === e.type !== this.isSymbolTile || e.minzoom && this.zoom < Math.floor(e.minzoom) || e.maxzoom && this.zoom >= e.maxzoom || "none" !== e.visibility && (Vf(t, this.zoom, r), (o[e.id] = e.createBucket({
              index: a.bucketLayerIDs.length,
              layers: t,
              zoom: this.zoom,
              canonical: this.canonical,
              pixelRatio: this.pixelRatio,
              overscaling: this.overscaling,
              collisionBoxArray: this.collisionBoxArray,
              sourceLayerIndex: h,
              sourceID: this.source,
              enableTerrain: this.enableTerrain,
              projection: this.projection.name,
              availableImages: r
            })).populate(p, u, this.tileID.canonical, this.tileTransform), a.bucketLayerIDs.push(t.map(t => t.id)));
          }
        }

        let h, p, f, d;
        l.trim();
        const y = {
          type: "maybePrepare",
          isSymbolTile: this.isSymbolTile,
          zoom: this.zoom
        },
              m = T(u.glyphDependencies, t => Object.keys(t).map(Number));
        Object.keys(m).length ? n.send("getGlyphs", {
          uid: this.uid,
          stacks: m
        }, (t, e) => {
          h || (h = t, p = e, b.call(this));
        }, void 0, !1, y) : p = {};
        const g = Object.keys(u.iconDependencies);
        g.length ? n.send("getImages", {
          icons: g,
          source: this.source,
          tileID: this.tileID,
          type: "icons"
        }, (t, e) => {
          h || (h = t, f = e, b.call(this));
        }, void 0, !1, y) : f = {};
        const x = Object.keys(u.patternDependencies);

        function b() {
          if (h) return i(h);

          if (p && f && d) {
            const t = new Df(p),
                  e = new Xc(f, d);

            for (const n in o) {
              const i = o[n];
              i instanceof tp ? (Vf(i.layers, this.zoom, r), Rh(i, p, t.positions, f, e.iconPositions, this.showCollisionBoxes, r, this.tileID.canonical, this.tileZoom, this.projection)) : i.hasPattern && (i instanceof Qu || i instanceof xu || i instanceof $u) && (Vf(i.layers, this.zoom, r), i.addFeatures(u, this.tileID.canonical, e.patternPositions, r, this.tileTransform));
            }

            this.status = "done", i(null, {
              buckets: v(o).filter(t => !t.isEmpty()),
              featureIndex: a,
              collisionBoxArray: this.collisionBoxArray,
              glyphAtlasImage: t.image,
              lineAtlas: l,
              imageAtlas: e,
              glyphMap: this.returnDependencies ? p : null,
              iconMap: this.returnDependencies ? f : null,
              glyphPositions: this.returnDependencies ? t.positions : null
            });
          }
        }

        x.length ? n.send("getImages", {
          icons: x,
          source: this.source,
          tileID: this.tileID,
          type: "patterns"
        }, (t, e) => {
          h || (h = t, d = e, b.call(this));
        }, void 0, !1, y) : d = {}, b.call(this);
      }

    }

    function Vf(t, e, r) {
      const n = new ss(e);

      for (const e of t) e.recalculate(n, r);
    }

    class Ff {
      constructor(t) {
        this.entries = {}, this.scheduler = t;
      }

      request(t, e, r, n) {
        const i = this.entries[t] = this.entries[t] || {
          callbacks: []
        };

        if (i.result) {
          const [t, r] = i.result;
          return this.scheduler ? this.scheduler.add(() => {
            n(t, r);
          }, e) : n(t, r), () => {};
        }

        return i.callbacks.push(n), i.cancel || (i.cancel = r((r, n) => {
          i.result = [r, n];

          for (const t of i.callbacks) this.scheduler ? this.scheduler.add(() => {
            t(r, n);
          }, e) : t(r, n);

          setTimeout(() => delete this.entries[t], 3e3);
        })), () => {
          i.result || (i.callbacks = i.callbacks.filter(t => t !== n), i.callbacks.length || (i.cancel(), delete this.entries[t]));
        };
      }

    }

    function Lf(t, e, r) {
      const n = JSON.stringify(t.request);
      return t.data && (this.deduped.entries[n] = {
        result: [null, t.data]
      }), this.deduped.request(n, {
        type: "parseTile",
        isSymbolTile: t.isSymbolTile,
        zoom: t.tileZoom
      }, e => {
        const n = Mt(t.request, (t, n, i, s) => {
          t ? e(t) : n && e(null, {
            vectorTile: r ? void 0 : new Du.VectorTile(new wc(n)),
            rawData: n,
            cacheControl: i,
            expires: s
          });
        });
        return () => {
          n.cancel(), e();
        };
      }, e);
    }

    const Rf = jo(new Float32Array(16));

    class Uf {
      constructor(t) {
        this.name = t.name, this.wrap = !1, this.requiresDraping = !1, this.supportsWorldCopies = !1, this.supportsTerrain = !1, this.supportsFog = !1, this.supportsFreeCamera = !1, this.zAxisUnit = "meters", this.isReprojectedInTileSpace = !0, this.unsupportedLayers = ["custom"], this.center = [0, 0], this.range = [3.5, 7];
      }

      project(t, e) {
        return {
          x: 0,
          y: 0,
          z: 0
        };
      }

      unproject(t, e) {
        return new Ja(0, 0);
      }

      projectTilePoint(t, e, r) {
        return {
          x: t,
          y: e,
          z: 0
        };
      }

      locationPoint(t, e) {
        return t._coordinatePoint(t.locationCoordinate(e), !1);
      }

      pixelsPerMeter(t, e) {
        return no(1, t) * e;
      }

      farthestPixelDistance(t) {
        return function (t, e) {
          const r = t.fovAboveCenter,
                n = t.elevation ? t.elevation.getMinElevationBelowMSL() * e : 0,
                i = (t._camera.position[2] * t.worldSize - n) / Math.cos(t._pitch),
                s = Math.sin(r) * i / Math.sin(Math.max(Math.PI / 2 - t._pitch - r, .01)),
                a = Math.sin(t._pitch) * s + i;
          return Math.min(1.01 * a, i * (1 / t._horizonShift));
        }(t, t.pixelsPerMeter);
      }

      pointCoordinate(t, e, r, n) {
        const s = t.horizonLineFromTop(!1),
              a = new i(e, Math.max(s, r));
        return t.rayIntersectionCoordinate(t.pointRayIntersection(a, n));
      }

      createInversionMatrix(t, e) {
        return Rf;
      }

      createTileMatrix(t, e, r) {
        let n, i, s;
        const a = r.canonical,
              o = jo(new Float64Array(16));

        if (this.isReprojectedInTileSpace) {
          const l = Zp(a, this);
          n = 1, i = l.x + r.wrap * l.scale, s = l.y, No(o, o, [n / l.scale, n / l.scale, t.pixelsPerMeter / e]);
        } else n = e / t.zoomScale(a.z), i = (a.x + Math.pow(2, a.z) * r.wrap) * n, s = a.y * n;

        return qo(o, o, [i, s, 0]), No(o, o, [n / Ya, n / Ya, 1]), o;
      }

      upVector(t, e, r) {
        return [0, 0, 1];
      }

      upVectorScale(t, e, r) {
        return {
          metersToTile: 1,
          metersToLabelSpace: 1
        };
      }

    }

    class $f extends Uf {
      constructor(t) {
        super(t), this.wrap = !0, this.supportsWorldCopies = !0, this.supportsTerrain = !0, this.supportsFog = !0, this.supportsFreeCamera = !0, this.isReprojectedInTileSpace = !1, this.unsupportedLayers = [], this.range = null;
      }

      project(t, e) {
        return {
          x: eo(t),
          y: ro(e),
          z: 0
        };
      }

      unproject(t, e) {
        const r = io(t),
              n = so(e);
        return new Ja(r, n);
      }

    }

    class jf extends Uf {
      constructor(t) {
        super(t), this.range = [4, 7], this.center = t.center || [-96, 37.5];
        const [e, r] = this.parallels = t.parallels || [29.5, 45.5],
              n = Math.sin(u(e));
        this.n = (n + Math.sin(u(r))) / 2, this.c = 1 + n * (2 * this.n - n), this.r0 = Math.sqrt(this.c) / this.n;
      }

      project(t, e) {
        const {
          n: r,
          c: n,
          r0: i
        } = this,
              s = u(t - this.center[0]),
              a = u(e),
              o = Math.sqrt(n - 2 * r * Math.sin(a)) / r;
        return {
          x: o * Math.sin(s * r),
          y: o * Math.cos(s * r) - i,
          z: 0
        };
      }

      unproject(t, e) {
        const {
          n: r,
          c: n,
          r0: i
        } = this,
              s = i + e;
        let a = Math.atan2(t, Math.abs(s)) * Math.sign(s);
        s * r < 0 && (a -= Math.PI * Math.sign(t) * Math.sign(s));
        const o = u(this.center[0]) * r;
        a = g(a, -Math.PI - o, Math.PI - o);
        const l = c(a / r) + this.center[0],
              h = Math.asin(y((n - (t * t + s * s) * r * r) / (2 * r), -1, 1)),
              p = y(c(h), -85.051129, oo);
        return new Ja(l, p);
      }

    }

    const Of = 1.340264,
          qf = -.081106,
          Nf = 893e-6,
          Gf = .003796,
          Zf = Math.sqrt(3) / 2;

    class Xf extends Uf {
      project(t, e) {
        e = e / 180 * Math.PI, t = t / 180 * Math.PI;
        const r = Math.asin(Zf * Math.sin(e)),
              n = r * r,
              i = n * n * n;
        return {
          x: .5 * (t * Math.cos(r) / (Zf * (Of + 3 * qf * n + i * (7 * Nf + 9 * Gf * n))) / Math.PI + .5),
          y: 1 - .5 * (r * (Of + qf * n + i * (Nf + Gf * n)) / Math.PI + 1),
          z: 0
        };
      }

      unproject(t, e) {
        t = (2 * t - .5) * Math.PI;
        let r = e = (2 * (1 - e) - 1) * Math.PI,
            n = r * r,
            i = n * n * n;

        for (let t, s, a, o = 0; o < 12 && (s = r * (Of + qf * n + i * (Nf + Gf * n)) - e, a = Of + 3 * qf * n + i * (7 * Nf + 9 * Gf * n), t = s / a, r = y(r - t, -Math.PI / 3, Math.PI / 3), n = r * r, i = n * n * n, !(Math.abs(t) < 1e-12)); ++o);

        const s = Zf * t * (Of + 3 * qf * n + i * (7 * Nf + 9 * Gf * n)) / Math.cos(r),
              a = Math.asin(Math.sin(r) / Zf),
              o = y(180 * s / Math.PI, -180, 180),
              l = y(180 * a / Math.PI, -85.051129, oo);
        return new Ja(o, l);
      }

    }

    class Kf extends Uf {
      constructor(t) {
        super(t), this.wrap = !0, this.supportsWorldCopies = !0;
      }

      project(t, e) {
        return {
          x: .5 + t / 360,
          y: .5 - e / 360,
          z: 0
        };
      }

      unproject(t, e) {
        const r = 360 * (t - .5),
              n = y(360 * (.5 - e), -85.051129, oo);
        return new Ja(r, n);
      }

    }

    const Yf = Math.PI / 2;

    function Hf(t) {
      return Math.tan((Yf + t) / 2);
    }

    class Wf extends Uf {
      constructor(t) {
        super(t), this.center = t.center || [0, 30];
        const [e, r] = this.parallels = t.parallels || [30, 30],
              n = u(e),
              i = u(r),
              s = Math.cos(n);
        this.n = n === i ? Math.sin(n) : Math.log(s / Math.cos(i)) / Math.log(Hf(i) / Hf(n)), this.f = s * Math.pow(Hf(n), this.n) / this.n;
      }

      project(t, e) {
        e = u(e), t = u(t - this.center[0]);
        const r = 1e-6,
              {
          n: n,
          f: i
        } = this;
        i > 0 ? e < -Yf + r && (e = -Yf + r) : e > Yf - r && (e = Yf - r);
        const s = i / Math.pow(Hf(e), n),
              a = s * Math.sin(n * t),
              o = i - s * Math.cos(n * t);
        return {
          x: .5 * (a / Math.PI + .5),
          y: 1 - .5 * (o / Math.PI + .5),
          z: 0
        };
      }

      unproject(t, e) {
        t = (2 * t - .5) * Math.PI, e = (2 * (1 - e) - .5) * Math.PI;
        const {
          n: r,
          f: n
        } = this,
              i = n - e,
              s = Math.sign(i),
              a = Math.sign(r) * Math.sqrt(t * t + i * i);
        let o = Math.atan2(t, Math.abs(i)) * s;
        i * r < 0 && (o -= Math.PI * Math.sign(t) * s);
        const l = y(c(o / r) + this.center[0], -180, 180),
              u = y(c(2 * Math.atan(Math.pow(n / a, 1 / r)) - Yf), -85.051129, oo);
        return new Ja(l, u);
      }

    }

    const Jf = u(oo);

    class Qf extends Uf {
      project(t, e) {
        const r = (e = u(e)) * e,
              n = r * r;
        return {
          x: .5 * ((t = u(t)) * (.8707 - .131979 * r + n * (n * (.003971 * r - .001529 * n) - .013791)) / Math.PI + .5),
          y: 1 - .5 * (e * (1.007226 + r * (.015085 + n * (.028874 * r - .044475 - .005916 * n))) / Math.PI + 1),
          z: 0
        };
      }

      unproject(t, e) {
        t = (2 * t - .5) * Math.PI;
        let r = e = (2 * (1 - e) - 1) * Math.PI,
            n = 25,
            i = 0,
            s = r * r;

        do {
          s = r * r;
          const t = s * s;
          i = (r * (1.007226 + s * (.015085 + t * (.028874 * s - .044475 - .005916 * t))) - e) / (1.007226 + s * (.045255 + t * (.259866 * s - .311325 - .005916 * 11 * t))), r = y(r - i, -Jf, Jf);
        } while (Math.abs(i) > 1e-6 && --n > 0);

        s = r * r;
        const a = y(c(t / (.8707 + s * (s * (s * s * s * (.003971 - .001529 * s) - .013791) - .131979))), -180, 180),
              o = c(r);
        return new Ja(a, o);
      }

    }

    const td = u(oo);

    class ed extends Uf {
      project(t, e) {
        e = u(e), t = u(t);
        const r = Math.cos(e),
              n = 2 / Math.PI,
              i = Math.acos(r * Math.cos(t / 2)),
              s = Math.sin(i) / i,
              a = .5 * (t * n + 2 * r * Math.sin(t / 2) / s) || 0,
              o = .5 * (e + Math.sin(e) / s) || 0;
        return {
          x: .5 * (a / Math.PI + .5),
          y: 1 - .5 * (o / Math.PI + 1),
          z: 0
        };
      }

      unproject(t, e) {
        let r = t = (2 * t - .5) * Math.PI,
            n = e = (2 * (1 - e) - 1) * Math.PI,
            i = 25;
        const s = 1e-6;
        let a = 0,
            o = 0;

        do {
          const i = Math.cos(n),
                s = Math.sin(n),
                l = 2 * s * i,
                u = s * s,
                c = i * i,
                h = Math.cos(r / 2),
                p = Math.sin(r / 2),
                f = 2 * h * p,
                d = p * p,
                m = 1 - c * h * h,
                g = m ? 1 / m : 0,
                x = m ? Math.acos(i * h) * Math.sqrt(1 / m) : 0,
                v = .5 * (2 * x * i * p + 2 * r / Math.PI) - t,
                b = .5 * (x * s + n) - e,
                _ = .5 * g * (c * d + x * i * h * u) + 1 / Math.PI,
                w = g * (f * l / 4 - x * s * p),
                A = .125 * g * (l * p - x * s * c * f),
                k = .5 * g * (u * h + x * d * i) + .5,
                S = w * A - k * _;

          a = (b * w - v * k) / S, o = (v * A - b * _) / S, r = y(r - a, -Math.PI, Math.PI), n = y(n - o, -td, td);
        } while ((Math.abs(a) > s || Math.abs(o) > s) && --i > 0);

        return new Ja(c(r), c(n));
      }

    }

    class rd extends Uf {
      constructor(t) {
        super(t), this.center = t.center || [0, 0], this.parallels = t.parallels || [0, 0], this.cosPhi = Math.max(.01, Math.cos(u(this.parallels[0]))), this.scale = 1 / (2 * Math.max(Math.PI * this.cosPhi, 1 / this.cosPhi)), this.wrap = !0, this.supportsWorldCopies = !0;
      }

      project(t, e) {
        const {
          scale: r,
          cosPhi: n
        } = this;
        return {
          x: u(t) * n * r + .5,
          y: -Math.sin(u(e)) / n * r + .5,
          z: 0
        };
      }

      unproject(t, e) {
        const {
          scale: r,
          cosPhi: n
        } = this,
              i = -(e - .5) / r,
              s = y(c((t - .5) / r) / n, -180, 180),
              a = Math.asin(y(i * n, -1, 1)),
              o = y(c(a), -85.051129, oo);
        return new Ja(s, o);
      }

    }

    t.ARRAY_TYPE = Uo, t.AUTH_ERR_MSG = tt, t.Aabb = vl, t.Actor = class {
      constructor(t, e, r) {
        this.target = t, this.parent = e, this.mapId = r, this.callbacks = {}, this.cancelCallbacks = {}, I(["receive"], this), this.target.addEventListener("message", this.receive, !1), this.globalScope = V() ? t : a, this.scheduler = new mp();
      }

      send(t, e, r, n, i = !1, s) {
        const a = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
        r && (r.metadata = s, this.callbacks[a] = r);
        const o = O(this.globalScope) ? void 0 : [];
        return this.target.postMessage({
          id: a,
          type: t,
          hasCallback: !!r,
          targetMapId: n,
          mustQueue: i,
          sourceMapId: this.mapId,
          data: ui(e, o)
        }, o), {
          cancel: () => {
            r && delete this.callbacks[a], this.target.postMessage({
              id: a,
              type: "<cancel>",
              targetMapId: n,
              sourceMapId: this.mapId
            });
          }
        };
      }

      receive(t) {
        const e = t.data,
              r = e.id;
        if (r && (!e.targetMapId || this.mapId === e.targetMapId)) if ("<cancel>" === e.type) {
          const t = this.cancelCallbacks[r];
          delete this.cancelCallbacks[r], t && t.cancel();
        } else if (e.mustQueue || V()) {
          const t = this.callbacks[r];
          this.cancelCallbacks[r] = this.scheduler.add(() => this.processTask(r, e), t && t.metadata || {
            type: "message"
          });
        } else this.processTask(r, e);
      }

      processTask(t, e) {
        if ("<response>" === e.type) {
          const r = this.callbacks[t];
          delete this.callbacks[t], r && (e.error ? r(ci(e.error)) : r(null, ci(e.data)));
        } else {
          const r = O(this.globalScope) ? void 0 : [],
                n = e.hasCallback ? (e, n) => {
            delete this.cancelCallbacks[t], this.target.postMessage({
              id: t,
              type: "<response>",
              sourceMapId: this.mapId,
              error: e ? ui(e) : null,
              data: ui(n, r)
            }, r);
          } : t => {},
                i = ci(e.data);
          if (this.parent[e.type]) this.parent[e.type](e.sourceMapId, i, n);else if (this.parent.getWorkerSource) {
            const t = e.type.split(".");
            this.parent.getWorkerSource(e.sourceMapId, t[0], i.source)[t[1]](i, n);
          } else n(new Error(`Could not find function ${e.type}`));
        }
      }

      remove() {
        this.scheduler.remove(), this.target.removeEventListener("message", this.receive, !1);
      }

    }, t.CanonicalTileID = Op, t.Color = ce, t.ColorMode = wf, t.CullFaceMode = Sf, t.DEMData = gf, t.DataConstantProperty = ds, t.DedupedRequest = Ff, t.DepthMode = vf, t.EXTENT = Ya, t.Elevation = class {
      isDataAvailableAtPoint(t) {
        const e = this._source();

        if (!e || t.y < 0 || t.y > 1) return !1;
        const r = e.getSource().maxzoom,
              n = 1 << r,
              i = Math.floor(t.x),
              s = Math.floor((t.x - i) * n),
              a = Math.floor(t.y * n),
              o = this.findDEMTileFor(new Np(r, i, r, s, a));
        return !(!o || !o.dem);
      }

      getAtPointOrZero(t, e = 0) {
        return this.getAtPoint(t, e) || 0;
      }

      getAtPoint(t, e, r = !0) {
        null == e && (e = null);

        const n = this._source();

        if (!n) return e;
        if (t.y < 0 || t.y > 1) return e;
        const i = n.getSource().maxzoom,
              s = 1 << i,
              a = Math.floor(t.x),
              o = t.x - a,
              l = new Np(i, a, i, Math.floor(o * s), Math.floor(t.y * s)),
              u = this.findDEMTileFor(l);
        if (!u || !u.dem) return e;
        const c = u.dem,
              h = 1 << u.tileID.canonical.z,
              p = (o * h - u.tileID.canonical.x) * c.dim,
              f = (t.y * h - u.tileID.canonical.y) * c.dim,
              d = Math.floor(p),
              y = Math.floor(f);
        return (r ? this.exaggeration() : 1) * rr(rr(c.get(d, y), c.get(d, y + 1), f - y), rr(c.get(d + 1, y), c.get(d + 1, y + 1), f - y), p - d);
      }

      getAtTileOffset(t, e, r) {
        const n = 1 << t.canonical.z;
        return this.getAtPointOrZero(new lo(t.wrap + (t.canonical.x + e / Ya) / n, (t.canonical.y + r / Ya) / n));
      }

      getAtTileOffsetFunc(t, e, r, n) {
        return i => {
          const s = this.getAtTileOffset(t, i.x, i.y),
                a = n.upVector(t.canonical, i.x, i.y);
          return nl(a, a, s * n.upVectorScale(t.canonical, e, r).metersToTile), a;
        };
      }

      getForTilePoints(t, e, r, n) {
        const i = zf.create(this, t, n);
        return !!i && (e.forEach(t => {
          t[2] = this.exaggeration() * i.getElevationAt(t[0], t[1], r);
        }), !0);
      }

      getMinMaxForTile(t) {
        const e = this.findDEMTileFor(t);
        if (!e || !e.dem) return null;
        const r = e.dem.tree,
              n = e.tileID,
              i = 1 << t.canonical.z - n.canonical.z;
        let s = t.canonical.x / i - n.canonical.x,
            a = t.canonical.y / i - n.canonical.y,
            o = 0;

        for (let e = 0; e < t.canonical.z - n.canonical.z && !r.leaves[o]; e++) {
          s *= 2, a *= 2;
          const t = 2 * Math.floor(a) + Math.floor(s);
          o = r.childOffsets[o] + t, s %= 1, a %= 1;
        }

        return {
          min: this.exaggeration() * r.minimums[o],
          max: this.exaggeration() * r.maximums[o]
        };
      }

      getMinElevationBelowMSL() {
        throw new Error("Pure virtual method called.");
      }

      raycast(t, e, r) {
        throw new Error("Pure virtual method called.");
      }

      pointCoordinate(t) {
        throw new Error("Pure virtual method called.");
      }

      _source() {
        throw new Error("Pure virtual method called.");
      }

      exaggeration() {
        throw new Error("Pure virtual method called.");
      }

      findDEMTileFor(t) {
        throw new Error("Pure virtual method called.");
      }

      get visibleDemTiles() {
        throw new Error("Getter must be implemented in subclass.");
      }

    }, t.ErrorEvent = Rt, t.EvaluationParameters = ss, t.Event = Lt, t.Evented = Ut, t.FillExtrusionBucket = $u, t.Frustum = xl, t.GLOBE_RADIUS = wp, t.GlobeSharedBuffers = class {
      constructor(t) {
        this._createGrid(t), this._createPoles(t), this._createAtmosphere(t);
      }

      destroy() {
        this._poleIndexBuffer.destroy(), this._gridBuffer.destroy(), this._gridIndexBuffer.destroy(), this._poleNorthVertexBuffer.destroy(), this._poleSouthVertexBuffer.destroy();

        for (const t of this._poleSegments) t.destroy();

        this._gridSegments.destroy(), this.atmosphereVertexBuffer.destroy(), this.atmosphereIndexBuffer.destroy(), this.atmosphereSegments.destroy(), this._wireframeIndexBuffer && (this._wireframeIndexBuffer.destroy(), this._wireframeSegments.destroy());
      }

      _createGrid(t) {
        const e = new Is(),
              r = new js(),
              n = 65;

        for (let t = 0; t < n; t++) for (let r = 0; r < n; r++) e.emplaceBack(r, t);

        for (let t = 0; t < 64; t++) for (let e = 0; e < 64; e++) {
          const i = t * n + e;
          r.emplaceBack(i + 1, i, i + n), r.emplaceBack(i + n, i + n + 1, i + 1);
        }

        this._gridBuffer = t.createVertexBuffer(e, _p.members), this._gridIndexBuffer = t.createIndexBuffer(r, !0), this._gridSegments = Ka.simpleSegment(0, 0, 4225, 8192);
      }

      _createPoles(t) {
        const e = new js();

        for (let t = 0; t <= 64; t++) e.emplaceBack(0, t + 1, t + 2);

        this._poleIndexBuffer = t.createIndexBuffer(e, !0);
        const r = new Gs(),
              n = new Gs();
        this._poleSegments = [];

        for (let t = 0, e = 0; t < 5; t++) {
          const i = 1 << t,
                s = 512 * i / Math.PI / 2,
                a = 360 / i;
          r.emplaceBack(0, -s, 0, 0, 0, .5, 0), n.emplaceBack(0, -s, 0, 0, 0, .5, 1);

          for (let t = 0; t <= 64; t++) {
            const e = t / 64,
                  i = rr(0, a, e),
                  [o, l, u] = Ep(Up, $p, i, s);
            r.emplaceBack(o, l, u, 0, 0, e, 0), n.emplaceBack(o, l, u, 0, 0, e, 1);
          }

          this._poleSegments.push(Ka.simpleSegment(e, 0, 66, 64)), e += 66;
        }

        this._poleNorthVertexBuffer = t.createVertexBuffer(r, vp, !1), this._poleSouthVertexBuffer = t.createVertexBuffer(n, vp, !1);
      }

      _createAtmosphere(t) {
        const e = new Zs();
        e.emplaceBack(-1, 1, 1, 0, 0), e.emplaceBack(1, 1, 1, 1, 0), e.emplaceBack(1, -1, 1, 1, 1), e.emplaceBack(-1, -1, 1, 0, 1);
        const r = new js();
        r.emplaceBack(0, 1, 2), r.emplaceBack(2, 3, 0), this.atmosphereVertexBuffer = t.createVertexBuffer(e, xp.members), this.atmosphereIndexBuffer = t.createIndexBuffer(r), this.atmosphereSegments = Ka.simpleSegment(0, 0, 4, 2);
      }

      getGridBuffers() {
        return [this._gridBuffer, this._gridIndexBuffer, this._gridSegments];
      }

      getPoleBuffers(t) {
        return [this._poleNorthVertexBuffer, this._poleSouthVertexBuffer, this._poleIndexBuffer, this._poleSegments[t]];
      }

      getWirefameBuffers(t) {
        if (!this._wireframeSegments) {
          const e = new Ks(),
                r = 64,
                n = r + 1;

          for (let t = 0; t < r; t++) for (let i = 0; i < r; i++) {
            const r = t * n + i;
            e.emplaceBack(r, r + 1), e.emplaceBack(r, r + n), e.emplaceBack(r, r + n + 1);
          }

          this._wireframeIndexBuffer = t.createIndexBuffer(e), this._wireframeSegments = Ka.simpleSegment(0, 0, r * r, e.length);
        }

        return [this._gridBuffer, this._wireframeIndexBuffer, this._wireframeSegments];
      }

    }, t.GlyphManager = Ah, t.ImagePosition = Zc, t.LineAtlas = pp, t.LngLat = Ja, t.LngLatBounds = Ha, t.LocalGlyphMode = wh, t.MAX_MERCATOR_LATITUDE = oo, t.MercatorCoordinate = lo, t.ONE_EM = cc, t.OverscaledTileID = Np, t.Properties = vs, t.RGBAImage = Bl, t.Ray = class {
      constructor(t, e) {
        this.pos = t, this.dir = e;
      }

      intersectsPlane(t, e, r) {
        const n = al(e, this.dir);
        if (Math.abs(n) < 1e-6) return !1;
        const i = ((t[0] - this.pos[0]) * e[0] + (t[1] - this.pos[1]) * e[1] + (t[2] - this.pos[2]) * e[2]) / n;
        return r[0] = this.pos[0] + this.dir[0] * i, r[1] = this.pos[1] + this.dir[1] * i, r[2] = this.pos[2] + this.dir[2] * i, !0;
      }

      closestPointOnSphere(t, e, r) {
        if (function (t, e) {
          var r = t[0],
              n = t[1],
              i = t[2],
              s = e[0],
              a = e[1],
              o = e[2];
          return Math.abs(r - s) <= Ro * Math.max(1, Math.abs(r), Math.abs(s)) && Math.abs(n - a) <= Ro * Math.max(1, Math.abs(n), Math.abs(a)) && Math.abs(i - o) <= Ro * Math.max(1, Math.abs(i), Math.abs(o));
        }(this.pos, t) || 0 === e) return r[0] = r[1] = r[2] = 0, !1;
        const [n, i, s] = this.dir,
              a = this.pos[0] - t[0],
              o = this.pos[1] - t[1],
              l = this.pos[2] - t[2],
              u = n * n + i * i + s * s,
              c = 2 * (a * n + o * i + l * s),
              h = c * c - 4 * u * (a * a + o * o + l * l - e * e);

        if (h < 0) {
          const t = Math.max(-c / 2, 0),
                u = a + n * t,
                h = o + i * t,
                p = l + s * t,
                f = Math.hypot(u, h, p);
          return r[0] = u * e / f, r[1] = h * e / f, r[2] = p * e / f, !1;
        }

        {
          const t = (-c - Math.sqrt(h)) / (2 * u);

          if (t < 0) {
            const t = Math.hypot(a, o, l);
            return r[0] = a * e / t, r[1] = o * e / t, r[2] = l * e / t, !1;
          }

          return r[0] = a + n * t, r[1] = o + i * t, r[2] = l + s * t, !0;
        }
      }

    }, t.RequestManager = class {
      constructor(t, e, r) {
        this._transformRequestFn = t, this._customAccessToken = e, this._silenceAuthErrors = !!r, this._createSkuToken();
      }

      _createSkuToken() {
        const t = function () {
          let t = "";

          for (let e = 0; e < 10; e++) t += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())];

          return {
            token: ["1", Q, t].join(""),
            tokenExpiresAt: Date.now() + 432e5
          };
        }();

        this._skuToken = t.token, this._skuTokenExpiresAt = t.tokenExpiresAt;
      }

      _isSkuTokenExpired() {
        return Date.now() > this._skuTokenExpiresAt;
      }

      transformRequest(t, e) {
        return this._transformRequestFn && this._transformRequestFn(t, e) || {
          url: t
        };
      }

      normalizeStyleURL(t, e) {
        if (!et(t)) return t;
        const r = it(t);
        return r.path = `/styles/v1${r.path}`, this._makeAPIURL(r, this._customAccessToken || e);
      }

      normalizeGlyphsURL(t, e) {
        if (!et(t)) return t;
        const r = it(t);
        return r.path = `/fonts/v1${r.path}`, this._makeAPIURL(r, this._customAccessToken || e);
      }

      normalizeSourceURL(t, e) {
        if (!et(t)) return t;
        const r = it(t);
        return r.path = `/v4/${r.authority}.json`, r.params.push("secure"), this._makeAPIURL(r, this._customAccessToken || e);
      }

      normalizeSpriteURL(t, e, r, n) {
        const i = it(t);
        return et(t) ? (i.path = `/styles/v1${i.path}/sprite${e}${r}`, this._makeAPIURL(i, this._customAccessToken || n)) : (i.path += `${e}${r}`, st(i));
      }

      normalizeTileURL(t, e, r) {
        if (this._isSkuTokenExpired() && this._createSkuToken(), t && !et(t)) return t;
        const n = it(t);
        n.path = n.path.replace(/(\.(png|jpg)\d*)(?=$)/, `${e || r && "raster" !== n.authority && 512 === r ? "@2x" : ""}${X.supported ? ".webp" : "$1"}`), "raster" === n.authority ? n.path = `/${Z.RASTER_URL_PREFIX}${n.path}` : (n.path = n.path.replace(/^.+\/v4\//, "/"), n.path = `/${Z.TILE_URL_VERSION}${n.path}`);

        const i = this._customAccessToken || function (t) {
          for (const e of t) {
            const t = e.match(/^access_token=(.*)$/);
            if (t) return t[1];
          }

          return null;
        }(n.params) || Z.ACCESS_TOKEN;

        return Z.REQUIRE_ACCESS_TOKEN && i && this._skuToken && n.params.push(`sku=${this._skuToken}`), this._makeAPIURL(n, i);
      }

      canonicalizeTileURL(t, e) {
        const r = it(t);
        if (!r.path.match(/^(\/v4\/|\/raster\/v1\/)/) || !r.path.match(/\.[\w]+$/)) return t;
        let n = "mapbox://";
        r.path.match(/^\/raster\/v1\//) ? n += `raster/${r.path.replace(`/${Z.RASTER_URL_PREFIX}/`, "")}` : n += `tiles/${r.path.replace(`/${Z.TILE_URL_VERSION}/`, "")}`;
        let i = r.params;
        return e && (i = i.filter(t => !t.match(/^access_token=/))), i.length && (n += `?${i.join("&")}`), n;
      }

      canonicalizeTileset(t, e) {
        const r = !!e && et(e),
              n = [];

        for (const e of t.tiles || []) rt(e) ? n.push(this.canonicalizeTileURL(e, r)) : n.push(e);

        return n;
      }

      _makeAPIURL(t, e) {
        const r = "See https://www.mapbox.com/api-documentation/#access-tokens-and-token-scopes",
              n = it(Z.API_URL);

        if (t.protocol = n.protocol, t.authority = n.authority, "http" === t.protocol) {
          const e = t.params.indexOf("secure");
          e >= 0 && t.params.splice(e, 1);
        }

        if ("/" !== n.path && (t.path = `${n.path}${t.path}`), !Z.REQUIRE_ACCESS_TOKEN) return st(t);

        if (e = e || Z.ACCESS_TOKEN, !this._silenceAuthErrors) {
          if (!e) throw new Error(`An API access token is required to use Mapbox GL. ${r}`);
          if ("s" === e[0]) throw new Error(`Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). ${r}`);
        }

        return t.params = t.params.filter(t => -1 === t.indexOf("access_token")), t.params.push(`access_token=${e || ""}`), st(t);
      }

    }, t.ResourceType = At, t.SegmentVector = Ka, t.SourceCache = If, t.StencilMode = _f, t.StructArrayLayout1ui2 = Ys, t.StructArrayLayout2f1f2i16 = Us, t.StructArrayLayout2i4 = Is, t.StructArrayLayout2ui4 = Ks, t.StructArrayLayout3f12 = Vs, t.StructArrayLayout3ui6 = js, t.StructArrayLayout4i8 = Ts, t.Texture = hp, t.Tile = af, t.Transitionable = ls, t.Uniform1f = Sa, t.Uniform1i = class extends ka {
      constructor(t, e) {
        super(t, e), this.current = 0;
      }

      set(t) {
        this.current !== t && (this.current = t, this.gl.uniform1i(this.location, t));
      }

    }, t.Uniform2f = class extends ka {
      constructor(t, e) {
        super(t, e), this.current = [0, 0];
      }

      set(t) {
        t[0] === this.current[0] && t[1] === this.current[1] || (this.current = t, this.gl.uniform2f(this.location, t[0], t[1]));
      }

    }, t.Uniform3f = class extends ka {
      constructor(t, e) {
        super(t, e), this.current = [0, 0, 0];
      }

      set(t) {
        t[0] === this.current[0] && t[1] === this.current[1] && t[2] === this.current[2] || (this.current = t, this.gl.uniform3f(this.location, t[0], t[1], t[2]));
      }

    }, t.Uniform4f = Ia, t.UniformColor = Ma, t.UniformMatrix2f = class extends ka {
      constructor(t, e) {
        super(t, e), this.current = Ba;
      }

      set(t) {
        for (let e = 0; e < 4; e++) if (t[e] !== this.current[e]) {
          this.current = t, this.gl.uniformMatrix2fv(this.location, !1, t);
          break;
        }
      }

    }, t.UniformMatrix3f = class extends ka {
      constructor(t, e) {
        super(t, e), this.current = za;
      }

      set(t) {
        for (let e = 0; e < 9; e++) if (t[e] !== this.current[e]) {
          this.current = t, this.gl.uniformMatrix3fv(this.location, !1, t);
          break;
        }
      }

    }, t.UniformMatrix4f = class extends ka {
      constructor(t, e) {
        super(t, e), this.current = Ta;
      }

      set(t) {
        if (t[12] !== this.current[12] || t[0] !== this.current[0]) return this.current = t, void this.gl.uniformMatrix4fv(this.location, !1, t);

        for (let e = 1; e < 16; e++) if (t[e] !== this.current[e]) {
          this.current = t, this.gl.uniformMatrix4fv(this.location, !1, t);
          break;
        }
      }

    }, t.UnwrappedTileID = qp, t.ValidationError = mn, t.VectorTileWorkerSource = class extends Ut {
      constructor(t, e, r, n, i) {
        super(), this.actor = t, this.layerIndex = e, this.availableImages = r, this.loadVectorData = i || Lf, this.loading = {}, this.loaded = {}, this.deduped = new Ff(t.scheduler), this.isSpriteLoaded = n, this.scheduler = t.scheduler;
      }

      loadTile(t, e) {
        const r = t.uid,
              n = t && t.request,
              i = n && n.collectResourceTiming,
              s = this.loading[r] = new Pf(t);
        s.abort = this.loadVectorData(t, (a, o) => {
          const l = !this.loading[r];
          if (delete this.loading[r], l || a || !o) return s.status = "done", l || (this.loaded[r] = s), e(a);
          const u = o.rawData,
                c = {};
          o.expires && (c.expires = o.expires), o.cacheControl && (c.cacheControl = o.cacheControl), s.vectorTile = o.vectorTile || new Du.VectorTile(new wc(u));

          const h = () => {
            s.parse(s.vectorTile, this.layerIndex, this.availableImages, this.actor, (t, r) => {
              if (t || !r) return e(t);
              const s = {};

              if (i) {
                const t = yp(n);
                t.length > 0 && (s.resourceTiming = JSON.parse(JSON.stringify(t)));
              }

              e(null, b({
                rawTileData: u.slice(0)
              }, r, c, s));
            });
          };

          this.isSpriteLoaded ? h() : this.once("isSpriteLoaded", () => {
            this.scheduler ? this.scheduler.add(h, {
              type: "parseTile",
              isSymbolTile: t.isSymbolTile,
              zoom: t.tileZoom
            }) : h();
          }), this.loaded = this.loaded || {}, this.loaded[r] = s;
        });
      }

      reloadTile(t, e) {
        const r = this.loaded,
              n = t.uid,
              i = this;

        if (r && r[n]) {
          const s = r[n];
          s.showCollisionBoxes = t.showCollisionBoxes, s.enableTerrain = !!t.enableTerrain, s.projection = t.projection, s.tileTransform = Zp(t.tileID.canonical, t.projection);

          const a = (t, r) => {
            const n = s.reloadCallback;
            n && (delete s.reloadCallback, s.parse(s.vectorTile, i.layerIndex, this.availableImages, i.actor, n)), e(t, r);
          };

          "parsing" === s.status ? s.reloadCallback = a : "done" === s.status && (s.vectorTile ? s.parse(s.vectorTile, this.layerIndex, this.availableImages, this.actor, a) : a());
        }
      }

      abortTile(t, e) {
        const r = t.uid,
              n = this.loading[r];
        n && (n.abort && n.abort(), delete this.loading[r]), e();
      }

      removeTile(t, e) {
        const r = this.loaded,
              n = t.uid;
        r && r[n] && delete r[n], e();
      }

    }, t.WritingMode = Kc, t.ZoomHistory = hi, t.add = Jo, t.addDynamicAttributes = Hh, t.adjoint = function (t, e) {
      var r = e[0],
          n = e[1],
          i = e[2],
          s = e[3],
          a = e[4],
          o = e[5],
          l = e[6],
          u = e[7],
          c = e[8];
      return t[0] = a * c - o * u, t[1] = i * u - n * c, t[2] = n * o - i * a, t[3] = o * l - s * c, t[4] = r * c - i * l, t[5] = i * s - r * o, t[6] = s * u - a * l, t[7] = n * l - r * u, t[8] = r * a - n * s, t;
    }, t.asyncAll = x, t.bezier = f, t.bindAll = I, t.boundsAttributes = nf, t.bufferConvexPolygon = function (t, e) {
      const r = [];

      for (let n = 0; n < t.length; n++) {
        const i = g(n - 1, -1, t.length - 1),
              s = g(n + 1, -1, t.length - 1),
              a = t[n],
              o = t[s],
              l = t[i].sub(a).unit(),
              u = o.sub(a).unit(),
              c = u.angleWithSep(l.x, l.y),
              h = l.add(u).unit().mult(-1 * e / Math.sin(c / 2));
        r.push(a.add(h));
      }

      return r;
    }, t.cacheEntryPossiblyAdded = function (t) {
      wt++, wt > vt && (t.getActor().send("enforceCacheSizeLimit", xt), wt = 0);
    }, t.calculateGlobeLabelMatrix = function (t, e) {
      const {
        lng: r,
        lat: n
      } = t._center,
            i = Fp(0, 0, t.worldSize / t._projectionScaler, r, n);
      return Oo(i, i, function (t) {
        const e = jo(new Float64Array(16)),
              r = 1 / Pp(t);
        return qo(e, e, t.min), No(e, e, [r, r, r]), e;
      }(Tp(e)));
    }, t.calculateGlobeMatrix = Lp, t.calculateGlobeMercatorMatrix = function (t) {
      const e = t.worldSize,
            r = t.point,
            n = no(1, t.center.lat) * e,
            i = t.pixelsPerMeter,
            s = e / (n / t.pixelsPerMeter),
            a = jo(new Float64Array(16));
      return qo(a, a, [r.x, r.y, 0]), No(a, a, [s, s, i]), Float32Array.from(a);
    }, t.circumferenceAtLatitude = to, t.clamp = y, t.clearTileCache = function (t) {
      const e = a.caches.delete(yt);
      t && e.catch(t).then(() => t());
    }, t.clipLine = xh, t.clone = function (t) {
      var e = new Uo(16);
      return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e;
    }, t.clone$1 = B, t.collisionCircleLayout = uc, t.config = Z, t.conjugate = function (t, e) {
      return t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t[3] = e[3], t;
    }, t.create = function () {
      var t = new Uo(16);
      return Uo != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0), t[0] = 1, t[5] = 1, t[10] = 1, t[15] = 1, t;
    }, t.create$1 = $o, t.createExpression = cn, t.createLayout = ks, t.createStyleLayer = function (t) {
      return "custom" === t.type ? new op(t) : new cp[t.type](t);
    }, t.cross = ol, t.degToRad = u, t.div = function (t, e, r) {
      return t[0] = e[0] / r[0], t[1] = e[1] / r[1], t[2] = e[2] / r[2], t;
    }, t.dot = al, t.earthRadius = Wa, t.ease = d, t.easeCubicInOut = p, t.emitValidationErrors = ri, t.endsWith = M, t.enforceCacheSizeLimit = function (t) {
      bt(), mt && mt.then(e => {
        e.keys().then(r => {
          for (let n = 0; n < r.length - t; n++) e.delete(r[n]);
        });
      });
    }, t.evaluateSizeForFeature = fc, t.evaluateSizeForZoom = dc, t.evaluateVariableOffset = Lh, t.evented = es, t.exactEquals = function (t, e) {
      return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3];
    }, t.exactEquals$1 = function (t, e) {
      return t[0] === e[0] && t[1] === e[1] && t[2] === e[2];
    }, t.exported = N, t.exported$1 = X, t.extend = b, t.extend$1 = jt, t.filterObject = z, t.fromMat4 = function (t, e) {
      return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[4], t[4] = e[5], t[5] = e[6], t[6] = e[8], t[7] = e[9], t[8] = e[10], t;
    }, t.fromQuat = function (t, e) {
      var r = e[0],
          n = e[1],
          i = e[2],
          s = e[3],
          a = r + r,
          o = n + n,
          l = i + i,
          u = r * a,
          c = n * a,
          h = n * o,
          p = i * a,
          f = i * o,
          d = i * l,
          y = s * a,
          m = s * o,
          g = s * l;
      return t[0] = 1 - h - d, t[1] = c + g, t[2] = p - m, t[3] = 0, t[4] = c - g, t[5] = 1 - u - d, t[6] = f + y, t[7] = 0, t[8] = p + m, t[9] = f - y, t[10] = 1 - u - h, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
    }, t.fromRotation = function (t, e) {
      var r = Math.sin(e),
          n = Math.cos(e);
      return t[0] = n, t[1] = r, t[2] = 0, t[3] = -r, t[4] = n, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t;
    }, t.fromScaling = function (t, e) {
      return t[0] = e[0], t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = e[1], t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = e[2], t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
    }, t.furthestTileCorner = function (t) {
      const e = Math.round((t + 45 + 360) % 360 / 90) % 4;
      return h[e];
    }, t.getAABBPointSquareDist = function (t, e, r) {
      let n = 0;

      for (let i = 0; i < 2; ++i) {
        const s = r ? r[i] : 0;
        t[i] > s && (n += (t[i] - s) * (t[i] - s)), e[i] < s && (n += (s - e[i]) * (s - e[i]));
      }

      return n;
    }, t.getAnchorAlignment = ah, t.getAnchorJustification = Uh, t.getBounds = function (t) {
      let e = 1 / 0,
          r = 1 / 0,
          n = -1 / 0,
          s = -1 / 0;

      for (const i of t) e = Math.min(e, i.x), r = Math.min(r, i.y), n = Math.max(n, i.x), s = Math.max(s, i.y);

      return {
        min: new i(e, r),
        max: new i(n, s)
      };
    }, t.getColumn = function (t, e) {
      return [t[4 * e], t[4 * e + 1], t[4 * e + 2], t[4 * e + 3]];
    }, t.getGridMatrix = function (t, e) {
      const [r, n] = e,
            i = .015625;
      return [0, (n[1] - r[1]) * i, 1 << t.z, (n[0] - r[0]) * i, 0, t.y, r[0], r[1], i];
    }, t.getImage = Pt, t.getJSON = function (t, e) {
      return It(b(t, {
        type: "json"
      }), e);
    }, t.getMapSessionAPI = ft, t.getPerformanceMeasurement = yp, t.getProjection = function (t) {
      const e = t.parallels,
            r = !!e && Math.abs(e[0] + e[1]) < .01;

      switch (t.name) {
        case "mercator":
          return new $f(t);

        case "equirectangular":
          return new Kf(t);

        case "naturalEarth":
          return new Qf(t);

        case "equalEarth":
          return new Xf(t);

        case "winkelTripel":
          return new ed(t);

        case "albers":
          return r ? new rd(t) : new jf(t);

        case "lambertConformalConic":
          return r ? new rd(t) : new Wf(t);
      }

      throw new Error(`Invalid projection name: ${t.name}`);
    }, t.getRTLTextPluginStatus = rs, t.getReferrer = St, t.getTilePoint = function (t, {
      x: e,
      y: r
    }, n = 0) {
      return new i(((e - n) * t.scale - t.x) * Ya, (r * t.scale - t.y) * Ya);
    }, t.getTileVec3 = function (t, e, r = 0) {
      return Wo(((e.x - r) * t.scale - t.x) * Ya, (e.y * t.scale - t.y) * Ya, ao(e.z, e.y));
    }, t.getVideo = function (t, e) {
      const r = a.document.createElement("video");
      r.muted = !0, r.onloadstart = function () {
        e(null, r);
      };

      for (let e = 0; e < t.length; e++) {
        const n = a.document.createElement("source");
        Bt(t[e]) || (r.crossOrigin = "Anonymous"), n.src = t[e], r.appendChild(n);
      }

      return {
        cancel: () => {}
      };
    }, t.globeECEFOrigin = function (t, e) {
      const r = [0, 0, 0];
      return ll(r, r, Vp(Tp(e.canonical))), ll(r, r, t), r;
    }, t.globePixelsToTileUnits = function (t, e) {
      return Ya / (512 * Math.pow(2, t)) * Pp(Tp(e));
    }, t.globePoleMatrixForTile = function (t, e, r) {
      const n = jo(new Float64Array(16)),
            i = 1 << t,
            s = 360 * (e / i - .5),
            a = r.point,
            o = r.worldSize / (r.tileSize * i);
      return qo(n, n, [a.x, a.y, -r.worldSize / Math.PI / 2]), No(n, n, [o, o, o]), Go(n, n, u(-r._center.lat)), Zo(n, n, u(-r._center.lng + s)), Float32Array.from(n);
    }, t.globeTileLatLngCorners = Bp, t.globeToMercatorTransition = function (t) {
      return m(5, 6, t);
    }, t.identity = jo, t.identity$1 = ml, t.invert = function (t, e) {
      var r = e[0],
          n = e[1],
          i = e[2],
          s = e[3],
          a = e[4],
          o = e[5],
          l = e[6],
          u = e[7],
          c = e[8],
          h = e[9],
          p = e[10],
          f = e[11],
          d = e[12],
          y = e[13],
          m = e[14],
          g = e[15],
          x = r * o - n * a,
          v = r * l - i * a,
          b = r * u - s * a,
          _ = n * l - i * o,
          w = n * u - s * o,
          A = i * u - s * l,
          k = c * y - h * d,
          S = c * m - p * d,
          I = c * g - f * d,
          M = h * m - p * y,
          T = h * g - f * y,
          z = p * g - f * m,
          B = x * z - v * T + b * M + _ * I - w * S + A * k;

      return B ? (t[0] = (o * z - l * T + u * M) * (B = 1 / B), t[1] = (i * T - n * z - s * M) * B, t[2] = (y * A - m * w + g * _) * B, t[3] = (p * w - h * A - f * _) * B, t[4] = (l * I - a * z - u * S) * B, t[5] = (r * z - i * I + s * S) * B, t[6] = (m * b - d * A - g * v) * B, t[7] = (c * A - p * b + f * v) * B, t[8] = (a * T - o * I + u * k) * B, t[9] = (n * I - r * T - s * k) * B, t[10] = (d * w - y * b + g * x) * B, t[11] = (h * b - c * w - f * x) * B, t[12] = (o * S - a * M - l * k) * B, t[13] = (r * M - n * S + i * k) * B, t[14] = (y * v - d * _ - m * x) * B, t[15] = (c * _ - h * v + p * x) * B, t) : null;
    }, t.isMapAuthenticated = function (t) {
      return dt.has(t);
    }, t.isMapboxURL = et, t.isSafariWithAntialiasingBug = function (t) {
      const e = t.navigator ? t.navigator.userAgent : null;
      return !!O(t) && e && (e.match("Version/15.4") || e.match("Version/15.5") || e.match(/CPU (OS|iPhone OS) (15_4|15_5) like Mac OS X/));
    }, t.latFromMercatorY = so, t.len = fl, t.length = Ho, t.length$1 = function (t) {
      return Math.hypot(t[0], t[1], t[2], t[3]);
    }, t.loadVectorTile = Lf, t.makeRequest = It, t.mercatorXfromLng = eo, t.mercatorYfromLat = ro, t.mercatorZfromAltitude = no, t.mul = Xo, t.mul$1 = pl, t.multiply = function (t, e, r) {
      var n = e[0],
          i = e[1],
          s = e[2],
          a = e[3],
          o = e[4],
          l = e[5],
          u = e[6],
          c = e[7],
          h = e[8],
          p = r[0],
          f = r[1],
          d = r[2],
          y = r[3],
          m = r[4],
          g = r[5],
          x = r[6],
          v = r[7],
          b = r[8];
      return t[0] = p * n + f * a + d * u, t[1] = p * i + f * o + d * c, t[2] = p * s + f * l + d * h, t[3] = y * n + m * a + g * u, t[4] = y * i + m * o + g * c, t[5] = y * s + m * l + g * h, t[6] = x * n + v * a + b * u, t[7] = x * i + v * o + b * c, t[8] = x * s + v * l + b * h, t;
    }, t.multiply$1 = Oo, t.multiply$2 = tl, t.nextPowerOfTwo = k, t.normalize = sl, t.normalize$1 = function (t, e) {
      var r = e[0],
          n = e[1],
          i = e[2],
          s = e[3],
          a = r * r + n * n + i * i + s * s;
      return a > 0 && (a = 1 / Math.sqrt(a)), t[0] = r * a, t[1] = n * a, t[2] = i * a, t[3] = s * a, t;
    }, t.number = rr, t.ortho = function (t, e, r, n, i, s, a) {
      var o = 1 / (e - r),
          l = 1 / (n - i),
          u = 1 / (s - a);
      return t[0] = -2 * o, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = -2 * l, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 2 * u, t[11] = 0, t[12] = (e + r) * o, t[13] = (i + n) * l, t[14] = (a + s) * u, t[15] = 1, t;
    }, t.pbf = wc, t.perspective = function (t, e, r, n, i) {
      var s,
          a = 1 / Math.tan(e / 2);
      return t[0] = a / r, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = a, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = -1, t[12] = 0, t[13] = 0, t[15] = 0, null != i && i !== 1 / 0 ? (t[10] = (i + n) * (s = 1 / (n - i)), t[14] = 2 * i * n * s) : (t[10] = -1, t[14] = -2 * n), t;
    }, t.pick = function (t, e) {
      const r = {};

      for (let n = 0; n < e.length; n++) {
        const i = e[n];
        i in t && (r[i] = t[i]);
      }

      return r;
    }, t.plugin = is, t.pointGeometry = i, t.polygonIntersectsBox = Bo, t.polygonIntersectsPolygon = bo, t.polygonizeBounds = function (t, e, r = 0, n = !0) {
      const s = new i(r, r),
            a = t.sub(s),
            o = e.add(s),
            l = [a, new i(o.x, a.y), o, new i(a.x, o.y)];
      return n && l.push(a), l;
    }, t.posAttributes = _p, t.postMapLoadEvent = ht, t.postTurnstileEvent = ut, t.potpack = Gc, t.prevPowerOfTwo = function (t) {
      return t <= 1 ? 1 : Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
    }, t.radToDeg = c, t.refProperties = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"], t.registerForPluginStateChange = function (t) {
      return t({
        pluginStatus: Wi,
        pluginURL: Ji
      }), es.on("pluginStateChange", t), t;
    }, t.removeAuthState = function (t) {
      dt.delete(t);
    }, t.renderColorRamp = Cl, t.rotateX = Go, t.rotateX$1 = gl, t.rotateY = Zo, t.rotateZ = function (t, e, r) {
      var n = Math.sin(r),
          i = Math.cos(r),
          s = e[0],
          a = e[1],
          o = e[2],
          l = e[3],
          u = e[4],
          c = e[5],
          h = e[6],
          p = e[7];
      return e !== t && (t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[0] = s * i + u * n, t[1] = a * i + c * n, t[2] = o * i + h * n, t[3] = l * i + p * n, t[4] = u * i - s * n, t[5] = c * i - a * n, t[6] = h * i - o * n, t[7] = p * i - l * n, t;
    }, t.rotateZ$1 = function (t, e, r) {
      r *= .5;
      var n = e[0],
          i = e[1],
          s = e[2],
          a = e[3],
          o = Math.sin(r),
          l = Math.cos(r);
      return t[0] = n * l + i * o, t[1] = i * l - n * o, t[2] = s * l + a * o, t[3] = a * l - s * o, t;
    }, t.scale = No, t.scale$1 = function (t, e, r) {
      return t[0] = e[0] * r, t[1] = e[1] * r, t[2] = e[2] * r, t[3] = e[3] * r, t;
    }, t.scale$2 = nl, t.scaleAndAdd = il, t.setCacheLimits = function (t, e) {
      xt = t, vt = e;
    }, t.setColumn = function (t, e, r) {
      t[4 * e + 0] = r[0], t[4 * e + 1] = r[1], t[4 * e + 2] = r[2], t[4 * e + 3] = r[3];
    }, t.setRTLTextPlugin = function (t, e, r = !1) {
      if (Wi === Xi || Wi === Ki || Wi === Yi) throw new Error("setRTLTextPlugin cannot be called multiple times.");
      Ji = N.resolveURL(t), Wi = Xi, Hi = e, ts(), r || ns();
    }, t.smoothstep = m, t.spec = $t, t.storeAuthState = function (t, e) {
      e ? dt.add(t) : dt.delete(t);
    }, t.sub = hl, t.subtract = Qo, t.symbolSize = yc, t.tileAABB = function (t, e, r, n, i, s, a, o, l) {
      if ("globe" === l.name) return zp(t, e, new Op(r, n, i));
      const u = Zp({
        z: r,
        x: n,
        y: i
      }, l);
      return new vl([(s + u.x / u.scale) * e, e * (u.y / u.scale), a], [(s + u.x2 / u.scale) * e, e * (u.y2 / u.scale), o]);
    }, t.tileTransform = Zp, t.transformMat3 = function (t, e, r) {
      var n = e[0],
          i = e[1],
          s = e[2];
      return t[0] = n * r[0] + i * r[3] + s * r[6], t[1] = n * r[1] + i * r[4] + s * r[7], t[2] = n * r[2] + i * r[5] + s * r[8], t;
    }, t.transformMat4 = ll, t.transformMat4$1 = dl, t.transformQuat = ul, t.translate = qo, t.transpose = function (t, e) {
      if (t === e) {
        var r = e[1],
            n = e[2],
            i = e[5];
        t[1] = e[3], t[2] = e[6], t[3] = r, t[5] = e[7], t[6] = n, t[7] = i;
      } else t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8];

      return t;
    }, t.triggerPluginCompletionEvent = Qi, t.uniqueId = w, t.validateCustomStyleLayer = function (t) {
      const e = [],
            r = t.id;
      return void 0 === r && e.push({
        message: `layers.${r}: missing required property "id"`
      }), void 0 === t.render && e.push({
        message: `layers.${r}: missing required method "render"`
      }), t.renderingMode && "2d" !== t.renderingMode && "3d" !== t.renderingMode && e.push({
        message: `layers.${r}: property "renderingMode" must be either "2d" or "3d"`
      }), e;
    }, t.validateFilter = t => ei(Ln(t)), t.validateFog = t => ei(Kn(t)), t.validateLayer = t => ei(On(t)), t.validateLight = t => ei(Zn(t)), t.validateSource = t => ei(Gn(t)), t.validateStyle = Jn, t.validateTerrain = t => ei(Xn(t)), t.values = v, t.vectorTile = Du, t.version = e, t.warnOnce = C, t.window = a, t.wrap = g;
  });
  define(["./shared"], function (e) {
    "use strict";

    function t(e) {
      if ("number" == typeof e || "boolean" == typeof e || "string" == typeof e || null == e) return JSON.stringify(e);

      if (Array.isArray(e)) {
        let r = "[";

        for (const o of e) r += `${t(o)},`;

        return `${r}]`;
      }

      let r = "{";

      for (const o of Object.keys(e).sort()) r += `${o}:${t(e[o])},`;

      return `${r}}`;
    }

    function r(r) {
      let o = "";

      for (const n of e.refProperties) o += `/${t(r[n])}`;

      return o;
    }

    class o {
      constructor(e) {
        this.keyCache = {}, e && this.replace(e);
      }

      replace(e) {
        this._layerConfigs = {}, this._layers = {}, this.update(e, []);
      }

      update(t, o) {
        for (const r of t) this._layerConfigs[r.id] = r, (this._layers[r.id] = e.createStyleLayer(r)).compileFilter(), this.keyCache[r.id] && delete this.keyCache[r.id];

        for (const e of o) delete this.keyCache[e], delete this._layerConfigs[e], delete this._layers[e];

        this.familiesBySource = {};

        const n = function (e, t) {
          const o = {};

          for (let n = 0; n < e.length; n++) {
            const i = t && t[e[n].id] || r(e[n]);
            t && (t[e[n].id] = i);
            let s = o[i];
            s || (s = o[i] = []), s.push(e[n]);
          }

          const n = [];

          for (const e in o) n.push(o[e]);

          return n;
        }(e.values(this._layerConfigs), this.keyCache);

        for (const e of n) {
          const t = e.map(e => this._layers[e.id]),
                r = t[0];
          if ("none" === r.visibility) continue;
          const o = r.source || "";
          let n = this.familiesBySource[o];
          n || (n = this.familiesBySource[o] = {});
          const i = r.sourceLayer || "_geojsonTileLayer";
          let s = n[i];
          s || (s = n[i] = []), s.push(t);
        }
      }

    }

    class n {
      loadTile(t, r) {
        const {
          uid: o,
          encoding: n,
          rawImageData: i,
          padding: s,
          buildQuadTree: a
        } = t,
              l = e.window.ImageBitmap && i instanceof e.window.ImageBitmap ? this.getImageData(i, s) : i;
        r(null, new e.DEMData(o, l, n, s < 1, a));
      }

      getImageData(e, t) {
        this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(e.width, e.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d")), this.offscreenCanvas.width = e.width, this.offscreenCanvas.height = e.height, this.offscreenCanvasContext.drawImage(e, 0, 0, e.width, e.height);
        const r = this.offscreenCanvasContext.getImageData(-t, -t, e.width + 2 * t, e.height + 2 * t);
        return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), r;
      }

    }

    var i = function e(t, r) {
      var o,
          n = t && t.type;
      if ("FeatureCollection" === n) for (o = 0; o < t.features.length; o++) e(t.features[o], r);else if ("GeometryCollection" === n) for (o = 0; o < t.geometries.length; o++) e(t.geometries[o], r);else if ("Feature" === n) e(t.geometry, r);else if ("Polygon" === n) s(t.coordinates, r);else if ("MultiPolygon" === n) for (o = 0; o < t.coordinates.length; o++) s(t.coordinates[o], r);
      return t;
    };

    function s(e, t) {
      if (0 !== e.length) {
        a(e[0], t);

        for (var r = 1; r < e.length; r++) a(e[r], !t);
      }
    }

    function a(e, t) {
      for (var r = 0, o = 0, n = 0, i = e.length, s = i - 1; n < i; s = n++) {
        var a = (e[n][0] - e[s][0]) * (e[s][1] + e[n][1]),
            l = r + a;
        o += Math.abs(r) >= Math.abs(a) ? r - l + a : a - l + r, r = l;
      }

      r + o >= 0 != !!t && e.reverse();
    }

    const l = e.vectorTile.VectorTileFeature.prototype.toGeoJSON;

    class u {
      constructor(t) {
        this._feature = t, this.extent = e.EXTENT, this.type = t.type, this.properties = t.tags, "id" in t && !isNaN(t.id) && (this.id = parseInt(t.id, 10));
      }

      loadGeometry() {
        if (1 === this._feature.type) {
          const t = [];

          for (const r of this._feature.geometry) t.push([new e.pointGeometry(r[0], r[1])]);

          return t;
        }

        {
          const t = [];

          for (const r of this._feature.geometry) {
            const o = [];

            for (const t of r) o.push(new e.pointGeometry(t[0], t[1]));

            t.push(o);
          }

          return t;
        }
      }

      toGeoJSON(e, t, r) {
        return l.call(this, e, t, r);
      }

    }

    class h {
      constructor(t) {
        this.layers = {
          _geojsonTileLayer: this
        }, this.name = "_geojsonTileLayer", this.extent = e.EXTENT, this.length = t.length, this._features = t;
      }

      feature(e) {
        return new u(this._features[e]);
      }

    }

    var c = e.vectorTile.VectorTileFeature,
        f = p;

    function p(e, t) {
      this.options = t || {}, this.features = e, this.length = e.length;
    }

    function g(e, t) {
      this.id = "number" == typeof e.id ? e.id : void 0, this.type = e.type, this.rawGeometry = 1 === e.type ? [e.geometry] : e.geometry, this.properties = e.tags, this.extent = t || 4096;
    }

    p.prototype.feature = function (e) {
      return new g(this.features[e], this.options.extent);
    }, g.prototype.loadGeometry = function () {
      var t = this.rawGeometry;
      this.geometry = [];

      for (var r = 0; r < t.length; r++) {
        for (var o = t[r], n = [], i = 0; i < o.length; i++) n.push(new e.pointGeometry(o[i][0], o[i][1]));

        this.geometry.push(n);
      }

      return this.geometry;
    }, g.prototype.bbox = function () {
      this.geometry || this.loadGeometry();

      for (var e = this.geometry, t = 1 / 0, r = -1 / 0, o = 1 / 0, n = -1 / 0, i = 0; i < e.length; i++) for (var s = e[i], a = 0; a < s.length; a++) {
        var l = s[a];
        t = Math.min(t, l.x), r = Math.max(r, l.x), o = Math.min(o, l.y), n = Math.max(n, l.y);
      }

      return [t, o, r, n];
    }, g.prototype.toGeoJSON = c.prototype.toGeoJSON;
    var d = y,
        m = f;

    function y(t) {
      var r = new e.pbf();
      return function (e, t) {
        for (var r in e.layers) t.writeMessage(3, v, e.layers[r]);
      }(t, r), r.finish();
    }

    function v(e, t) {
      var r;
      t.writeVarintField(15, e.version || 1), t.writeStringField(1, e.name || ""), t.writeVarintField(5, e.extent || 4096);
      var o = {
        keys: [],
        values: [],
        keycache: {},
        valuecache: {}
      };

      for (r = 0; r < e.length; r++) o.feature = e.feature(r), t.writeMessage(2, x, o);

      var n = o.keys;

      for (r = 0; r < n.length; r++) t.writeStringField(3, n[r]);

      var i = o.values;

      for (r = 0; r < i.length; r++) t.writeMessage(4, b, i[r]);
    }

    function x(e, t) {
      var r = e.feature;
      void 0 !== r.id && t.writeVarintField(1, r.id), t.writeMessage(2, w, e), t.writeVarintField(3, r.type), t.writeMessage(4, P, r);
    }

    function w(e, t) {
      var r = e.feature,
          o = e.keys,
          n = e.values,
          i = e.keycache,
          s = e.valuecache;

      for (var a in r.properties) {
        var l = r.properties[a],
            u = i[a];

        if (null !== l) {
          void 0 === u && (o.push(a), i[a] = u = o.length - 1), t.writeVarint(u);
          var h = typeof l;
          "string" !== h && "boolean" !== h && "number" !== h && (l = JSON.stringify(l));
          var c = h + ":" + l,
              f = s[c];
          void 0 === f && (n.push(l), s[c] = f = n.length - 1), t.writeVarint(f);
        }
      }
    }

    function S(e, t) {
      return (t << 3) + (7 & e);
    }

    function M(e) {
      return e << 1 ^ e >> 31;
    }

    function P(e, t) {
      for (var r = e.loadGeometry(), o = e.type, n = 0, i = 0, s = r.length, a = 0; a < s; a++) {
        var l = r[a],
            u = 1;
        1 === o && (u = l.length), t.writeVarint(S(1, u));

        for (var h = 3 === o ? l.length - 1 : l.length, c = 0; c < h; c++) {
          1 === c && 1 !== o && t.writeVarint(S(2, h - 1));
          var f = l[c].x - n,
              p = l[c].y - i;
          t.writeVarint(M(f)), t.writeVarint(M(p)), n += f, i += p;
        }

        3 === o && t.writeVarint(S(7, 1));
      }
    }

    function b(e, t) {
      var r = typeof e;
      "string" === r ? t.writeStringField(1, e) : "boolean" === r ? t.writeBooleanField(7, e) : "number" === r && (e % 1 != 0 ? t.writeDoubleField(3, e) : e < 0 ? t.writeSVarintField(6, e) : t.writeVarintField(5, e));
    }

    function T(e, t, r, o, n, i) {
      if (n - o <= r) return;
      const s = o + n >> 1;
      k(e, t, s, o, n, i % 2), T(e, t, r, o, s - 1, i + 1), T(e, t, r, s + 1, n, i + 1);
    }

    function k(e, t, r, o, n, i) {
      for (; n > o;) {
        if (n - o > 600) {
          const s = n - o + 1,
                a = r - o + 1,
                l = Math.log(s),
                u = .5 * Math.exp(2 * l / 3),
                h = .5 * Math.sqrt(l * u * (s - u) / s) * (a - s / 2 < 0 ? -1 : 1);
          k(e, t, r, Math.max(o, Math.floor(r - a * u / s + h)), Math.min(n, Math.floor(r + (s - a) * u / s + h)), i);
        }

        const s = t[2 * r + i];
        let a = o,
            l = n;

        for (I(e, t, o, r), t[2 * n + i] > s && I(e, t, o, n); a < l;) {
          for (I(e, t, a, l), a++, l--; t[2 * a + i] < s;) a++;

          for (; t[2 * l + i] > s;) l--;
        }

        t[2 * o + i] === s ? I(e, t, o, l) : (l++, I(e, t, l, n)), l <= r && (o = l + 1), r <= l && (n = l - 1);
      }
    }

    function I(e, t, r, o) {
      _(e, r, o), _(t, 2 * r, 2 * o), _(t, 2 * r + 1, 2 * o + 1);
    }

    function _(e, t, r) {
      const o = e[t];
      e[t] = e[r], e[r] = o;
    }

    function L(e, t, r, o) {
      const n = e - r,
            i = t - o;
      return n * n + i * i;
    }

    d.fromVectorTileJs = y, d.fromGeojsonVt = function (e, t) {
      t = t || {};
      var r = {};

      for (var o in e) r[o] = new f(e[o].features, t), r[o].name = o, r[o].version = t.version, r[o].extent = t.extent;

      return y({
        layers: r
      });
    }, d.GeoJSONWrapper = m;

    const C = e => e[0],
          O = e => e[1];

    class z {
      constructor(e, t = C, r = O, o = 64, n = Float64Array) {
        this.nodeSize = o, this.points = e;
        const i = e.length < 65536 ? Uint16Array : Uint32Array,
              s = this.ids = new i(e.length),
              a = this.coords = new n(2 * e.length);

        for (let o = 0; o < e.length; o++) s[o] = o, a[2 * o] = t(e[o]), a[2 * o + 1] = r(e[o]);

        T(s, a, o, 0, s.length - 1, 0);
      }

      range(e, t, r, o) {
        return function (e, t, r, o, n, i, s) {
          const a = [0, e.length - 1, 0],
                l = [];
          let u, h;

          for (; a.length;) {
            const c = a.pop(),
                  f = a.pop(),
                  p = a.pop();

            if (f - p <= s) {
              for (let s = p; s <= f; s++) u = t[2 * s], h = t[2 * s + 1], u >= r && u <= n && h >= o && h <= i && l.push(e[s]);

              continue;
            }

            const g = Math.floor((p + f) / 2);
            u = t[2 * g], h = t[2 * g + 1], u >= r && u <= n && h >= o && h <= i && l.push(e[g]);
            const d = (c + 1) % 2;
            (0 === c ? r <= u : o <= h) && (a.push(p), a.push(g - 1), a.push(d)), (0 === c ? n >= u : i >= h) && (a.push(g + 1), a.push(f), a.push(d));
          }

          return l;
        }(this.ids, this.coords, e, t, r, o, this.nodeSize);
      }

      within(e, t, r) {
        return function (e, t, r, o, n, i) {
          const s = [0, e.length - 1, 0],
                a = [],
                l = n * n;

          for (; s.length;) {
            const u = s.pop(),
                  h = s.pop(),
                  c = s.pop();

            if (h - c <= i) {
              for (let n = c; n <= h; n++) L(t[2 * n], t[2 * n + 1], r, o) <= l && a.push(e[n]);

              continue;
            }

            const f = Math.floor((c + h) / 2),
                  p = t[2 * f],
                  g = t[2 * f + 1];
            L(p, g, r, o) <= l && a.push(e[f]);
            const d = (u + 1) % 2;
            (0 === u ? r - n <= p : o - n <= g) && (s.push(c), s.push(f - 1), s.push(d)), (0 === u ? r + n >= p : o + n >= g) && (s.push(f + 1), s.push(h), s.push(d));
          }

          return a;
        }(this.ids, this.coords, e, t, r, this.nodeSize);
      }

    }

    const E = {
      minZoom: 0,
      maxZoom: 16,
      minPoints: 2,
      radius: 40,
      extent: 512,
      nodeSize: 64,
      log: !1,
      generateId: !1,
      reduce: null,
      map: e => e
    },
          F = Math.fround || (N = new Float32Array(1), e => (N[0] = +e, N[0]));
    var N;

    class j {
      constructor(e) {
        this.options = A(Object.create(E), e), this.trees = new Array(this.options.maxZoom + 1);
      }

      load(e) {
        const {
          log: t,
          minZoom: r,
          maxZoom: o,
          nodeSize: n
        } = this.options;
        t && console.time("total time");
        const i = `prepare ${e.length} points`;
        t && console.time(i), this.points = e;
        let s = [];

        for (let t = 0; t < e.length; t++) e[t].geometry && s.push(G(e[t], t));

        this.trees[o + 1] = new z(s, D, $, n, Float32Array), t && console.timeEnd(i);

        for (let e = o; e >= r; e--) {
          const r = +Date.now();
          s = this._cluster(s, e), this.trees[e] = new z(s, D, $, n, Float32Array), t && console.log("z%d: %d clusters in %dms", e, s.length, +Date.now() - r);
        }

        return t && console.timeEnd("total time"), this;
      }

      getClusters(e, t) {
        let r = ((e[0] + 180) % 360 + 360) % 360 - 180;
        const o = Math.max(-90, Math.min(90, e[1]));
        let n = 180 === e[2] ? 180 : ((e[2] + 180) % 360 + 360) % 360 - 180;
        const i = Math.max(-90, Math.min(90, e[3]));
        if (e[2] - e[0] >= 360) r = -180, n = 180;else if (r > n) {
          const e = this.getClusters([r, o, 180, i], t),
                s = this.getClusters([-180, o, n, i], t);
          return e.concat(s);
        }

        const s = this.trees[this._limitZoom(t)],
              a = s.range(Y(r), X(i), Y(n), X(o)),
              l = [];

        for (const e of a) {
          const t = s.points[e];
          l.push(t.numPoints ? J(t) : this.points[t.index]);
        }

        return l;
      }

      getChildren(e) {
        const t = this._getOriginId(e),
              r = this._getOriginZoom(e),
              o = "No cluster with the specified id.",
              n = this.trees[r];

        if (!n) throw new Error(o);
        const i = n.points[t];
        if (!i) throw new Error(o);
        const s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)),
              a = n.within(i.x, i.y, s),
              l = [];

        for (const t of a) {
          const r = n.points[t];
          r.parentId === e && l.push(r.numPoints ? J(r) : this.points[r.index]);
        }

        if (0 === l.length) throw new Error(o);
        return l;
      }

      getLeaves(e, t, r) {
        const o = [];
        return this._appendLeaves(o, e, t = t || 10, r = r || 0, 0), o;
      }

      getTile(e, t, r) {
        const o = this.trees[this._limitZoom(e)],
              n = Math.pow(2, e),
              {
          extent: i,
          radius: s
        } = this.options,
              a = s / i,
              l = (r - a) / n,
              u = (r + 1 + a) / n,
              h = {
          features: []
        };

        return this._addTileFeatures(o.range((t - a) / n, l, (t + 1 + a) / n, u), o.points, t, r, n, h), 0 === t && this._addTileFeatures(o.range(1 - a / n, l, 1, u), o.points, n, r, n, h), t === n - 1 && this._addTileFeatures(o.range(0, l, a / n, u), o.points, -1, r, n, h), h.features.length ? h : null;
      }

      getClusterExpansionZoom(e) {
        let t = this._getOriginZoom(e) - 1;

        for (; t <= this.options.maxZoom;) {
          const r = this.getChildren(e);
          if (t++, 1 !== r.length) break;
          e = r[0].properties.cluster_id;
        }

        return t;
      }

      _appendLeaves(e, t, r, o, n) {
        const i = this.getChildren(t);

        for (const t of i) {
          const i = t.properties;
          if (i && i.cluster ? n + i.point_count <= o ? n += i.point_count : n = this._appendLeaves(e, i.cluster_id, r, o, n) : n < o ? n++ : e.push(t), e.length === r) break;
        }

        return n;
      }

      _addTileFeatures(e, t, r, o, n, i) {
        for (const s of e) {
          const e = t[s],
                a = e.numPoints;
          let l, u, h;
          if (a) l = W(e), u = e.x, h = e.y;else {
            const t = this.points[e.index];
            l = t.properties, u = Y(t.geometry.coordinates[0]), h = X(t.geometry.coordinates[1]);
          }
          const c = {
            type: 1,
            geometry: [[Math.round(this.options.extent * (u * n - r)), Math.round(this.options.extent * (h * n - o))]],
            tags: l
          };
          let f;
          a ? f = e.id : this.options.generateId ? f = e.index : this.points[e.index].id && (f = this.points[e.index].id), void 0 !== f && (c.id = f), i.features.push(c);
        }
      }

      _limitZoom(e) {
        return Math.max(this.options.minZoom, Math.min(+e, this.options.maxZoom + 1));
      }

      _cluster(e, t) {
        const r = [],
              {
          radius: o,
          extent: n,
          reduce: i,
          minPoints: s
        } = this.options,
              a = o / (n * Math.pow(2, t));

        for (let o = 0; o < e.length; o++) {
          const n = e[o];
          if (n.zoom <= t) continue;
          n.zoom = t;
          const l = this.trees[t + 1],
                u = l.within(n.x, n.y, a),
                h = n.numPoints || 1;
          let c = h;

          for (const e of u) {
            const r = l.points[e];
            r.zoom > t && (c += r.numPoints || 1);
          }

          if (c > h && c >= s) {
            let e = n.x * h,
                s = n.y * h,
                a = i && h > 1 ? this._map(n, !0) : null;
            const f = (o << 5) + (t + 1) + this.points.length;

            for (const r of u) {
              const o = l.points[r];
              if (o.zoom <= t) continue;
              o.zoom = t;
              const u = o.numPoints || 1;
              e += o.x * u, s += o.y * u, o.parentId = f, i && (a || (a = this._map(n, !0)), i(a, this._map(o)));
            }

            n.parentId = f, r.push(Z(e / c, s / c, f, c, a));
          } else if (r.push(n), c > 1) for (const e of u) {
            const o = l.points[e];
            o.zoom <= t || (o.zoom = t, r.push(o));
          }
        }

        return r;
      }

      _getOriginId(e) {
        return e - this.points.length >> 5;
      }

      _getOriginZoom(e) {
        return (e - this.points.length) % 32;
      }

      _map(e, t) {
        if (e.numPoints) return t ? A({}, e.properties) : e.properties;
        const r = this.points[e.index].properties,
              o = this.options.map(r);
        return t && o === r ? A({}, o) : o;
      }

    }

    function Z(e, t, r, o, n) {
      return {
        x: F(e),
        y: F(t),
        zoom: 1 / 0,
        id: r,
        parentId: -1,
        numPoints: o,
        properties: n
      };
    }

    function G(e, t) {
      const [r, o] = e.geometry.coordinates;
      return {
        x: F(Y(r)),
        y: F(X(o)),
        zoom: 1 / 0,
        index: t,
        parentId: -1
      };
    }

    function J(e) {
      return {
        type: "Feature",
        id: e.id,
        properties: W(e),
        geometry: {
          type: "Point",
          coordinates: [(t = e.x, 360 * (t - .5)), V(e.y)]
        }
      };
      var t;
    }

    function W(e) {
      const t = e.numPoints,
            r = t >= 1e4 ? `${Math.round(t / 1e3)}k` : t >= 1e3 ? Math.round(t / 100) / 10 + "k" : t;
      return A(A({}, e.properties), {
        cluster: !0,
        cluster_id: e.id,
        point_count: t,
        point_count_abbreviated: r
      });
    }

    function Y(e) {
      return e / 360 + .5;
    }

    function X(e) {
      const t = Math.sin(e * Math.PI / 180),
            r = .5 - .25 * Math.log((1 + t) / (1 - t)) / Math.PI;
      return r < 0 ? 0 : r > 1 ? 1 : r;
    }

    function V(e) {
      const t = (180 - 360 * e) * Math.PI / 180;
      return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
    }

    function A(e, t) {
      for (const r in t) e[r] = t[r];

      return e;
    }

    function D(e) {
      return e.x;
    }

    function $(e) {
      return e.y;
    }

    function B(e, t, r, o) {
      for (var n, i = o, s = r - t >> 1, a = r - t, l = e[t], u = e[t + 1], h = e[r], c = e[r + 1], f = t + 3; f < r; f += 3) {
        var p = R(e[f], e[f + 1], l, u, h, c);
        if (p > i) n = f, i = p;else if (p === i) {
          var g = Math.abs(f - s);
          g < a && (n = f, a = g);
        }
      }

      i > o && (n - t > 3 && B(e, t, n, o), e[n + 2] = i, r - n > 3 && B(e, n, r, o));
    }

    function R(e, t, r, o, n, i) {
      var s = n - r,
          a = i - o;

      if (0 !== s || 0 !== a) {
        var l = ((e - r) * s + (t - o) * a) / (s * s + a * a);
        l > 1 ? (r = n, o = i) : l > 0 && (r += s * l, o += a * l);
      }

      return (s = e - r) * s + (a = t - o) * a;
    }

    function q(e, t, r, o) {
      var n = {
        id: void 0 === e ? null : e,
        type: t,
        geometry: r,
        tags: o,
        minX: 1 / 0,
        minY: 1 / 0,
        maxX: -1 / 0,
        maxY: -1 / 0
      };
      return function (e) {
        var t = e.geometry,
            r = e.type;
        if ("Point" === r || "MultiPoint" === r || "LineString" === r) U(e, t);else if ("Polygon" === r || "MultiLineString" === r) for (var o = 0; o < t.length; o++) U(e, t[o]);else if ("MultiPolygon" === r) for (o = 0; o < t.length; o++) for (var n = 0; n < t[o].length; n++) U(e, t[o][n]);
      }(n), n;
    }

    function U(e, t) {
      for (var r = 0; r < t.length; r += 3) e.minX = Math.min(e.minX, t[r]), e.minY = Math.min(e.minY, t[r + 1]), e.maxX = Math.max(e.maxX, t[r]), e.maxY = Math.max(e.maxY, t[r + 1]);
    }

    function Q(e, t, r, o) {
      if (t.geometry) {
        var n = t.geometry.coordinates,
            i = t.geometry.type,
            s = Math.pow(r.tolerance / ((1 << r.maxZoom) * r.extent), 2),
            a = [],
            l = t.id;
        if (r.promoteId ? l = t.properties[r.promoteId] : r.generateId && (l = o || 0), "Point" === i) H(n, a);else if ("MultiPoint" === i) for (var u = 0; u < n.length; u++) H(n[u], a);else if ("LineString" === i) K(n, a, s, !1);else if ("MultiLineString" === i) {
          if (r.lineMetrics) {
            for (u = 0; u < n.length; u++) K(n[u], a = [], s, !1), e.push(q(l, "LineString", a, t.properties));

            return;
          }

          ee(n, a, s, !1);
        } else if ("Polygon" === i) ee(n, a, s, !0);else {
          if ("MultiPolygon" !== i) {
            if ("GeometryCollection" === i) {
              for (u = 0; u < t.geometry.geometries.length; u++) Q(e, {
                id: l,
                geometry: t.geometry.geometries[u],
                properties: t.properties
              }, r, o);

              return;
            }

            throw new Error("Input data is not a valid GeoJSON object.");
          }

          for (u = 0; u < n.length; u++) {
            var h = [];
            ee(n[u], h, s, !0), a.push(h);
          }
        }
        e.push(q(l, i, a, t.properties));
      }
    }

    function H(e, t) {
      t.push(te(e[0])), t.push(re(e[1])), t.push(0);
    }

    function K(e, t, r, o) {
      for (var n, i, s = 0, a = 0; a < e.length; a++) {
        var l = te(e[a][0]),
            u = re(e[a][1]);
        t.push(l), t.push(u), t.push(0), a > 0 && (s += o ? (n * u - l * i) / 2 : Math.sqrt(Math.pow(l - n, 2) + Math.pow(u - i, 2))), n = l, i = u;
      }

      var h = t.length - 3;
      t[2] = 1, B(t, 0, h, r), t[h + 2] = 1, t.size = Math.abs(s), t.start = 0, t.end = t.size;
    }

    function ee(e, t, r, o) {
      for (var n = 0; n < e.length; n++) {
        var i = [];
        K(e[n], i, r, o), t.push(i);
      }
    }

    function te(e) {
      return e / 360 + .5;
    }

    function re(e) {
      var t = Math.sin(e * Math.PI / 180),
          r = .5 - .25 * Math.log((1 + t) / (1 - t)) / Math.PI;
      return r < 0 ? 0 : r > 1 ? 1 : r;
    }

    function oe(e, t, r, o, n, i, s, a) {
      if (o /= t, i >= (r /= t) && s < o) return e;
      if (s < r || i >= o) return null;

      for (var l = [], u = 0; u < e.length; u++) {
        var h = e[u],
            c = h.geometry,
            f = h.type,
            p = 0 === n ? h.minX : h.minY,
            g = 0 === n ? h.maxX : h.maxY;
        if (p >= r && g < o) l.push(h);else if (!(g < r || p >= o)) {
          var d = [];
          if ("Point" === f || "MultiPoint" === f) ne(c, d, r, o, n);else if ("LineString" === f) ie(c, d, r, o, n, !1, a.lineMetrics);else if ("MultiLineString" === f) ae(c, d, r, o, n, !1);else if ("Polygon" === f) ae(c, d, r, o, n, !0);else if ("MultiPolygon" === f) for (var m = 0; m < c.length; m++) {
            var y = [];
            ae(c[m], y, r, o, n, !0), y.length && d.push(y);
          }

          if (d.length) {
            if (a.lineMetrics && "LineString" === f) {
              for (m = 0; m < d.length; m++) l.push(q(h.id, f, d[m], h.tags));

              continue;
            }

            "LineString" !== f && "MultiLineString" !== f || (1 === d.length ? (f = "LineString", d = d[0]) : f = "MultiLineString"), "Point" !== f && "MultiPoint" !== f || (f = 3 === d.length ? "Point" : "MultiPoint"), l.push(q(h.id, f, d, h.tags));
          }
        }
      }

      return l.length ? l : null;
    }

    function ne(e, t, r, o, n) {
      for (var i = 0; i < e.length; i += 3) {
        var s = e[i + n];
        s >= r && s <= o && (t.push(e[i]), t.push(e[i + 1]), t.push(e[i + 2]));
      }
    }

    function ie(e, t, r, o, n, i, s) {
      for (var a, l, u = se(e), h = 0 === n ? ue : he, c = e.start, f = 0; f < e.length - 3; f += 3) {
        var p = e[f],
            g = e[f + 1],
            d = e[f + 2],
            m = e[f + 3],
            y = e[f + 4],
            v = 0 === n ? p : g,
            x = 0 === n ? m : y,
            w = !1;
        s && (a = Math.sqrt(Math.pow(p - m, 2) + Math.pow(g - y, 2))), v < r ? x > r && (l = h(u, p, g, m, y, r), s && (u.start = c + a * l)) : v > o ? x < o && (l = h(u, p, g, m, y, o), s && (u.start = c + a * l)) : le(u, p, g, d), x < r && v >= r && (l = h(u, p, g, m, y, r), w = !0), x > o && v <= o && (l = h(u, p, g, m, y, o), w = !0), !i && w && (s && (u.end = c + a * l), t.push(u), u = se(e)), s && (c += a);
      }

      var S = e.length - 3;
      p = e[S], g = e[S + 1], d = e[S + 2], (v = 0 === n ? p : g) >= r && v <= o && le(u, p, g, d), S = u.length - 3, i && S >= 3 && (u[S] !== u[0] || u[S + 1] !== u[1]) && le(u, u[0], u[1], u[2]), u.length && t.push(u);
    }

    function se(e) {
      var t = [];
      return t.size = e.size, t.start = e.start, t.end = e.end, t;
    }

    function ae(e, t, r, o, n, i) {
      for (var s = 0; s < e.length; s++) ie(e[s], t, r, o, n, i, !1);
    }

    function le(e, t, r, o) {
      e.push(t), e.push(r), e.push(o);
    }

    function ue(e, t, r, o, n, i) {
      var s = (i - t) / (o - t);
      return e.push(i), e.push(r + (n - r) * s), e.push(1), s;
    }

    function he(e, t, r, o, n, i) {
      var s = (i - r) / (n - r);
      return e.push(t + (o - t) * s), e.push(i), e.push(1), s;
    }

    function ce(e, t) {
      for (var r = [], o = 0; o < e.length; o++) {
        var n,
            i = e[o],
            s = i.type;
        if ("Point" === s || "MultiPoint" === s || "LineString" === s) n = fe(i.geometry, t);else if ("MultiLineString" === s || "Polygon" === s) {
          n = [];

          for (var a = 0; a < i.geometry.length; a++) n.push(fe(i.geometry[a], t));
        } else if ("MultiPolygon" === s) for (n = [], a = 0; a < i.geometry.length; a++) {
          for (var l = [], u = 0; u < i.geometry[a].length; u++) l.push(fe(i.geometry[a][u], t));

          n.push(l);
        }
        r.push(q(i.id, s, n, i.tags));
      }

      return r;
    }

    function fe(e, t) {
      var r = [];
      r.size = e.size, void 0 !== e.start && (r.start = e.start, r.end = e.end);

      for (var o = 0; o < e.length; o += 3) r.push(e[o] + t, e[o + 1], e[o + 2]);

      return r;
    }

    function pe(e, t) {
      if (e.transformed) return e;
      var r,
          o,
          n,
          i = 1 << e.z,
          s = e.x,
          a = e.y;

      for (r = 0; r < e.features.length; r++) {
        var l = e.features[r],
            u = l.geometry,
            h = l.type;
        if (l.geometry = [], 1 === h) for (o = 0; o < u.length; o += 2) l.geometry.push(ge(u[o], u[o + 1], t, i, s, a));else for (o = 0; o < u.length; o++) {
          var c = [];

          for (n = 0; n < u[o].length; n += 2) c.push(ge(u[o][n], u[o][n + 1], t, i, s, a));

          l.geometry.push(c);
        }
      }

      return e.transformed = !0, e;
    }

    function ge(e, t, r, o, n, i) {
      return [Math.round(r * (e * o - n)), Math.round(r * (t * o - i))];
    }

    function de(e, t, r, o, n) {
      for (var i = t === n.maxZoom ? 0 : n.tolerance / ((1 << t) * n.extent), s = {
        features: [],
        numPoints: 0,
        numSimplified: 0,
        numFeatures: 0,
        source: null,
        x: r,
        y: o,
        z: t,
        transformed: !1,
        minX: 2,
        minY: 1,
        maxX: -1,
        maxY: 0
      }, a = 0; a < e.length; a++) {
        s.numFeatures++, me(s, e[a], i, n);
        var l = e[a].minX,
            u = e[a].minY,
            h = e[a].maxX,
            c = e[a].maxY;
        l < s.minX && (s.minX = l), u < s.minY && (s.minY = u), h > s.maxX && (s.maxX = h), c > s.maxY && (s.maxY = c);
      }

      return s;
    }

    function me(e, t, r, o) {
      var n = t.geometry,
          i = t.type,
          s = [];
      if ("Point" === i || "MultiPoint" === i) for (var a = 0; a < n.length; a += 3) s.push(n[a]), s.push(n[a + 1]), e.numPoints++, e.numSimplified++;else if ("LineString" === i) ye(s, n, e, r, !1, !1);else if ("MultiLineString" === i || "Polygon" === i) for (a = 0; a < n.length; a++) ye(s, n[a], e, r, "Polygon" === i, 0 === a);else if ("MultiPolygon" === i) for (var l = 0; l < n.length; l++) {
        var u = n[l];

        for (a = 0; a < u.length; a++) ye(s, u[a], e, r, !0, 0 === a);
      }

      if (s.length) {
        var h = t.tags || null;

        if ("LineString" === i && o.lineMetrics) {
          for (var c in h = {}, t.tags) h[c] = t.tags[c];

          h.mapbox_clip_start = n.start / n.size, h.mapbox_clip_end = n.end / n.size;
        }

        var f = {
          geometry: s,
          type: "Polygon" === i || "MultiPolygon" === i ? 3 : "LineString" === i || "MultiLineString" === i ? 2 : 1,
          tags: h
        };
        null !== t.id && (f.id = t.id), e.features.push(f);
      }
    }

    function ye(e, t, r, o, n, i) {
      var s = o * o;
      if (o > 0 && t.size < (n ? s : o)) r.numPoints += t.length / 3;else {
        for (var a = [], l = 0; l < t.length; l += 3) (0 === o || t[l + 2] > s) && (r.numSimplified++, a.push(t[l]), a.push(t[l + 1])), r.numPoints++;

        n && function (e, t) {
          for (var r = 0, o = 0, n = e.length, i = n - 2; o < n; i = o, o += 2) r += (e[o] - e[i]) * (e[o + 1] + e[i + 1]);

          if (r > 0 === t) for (o = 0, n = e.length; o < n / 2; o += 2) {
            var s = e[o],
                a = e[o + 1];
            e[o] = e[n - 2 - o], e[o + 1] = e[n - 1 - o], e[n - 2 - o] = s, e[n - 1 - o] = a;
          }
        }(a, i), e.push(a);
      }
    }

    function ve(e, t) {
      var r = (t = this.options = function (e, t) {
        for (var r in t) e[r] = t[r];

        return e;
      }(Object.create(this.options), t)).debug;

      if (r && console.time("preprocess data"), t.maxZoom < 0 || t.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
      if (t.promoteId && t.generateId) throw new Error("promoteId and generateId cannot be used together.");

      var o = function (e, t) {
        var r = [];
        if ("FeatureCollection" === e.type) for (var o = 0; o < e.features.length; o++) Q(r, e.features[o], t, o);else Q(r, "Feature" === e.type ? e : {
          geometry: e
        }, t);
        return r;
      }(e, t);

      this.tiles = {}, this.tileCoords = [], r && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t.indexMaxZoom, t.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), (o = function (e, t) {
        var r = t.buffer / t.extent,
            o = e,
            n = oe(e, 1, -1 - r, r, 0, -1, 2, t),
            i = oe(e, 1, 1 - r, 2 + r, 0, -1, 2, t);
        return (n || i) && (o = oe(e, 1, -r, 1 + r, 0, -1, 2, t) || [], n && (o = ce(n, 1).concat(o)), i && (o = o.concat(ce(i, -1)))), o;
      }(o, t)).length && this.splitTile(o, 0, 0, 0), r && (o.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
    }

    function xe(e, t, r) {
      return 32 * ((1 << e) * r + t) + e;
    }

    function we(e, t) {
      const r = e.tileID.canonical;
      if (!this._geoJSONIndex) return t(null, null);

      const o = this._geoJSONIndex.getTile(r.z, r.x, r.y);

      if (!o) return t(null, null);
      const n = new h(o.features);
      let i = d(n);
      0 === i.byteOffset && i.byteLength === i.buffer.byteLength || (i = new Uint8Array(i)), t(null, {
        vectorTile: n,
        rawData: i.buffer
      });
    }

    ve.prototype.options = {
      maxZoom: 14,
      indexMaxZoom: 5,
      indexMaxPoints: 1e5,
      tolerance: 3,
      extent: 4096,
      buffer: 64,
      lineMetrics: !1,
      promoteId: null,
      generateId: !1,
      debug: 0
    }, ve.prototype.splitTile = function (e, t, r, o, n, i, s) {
      for (var a = [e, t, r, o], l = this.options, u = l.debug; a.length;) {
        o = a.pop(), r = a.pop(), t = a.pop(), e = a.pop();
        var h = 1 << t,
            c = xe(t, r, o),
            f = this.tiles[c];

        if (!f && (u > 1 && console.time("creation"), f = this.tiles[c] = de(e, t, r, o, l), this.tileCoords.push({
          z: t,
          x: r,
          y: o
        }), u)) {
          u > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t, r, o, f.numFeatures, f.numPoints, f.numSimplified), console.timeEnd("creation"));
          var p = "z" + t;
          this.stats[p] = (this.stats[p] || 0) + 1, this.total++;
        }

        if (f.source = e, n) {
          if (t === l.maxZoom || t === n) continue;
          var g = 1 << n - t;
          if (r !== Math.floor(i / g) || o !== Math.floor(s / g)) continue;
        } else if (t === l.indexMaxZoom || f.numPoints <= l.indexMaxPoints) continue;

        if (f.source = null, 0 !== e.length) {
          u > 1 && console.time("clipping");
          var d,
              m,
              y,
              v,
              x,
              w,
              S = .5 * l.buffer / l.extent,
              M = .5 - S,
              P = .5 + S,
              b = 1 + S;
          d = m = y = v = null, x = oe(e, h, r - S, r + P, 0, f.minX, f.maxX, l), w = oe(e, h, r + M, r + b, 0, f.minX, f.maxX, l), e = null, x && (d = oe(x, h, o - S, o + P, 1, f.minY, f.maxY, l), m = oe(x, h, o + M, o + b, 1, f.minY, f.maxY, l), x = null), w && (y = oe(w, h, o - S, o + P, 1, f.minY, f.maxY, l), v = oe(w, h, o + M, o + b, 1, f.minY, f.maxY, l), w = null), u > 1 && console.timeEnd("clipping"), a.push(d || [], t + 1, 2 * r, 2 * o), a.push(m || [], t + 1, 2 * r, 2 * o + 1), a.push(y || [], t + 1, 2 * r + 1, 2 * o), a.push(v || [], t + 1, 2 * r + 1, 2 * o + 1);
        }
      }
    }, ve.prototype.getTile = function (e, t, r) {
      var o = this.options,
          n = o.extent,
          i = o.debug;
      if (e < 0 || e > 24) return null;
      var s = 1 << e,
          a = xe(e, t = (t % s + s) % s, r);
      if (this.tiles[a]) return pe(this.tiles[a], n);
      i > 1 && console.log("drilling down to z%d-%d-%d", e, t, r);

      for (var l, u = e, h = t, c = r; !l && u > 0;) u--, h = Math.floor(h / 2), c = Math.floor(c / 2), l = this.tiles[xe(u, h, c)];

      return l && l.source ? (i > 1 && console.log("found parent tile z%d-%d-%d", u, h, c), i > 1 && console.time("drilling down"), this.splitTile(l.source, u, h, c, e, t, r), i > 1 && console.timeEnd("drilling down"), this.tiles[a] ? pe(this.tiles[a], n) : null) : null;
    };

    class Se extends e.VectorTileWorkerSource {
      constructor(e, t, r, o, n) {
        super(e, t, r, o, we), n && (this.loadGeoJSON = n);
      }

      loadData(t, r) {
        const o = t && t.request,
              n = o && o.collectResourceTiming;
        this.loadGeoJSON(t, (s, a) => {
          if (s || !a) return r(s);
          if ("object" != typeof a) return r(new Error(`Input data given to '${t.source}' is not a valid GeoJSON object.`));
          {
            i(a, !0);

            try {
              if (t.filter) {
                const r = e.createExpression(t.filter, {
                  type: "boolean",
                  "property-type": "data-driven",
                  overridable: !1,
                  transition: !1
                });
                if ("error" === r.result) throw new Error(r.value.map(e => `${e.key}: ${e.message}`).join(", "));
                const o = a.features.filter(e => r.value.evaluate({
                  zoom: 0
                }, e));
                a = {
                  type: "FeatureCollection",
                  features: o
                };
              }

              this._geoJSONIndex = t.cluster ? new j(function ({
                superclusterOptions: t,
                clusterProperties: r
              }) {
                if (!r || !t) return t;
                const o = {},
                      n = {},
                      i = {
                  accumulated: null,
                  zoom: 0
                },
                      s = {
                  properties: null
                },
                      a = Object.keys(r);

                for (const t of a) {
                  const [i, s] = r[t],
                        a = e.createExpression(s),
                        l = e.createExpression("string" == typeof i ? [i, ["accumulated"], ["get", t]] : i);
                  o[t] = a.value, n[t] = l.value;
                }

                return t.map = e => {
                  s.properties = e;
                  const t = {};

                  for (const e of a) t[e] = o[e].evaluate(i, s);

                  return t;
                }, t.reduce = (e, t) => {
                  s.properties = t;

                  for (const t of a) i.accumulated = e[t], e[t] = n[t].evaluate(i, s);
                }, t;
              }(t)).load(a.features) : function (e, t) {
                return new ve(e, t);
              }(a, t.geojsonVtOptions);
            } catch (s) {
              return r(s);
            }

            this.loaded = {};
            const l = {};

            if (n) {
              const r = e.getPerformanceMeasurement(o);
              r && (l.resourceTiming = {}, l.resourceTiming[t.source] = JSON.parse(JSON.stringify(r)));
            }

            r(null, l);
          }
        });
      }

      reloadTile(e, t) {
        const r = this.loaded;
        return r && r[e.uid] ? super.reloadTile(e, t) : this.loadTile(e, t);
      }

      loadGeoJSON(t, r) {
        if (t.request) e.getJSON(t.request, r);else {
          if ("string" != typeof t.data) return r(new Error(`Input data given to '${t.source}' is not a valid GeoJSON object.`));

          try {
            return r(null, JSON.parse(t.data));
          } catch (e) {
            return r(new Error(`Input data given to '${t.source}' is not a valid GeoJSON object.`));
          }
        }
      }

      getClusterExpansionZoom(e, t) {
        try {
          t(null, this._geoJSONIndex.getClusterExpansionZoom(e.clusterId));
        } catch (e) {
          t(e);
        }
      }

      getClusterChildren(e, t) {
        try {
          t(null, this._geoJSONIndex.getChildren(e.clusterId));
        } catch (e) {
          t(e);
        }
      }

      getClusterLeaves(e, t) {
        try {
          t(null, this._geoJSONIndex.getLeaves(e.clusterId, e.limit, e.offset));
        } catch (e) {
          t(e);
        }
      }

    }

    class Me {
      constructor(t) {
        this.self = t, this.actor = new e.Actor(t, this), this.layerIndexes = {}, this.availableImages = {}, this.isSpriteLoaded = {}, this.projections = {}, this.defaultProjection = e.getProjection({
          name: "mercator"
        }), this.workerSourceTypes = {
          vector: e.VectorTileWorkerSource,
          geojson: Se
        }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = (e, t) => {
          if (this.workerSourceTypes[e]) throw new Error(`Worker source with name "${e}" already registered.`);
          this.workerSourceTypes[e] = t;
        }, this.self.registerRTLTextPlugin = t => {
          if (e.plugin.isParsed()) throw new Error("RTL text plugin already registered.");
          e.plugin.applyArabicShaping = t.applyArabicShaping, e.plugin.processBidirectionalText = t.processBidirectionalText, e.plugin.processStyledBidirectionalText = t.processStyledBidirectionalText;
        };
      }

      clearCaches(e, t, r) {
        delete this.layerIndexes[e], delete this.availableImages[e], delete this.workerSources[e], delete this.demWorkerSources[e], r();
      }

      checkIfReady(e, t, r) {
        r();
      }

      setReferrer(e, t) {
        this.referrer = t;
      }

      spriteLoaded(t, r) {
        this.isSpriteLoaded[t] = r;

        for (const o in this.workerSources[t]) {
          const n = this.workerSources[t][o];

          for (const t in n) n[t] instanceof e.VectorTileWorkerSource && (n[t].isSpriteLoaded = r, n[t].fire(new e.Event("isSpriteLoaded")));
        }
      }

      setImages(e, t, r) {
        this.availableImages[e] = t;

        for (const r in this.workerSources[e]) {
          const o = this.workerSources[e][r];

          for (const e in o) o[e].availableImages = t;
        }

        r();
      }

      enableTerrain(e, t, r) {
        this.terrain = t, r();
      }

      setProjection(t, r) {
        this.projections[t] = e.getProjection(r);
      }

      setLayers(e, t, r) {
        this.getLayerIndex(e).replace(t), r();
      }

      updateLayers(e, t, r) {
        this.getLayerIndex(e).update(t.layers, t.removedIds), r();
      }

      loadTile(t, r, o) {
        const n = this.enableTerrain ? e.extend({
          enableTerrain: this.terrain
        }, r) : r;
        n.projection = this.projections[t] || this.defaultProjection, this.getWorkerSource(t, r.type, r.source).loadTile(n, o);
      }

      loadDEMTile(t, r, o) {
        const n = this.enableTerrain ? e.extend({
          buildQuadTree: this.terrain
        }, r) : r;
        this.getDEMWorkerSource(t, r.source).loadTile(n, o);
      }

      reloadTile(t, r, o) {
        const n = this.enableTerrain ? e.extend({
          enableTerrain: this.terrain
        }, r) : r;
        n.projection = this.projections[t] || this.defaultProjection, this.getWorkerSource(t, r.type, r.source).reloadTile(n, o);
      }

      abortTile(e, t, r) {
        this.getWorkerSource(e, t.type, t.source).abortTile(t, r);
      }

      removeTile(e, t, r) {
        this.getWorkerSource(e, t.type, t.source).removeTile(t, r);
      }

      removeSource(e, t, r) {
        if (!this.workerSources[e] || !this.workerSources[e][t.type] || !this.workerSources[e][t.type][t.source]) return;
        const o = this.workerSources[e][t.type][t.source];
        delete this.workerSources[e][t.type][t.source], void 0 !== o.removeSource ? o.removeSource(t, r) : r();
      }

      loadWorkerSource(e, t, r) {
        try {
          this.self.importScripts(t.url), r();
        } catch (e) {
          r(e.toString());
        }
      }

      syncRTLPluginState(t, r, o) {
        try {
          e.plugin.setState(r);
          const t = e.plugin.getPluginURL();

          if (e.plugin.isLoaded() && !e.plugin.isParsed() && null != t) {
            this.self.importScripts(t);
            const r = e.plugin.isParsed();
            o(r ? void 0 : new Error(`RTL Text Plugin failed to import scripts from ${t}`), r);
          }
        } catch (e) {
          o(e.toString());
        }
      }

      getAvailableImages(e) {
        let t = this.availableImages[e];
        return t || (t = []), t;
      }

      getLayerIndex(e) {
        let t = this.layerIndexes[e];
        return t || (t = this.layerIndexes[e] = new o()), t;
      }

      getWorkerSource(e, t, r) {
        return this.workerSources[e] || (this.workerSources[e] = {}), this.workerSources[e][t] || (this.workerSources[e][t] = {}), this.workerSources[e][t][r] || (this.workerSources[e][t][r] = new this.workerSourceTypes[t]({
          send: (t, r, o, n, i, s) => {
            this.actor.send(t, r, o, e, i, s);
          },
          scheduler: this.actor.scheduler
        }, this.getLayerIndex(e), this.getAvailableImages(e), this.isSpriteLoaded[e])), this.workerSources[e][t][r];
      }

      getDEMWorkerSource(e, t) {
        return this.demWorkerSources[e] || (this.demWorkerSources[e] = {}), this.demWorkerSources[e][t] || (this.demWorkerSources[e][t] = new n()), this.demWorkerSources[e][t];
      }

      enforceCacheSizeLimit(t, r) {
        e.enforceCacheSizeLimit(r);
      }

      getWorkerPerformanceMetrics(e, t, r) {
        r(void 0, void 0);
      }

    }

    return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope && (self.worker = new Me(self)), Me;
  });
  define(["./shared"], function (e) {
    "use strict";

    var t = i;

    function i(e) {
      return !function (e) {
        return "undefined" == typeof window || "undefined" == typeof document ? "not a browser" : Array.prototype && Array.prototype.every && Array.prototype.filter && Array.prototype.forEach && Array.prototype.indexOf && Array.prototype.lastIndexOf && Array.prototype.map && Array.prototype.some && Array.prototype.reduce && Array.prototype.reduceRight && Array.isArray ? Function.prototype && Function.prototype.bind ? Object.keys && Object.create && Object.getPrototypeOf && Object.getOwnPropertyNames && Object.isSealed && Object.isFrozen && Object.isExtensible && Object.getOwnPropertyDescriptor && Object.defineProperty && Object.defineProperties && Object.seal && Object.freeze && Object.preventExtensions ? "JSON" in window && "parse" in JSON && "stringify" in JSON ? function () {
          if (!("Worker" in window && "Blob" in window && "URL" in window)) return !1;
          var e,
              t,
              i = new Blob([""], {
            type: "text/javascript"
          }),
              o = URL.createObjectURL(i);

          try {
            t = new Worker(o), e = !0;
          } catch (t) {
            e = !1;
          }

          return t && t.terminate(), URL.revokeObjectURL(o), e;
        }() ? "Uint8ClampedArray" in window ? ArrayBuffer.isView ? function () {
          var e = document.createElement("canvas");
          e.width = e.height = 1;
          var t = e.getContext("2d");
          if (!t) return !1;
          var i = t.getImageData(0, 0, 1, 1);
          return i && i.width === e.width;
        }() ? (void 0 === o[t = e && e.failIfMajorPerformanceCaveat] && (o[t] = function (e) {
          var t,
              o = function (e) {
            var t = document.createElement("canvas"),
                o = Object.create(i.webGLContextAttributes);
            return o.failIfMajorPerformanceCaveat = e, t.getContext("webgl", o) || t.getContext("experimental-webgl", o);
          }(e);

          if (!o) return !1;

          try {
            t = o.createShader(o.VERTEX_SHADER);
          } catch (e) {
            return !1;
          }

          return !(!t || o.isContextLost()) && (o.shaderSource(t, "void main() {}"), o.compileShader(t), !0 === o.getShaderParameter(t, o.COMPILE_STATUS));
        }(t)), o[t] ? document.documentMode ? "insufficient ECMAScript 6 support" : void 0 : "insufficient WebGL support") : "insufficient Canvas/getImageData support" : "insufficient ArrayBuffer support" : "insufficient Uint8ClampedArray support" : "insufficient worker support" : "insufficient JSON support" : "insufficient Object support" : "insufficient Function support" : "insufficent Array support";
        var t;
      }(e);
    }

    var o = {};

    function r(e, t) {
      if (Array.isArray(e)) {
        if (!Array.isArray(t) || e.length !== t.length) return !1;

        for (let i = 0; i < e.length; i++) if (!r(e[i], t[i])) return !1;

        return !0;
      }

      if ("object" == typeof e && null !== e && null !== t) {
        if ("object" != typeof t) return !1;
        if (Object.keys(e).length !== Object.keys(t).length) return !1;

        for (const i in e) if (!r(e[i], t[i])) return !1;

        return !0;
      }

      return e === t;
    }

    function n(t, i, o) {
      const r = e.window.document.createElement(t);
      return void 0 !== i && (r.className = i), o && o.appendChild(r), r;
    }

    function a(t, i, o) {
      const r = e.window.document.createElementNS("http://www.w3.org/2000/svg", t);

      for (const e of Object.keys(i)) r.setAttributeNS(null, e, i[e]);

      return o && o.appendChild(r), r;
    }

    i.webGLContextAttributes = {
      antialias: !1,
      alpha: !0,
      stencil: !0,
      depth: !0
    };
    const s = e.window.document && e.window.document.documentElement.style,
          l = s && void 0 !== s.userSelect ? "userSelect" : "WebkitUserSelect";
    let c;

    function h() {
      s && l && (c = s[l], s[l] = "none");
    }

    function _() {
      s && l && (s[l] = c);
    }

    function u(t) {
      t.preventDefault(), t.stopPropagation(), e.window.removeEventListener("click", u, !0);
    }

    function d() {
      e.window.addEventListener("click", u, !0), e.window.setTimeout(() => {
        e.window.removeEventListener("click", u, !0);
      }, 0);
    }

    function p(e, t) {
      const i = e.getBoundingClientRect();
      return g(e, i, t);
    }

    function m(e, t) {
      const i = e.getBoundingClientRect(),
            o = [];

      for (let r = 0; r < t.length; r++) o.push(g(e, i, t[r]));

      return o;
    }

    function f(t) {
      return void 0 !== e.window.InstallTrigger && 2 === t.button && t.ctrlKey && e.window.navigator.platform.toUpperCase().indexOf("MAC") >= 0 ? 0 : t.button;
    }

    function g(t, i, o) {
      const r = t.offsetWidth === i.width ? 1 : t.offsetWidth / i.width;
      return new e.pointGeometry((o.clientX - i.left) * r, (o.clientY - i.top) * r);
    }

    function v(e, t) {
      var i = t[0],
          o = t[1],
          r = t[2],
          n = t[3],
          a = i * n - r * o;
      return a ? (e[0] = n * (a = 1 / a), e[1] = -o * a, e[2] = -r * a, e[3] = i * a, e) : null;
    }

    function x(e) {
      const {
        userImage: t
      } = e;
      return !!(t && t.render && t.render()) && (e.data.replace(new Uint8Array(t.data.buffer)), !0);
    }

    class y extends e.Evented {
      constructor() {
        super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new e.RGBAImage({
          width: 1,
          height: 1
        }), this.dirty = !0;
      }

      isLoaded() {
        return this.loaded;
      }

      setLoaded(e) {
        if (this.loaded !== e && (this.loaded = e, e)) {
          for (const {
            ids: e,
            callback: t
          } of this.requestors) this._notify(e, t);

          this.requestors = [];
        }
      }

      hasImage(e) {
        return !!this.getImage(e);
      }

      getImage(e) {
        return this.images[e];
      }

      addImage(e, t) {
        this._validate(e, t) && (this.images[e] = t);
      }

      _validate(t, i) {
        let o = !0;
        return this._validateStretch(i.stretchX, i.data && i.data.width) || (this.fire(new e.ErrorEvent(new Error(`Image "${t}" has invalid "stretchX" value`))), o = !1), this._validateStretch(i.stretchY, i.data && i.data.height) || (this.fire(new e.ErrorEvent(new Error(`Image "${t}" has invalid "stretchY" value`))), o = !1), this._validateContent(i.content, i) || (this.fire(new e.ErrorEvent(new Error(`Image "${t}" has invalid "content" value`))), o = !1), o;
      }

      _validateStretch(e, t) {
        if (!e) return !0;
        let i = 0;

        for (const o of e) {
          if (o[0] < i || o[1] < o[0] || t < o[1]) return !1;
          i = o[1];
        }

        return !0;
      }

      _validateContent(e, t) {
        return !(e && (4 !== e.length || e[0] < 0 || t.data.width < e[0] || e[1] < 0 || t.data.height < e[1] || e[2] < 0 || t.data.width < e[2] || e[3] < 0 || t.data.height < e[3] || e[2] < e[0] || e[3] < e[1]));
      }

      updateImage(e, t) {
        t.version = this.images[e].version + 1, this.images[e] = t, this.updatedImages[e] = !0;
      }

      removeImage(e) {
        const t = this.images[e];
        delete this.images[e], delete this.patterns[e], t.userImage && t.userImage.onRemove && t.userImage.onRemove();
      }

      listImages() {
        return Object.keys(this.images);
      }

      getImages(e, t) {
        let i = !0;
        if (!this.isLoaded()) for (const t of e) this.images[t] || (i = !1);
        this.isLoaded() || i ? this._notify(e, t) : this.requestors.push({
          ids: e,
          callback: t
        });
      }

      _notify(t, i) {
        const o = {};

        for (const i of t) {
          this.images[i] || this.fire(new e.Event("styleimagemissing", {
            id: i
          }));
          const t = this.images[i];
          t ? o[i] = {
            data: t.data.clone(),
            pixelRatio: t.pixelRatio,
            sdf: t.sdf,
            version: t.version,
            stretchX: t.stretchX,
            stretchY: t.stretchY,
            content: t.content,
            hasRenderCallback: Boolean(t.userImage && t.userImage.render)
          } : e.warnOnce(`Image "${i}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
        }

        i(null, o);
      }

      getPixelSize() {
        const {
          width: e,
          height: t
        } = this.atlasImage;
        return {
          width: e,
          height: t
        };
      }

      getPattern(t) {
        const i = this.patterns[t],
              o = this.getImage(t);
        if (!o) return null;
        if (i && i.position.version === o.version) return i.position;
        if (i) i.position.version = o.version;else {
          const i = {
            w: o.data.width + 2,
            h: o.data.height + 2,
            x: 0,
            y: 0
          },
                r = new e.ImagePosition(i, o);
          this.patterns[t] = {
            bin: i,
            position: r
          };
        }
        return this._updatePatternAtlas(), this.patterns[t].position;
      }

      bind(t) {
        const i = t.gl;
        this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new e.Texture(t, this.atlasImage, i.RGBA), this.atlasTexture.bind(i.LINEAR, i.CLAMP_TO_EDGE);
      }

      _updatePatternAtlas() {
        const t = [];

        for (const e in this.patterns) t.push(this.patterns[e].bin);

        const {
          w: i,
          h: o
        } = e.potpack(t),
              r = this.atlasImage;
        r.resize({
          width: i || 1,
          height: o || 1
        });

        for (const t in this.patterns) {
          const {
            bin: i
          } = this.patterns[t],
                o = i.x + 1,
                n = i.y + 1,
                a = this.images[t].data,
                s = a.width,
                l = a.height;
          e.RGBAImage.copy(a, r, {
            x: 0,
            y: 0
          }, {
            x: o,
            y: n
          }, {
            width: s,
            height: l
          }), e.RGBAImage.copy(a, r, {
            x: 0,
            y: l - 1
          }, {
            x: o,
            y: n - 1
          }, {
            width: s,
            height: 1
          }), e.RGBAImage.copy(a, r, {
            x: 0,
            y: 0
          }, {
            x: o,
            y: n + l
          }, {
            width: s,
            height: 1
          }), e.RGBAImage.copy(a, r, {
            x: s - 1,
            y: 0
          }, {
            x: o - 1,
            y: n
          }, {
            width: 1,
            height: l
          }), e.RGBAImage.copy(a, r, {
            x: 0,
            y: 0
          }, {
            x: o + s,
            y: n
          }, {
            width: 1,
            height: l
          });
        }

        this.dirty = !0;
      }

      beginFrame() {
        this.callbackDispatchedThisFrame = {};
      }

      dispatchRenderCallbacks(e) {
        for (const t of e) {
          if (this.callbackDispatchedThisFrame[t]) continue;
          this.callbackDispatchedThisFrame[t] = !0;
          const e = this.images[t];
          x(e) && this.updateImage(t, e);
        }
      }

    }

    const b = new e.Properties({
      anchor: new e.DataConstantProperty(e.spec.light.anchor),
      position: new class {
        constructor() {
          this.specification = e.spec.light.position;
        }

        possiblyEvaluate(t, i) {
          return function ([t, i, o]) {
            const r = e.degToRad(i + 90),
                  n = e.degToRad(o);
            return {
              x: t * Math.cos(r) * Math.sin(n),
              y: t * Math.sin(r) * Math.sin(n),
              z: t * Math.cos(n),
              azimuthal: i,
              polar: o
            };
          }(t.expression.evaluate(i));
        }

        interpolate(t, i, o) {
          return {
            x: e.number(t.x, i.x, o),
            y: e.number(t.y, i.y, o),
            z: e.number(t.z, i.z, o),
            azimuthal: e.number(t.azimuthal, i.azimuthal, o),
            polar: e.number(t.polar, i.polar, o)
          };
        }

      }(),
      color: new e.DataConstantProperty(e.spec.light.color),
      intensity: new e.DataConstantProperty(e.spec.light.intensity)
    }),
          w = "-transition";

    class T extends e.Evented {
      constructor(t) {
        super(), this._transitionable = new e.Transitionable(b), this.setLight(t), this._transitioning = this._transitionable.untransitioned();
      }

      getLight() {
        return this._transitionable.serialize();
      }

      setLight(t, i = {}) {
        if (!this._validate(e.validateLight, t, i)) for (const i in t) {
          const o = t[i];
          e.endsWith(i, w) ? this._transitionable.setTransition(i.slice(0, -w.length), o) : this._transitionable.setValue(i, o);
        }
      }

      updateTransitions(e) {
        this._transitioning = this._transitionable.transitioned(e, this._transitioning);
      }

      hasTransition() {
        return this._transitioning.hasTransition();
      }

      recalculate(e) {
        this.properties = this._transitioning.possiblyEvaluate(e);
      }

      _validate(t, i, o) {
        return (!o || !1 !== o.validate) && e.emitValidationErrors(this, t.call(e.validateStyle, e.extend({
          value: i,
          style: {
            glyphs: !0,
            sprite: !0
          },
          styleSpec: e.spec
        })));
      }

    }

    const E = new e.Properties({
      source: new e.DataConstantProperty(e.spec.terrain.source),
      exaggeration: new e.DataConstantProperty(e.spec.terrain.exaggeration)
    }),
          C = "-transition";

    class I extends e.Evented {
      constructor(t, i) {
        super(), this._transitionable = new e.Transitionable(E), this.set(t), this._transitioning = this._transitionable.untransitioned(), this.drapeRenderMode = i;
      }

      get() {
        return this._transitionable.serialize();
      }

      set(t) {
        for (const i in t) {
          const o = t[i];
          e.endsWith(i, C) ? this._transitionable.setTransition(i.slice(0, -C.length), o) : this._transitionable.setValue(i, o);
        }
      }

      updateTransitions(e) {
        this._transitioning = this._transitionable.transitioned(e, this._transitioning);
      }

      hasTransition() {
        return this._transitioning.hasTransition();
      }

      recalculate(e) {
        this.properties = this._transitioning.possiblyEvaluate(e);
      }

    }

    function M(t, i, o, r) {
      const n = e.smoothstep(45, 65, o),
            [a, s] = S(t, r),
            l = e.length(i);
      let c = 1 - Math.min(1, Math.exp((l - a) / (s - a) * -6));
      return c *= c * c, c = Math.min(1, 1.00747 * c), c * n * t.alpha;
    }

    function S(e, t) {
      const i = .5 / Math.tan(.5 * t);
      return [e.range[0] + i, e.range[1] + i];
    }

    const z = new e.Properties({
      range: new e.DataConstantProperty(e.spec.fog.range),
      color: new e.DataConstantProperty(e.spec.fog.color),
      "horizon-blend": new e.DataConstantProperty(e.spec.fog["horizon-blend"])
    }),
          D = "-transition";

    class P extends e.Evented {
      constructor(t, i) {
        super(), this._transitionable = new e.Transitionable(z), this.set(t), this._transitioning = this._transitionable.untransitioned(), this._transform = i;
      }

      get state() {
        return {
          range: this.properties.get("range"),
          horizonBlend: this.properties.get("horizon-blend"),
          alpha: this.properties.get("color").a
        };
      }

      get() {
        return this._transitionable.serialize();
      }

      set(t, i = {}) {
        if (!this._validate(e.validateFog, t, i)) for (const i in t) {
          const o = t[i];
          e.endsWith(i, D) ? this._transitionable.setTransition(i.slice(0, -D.length), o) : this._transitionable.setValue(i, o);
        }
      }

      getOpacity(t) {
        if (!this._transform.projection.supportsFog) return 0;
        const i = this.properties && this.properties.get("color") || 1;
        return e.smoothstep(45, 65, t) * i.a;
      }

      getOpacityAtLatLng(t, i) {
        return this._transform.projection.supportsFog ? function (t, i, o) {
          const r = e.MercatorCoordinate.fromLngLat(i),
                n = o.elevation ? o.elevation.getAtPointOrZero(r) : 0,
                a = [r.x, r.y, n];
          return e.transformMat4(a, a, o.mercatorFogMatrix), M(t, a, o.pitch, o._fov);
        }(this.state, t, i) : 0;
      }

      getFovAdjustedRange(e) {
        return this._transform.projection.supportsFog ? S(this.state, e) : [0, 1];
      }

      updateTransitions(e) {
        this._transitioning = this._transitionable.transitioned(e, this._transitioning);
      }

      hasTransition() {
        return this._transitioning.hasTransition();
      }

      recalculate(e) {
        this.properties = this._transitioning.possiblyEvaluate(e);
      }

      _validate(t, i, o) {
        return (!o || !1 !== o.validate) && e.emitValidationErrors(this, t.call(e.validateStyle, e.extend({
          value: i,
          style: {
            glyphs: !0,
            sprite: !0
          },
          styleSpec: e.spec
        })));
      }

    }

    class A {
      constructor(t, i) {
        this.workerPool = t, this.actors = [], this.currentActor = 0, this.id = e.uniqueId();
        const o = this.workerPool.acquire(this.id);

        for (let e = 0; e < o.length; e++) {
          const t = new A.Actor(o[e], i, this.id);
          t.name = `Worker ${e}`, this.actors.push(t);
        }

        this.ready = !1, this.broadcast("checkIfReady", null, () => {
          this.ready = !0;
        });
      }

      broadcast(t, i, o) {
        e.asyncAll(this.actors, (e, o) => {
          e.send(t, i, o);
        }, o = o || function () {});
      }

      getActor() {
        return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
      }

      remove() {
        this.actors.forEach(e => {
          e.remove();
        }), this.actors = [], this.workerPool.release(this.id);
      }

    }

    function L(t, i, o) {
      return i * (e.EXTENT / (t.tileSize * Math.pow(2, o - t.tileID.overscaledZ)));
    }

    A.Actor = e.Actor;

    class R {
      constructor(e, t, i, o) {
        this.screenBounds = e, this.cameraPoint = t, this._screenRaycastCache = {}, this._cameraRaycastCache = {}, this.isAboveHorizon = i, this.screenGeometry = this.bufferedScreenGeometry(0), this.screenGeometryMercator = this.screenGeometry.map(e => o.pointCoordinate3D(e)), this.cameraGeometry = this.bufferedCameraGeometry(0);
      }

      static createFromScreenPoints(t, i) {
        let o, r;

        if (t instanceof e.pointGeometry || "number" == typeof t[0]) {
          const n = e.pointGeometry.convert(t);
          o = [e.pointGeometry.convert(t)], r = i.isPointAboveHorizon(n);
        } else {
          const n = e.pointGeometry.convert(t[0]),
                a = e.pointGeometry.convert(t[1]);
          o = [n, a], r = e.polygonizeBounds(n, a).every(e => i.isPointAboveHorizon(e));
        }

        return new R(o, i.getCameraPoint(), r, i);
      }

      isPointQuery() {
        return 1 === this.screenBounds.length;
      }

      bufferedScreenGeometry(t) {
        return e.polygonizeBounds(this.screenBounds[0], 1 === this.screenBounds.length ? this.screenBounds[0] : this.screenBounds[1], t);
      }

      bufferedCameraGeometry(t) {
        const i = this.screenBounds[0],
              o = 1 === this.screenBounds.length ? this.screenBounds[0].add(new e.pointGeometry(1, 1)) : this.screenBounds[1],
              r = e.polygonizeBounds(i, o, 0, !1);
        return this.cameraPoint.y > o.y && (this.cameraPoint.x > i.x && this.cameraPoint.x < o.x ? r.splice(3, 0, this.cameraPoint) : this.cameraPoint.x >= o.x ? r[2] = this.cameraPoint : this.cameraPoint.x <= i.x && (r[3] = this.cameraPoint)), e.bufferConvexPolygon(r, t);
      }

      containsTile(t, i, o) {
        const r = t.queryPadding + 1,
              n = t.tileID.wrap,
              a = o ? this._bufferedCameraMercator(r, i).map(i => e.getTilePoint(t.tileTransform, i, n)) : this._bufferedScreenMercator(r, i).map(i => e.getTilePoint(t.tileTransform, i, n)),
              s = this.screenGeometryMercator.map(i => e.getTileVec3(t.tileTransform, i, n)),
              l = s.map(t => new e.pointGeometry(t[0], t[1])),
              c = i.getFreeCameraOptions().position || new e.MercatorCoordinate(0, 0, 0),
              h = e.getTileVec3(t.tileTransform, c, n),
              _ = s.map(t => {
          const i = e.sub(t, t, h);
          return e.normalize(i, i), new e.Ray(h, i);
        }),
              u = L(t, 1, i.zoom);

        if (e.polygonIntersectsBox(a, 0, 0, e.EXTENT, e.EXTENT)) return {
          queryGeometry: this,
          tilespaceGeometry: l,
          tilespaceRays: _,
          bufferedTilespaceGeometry: a,
          bufferedTilespaceBounds: (d = e.getBounds(a), d.min.x = e.clamp(d.min.x, 0, e.EXTENT), d.min.y = e.clamp(d.min.y, 0, e.EXTENT), d.max.x = e.clamp(d.max.x, 0, e.EXTENT), d.max.y = e.clamp(d.max.y, 0, e.EXTENT), d),
          tile: t,
          tileID: t.tileID,
          pixelToTileUnitsFactor: u
        };
        var d;
      }

      _bufferedScreenMercator(e, t) {
        const i = k(e);
        if (this._screenRaycastCache[i]) return this._screenRaycastCache[i];
        {
          const o = this.bufferedScreenGeometry(e).map(e => t.pointCoordinate3D(e));
          return this._screenRaycastCache[i] = o, o;
        }
      }

      _bufferedCameraMercator(e, t) {
        const i = k(e);
        if (this._cameraRaycastCache[i]) return this._cameraRaycastCache[i];
        {
          const o = this.bufferedCameraGeometry(e).map(e => t.pointCoordinate3D(e));
          return this._cameraRaycastCache[i] = o, o;
        }
      }

    }

    function k(e) {
      return 100 * e | 0;
    }

    function O(t, i, o) {
      const r = function (r, n) {
        if (r) return o(r);

        if (n) {
          const r = e.pick(e.extend(n, t), ["tiles", "minzoom", "maxzoom", "attribution", "mapbox_logo", "bounds", "scheme", "tileSize", "encoding"]);
          n.vector_layers && (r.vectorLayers = n.vector_layers, r.vectorLayerIds = r.vectorLayers.map(e => e.id)), r.tiles = i.canonicalizeTileset(r, t.url), o(null, r);
        }
      };

      return t.url ? e.getJSON(i.transformRequest(i.normalizeSourceURL(t.url), e.ResourceType.Source), r) : e.exported.frame(() => r(null, t));
    }

    class B {
      constructor(t, i, o) {
        this.bounds = e.LngLatBounds.convert(this.validateBounds(t)), this.minzoom = i || 0, this.maxzoom = o || 24;
      }

      validateBounds(e) {
        return Array.isArray(e) && 4 === e.length ? [Math.max(-180, e[0]), Math.max(-90, e[1]), Math.min(180, e[2]), Math.min(90, e[3])] : [-180, -90, 180, 90];
      }

      contains(t) {
        const i = Math.pow(2, t.z),
              o = Math.floor(e.mercatorXfromLng(this.bounds.getWest()) * i),
              r = Math.floor(e.mercatorYfromLat(this.bounds.getNorth()) * i),
              n = Math.ceil(e.mercatorXfromLng(this.bounds.getEast()) * i),
              a = Math.ceil(e.mercatorYfromLat(this.bounds.getSouth()) * i);
        return t.x >= o && t.x < n && t.y >= r && t.y < a;
      }

    }

    class F {
      constructor(e, t, i) {
        this.context = e;
        const o = e.gl;
        this.buffer = o.createBuffer(), this.dynamicDraw = Boolean(i), this.context.unbindVAO(), e.bindElementBuffer.set(this.buffer), o.bufferData(o.ELEMENT_ARRAY_BUFFER, t.arrayBuffer, this.dynamicDraw ? o.DYNAMIC_DRAW : o.STATIC_DRAW), this.dynamicDraw || t.destroy();
      }

      bind() {
        this.context.bindElementBuffer.set(this.buffer);
      }

      updateData(e) {
        const t = this.context.gl;
        this.context.unbindVAO(), this.bind(), t.bufferSubData(t.ELEMENT_ARRAY_BUFFER, 0, e.arrayBuffer);
      }

      destroy() {
        this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
      }

    }

    const U = {
      Int8: "BYTE",
      Uint8: "UNSIGNED_BYTE",
      Int16: "SHORT",
      Uint16: "UNSIGNED_SHORT",
      Int32: "INT",
      Uint32: "UNSIGNED_INT",
      Float32: "FLOAT"
    };

    class N {
      constructor(e, t, i, o) {
        this.length = t.length, this.attributes = i, this.itemSize = t.bytesPerElement, this.dynamicDraw = o, this.context = e;
        const r = e.gl;
        this.buffer = r.createBuffer(), e.bindVertexBuffer.set(this.buffer), r.bufferData(r.ARRAY_BUFFER, t.arrayBuffer, this.dynamicDraw ? r.DYNAMIC_DRAW : r.STATIC_DRAW), this.dynamicDraw || t.destroy();
      }

      bind() {
        this.context.bindVertexBuffer.set(this.buffer);
      }

      updateData(e) {
        const t = this.context.gl;
        this.bind(), t.bufferSubData(t.ARRAY_BUFFER, 0, e.arrayBuffer);
      }

      enableAttributes(e, t) {
        for (let i = 0; i < this.attributes.length; i++) {
          const o = t.attributes[this.attributes[i].name];
          void 0 !== o && e.enableVertexAttribArray(o);
        }
      }

      setVertexAttribPointers(e, t, i) {
        for (let o = 0; o < this.attributes.length; o++) {
          const r = this.attributes[o],
                n = t.attributes[r.name];
          void 0 !== n && e.vertexAttribPointer(n, r.components, e[U[r.type]], !1, this.itemSize, r.offset + this.itemSize * (i || 0));
        }
      }

      destroy() {
        this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
      }

    }

    class G {
      constructor(e) {
        this.gl = e.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;
      }

      get() {
        return this.current;
      }

      set(e) {}

      getDefault() {
        return this.default;
      }

      setDefault() {
        this.set(this.default);
      }

    }

    class j extends G {
      getDefault() {
        return e.Color.transparent;
      }

      set(e) {
        const t = this.current;
        (e.r !== t.r || e.g !== t.g || e.b !== t.b || e.a !== t.a || this.dirty) && (this.gl.clearColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1);
      }

    }

    class Z extends G {
      getDefault() {
        return 1;
      }

      set(e) {
        (e !== this.current || this.dirty) && (this.gl.clearDepth(e), this.current = e, this.dirty = !1);
      }

    }

    class V extends G {
      getDefault() {
        return 0;
      }

      set(e) {
        (e !== this.current || this.dirty) && (this.gl.clearStencil(e), this.current = e, this.dirty = !1);
      }

    }

    class W extends G {
      getDefault() {
        return [!0, !0, !0, !0];
      }

      set(e) {
        const t = this.current;
        (e[0] !== t[0] || e[1] !== t[1] || e[2] !== t[2] || e[3] !== t[3] || this.dirty) && (this.gl.colorMask(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1);
      }

    }

    class q extends G {
      getDefault() {
        return !0;
      }

      set(e) {
        (e !== this.current || this.dirty) && (this.gl.depthMask(e), this.current = e, this.dirty = !1);
      }

    }

    class X extends G {
      getDefault() {
        return 255;
      }

      set(e) {
        (e !== this.current || this.dirty) && (this.gl.stencilMask(e), this.current = e, this.dirty = !1);
      }

    }

    class $ extends G {
      getDefault() {
        return {
          func: this.gl.ALWAYS,
          ref: 0,
          mask: 255
        };
      }

      set(e) {
        const t = this.current;
        (e.func !== t.func || e.ref !== t.ref || e.mask !== t.mask || this.dirty) && (this.gl.stencilFunc(e.func, e.ref, e.mask), this.current = e, this.dirty = !1);
      }

    }

    class H extends G {
      getDefault() {
        const e = this.gl;
        return [e.KEEP, e.KEEP, e.KEEP];
      }

      set(e) {
        const t = this.current;
        (e[0] !== t[0] || e[1] !== t[1] || e[2] !== t[2] || this.dirty) && (this.gl.stencilOp(e[0], e[1], e[2]), this.current = e, this.dirty = !1);
      }

    }

    class K extends G {
      getDefault() {
        return !1;
      }

      set(e) {
        if (e === this.current && !this.dirty) return;
        const t = this.gl;
        e ? t.enable(t.STENCIL_TEST) : t.disable(t.STENCIL_TEST), this.current = e, this.dirty = !1;
      }

    }

    class Y extends G {
      getDefault() {
        return [0, 1];
      }

      set(e) {
        const t = this.current;
        (e[0] !== t[0] || e[1] !== t[1] || this.dirty) && (this.gl.depthRange(e[0], e[1]), this.current = e, this.dirty = !1);
      }

    }

    class J extends G {
      getDefault() {
        return !1;
      }

      set(e) {
        if (e === this.current && !this.dirty) return;
        const t = this.gl;
        e ? t.enable(t.DEPTH_TEST) : t.disable(t.DEPTH_TEST), this.current = e, this.dirty = !1;
      }

    }

    class Q extends G {
      getDefault() {
        return this.gl.LESS;
      }

      set(e) {
        (e !== this.current || this.dirty) && (this.gl.depthFunc(e), this.current = e, this.dirty = !1);
      }

    }

    class ee extends G {
      getDefault() {
        return !1;
      }

      set(e) {
        if (e === this.current && !this.dirty) return;
        const t = this.gl;
        e ? t.enable(t.BLEND) : t.disable(t.BLEND), this.current = e, this.dirty = !1;
      }

    }

    class te extends G {
      getDefault() {
        const e = this.gl;
        return [e.ONE, e.ZERO];
      }

      set(e) {
        const t = this.current;
        (e[0] !== t[0] || e[1] !== t[1] || this.dirty) && (this.gl.blendFunc(e[0], e[1]), this.current = e, this.dirty = !1);
      }

    }

    class ie extends G {
      getDefault() {
        return e.Color.transparent;
      }

      set(e) {
        const t = this.current;
        (e.r !== t.r || e.g !== t.g || e.b !== t.b || e.a !== t.a || this.dirty) && (this.gl.blendColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1);
      }

    }

    class oe extends G {
      getDefault() {
        return this.gl.FUNC_ADD;
      }

      set(e) {
        (e !== this.current || this.dirty) && (this.gl.blendEquation(e), this.current = e, this.dirty = !1);
      }

    }

    class re extends G {
      getDefault() {
        return !1;
      }

      set(e) {
        if (e === this.current && !this.dirty) return;
        const t = this.gl;
        e ? t.enable(t.CULL_FACE) : t.disable(t.CULL_FACE), this.current = e, this.dirty = !1;
      }

    }

    class ne extends G {
      getDefault() {
        return this.gl.BACK;
      }

      set(e) {
        (e !== this.current || this.dirty) && (this.gl.cullFace(e), this.current = e, this.dirty = !1);
      }

    }

    class ae extends G {
      getDefault() {
        return this.gl.CCW;
      }

      set(e) {
        (e !== this.current || this.dirty) && (this.gl.frontFace(e), this.current = e, this.dirty = !1);
      }

    }

    class se extends G {
      getDefault() {
        return null;
      }

      set(e) {
        (e !== this.current || this.dirty) && (this.gl.useProgram(e), this.current = e, this.dirty = !1);
      }

    }

    class le extends G {
      getDefault() {
        return this.gl.TEXTURE0;
      }

      set(e) {
        (e !== this.current || this.dirty) && (this.gl.activeTexture(e), this.current = e, this.dirty = !1);
      }

    }

    class ce extends G {
      getDefault() {
        const e = this.gl;
        return [0, 0, e.drawingBufferWidth, e.drawingBufferHeight];
      }

      set(e) {
        const t = this.current;
        (e[0] !== t[0] || e[1] !== t[1] || e[2] !== t[2] || e[3] !== t[3] || this.dirty) && (this.gl.viewport(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1);
      }

    }

    class he extends G {
      getDefault() {
        return null;
      }

      set(e) {
        if (e === this.current && !this.dirty) return;
        const t = this.gl;
        t.bindFramebuffer(t.FRAMEBUFFER, e), this.current = e, this.dirty = !1;
      }

    }

    class _e extends G {
      getDefault() {
        return null;
      }

      set(e) {
        if (e === this.current && !this.dirty) return;
        const t = this.gl;
        t.bindRenderbuffer(t.RENDERBUFFER, e), this.current = e, this.dirty = !1;
      }

    }

    class ue extends G {
      getDefault() {
        return null;
      }

      set(e) {
        if (e === this.current && !this.dirty) return;
        const t = this.gl;
        t.bindTexture(t.TEXTURE_2D, e), this.current = e, this.dirty = !1;
      }

    }

    class de extends G {
      getDefault() {
        return null;
      }

      set(e) {
        if (e === this.current && !this.dirty) return;
        const t = this.gl;
        t.bindBuffer(t.ARRAY_BUFFER, e), this.current = e, this.dirty = !1;
      }

    }

    class pe extends G {
      getDefault() {
        return null;
      }

      set(e) {
        const t = this.gl;
        t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, e), this.current = e, this.dirty = !1;
      }

    }

    class me extends G {
      constructor(e) {
        super(e), this.vao = e.extVertexArrayObject;
      }

      getDefault() {
        return null;
      }

      set(e) {
        this.vao && (e !== this.current || this.dirty) && (this.vao.bindVertexArrayOES(e), this.current = e, this.dirty = !1);
      }

    }

    class fe extends G {
      getDefault() {
        return 4;
      }

      set(e) {
        if (e === this.current && !this.dirty) return;
        const t = this.gl;
        t.pixelStorei(t.UNPACK_ALIGNMENT, e), this.current = e, this.dirty = !1;
      }

    }

    class ge extends G {
      getDefault() {
        return !1;
      }

      set(e) {
        if (e === this.current && !this.dirty) return;
        const t = this.gl;
        t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e), this.current = e, this.dirty = !1;
      }

    }

    class ve extends G {
      getDefault() {
        return !1;
      }

      set(e) {
        if (e === this.current && !this.dirty) return;
        const t = this.gl;
        t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, e), this.current = e, this.dirty = !1;
      }

    }

    class xe extends G {
      constructor(e, t) {
        super(e), this.context = e, this.parent = t;
      }

      getDefault() {
        return null;
      }

    }

    class ye extends xe {
      setDirty() {
        this.dirty = !0;
      }

      set(e) {
        if (e === this.current && !this.dirty) return;
        this.context.bindFramebuffer.set(this.parent);
        const t = this.gl;
        t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, e, 0), this.current = e, this.dirty = !1;
      }

    }

    class be extends xe {
      attachment() {
        return this.gl.DEPTH_ATTACHMENT;
      }

      set(e) {
        if (e === this.current && !this.dirty) return;
        this.context.bindFramebuffer.set(this.parent);
        const t = this.gl;
        t.framebufferRenderbuffer(t.FRAMEBUFFER, this.attachment(), t.RENDERBUFFER, e), this.current = e, this.dirty = !1;
      }

    }

    class we extends be {
      attachment() {
        return this.gl.DEPTH_STENCIL_ATTACHMENT;
      }

    }

    class Te {
      constructor(e, t, i, o) {
        this.context = e, this.width = t, this.height = i;
        const r = this.framebuffer = e.gl.createFramebuffer();
        this.colorAttachment = new ye(e, r), o && (this.depthAttachment = new be(e, r));
      }

      destroy() {
        const e = this.context.gl,
              t = this.colorAttachment.get();

        if (t && e.deleteTexture(t), this.depthAttachment) {
          const t = this.depthAttachment.get();
          t && e.deleteRenderbuffer(t);
        }

        e.deleteFramebuffer(this.framebuffer);
      }

    }

    class Ee {
      constructor(e) {
        this.gl = e, this.extVertexArrayObject = this.gl.getExtension("OES_vertex_array_object"), this.clearColor = new j(this), this.clearDepth = new Z(this), this.clearStencil = new V(this), this.colorMask = new W(this), this.depthMask = new q(this), this.stencilMask = new X(this), this.stencilFunc = new $(this), this.stencilOp = new H(this), this.stencilTest = new K(this), this.depthRange = new Y(this), this.depthTest = new J(this), this.depthFunc = new Q(this), this.blend = new ee(this), this.blendFunc = new te(this), this.blendColor = new ie(this), this.blendEquation = new oe(this), this.cullFace = new re(this), this.cullFaceSide = new ne(this), this.frontFace = new ae(this), this.program = new se(this), this.activeTexture = new le(this), this.viewport = new ce(this), this.bindFramebuffer = new he(this), this.bindRenderbuffer = new _e(this), this.bindTexture = new ue(this), this.bindVertexBuffer = new de(this), this.bindElementBuffer = new pe(this), this.bindVertexArrayOES = this.extVertexArrayObject && new me(this), this.pixelStoreUnpack = new fe(this), this.pixelStoreUnpackPremultiplyAlpha = new ge(this), this.pixelStoreUnpackFlipY = new ve(this), this.extTextureFilterAnisotropic = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.extTextureFilterAnisotropicForceOff = !1, this.extTextureHalfFloat = e.getExtension("OES_texture_half_float"), this.extTextureHalfFloat && (e.getExtension("OES_texture_half_float_linear"), this.extRenderToTextureHalfFloat = e.getExtension("EXT_color_buffer_half_float")), this.extTimerQuery = e.getExtension("EXT_disjoint_timer_query"), this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE);
      }

      setDefault() {
        this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
      }

      setDirty() {
        this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.extVertexArrayObject && (this.bindVertexArrayOES.dirty = !0), this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;
      }

      createIndexBuffer(e, t) {
        return new F(this, e, t);
      }

      createVertexBuffer(e, t, i) {
        return new N(this, e, t, i);
      }

      createRenderbuffer(e, t, i) {
        const o = this.gl,
              r = o.createRenderbuffer();
        return this.bindRenderbuffer.set(r), o.renderbufferStorage(o.RENDERBUFFER, e, t, i), this.bindRenderbuffer.set(null), r;
      }

      createFramebuffer(e, t, i) {
        return new Te(this, e, t, i);
      }

      clear({
        color: e,
        depth: t,
        stencil: i
      }) {
        const o = this.gl;
        let r = 0;
        e && (r |= o.COLOR_BUFFER_BIT, this.clearColor.set(e), this.colorMask.set([!0, !0, !0, !0])), void 0 !== t && (r |= o.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(t), this.depthMask.set(!0)), void 0 !== i && (r |= o.STENCIL_BUFFER_BIT, this.clearStencil.set(i), this.stencilMask.set(255)), o.clear(r);
      }

      setCullFace(e) {
        !1 === e.enable ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(e.mode), this.frontFace.set(e.frontFace));
      }

      setDepthMode(e) {
        e.func !== this.gl.ALWAYS || e.mask ? (this.depthTest.set(!0), this.depthFunc.set(e.func), this.depthMask.set(e.mask), this.depthRange.set(e.range)) : this.depthTest.set(!1);
      }

      setStencilMode(e) {
        e.test.func !== this.gl.ALWAYS || e.mask ? (this.stencilTest.set(!0), this.stencilMask.set(e.mask), this.stencilOp.set([e.fail, e.depthFail, e.pass]), this.stencilFunc.set({
          func: e.test.func,
          ref: e.ref,
          mask: e.test.mask
        })) : this.stencilTest.set(!1);
      }

      setColorMode(t) {
        r(t.blendFunction, e.ColorMode.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(t.blendFunction), this.blendColor.set(t.blendColor)), this.colorMask.set(t.mask);
      }

      unbindVAO() {
        this.extVertexArrayObject && this.bindVertexArrayOES.set(null);
      }

    }

    class Ce extends e.Evented {
      constructor(t, i, o, r) {
        super(), this.id = t, this.dispatcher = o, this.setEventedParent(r), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = e.extend({
          type: "raster"
        }, i), e.extend(this, e.pick(i, ["url", "scheme", "tileSize"]));
      }

      load() {
        this._loaded = !1, this.fire(new e.Event("dataloading", {
          dataType: "source"
        })), this._tileJSONRequest = O(this._options, this.map._requestManager, (t, i) => {
          this._tileJSONRequest = null, this._loaded = !0, t ? this.fire(new e.ErrorEvent(t)) : i && (e.extend(this, i), i.bounds && (this.tileBounds = new B(i.bounds, this.minzoom, this.maxzoom)), e.postTurnstileEvent(i.tiles), this.fire(new e.Event("data", {
            dataType: "source",
            sourceDataType: "metadata"
          })), this.fire(new e.Event("data", {
            dataType: "source",
            sourceDataType: "content"
          })));
        });
      }

      loaded() {
        return this._loaded;
      }

      onAdd(e) {
        this.map = e, this.load();
      }

      onRemove() {
        this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
      }

      serialize() {
        return e.extend({}, this._options);
      }

      hasTile(e) {
        return !this.tileBounds || this.tileBounds.contains(e.canonical);
      }

      loadTile(t, i) {
        const o = e.exported.devicePixelRatio >= 2,
              r = this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles, this.scheme), o, this.tileSize);

        t.request = e.getImage(this.map._requestManager.transformRequest(r, e.ResourceType.Tile), (o, r, n, a) => (delete t.request, t.aborted ? (t.state = "unloaded", i(null)) : o ? (t.state = "errored", i(o)) : r ? (this.map._refreshExpiredTiles && t.setExpiryData({
          cacheControl: n,
          expires: a
        }), t.setTexture(r, this.map.painter), t.state = "loaded", e.cacheEntryPossiblyAdded(this.dispatcher), void i(null)) : i(null)));
      }

      static loadTileData(e, t, i) {
        e.setTexture(t, i);
      }

      static unloadTileData(e, t) {
        e.texture && t.saveTileTexture(e.texture);
      }

      abortTile(e, t) {
        e.request && (e.request.cancel(), delete e.request), t();
      }

      unloadTile(e, t) {
        e.texture && this.map.painter.saveTileTexture(e.texture), t();
      }

      hasTransition() {
        return !1;
      }

    }

    let Ie;

    function Me(t, i, o, r, n, a, s, l) {
      const c = [t, o, n, i, r, a, 1, 1, 1],
            h = [s, l, 1],
            _ = e.adjoint([], c),
            [u, d, p] = e.transformMat3(h, h, e.transpose(_, _));

      return e.multiply(c, [u, 0, 0, 0, d, 0, 0, 0, p], c);
    }

    class Se extends e.Evented {
      constructor(e, t, i, o) {
        super(), this.id = e, this.dispatcher = i, this.coordinates = t.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(o), this.options = t;
      }

      load(t) {
        this._loaded = !1, this.fire(new e.Event("dataloading", {
          dataType: "source"
        })), this.url = this.options.url, e.getImage(this.map._requestManager.transformRequest(this.url, e.ResourceType.Image), (i, o) => {
          if (this._loaded = !0, i) this.fire(new e.ErrorEvent(i));else if (o) {
            const {
              HTMLImageElement: i
            } = e.window;
            this.image = o instanceof i ? e.exported.getImageData(o) : o, this.width = this.image.width, this.height = this.image.height, t && (this.coordinates = t), this._finishLoading();
          }
        });
      }

      loaded() {
        return this._loaded;
      }

      updateImage(e) {
        return this.image && e.url ? (this.options.url = e.url, this.load(e.coordinates), this) : this;
      }

      _finishLoading() {
        this.map && (this.setCoordinates(this.coordinates), this.fire(new e.Event("data", {
          dataType: "source",
          sourceDataType: "metadata"
        })));
      }

      onAdd(e) {
        this.map = e, this.load();
      }

      onRemove() {
        this.texture && this.texture.destroy();
      }

      setCoordinates(t) {
        this.coordinates = t, this._boundsArray = void 0;
        const i = t.map(e.MercatorCoordinate.fromLngLat);
        return this.tileID = function (t) {
          let i = 1 / 0,
              o = 1 / 0,
              r = -1 / 0,
              n = -1 / 0;

          for (const e of t) i = Math.min(i, e.x), o = Math.min(o, e.y), r = Math.max(r, e.x), n = Math.max(n, e.y);

          const a = Math.max(r - i, n - o),
                s = Math.max(0, Math.floor(-Math.log(a) / Math.LN2)),
                l = Math.pow(2, s);
          return new e.CanonicalTileID(s, Math.floor((i + r) / 2 * l), Math.floor((o + n) / 2 * l));
        }(i), this.minzoom = this.maxzoom = this.tileID.z, this.fire(new e.Event("data", {
          dataType: "source",
          sourceDataType: "content"
        })), this;
      }

      _clear() {
        this._boundsArray = void 0;
      }

      _prepareData(t) {
        for (const e in this.tiles) {
          const t = this.tiles[e];
          "loaded" !== t.state && (t.state = "loaded", t.texture = this.texture);
        }

        if (this._boundsArray) return;
        const i = e.tileTransform(this.tileID, this.map.transform.projection),
              [o, r, n, a] = this.coordinates.map(t => {
          const o = i.projection.project(t[0], t[1]);
          return e.getTilePoint(i, o)._round();
        });

        this.perspectiveTransform = function (t, i, o, r, n, a, s, l, c, h) {
          const _ = Me(0, 0, t, 0, 0, i, t, i),
                u = Me(o, r, n, a, s, l, c, h);

          return e.multiply(u, e.adjoint(_, _), u), [u[6] / u[8] * t / e.EXTENT, u[7] / u[8] * i / e.EXTENT];
        }(this.width, this.height, o.x, o.y, r.x, r.y, a.x, a.y, n.x, n.y);

        const s = this._boundsArray = new e.StructArrayLayout4i8();
        s.emplaceBack(o.x, o.y, 0, 0), s.emplaceBack(r.x, r.y, e.EXTENT, 0), s.emplaceBack(a.x, a.y, 0, e.EXTENT), s.emplaceBack(n.x, n.y, e.EXTENT, e.EXTENT), this.boundsBuffer && this.boundsBuffer.destroy(), this.boundsBuffer = t.createVertexBuffer(s, e.boundsAttributes.members), this.boundsSegments = e.SegmentVector.simpleSegment(0, 0, 4, 2);
      }

      prepare() {
        if (0 === Object.keys(this.tiles).length || !this.image) return;
        const t = this.map.painter.context,
              i = t.gl;
        this.texture ? this.texture.update(this.image) : (this.texture = new e.Texture(t, this.image, i.RGBA), this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE)), this._prepareData(t);
      }

      loadTile(e, t) {
        this.tileID && this.tileID.equals(e.tileID.canonical) ? (this.tiles[String(e.tileID.wrap)] = e, e.buckets = {}, t(null)) : (e.state = "errored", t(null));
      }

      serialize() {
        return {
          type: "image",
          url: this.options.url,
          coordinates: this.coordinates
        };
      }

      hasTransition() {
        return !1;
      }

    }

    const ze = {
      vector: class extends e.Evented {
        constructor(t, i, o, r) {
          if (super(), this.id = t, this.dispatcher = o, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, e.extend(this, e.pick(i, ["url", "scheme", "tileSize", "promoteId"])), this._options = e.extend({
            type: "vector"
          }, i), this._collectResourceTiming = i.collectResourceTiming, 512 !== this.tileSize) throw new Error("vector tile sources must have a tileSize of 512");
          this.setEventedParent(r), this._tileWorkers = {}, this._deduped = new e.DedupedRequest();
        }

        load() {
          this._loaded = !1, this.fire(new e.Event("dataloading", {
            dataType: "source"
          })), this._tileJSONRequest = O(this._options, this.map._requestManager, (t, i) => {
            this._tileJSONRequest = null, this._loaded = !0, t ? this.fire(new e.ErrorEvent(t)) : i && (e.extend(this, i), i.bounds && (this.tileBounds = new B(i.bounds, this.minzoom, this.maxzoom)), e.postTurnstileEvent(i.tiles, this.map._requestManager._customAccessToken), this.fire(new e.Event("data", {
              dataType: "source",
              sourceDataType: "metadata"
            })), this.fire(new e.Event("data", {
              dataType: "source",
              sourceDataType: "content"
            })));
          });
        }

        loaded() {
          return this._loaded;
        }

        hasTile(e) {
          return !this.tileBounds || this.tileBounds.contains(e.canonical);
        }

        onAdd(e) {
          this.map = e, this.load();
        }

        setSourceProperty(e) {
          this._tileJSONRequest && this._tileJSONRequest.cancel(), e();

          const t = this.map.style._getSourceCaches(this.id);

          for (const e of t) e.clearTiles();

          this.load();
        }

        setTiles(e) {
          return this.setSourceProperty(() => {
            this._options.tiles = e;
          }), this;
        }

        setUrl(e) {
          return this.setSourceProperty(() => {
            this.url = e, this._options.url = e;
          }), this;
        }

        onRemove() {
          this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
        }

        serialize() {
          return e.extend({}, this._options);
        }

        loadTile(t, i) {
          const o = this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles, this.scheme)),
                r = {
            request: this.map._requestManager.transformRequest(o, e.ResourceType.Tile),
            data: void 0,
            uid: t.uid,
            tileID: t.tileID,
            tileZoom: t.tileZoom,
            zoom: t.tileID.overscaledZ,
            tileSize: this.tileSize * t.tileID.overscaleFactor(),
            type: this.type,
            source: this.id,
            pixelRatio: e.exported.devicePixelRatio,
            showCollisionBoxes: this.map.showCollisionBoxes,
            promoteId: this.promoteId,
            isSymbolTile: t.isSymbolTile
          };

          if (r.request.collectResourceTiming = this._collectResourceTiming, t.actor && "expired" !== t.state) "loading" === t.state ? t.reloadCallback = i : t.request = t.actor.send("reloadTile", r, n.bind(this));else if (t.actor = this._tileWorkers[o] = this._tileWorkers[o] || this.dispatcher.getActor(), this.dispatcher.ready) t.request = t.actor.send("loadTile", r, n.bind(this), void 0, !0);else {
            const i = e.loadVectorTile.call({
              deduped: this._deduped
            }, r, (e, i) => {
              e || !i ? n.call(this, e) : (r.data = {
                cacheControl: i.cacheControl,
                expires: i.expires,
                rawData: i.rawData.slice(0)
              }, t.actor && t.actor.send("loadTile", r, n.bind(this), void 0, !0));
            }, !0);
            t.request = {
              cancel: i
            };
          }

          function n(o, r) {
            return delete t.request, t.aborted ? i(null) : o && 404 !== o.status ? i(o) : (r && r.resourceTiming && (t.resourceTiming = r.resourceTiming), this.map._refreshExpiredTiles && r && t.setExpiryData(r), t.loadVectorData(r, this.map.painter), e.cacheEntryPossiblyAdded(this.dispatcher), i(null), void (t.reloadCallback && (this.loadTile(t, t.reloadCallback), t.reloadCallback = null)));
          }
        }

        abortTile(e) {
          e.request && (e.request.cancel(), delete e.request), e.actor && e.actor.send("abortTile", {
            uid: e.uid,
            type: this.type,
            source: this.id
          });
        }

        unloadTile(e) {
          e.unloadVectorData(), e.actor && e.actor.send("removeTile", {
            uid: e.uid,
            type: this.type,
            source: this.id
          });
        }

        hasTransition() {
          return !1;
        }

        afterUpdate() {
          this._tileWorkers = {};
        }

      },
      raster: Ce,
      "raster-dem": class extends Ce {
        constructor(t, i, o, r) {
          super(t, i, o, r), this.type = "raster-dem", this.maxzoom = 22, this._options = e.extend({
            type: "raster-dem"
          }, i), this.encoding = i.encoding || "mapbox";
        }

        loadTile(t, i) {
          const o = this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles, this.scheme), !1, this.tileSize);

          function r(e, o) {
            e && (t.state = "errored", i(e)), o && (t.dem = o, t.dem.onDeserialize(), t.needsHillshadePrepare = !0, t.needsDEMTextureUpload = !0, t.state = "loaded", i(null));
          }

          t.request = e.getImage(this.map._requestManager.transformRequest(o, e.ResourceType.Tile), function (o, n, a, s) {
            if (delete t.request, t.aborted) t.state = "unloaded", i(null);else if (o) t.state = "errored", i(o);else if (n) {
              this.map._refreshExpiredTiles && t.setExpiryData({
                cacheControl: a,
                expires: s
              });
              const i = e.window.ImageBitmap && n instanceof e.window.ImageBitmap && (null == Ie && (Ie = e.window.OffscreenCanvas && new e.window.OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof e.window.createImageBitmap), Ie),
                    o = 1 - (n.width - e.prevPowerOfTwo(n.width)) / 2;
              o < 1 || t.neighboringTiles || (t.neighboringTiles = this._getNeighboringTiles(t.tileID));
              const l = i ? n : e.exported.getImageData(n, o),
                    c = {
                uid: t.uid,
                coord: t.tileID,
                source: this.id,
                rawImageData: l,
                encoding: this.encoding,
                padding: o
              };
              t.actor && "expired" !== t.state || (t.actor = this.dispatcher.getActor(), t.actor.send("loadDEMTile", c, r.bind(this), void 0, !0));
            }
          }.bind(this));
        }

        _getNeighboringTiles(t) {
          const i = t.canonical,
                o = Math.pow(2, i.z),
                r = (i.x - 1 + o) % o,
                n = 0 === i.x ? t.wrap - 1 : t.wrap,
                a = (i.x + 1 + o) % o,
                s = i.x + 1 === o ? t.wrap + 1 : t.wrap,
                l = {};
          return l[new e.OverscaledTileID(t.overscaledZ, n, i.z, r, i.y).key] = {
            backfilled: !1
          }, l[new e.OverscaledTileID(t.overscaledZ, s, i.z, a, i.y).key] = {
            backfilled: !1
          }, i.y > 0 && (l[new e.OverscaledTileID(t.overscaledZ, n, i.z, r, i.y - 1).key] = {
            backfilled: !1
          }, l[new e.OverscaledTileID(t.overscaledZ, t.wrap, i.z, i.x, i.y - 1).key] = {
            backfilled: !1
          }, l[new e.OverscaledTileID(t.overscaledZ, s, i.z, a, i.y - 1).key] = {
            backfilled: !1
          }), i.y + 1 < o && (l[new e.OverscaledTileID(t.overscaledZ, n, i.z, r, i.y + 1).key] = {
            backfilled: !1
          }, l[new e.OverscaledTileID(t.overscaledZ, t.wrap, i.z, i.x, i.y + 1).key] = {
            backfilled: !1
          }, l[new e.OverscaledTileID(t.overscaledZ, s, i.z, a, i.y + 1).key] = {
            backfilled: !1
          }), l;
        }

        unloadTile(e) {
          e.demTexture && this.map.painter.saveTileTexture(e.demTexture), e.fbo && (e.fbo.destroy(), delete e.fbo), e.dem && delete e.dem, delete e.neighboringTiles, e.state = "unloaded";
        }

      },
      geojson: class extends e.Evented {
        constructor(t, i, o, r) {
          super(), this.id = t, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._loaded = !1, this.actor = o.getActor(), this.setEventedParent(r), this._data = i.data, this._options = e.extend({}, i), this._collectResourceTiming = i.collectResourceTiming, void 0 !== i.maxzoom && (this.maxzoom = i.maxzoom), i.type && (this.type = i.type), i.attribution && (this.attribution = i.attribution), this.promoteId = i.promoteId;
          const n = e.EXTENT / this.tileSize;
          this.workerOptions = e.extend({
            source: this.id,
            cluster: i.cluster || !1,
            geojsonVtOptions: {
              buffer: (void 0 !== i.buffer ? i.buffer : 128) * n,
              tolerance: (void 0 !== i.tolerance ? i.tolerance : .375) * n,
              extent: e.EXTENT,
              maxZoom: this.maxzoom,
              lineMetrics: i.lineMetrics || !1,
              generateId: i.generateId || !1
            },
            superclusterOptions: {
              maxZoom: void 0 !== i.clusterMaxZoom ? i.clusterMaxZoom : this.maxzoom - 1,
              minPoints: Math.max(2, i.clusterMinPoints || 2),
              extent: e.EXTENT,
              radius: (void 0 !== i.clusterRadius ? i.clusterRadius : 50) * n,
              log: !1,
              generateId: i.generateId || !1
            },
            clusterProperties: i.clusterProperties,
            filter: i.filter
          }, i.workerOptions);
        }

        onAdd(e) {
          this.map = e, this.setData(this._data);
        }

        setData(e) {
          return this._data = e, this._updateWorkerData(), this;
        }

        getClusterExpansionZoom(e, t) {
          return this.actor.send("geojson.getClusterExpansionZoom", {
            clusterId: e,
            source: this.id
          }, t), this;
        }

        getClusterChildren(e, t) {
          return this.actor.send("geojson.getClusterChildren", {
            clusterId: e,
            source: this.id
          }, t), this;
        }

        getClusterLeaves(e, t, i, o) {
          return this.actor.send("geojson.getClusterLeaves", {
            source: this.id,
            clusterId: e,
            limit: t,
            offset: i
          }, o), this;
        }

        _updateWorkerData() {
          if (this._pendingLoad) return void (this._coalesce = !0);
          this.fire(new e.Event("dataloading", {
            dataType: "source"
          })), this._loaded = !1;
          const t = e.extend({}, this.workerOptions),
                i = this._data;
          "string" == typeof i ? (t.request = this.map._requestManager.transformRequest(e.exported.resolveURL(i), e.ResourceType.Source), t.request.collectResourceTiming = this._collectResourceTiming) : t.data = JSON.stringify(i), this._pendingLoad = this.actor.send(`${this.type}.loadData`, t, (t, i) => {
            if (this._loaded = !0, this._pendingLoad = null, t) this.fire(new e.ErrorEvent(t));else {
              const t = {
                dataType: "source",
                sourceDataType: this._metadataFired ? "content" : "metadata"
              };
              this._collectResourceTiming && i && i.resourceTiming && i.resourceTiming[this.id] && (t.resourceTiming = i.resourceTiming[this.id]), this.fire(new e.Event("data", t)), this._metadataFired = !0;
            }
            this._coalesce && (this._updateWorkerData(), this._coalesce = !1);
          });
        }

        loaded() {
          return this._loaded;
        }

        loadTile(t, i) {
          const o = t.actor ? "reloadTile" : "loadTile";
          t.actor = this.actor, t.request = this.actor.send(o, {
            type: this.type,
            uid: t.uid,
            tileID: t.tileID,
            tileZoom: t.tileZoom,
            zoom: t.tileID.overscaledZ,
            maxZoom: this.maxzoom,
            tileSize: this.tileSize,
            source: this.id,
            pixelRatio: e.exported.devicePixelRatio,
            showCollisionBoxes: this.map.showCollisionBoxes,
            promoteId: this.promoteId
          }, (e, r) => (delete t.request, t.unloadVectorData(), t.aborted ? i(null) : e ? i(e) : (t.loadVectorData(r, this.map.painter, "reloadTile" === o), i(null))), void 0, "loadTile" === o);
        }

        abortTile(e) {
          e.request && (e.request.cancel(), delete e.request), e.aborted = !0;
        }

        unloadTile(e) {
          e.unloadVectorData(), this.actor.send("removeTile", {
            uid: e.uid,
            type: this.type,
            source: this.id
          });
        }

        onRemove() {
          this._pendingLoad && this._pendingLoad.cancel();
        }

        serialize() {
          return e.extend({}, this._options, {
            type: this.type,
            data: this._data
          });
        }

        hasTransition() {
          return !1;
        }

      },
      video: class extends Se {
        constructor(e, t, i, o) {
          super(e, t, i, o), this.roundZoom = !0, this.type = "video", this.options = t;
        }

        load() {
          this._loaded = !1;
          const t = this.options;
          this.urls = [];

          for (const i of t.urls) this.urls.push(this.map._requestManager.transformRequest(i, e.ResourceType.Source).url);

          e.getVideo(this.urls, (t, i) => {
            this._loaded = !0, t ? this.fire(new e.ErrorEvent(t)) : i && (this.video = i, this.video.loop = !0, this.video.setAttribute("playsinline", ""), this.video.addEventListener("playing", () => {
              this.map.triggerRepaint();
            }), this.map && this.video.play(), this._finishLoading());
          });
        }

        pause() {
          this.video && this.video.pause();
        }

        play() {
          this.video && this.video.play();
        }

        seek(t) {
          if (this.video) {
            const i = this.video.seekable;
            t < i.start(0) || t > i.end(0) ? this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i.start(0)} and ${i.end(0)}-second mark.`))) : this.video.currentTime = t;
          }
        }

        getVideo() {
          return this.video;
        }

        onAdd(e) {
          this.map || (this.map = e, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
        }

        prepare() {
          if (0 === Object.keys(this.tiles).length || this.video.readyState < 2) return;
          const t = this.map.painter.context,
                i = t.gl;
          this.texture ? this.video.paused || (this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE), i.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, i.RGBA, i.UNSIGNED_BYTE, this.video)) : (this.texture = new e.Texture(t, this.video, i.RGBA), this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE), this.width = this.video.videoWidth, this.height = this.video.videoHeight), this._prepareData(t);
        }

        serialize() {
          return {
            type: "video",
            urls: this.urls,
            coordinates: this.coordinates
          };
        }

        hasTransition() {
          return this.video && !this.video.paused;
        }

      },
      image: Se,
      canvas: class extends Se {
        constructor(t, i, o, r) {
          super(t, i, o, r), i.coordinates ? Array.isArray(i.coordinates) && 4 === i.coordinates.length && !i.coordinates.some(e => !Array.isArray(e) || 2 !== e.length || e.some(e => "number" != typeof e)) || this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t}`, null, 'missing required property "coordinates"'))), i.animate && "boolean" != typeof i.animate && this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t}`, null, 'optional "animate" property must be a boolean value'))), i.canvas ? "string" == typeof i.canvas || i.canvas instanceof e.window.HTMLCanvasElement || this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t}`, null, 'missing required property "canvas"'))), this.options = i, this.animate = void 0 === i.animate || i.animate;
        }

        load() {
          this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof e.window.HTMLCanvasElement ? this.options.canvas : e.window.document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new e.ErrorEvent(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function () {
            this._playing = !0, this.map.triggerRepaint();
          }, this.pause = function () {
            this._playing && (this.prepare(), this._playing = !1);
          }, this._finishLoading());
        }

        getCanvas() {
          return this.canvas;
        }

        onAdd(e) {
          this.map = e, this.load(), this.canvas && this.animate && this.play();
        }

        onRemove() {
          this.pause();
        }

        prepare() {
          let t = !1;
          if (this.canvas.width !== this.width && (this.width = this.canvas.width, t = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, t = !0), this._hasInvalidDimensions()) return;
          if (0 === Object.keys(this.tiles).length) return;
          const i = this.map.painter.context;
          this.texture ? (t || this._playing) && this.texture.update(this.canvas, {
            premultiply: !0
          }) : this.texture = new e.Texture(i, this.canvas, i.gl.RGBA, {
            premultiply: !0
          }), this._prepareData(i);
        }

        serialize() {
          return {
            type: "canvas",
            coordinates: this.coordinates
          };
        }

        hasTransition() {
          return this._playing;
        }

        _hasInvalidDimensions() {
          for (const e of [this.canvas.width, this.canvas.height]) if (isNaN(e) || e <= 0) return !0;

          return !1;
        }

      },
      custom: class extends e.Evented {
        constructor(t, i, o, r) {
          super(), this.id = t, this.type = "custom", this._dataType = "raster", this._dispatcher = o, this._implementation = i, this.setEventedParent(r), this.scheme = "xyz", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this._loaded = !1, this.roundZoom = !0, this._implementation || this.fire(new e.ErrorEvent(new Error(`Missing implementation for ${this.id} custom source`))), this._implementation.loadTile || this.fire(new e.ErrorEvent(new Error(`Missing loadTile implementation for ${this.id} custom source`))), this._implementation.bounds && (this.tileBounds = new B(this._implementation.bounds, this.minzoom, this.maxzoom)), i.update = this._update.bind(this), i.coveringTiles = this._coveringTiles.bind(this), e.extend(this, e.pick(i, ["dataType", "scheme", "minzoom", "maxzoom", "tileSize", "attribution", "minTileCacheSize", "maxTileCacheSize"]));
        }

        serialize() {
          return e.pick(this, ["type", "scheme", "minzoom", "maxzoom", "tileSize", "attribution"]);
        }

        load() {
          this._loaded = !0, this.fire(new e.Event("data", {
            dataType: "source",
            sourceDataType: "metadata"
          })), this.fire(new e.Event("data", {
            dataType: "source",
            sourceDataType: "content"
          }));
        }

        loaded() {
          return this._loaded;
        }

        onAdd(t) {
          this._map = t, this._loaded = !1, this.fire(new e.Event("dataloading", {
            dataType: "source"
          })), this._implementation.onAdd && this._implementation.onAdd(t), this.load();
        }

        onRemove(e) {
          this._implementation.onRemove && this._implementation.onRemove(e);
        }

        hasTile(e) {
          if (this._implementation.hasTile) {
            const {
              x: t,
              y: i,
              z: o
            } = e.canonical;
            return this._implementation.hasTile({
              x: t,
              y: i,
              z: o
            });
          }

          return !this.tileBounds || this.tileBounds.contains(e.canonical);
        }

        loadTile(t, i) {
          const {
            x: o,
            y: r,
            z: n
          } = t.tileID.canonical,
                a = new e.window.AbortController(),
                s = this._implementation.loadTile({
            x: o,
            y: r,
            z: n
          }, {
            signal: a.signal
          });

          if (!s) return this.loadTileData(t, {
            width: this.tileSize,
            height: this.tileSize,
            data: null
          }), t.state = "loaded", i(null);
          s.cancel = () => a.abort(), t.request = s.then(function (o) {
            return delete t.request, t.aborted ? (t.state = "unloaded", i(null)) : o ? function (t) {
              return t instanceof e.window.ImageData || t instanceof e.window.ImageBitmap || t instanceof e.window.HTMLCanvasElement;
            }(o) ? (this.loadTileData(t, o), t.state = "loaded", void i(null)) : (t.state = "errored", i(new Error(`Can't infer data type for ${this.id}, only raster data supported at the moment`))) : (this.loadTileData(t, {
              width: this.tileSize,
              height: this.tileSize,
              data: null
            }), t.state = "loaded", i(null));
          }.bind(this)).catch(e => {
            20 !== e.code && (t.state = "errored", i(e));
          });
        }

        loadTileData(e, t) {
          Ce.loadTileData(e, t, this._map.painter);
        }

        unloadTileData(e) {
          Ce.unloadTileData(e, this._map.painter);
        }

        prepareTile(e) {
          if (!this._implementation.prepareTile) return null;

          const {
            x: t,
            y: i,
            z: o
          } = e.tileID.canonical,
                r = this._implementation.prepareTile({
            x: t,
            y: i,
            z: o
          });

          return r ? (this.loadTileData(e, r), e.state = "loaded", r) : null;
        }

        unloadTile(e, t) {
          if (this.unloadTileData(e), this._implementation.unloadTile) {
            const {
              x: t,
              y: i,
              z: o
            } = e.tileID.canonical;

            this._implementation.unloadTile({
              x: t,
              y: i,
              z: o
            });
          }

          t();
        }

        abortTile(e, t) {
          e.request && e.request.cancel && (e.request.cancel(), delete e.request), t();
        }

        hasTransition() {
          return !1;
        }

        _coveringTiles() {
          return this._map.transform.coveringTiles({
            tileSize: this.tileSize,
            minzoom: this.minzoom,
            maxzoom: this.maxzoom,
            roundZoom: this.roundZoom
          }).map(e => ({
            x: e.canonical.x,
            y: e.canonical.y,
            z: e.canonical.z
          }));
        }

        _update() {
          this.fire(new e.Event("data", {
            dataType: "source",
            sourceDataType: "content"
          }));
        }

      }
    },
          De = function (t, i, o, r) {
      const n = new ze[i.type](t, i, o, r);
      if (n.id !== t) throw new Error(`Expected Source id to be ${t} instead of ${n.id}`);
      return e.bindAll(["load", "abort", "unload", "serialize", "prepare"], n), n;
    };

    function Pe(t, i) {
      const o = e.identity([]);
      return e.scale(o, o, [.5 * t.width, .5 * -t.height, 1]), e.translate(o, o, [1, -1, 0]), e.multiply$1(o, o, t.calculateProjMatrix(i.toUnwrapped())), Float32Array.from(o);
    }

    function Ae(e, t, i, o, r, n, a, s = !1) {
      const l = e.tilesIn(o, a, s);
      l.sort(Re);
      const c = [];

      for (const o of l) c.push({
        wrappedTileID: o.tile.tileID.wrapped().key,
        queryResults: o.tile.queryRenderedFeatures(t, i, e._state, o, r, n, Pe(e.transform, o.tile.tileID), s)
      });

      const h = function (e) {
        const t = {},
              i = {};

        for (const o of e) {
          const e = o.queryResults,
                r = o.wrappedTileID,
                n = i[r] = i[r] || {};

          for (const i in e) {
            const o = e[i],
                  r = n[i] = n[i] || {},
                  a = t[i] = t[i] || [];

            for (const e of o) r[e.featureIndex] || (r[e.featureIndex] = !0, a.push(e));
          }
        }

        return t;
      }(c);

      for (const t in h) h[t].forEach(t => {
        const i = t.feature,
              o = i.layer;
        o && "background" !== o.type && "sky" !== o.type && (i.source = o.source, o["source-layer"] && (i.sourceLayer = o["source-layer"]), i.state = void 0 !== i.id ? e.getFeatureState(o["source-layer"], i.id) : {});
      });

      return h;
    }

    function Le(e, t) {
      const i = e.getRenderableIds().map(t => e.getTileByID(t)),
            o = [],
            r = {};

      for (let e = 0; e < i.length; e++) {
        const n = i[e],
              a = n.tileID.canonical.key;
        r[a] || (r[a] = !0, n.querySourceFeatures(o, t));
      }

      return o;
    }

    function Re(e, t) {
      const i = e.tileID,
            o = t.tileID;
      return i.overscaledZ - o.overscaledZ || i.canonical.y - o.canonical.y || i.wrap - o.wrap || i.canonical.x - o.canonical.x;
    }

    function ke() {
      return null != ln.workerClass ? new ln.workerClass() : new e.window.Worker(ln.workerUrl);
    }

    const Oe = "mapboxgl_preloaded_worker_pool";

    class Be {
      constructor() {
        this.active = {};
      }

      acquire(e) {
        if (!this.workers) for (this.workers = []; this.workers.length < Be.workerCount;) this.workers.push(new ke());
        return this.active[e] = !0, this.workers.slice();
      }

      release(e) {
        delete this.active[e], 0 === this.numActive() && (this.workers.forEach(e => {
          e.terminate();
        }), this.workers = null);
      }

      isPreloaded() {
        return !!this.active[Oe];
      }

      numActive() {
        return Object.keys(this.active).length;
      }

    }

    let Fe;

    function Ue() {
      return Fe || (Fe = new Be()), Fe;
    }

    function Ne(t, i) {
      const o = {};

      for (const e in t) "ref" !== e && (o[e] = t[e]);

      return e.refProperties.forEach(e => {
        e in i && (o[e] = i[e]);
      }), o;
    }

    function Ge(e) {
      e = e.slice();
      const t = Object.create(null);

      for (let i = 0; i < e.length; i++) t[e[i].id] = e[i];

      for (let i = 0; i < e.length; i++) "ref" in e[i] && (e[i] = Ne(e[i], t[e[i].ref]));

      return e;
    }

    Be.workerCount = 2;
    const je = {
      setStyle: "setStyle",
      addLayer: "addLayer",
      removeLayer: "removeLayer",
      setPaintProperty: "setPaintProperty",
      setLayoutProperty: "setLayoutProperty",
      setFilter: "setFilter",
      addSource: "addSource",
      removeSource: "removeSource",
      setGeoJSONSourceData: "setGeoJSONSourceData",
      setLayerZoomRange: "setLayerZoomRange",
      setLayerProperty: "setLayerProperty",
      setCenter: "setCenter",
      setZoom: "setZoom",
      setBearing: "setBearing",
      setPitch: "setPitch",
      setSprite: "setSprite",
      setGlyphs: "setGlyphs",
      setTransition: "setTransition",
      setLight: "setLight",
      setTerrain: "setTerrain",
      setFog: "setFog",
      setProjection: "setProjection"
    };

    function Ze(e, t, i) {
      i.push({
        command: je.addSource,
        args: [e, t[e]]
      });
    }

    function Ve(e, t, i) {
      t.push({
        command: je.removeSource,
        args: [e]
      }), i[e] = !0;
    }

    function We(e, t, i, o) {
      Ve(e, i, o), Ze(e, t, i);
    }

    function qe(e, t, i) {
      let o;

      for (o in e[i]) if (e[i].hasOwnProperty(o) && "data" !== o && !r(e[i][o], t[i][o])) return !1;

      for (o in t[i]) if (t[i].hasOwnProperty(o) && "data" !== o && !r(e[i][o], t[i][o])) return !1;

      return !0;
    }

    function Xe(e, t, i, o, n, a) {
      let s;

      for (s in t = t || {}, e = e || {}) e.hasOwnProperty(s) && (r(e[s], t[s]) || i.push({
        command: a,
        args: [o, s, t[s], n]
      }));

      for (s in t) t.hasOwnProperty(s) && !e.hasOwnProperty(s) && (r(e[s], t[s]) || i.push({
        command: a,
        args: [o, s, t[s], n]
      }));
    }

    function $e(e) {
      return e.id;
    }

    function He(e, t) {
      return e[t.id] = t, e;
    }

    class Ke {
      constructor(e, t) {
        this.reset(e, t);
      }

      reset(e, t) {
        this.points = e || [], this._distances = [0];

        for (let e = 1; e < this.points.length; e++) this._distances[e] = this._distances[e - 1] + this.points[e].dist(this.points[e - 1]);

        this.length = this._distances[this._distances.length - 1], this.padding = Math.min(t || 0, .5 * this.length), this.paddedLength = this.length - 2 * this.padding;
      }

      lerp(t) {
        if (1 === this.points.length) return this.points[0];
        t = e.clamp(t, 0, 1);
        let i = 1,
            o = this._distances[i];
        const r = t * this.paddedLength + this.padding;

        for (; o < r && i < this._distances.length;) o = this._distances[++i];

        const n = i - 1,
              a = this._distances[n],
              s = o - a,
              l = s > 0 ? (r - a) / s : 0;
        return this.points[n].mult(1 - l).add(this.points[i].mult(l));
      }

    }

    class Ye {
      constructor(e, t, i) {
        const o = this.boxCells = [],
              r = this.circleCells = [];
        this.xCellCount = Math.ceil(e / i), this.yCellCount = Math.ceil(t / i);

        for (let e = 0; e < this.xCellCount * this.yCellCount; e++) o.push([]), r.push([]);

        this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e, this.height = t, this.xScale = this.xCellCount / e, this.yScale = this.yCellCount / t, this.boxUid = 0, this.circleUid = 0;
      }

      keysLength() {
        return this.boxKeys.length + this.circleKeys.length;
      }

      insert(e, t, i, o, r) {
        this._forEachCell(t, i, o, r, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e), this.bboxes.push(t), this.bboxes.push(i), this.bboxes.push(o), this.bboxes.push(r);
      }

      insertCircle(e, t, i, o) {
        this._forEachCell(t - o, i - o, t + o, i + o, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e), this.circles.push(t), this.circles.push(i), this.circles.push(o);
      }

      _insertBoxCell(e, t, i, o, r, n) {
        this.boxCells[r].push(n);
      }

      _insertCircleCell(e, t, i, o, r, n) {
        this.circleCells[r].push(n);
      }

      _query(e, t, i, o, r, n) {
        if (i < 0 || e > this.width || o < 0 || t > this.height) return !r && [];
        const a = [];

        if (e <= 0 && t <= 0 && this.width <= i && this.height <= o) {
          if (r) return !0;

          for (let e = 0; e < this.boxKeys.length; e++) a.push({
            key: this.boxKeys[e],
            x1: this.bboxes[4 * e],
            y1: this.bboxes[4 * e + 1],
            x2: this.bboxes[4 * e + 2],
            y2: this.bboxes[4 * e + 3]
          });

          for (let e = 0; e < this.circleKeys.length; e++) {
            const t = this.circles[3 * e],
                  i = this.circles[3 * e + 1],
                  o = this.circles[3 * e + 2];
            a.push({
              key: this.circleKeys[e],
              x1: t - o,
              y1: i - o,
              x2: t + o,
              y2: i + o
            });
          }

          return n ? a.filter(n) : a;
        }

        return this._forEachCell(e, t, i, o, this._queryCell, a, {
          hitTest: r,
          seenUids: {
            box: {},
            circle: {}
          }
        }, n), r ? a.length > 0 : a;
      }

      _queryCircle(e, t, i, o, r) {
        const n = e - i,
              a = e + i,
              s = t - i,
              l = t + i;
        if (a < 0 || n > this.width || l < 0 || s > this.height) return !o && [];
        const c = [];
        return this._forEachCell(n, s, a, l, this._queryCellCircle, c, {
          hitTest: o,
          circle: {
            x: e,
            y: t,
            radius: i
          },
          seenUids: {
            box: {},
            circle: {}
          }
        }, r), o ? c.length > 0 : c;
      }

      query(e, t, i, o, r) {
        return this._query(e, t, i, o, !1, r);
      }

      hitTest(e, t, i, o, r) {
        return this._query(e, t, i, o, !0, r);
      }

      hitTestCircle(e, t, i, o) {
        return this._queryCircle(e, t, i, !0, o);
      }

      _queryCell(e, t, i, o, r, n, a, s) {
        const l = a.seenUids,
              c = this.boxCells[r];

        if (null !== c) {
          const r = this.bboxes;

          for (const h of c) if (!l.box[h]) {
            l.box[h] = !0;
            const c = 4 * h;

            if (e <= r[c + 2] && t <= r[c + 3] && i >= r[c + 0] && o >= r[c + 1] && (!s || s(this.boxKeys[h]))) {
              if (a.hitTest) return n.push(!0), !0;
              n.push({
                key: this.boxKeys[h],
                x1: r[c],
                y1: r[c + 1],
                x2: r[c + 2],
                y2: r[c + 3]
              });
            }
          }
        }

        const h = this.circleCells[r];

        if (null !== h) {
          const r = this.circles;

          for (const c of h) if (!l.circle[c]) {
            l.circle[c] = !0;
            const h = 3 * c;

            if (this._circleAndRectCollide(r[h], r[h + 1], r[h + 2], e, t, i, o) && (!s || s(this.circleKeys[c]))) {
              if (a.hitTest) return n.push(!0), !0;
              {
                const e = r[h],
                      t = r[h + 1],
                      i = r[h + 2];
                n.push({
                  key: this.circleKeys[c],
                  x1: e - i,
                  y1: t - i,
                  x2: e + i,
                  y2: t + i
                });
              }
            }
          }
        }
      }

      _queryCellCircle(e, t, i, o, r, n, a, s) {
        const l = a.circle,
              c = a.seenUids,
              h = this.boxCells[r];

        if (null !== h) {
          const e = this.bboxes;

          for (const t of h) if (!c.box[t]) {
            c.box[t] = !0;
            const i = 4 * t;
            if (this._circleAndRectCollide(l.x, l.y, l.radius, e[i + 0], e[i + 1], e[i + 2], e[i + 3]) && (!s || s(this.boxKeys[t]))) return n.push(!0), !0;
          }
        }

        const _ = this.circleCells[r];

        if (null !== _) {
          const e = this.circles;

          for (const t of _) if (!c.circle[t]) {
            c.circle[t] = !0;
            const i = 3 * t;
            if (this._circlesCollide(e[i], e[i + 1], e[i + 2], l.x, l.y, l.radius) && (!s || s(this.circleKeys[t]))) return n.push(!0), !0;
          }
        }
      }

      _forEachCell(e, t, i, o, r, n, a, s) {
        const l = this._convertToXCellCoord(e),
              c = this._convertToYCellCoord(t),
              h = this._convertToXCellCoord(i),
              _ = this._convertToYCellCoord(o);

        for (let u = l; u <= h; u++) for (let l = c; l <= _; l++) if (r.call(this, e, t, i, o, this.xCellCount * l + u, n, a, s)) return;
      }

      _convertToXCellCoord(e) {
        return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e * this.xScale)));
      }

      _convertToYCellCoord(e) {
        return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e * this.yScale)));
      }

      _circlesCollide(e, t, i, o, r, n) {
        const a = o - e,
              s = r - t,
              l = i + n;
        return l * l > a * a + s * s;
      }

      _circleAndRectCollide(e, t, i, o, r, n, a) {
        const s = (n - o) / 2,
              l = Math.abs(e - (o + s));
        if (l > s + i) return !1;
        const c = (a - r) / 2,
              h = Math.abs(t - (r + c));
        if (h > c + i) return !1;
        if (l <= s || h <= c) return !0;

        const _ = l - s,
              u = h - c;

        return _ * _ + u * u <= i * i;
      }

    }

    const Je = Math.tan(85 * Math.PI / 180);

    function Qe(t, i, o, r, n, a) {
      const s = e.create();

      if (o) {
        if ("globe" === n.projection.name) e.multiply$1(s, s, e.calculateGlobeLabelMatrix(n, i));else {
          const e = v([], a);
          s[0] = e[0], s[1] = e[1], s[4] = e[2], s[5] = e[3];
        }
        r || e.rotateZ(s, s, n.angle);
      } else e.multiply$1(s, n.labelPlaneMatrix, t);

      return s;
    }

    function et(t, i, o, r, n, a) {
      if (o) {
        if ("globe" === n.projection.name) {
          const s = Qe(t, i, o, r, n, a);
          return e.invert(s, s), e.multiply$1(s, t, s), s;
        }

        {
          const i = e.clone(t),
                o = e.identity([]);
          return o[0] = a[0], o[1] = a[1], o[4] = a[2], o[5] = a[3], e.multiply$1(i, i, o), r || e.rotateZ(i, i, -n.angle), i;
        }
      }

      return n.glCoordMatrix;
    }

    function tt(t, i, o = 0) {
      const r = [t.x, t.y, o, 1];
      o ? e.transformMat4$1(r, r, i) : pt(r, r, i);
      const n = r[3];
      return {
        point: new e.pointGeometry(r[0] / n, r[1] / n),
        signedDistanceFromCamera: n
      };
    }

    function it(t, i) {
      const o = [t[0], t[1], t[2], 1];
      e.transformMat4$1(o, o, i);
      const r = o[3];
      return {
        point: new e.pointGeometry(o[0] / r, o[1] / r),
        signedDistanceFromCamera: r
      };
    }

    function ot(e, t) {
      return Math.min(.5 + e / t * .5, 1.5);
    }

    function rt(e, t) {
      const i = e[0] / e[3],
            o = e[1] / e[3];
      return i >= -t[0] && i <= t[0] && o >= -t[1] && o <= t[1];
    }

    function nt(t, i, o, r, n, a, s, l, c, h) {
      const _ = o.transform,
            u = r ? t.textSizeData : t.iconSizeData,
            d = e.evaluateSizeForZoom(u, o.transform.zoom),
            p = [256 / o.width * 2 + 1, 256 / o.height * 2 + 1],
            m = r ? t.text.dynamicLayoutVertexArray : t.icon.dynamicLayoutVertexArray;
      m.clear();
      const f = t.lineVertexArray,
            g = r ? t.text.placedSymbolArray : t.icon.placedSymbolArray,
            v = o.transform.width / o.transform.height;
      let x = !1;

      for (let r = 0; r < g.length; r++) {
        const y = g.get(r);

        if (y.writingMode !== e.WritingMode.vertical || x || 0 !== r && g.get(r - 1).writingMode === e.WritingMode.horizontal || (x = !0), (y.hidden || y.writingMode === e.WritingMode.vertical) && !x) {
          dt(y.numGlyphs, m);
          continue;
        }

        x = !1;

        const b = new e.pointGeometry(y.tileAnchorX, y.tileAnchorY),
              w = c ? c(b) : [0, 0, 0],
              T = _.projection.projectTilePoint(b.x, b.y, h.canonical),
              E = [T.x + w[0], T.y + w[1], T.z + w[2]],
              C = [...E, 1];

        if (e.transformMat4$1(C, C, i), !rt(C, p)) {
          dt(y.numGlyphs, m);
          continue;
        }

        const I = ot(o.transform.cameraToCenterDistance, C[3]),
              M = e.evaluateSizeForFeature(u, d, y),
              S = s ? M / I : M * I,
              z = tt(new e.pointGeometry(E[0], E[1]), n, E[2]);

        if (z.signedDistanceFromCamera <= 0) {
          dt(y.numGlyphs, m);
          continue;
        }

        let D = {};
        const P = s ? null : c,
              A = lt(y, S, !1, l, i, n, a, t.glyphOffsetArray, f, m, z.point, b, D, v, P, _.projection, h);
        x = A.useVertical, P && A.needsFlipping && (D = {}), (A.notEnoughRoom || x || A.needsFlipping && lt(y, S, !0, l, i, n, a, t.glyphOffsetArray, f, m, z.point, b, D, v, P, _.projection, h).notEnoughRoom) && dt(y.numGlyphs, m);
      }

      r ? t.text.dynamicLayoutVertexBuffer.updateData(m) : t.icon.dynamicLayoutVertexBuffer.updateData(m);
    }

    function at(e, t, i, o, r, n, a, s, l, c, h, _, u, d, p) {
      const m = s.glyphStartIndex + s.numGlyphs,
            f = s.lineStartIndex,
            g = s.lineStartIndex + s.lineLength,
            v = t.getoffsetX(s.glyphStartIndex),
            x = t.getoffsetX(m - 1),
            y = _t(e * v, i, o, r, n, a, s.segment, f, g, l, c, h, _, u, !0, d, p);

      if (!y) return null;

      const b = _t(e * x, i, o, r, n, a, s.segment, f, g, l, c, h, _, u, !0, d, p);

      return b ? {
        first: y,
        last: b
      } : null;
    }

    function st(t, i, o, r) {
      return t.writingMode === e.WritingMode.horizontal && Math.abs(o.y - i.y) > Math.abs(o.x - i.x) * r ? {
        useVertical: !0
      } : t.writingMode === e.WritingMode.vertical ? i.y < o.y ? {
        needsFlipping: !0
      } : null : 0 !== t.flipState && function (e, t, i) {
        const o = (t.x - e.x) * i;
        return 0 === o || Math.abs((t.y - e.y) / o) > Je;
      }(i, o, r) ? 1 === t.flipState ? {
        needsFlipping: !0
      } : null : i.x > o.x ? {
        needsFlipping: !0
      } : null;
    }

    function lt(t, i, o, r, n, a, s, l, c, h, _, u, d, p, m, f, g) {
      const v = i / 24,
            x = t.lineOffsetX * v,
            y = t.lineOffsetY * v;
      let b;

      if (t.numGlyphs > 1) {
        const e = t.glyphStartIndex + t.numGlyphs,
              i = t.lineStartIndex,
              n = t.lineStartIndex + t.lineLength,
              h = at(v, l, x, y, o, _, u, t, c, a, d, m, !1, f, g);
        if (!h) return {
          notEnoughRoom: !0
        };
        const w = tt(h.first.point, s).point,
              T = tt(h.last.point, s).point;

        if (r && !o) {
          const e = st(t, w, T, p);
          if (t.flipState = e && e.needsFlipping ? 1 : 2, e) return e;
        }

        b = [h.first];

        for (let r = t.glyphStartIndex + 1; r < e - 1; r++) b.push(_t(v * l.getoffsetX(r), x, y, o, _, u, t.segment, i, n, c, a, d, m, !1, !1, f, g));

        b.push(h.last);
      } else {
        if (r && !o) {
          const i = tt(u, n).point,
                o = t.lineStartIndex + t.segment + 1,
                r = new e.pointGeometry(c.getx(o), c.gety(o)),
                a = tt(r, n),
                s = st(t, i, a.signedDistanceFromCamera > 0 ? a.point : ht(u, r, i, 1, n, void 0, f, g.canonical), p);
          if (t.flipState = s && s.needsFlipping ? 1 : 2, s) return s;
        }

        const i = _t(v * l.getoffsetX(t.glyphStartIndex), x, y, o, _, u, t.segment, t.lineStartIndex, t.lineStartIndex + t.lineLength, c, a, d, m, !1, !1, f, g);

        if (!i) return {
          notEnoughRoom: !0
        };
        b = [i];
      }

      for (const t of b) e.addDynamicAttributes(h, t.point, t.angle);

      return {};
    }

    function ct(t, i, o, r, n) {
      const a = r.projectTilePoint(t.x, t.y, i);
      if (!n) return tt(a, o, a.z);
      const s = n(t);
      return tt(new e.pointGeometry(a.x + s[0], a.y + s[1]), o, a.z + s[2]);
    }

    function ht(e, t, i, o, r, n, a, s) {
      const l = ct(e.add(e.sub(t)._unit()), s, r, a, n).point,
            c = i.sub(l);
      return i.add(c._mult(o / c.mag()));
    }

    function _t(t, i, o, r, n, a, s, l, c, h, _, u, d, p, m, f, g) {
      const v = r ? t - i : t + i;
      let x = v > 0 ? 1 : -1,
          y = 0;
      r && (x *= -1, y = Math.PI), x < 0 && (y += Math.PI);
      let b = x > 0 ? l + s : l + s + 1,
          w = n,
          T = n,
          E = 0,
          C = 0;
      const I = Math.abs(v),
            M = [],
            S = [];
      let z = a;

      const D = () => {
        const t = b - x;
        return 0 === E ? a : new e.pointGeometry(h.getx(t), h.gety(t));
      },
            P = () => ht(D(), z, T, I - E + 1, _, d, f, g.canonical);

      for (; E + C <= I;) {
        if (b += x, b < l || b >= c) return null;

        if (T = w, M.push(w), p && S.push(z || D()), w = u[b], void 0 === w) {
          z = new e.pointGeometry(h.getx(b), h.gety(b));
          const t = ct(z, g.canonical, _, f, d);
          w = t.signedDistanceFromCamera > 0 ? u[b] = t.point : P();
        } else z = null;

        E += C, C = T.dist(w);
      }

      m && d && (z = z || new e.pointGeometry(h.getx(b), h.gety(b)), u[b] = w = void 0 === u[b] ? w : P(), C = T.dist(w));

      const A = (I - E) / C,
            L = w.sub(T),
            R = L.mult(A)._add(T);

      o && R._add(L._unit()._perp()._mult(o * x));
      const k = y + Math.atan2(w.y - T.y, w.x - T.x);
      return M.push(R), p && (z = z || new e.pointGeometry(h.getx(b), h.gety(b)), S.push(function (t, i, o) {
        const r = 1 - o;
        return new e.pointGeometry(t.x * r + i.x * o, t.y * r + i.y * o);
      }(S.length > 0 ? S[S.length - 1] : z, z, A))), {
        point: R,
        angle: k,
        path: M,
        tilePath: S
      };
    }

    const ut = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);

    function dt(e, t) {
      for (let i = 0; i < e; i++) {
        const e = t.length;
        t.resize(e + 4), t.float32.set(ut, 3 * e);
      }
    }

    function pt(e, t, i) {
      const o = t[0],
            r = t[1];
      return e[0] = i[0] * o + i[4] * r + i[12], e[1] = i[1] * o + i[5] * r + i[13], e[3] = i[3] * o + i[7] * r + i[15], e;
    }

    const mt = 100;

    class ft {
      constructor(e, t, i = new Ye(e.width + 200, e.height + 200, 25), o = new Ye(e.width + 200, e.height + 200, 25)) {
        this.transform = e, this.grid = i, this.ignoredGrid = o, this.pitchfactor = Math.cos(e._pitch) * e.cameraToCenterDistance, this.screenRightBoundary = e.width + mt, this.screenBottomBoundary = e.height + mt, this.gridRightBoundary = e.width + 200, this.gridBottomBoundary = e.height + 200, this.fogState = t;
      }

      placeCollisionBox(e, t, i, o, r, n, a) {
        let s = t.projectedAnchorX,
            l = t.projectedAnchorY,
            c = t.projectedAnchorZ;
        const h = t.elevation,
              _ = t.tileID;

        if (h && _) {
          const e = this.transform.projection.upVector(_.canonical, t.tileAnchorX, t.tileAnchorY),
                i = this.transform.projection.upVectorScale(_.canonical, this.transform.center.lat, this.transform.worldSize).metersToTile;
          s += e[0] * h * i, l += e[1] * h * i, c += e[2] * h * i;
        }

        const u = this.projectAndGetPerspectiveRatio(n, [s, l, c], t.tileID, "globe" === this.transform.projection.name || !!h || this.transform.pitch > 0),
              d = r * u.perspectiveRatio,
              p = (t.x1 * e + i.x - t.padding) * d + u.point.x,
              m = (t.y1 * e + i.y - t.padding) * d + u.point.y,
              f = (t.x2 * e + i.x + t.padding) * d + u.point.x,
              g = (t.y2 * e + i.y + t.padding) * d + u.point.y,
              v = u.perspectiveRatio <= .55 || u.occluded;
        return !this.isInsideGrid(p, m, f, g) || !o && this.grid.hitTest(p, m, f, g, a) || v ? {
          box: [],
          offscreen: !1,
          occluded: u.occluded
        } : {
          box: [p, m, f, g],
          offscreen: this.isOffscreen(p, m, f, g),
          occluded: !1
        };
      }

      placeCollisionCircles(t, i, o, r, n, a, s, l, c, h, _, u, d, p) {
        const m = [],
              f = this.transform.elevation,
              g = f ? f.getAtTileOffsetFunc(p, this.transform.center.lat, this.transform.worldSize, this.transform.projection) : e => [0, 0, 0],
              v = new e.pointGeometry(i.tileAnchorX, i.tileAnchorY),
              x = this.transform.projection.projectTilePoint(i.tileAnchorX, i.tileAnchorY, p.canonical),
              y = g(v),
              b = [x.x + y[0], x.y + y[1], x.z + y[2]],
              w = this.projectAndGetPerspectiveRatio(a, [b[0], b[1], b[2]], p, "globe" === this.transform.projection.name || !!f || this.transform.pitch > 0),
              {
          perspectiveRatio: T
        } = w,
              E = (h ? n / T : n * T) / e.ONE_EM,
              C = tt(new e.pointGeometry(b[0], b[1]), s, b[2]).point,
              I = w.signedDistanceFromCamera > 0 ? at(E, r, i.lineOffsetX * E, i.lineOffsetY * E, !1, C, v, i, o, s, {}, f && !h ? g : null, h && !!f, this.transform.projection, p) : null;
        let M = !1,
            S = !1,
            z = !0;

        if (I && !w.occluded) {
          const i = .5 * u * T + d,
                o = new e.pointGeometry(-100, -100),
                r = new e.pointGeometry(this.screenRightBoundary, this.screenBottomBoundary),
                n = new Ke(),
                a = I.first,
                s = I.last;
          let h = [];

          for (let e = a.path.length - 1; e >= 1; e--) h.push(a.path[e]);

          for (let e = 1; e < s.path.length; e++) h.push(s.path[e]);

          const p = 2.5 * i;

          if (l) {
            const e = h.map(f ? (e, t) => {
              const i = g(t < a.path.length - 1 ? a.tilePath[a.path.length - 1 - t] : s.tilePath[t - a.path.length + 2]);
              return tt(e, l, i[2]);
            } : e => tt(e, l));
            h = e.some(e => e.signedDistanceFromCamera <= 0) ? [] : e.map(e => e.point);
          }

          let v = [];

          if (h.length > 0) {
            const t = h[0].clone(),
                  i = h[0].clone();

            for (let e = 1; e < h.length; e++) t.x = Math.min(t.x, h[e].x), t.y = Math.min(t.y, h[e].y), i.x = Math.max(i.x, h[e].x), i.y = Math.max(i.y, h[e].y);

            v = t.x >= o.x && i.x <= r.x && t.y >= o.y && i.y <= r.y ? [h] : i.x < o.x || t.x > r.x || i.y < o.y || t.y > r.y ? [] : e.clipLine([h], o.x, o.y, r.x, r.y);
          }

          for (const e of v) {
            n.reset(e, .25 * i);
            let o = 0;
            o = n.length <= .5 * i ? 1 : Math.ceil(n.paddedLength / p) + 1;

            for (let e = 0; e < o; e++) {
              const r = e / Math.max(o - 1, 1),
                    a = n.lerp(r),
                    s = a.x + mt,
                    l = a.y + mt;
              m.push(s, l, i, 0);
              const h = s - i,
                    u = l - i,
                    d = s + i,
                    p = l + i;
              if (z = z && this.isOffscreen(h, u, d, p), S = S || this.isInsideGrid(h, u, d, p), !t && this.grid.hitTestCircle(s, l, i, _) && (M = !0, !c)) return {
                circles: [],
                offscreen: !1,
                collisionDetected: M,
                occluded: !1
              };
            }
          }
        }

        return {
          circles: !c && M || !S ? [] : m,
          offscreen: z,
          collisionDetected: M,
          occluded: w.occluded
        };
      }

      queryRenderedSymbols(t) {
        if (0 === t.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength()) return {};
        const i = [];
        let o = 1 / 0,
            r = 1 / 0,
            n = -1 / 0,
            a = -1 / 0;

        for (const s of t) {
          const t = new e.pointGeometry(s.x + mt, s.y + mt);
          o = Math.min(o, t.x), r = Math.min(r, t.y), n = Math.max(n, t.x), a = Math.max(a, t.y), i.push(t);
        }

        const s = this.grid.query(o, r, n, a).concat(this.ignoredGrid.query(o, r, n, a)),
              l = {},
              c = {};

        for (const t of s) {
          const o = t.key;
          if (void 0 === l[o.bucketInstanceId] && (l[o.bucketInstanceId] = {}), l[o.bucketInstanceId][o.featureIndex]) continue;
          const r = [new e.pointGeometry(t.x1, t.y1), new e.pointGeometry(t.x2, t.y1), new e.pointGeometry(t.x2, t.y2), new e.pointGeometry(t.x1, t.y2)];
          e.polygonIntersectsPolygon(i, r) && (l[o.bucketInstanceId][o.featureIndex] = !0, void 0 === c[o.bucketInstanceId] && (c[o.bucketInstanceId] = []), c[o.bucketInstanceId].push(o.featureIndex));
        }

        return c;
      }

      insertCollisionBox(e, t, i, o, r) {
        (t ? this.ignoredGrid : this.grid).insert({
          bucketInstanceId: i,
          featureIndex: o,
          collisionGroupID: r
        }, e[0], e[1], e[2], e[3]);
      }

      insertCollisionCircles(e, t, i, o, r) {
        const n = t ? this.ignoredGrid : this.grid,
              a = {
          bucketInstanceId: i,
          featureIndex: o,
          collisionGroupID: r
        };

        for (let t = 0; t < e.length; t += 4) n.insertCircle(a, e[t], e[t + 1], e[t + 2]);
      }

      projectAndGetPerspectiveRatio(t, i, o, r) {
        const n = [i[0], i[1], i[2], 1];
        let a = !1;
        return i[2] || this.transform.pitch > 0 ? (e.transformMat4$1(n, n, t), this.fogState && o && (a = function (t, i, o, r, n, a) {
          const s = a.calculateFogTileMatrix(n),
                l = [i, o, r];
          return e.transformMat4(l, l, s), M(t, l, a.pitch, a._fov);
        }(this.fogState, i[0], i[1], i[2], o.toUnwrapped(), this.transform) > .9)) : pt(n, n, t), {
          point: new e.pointGeometry((n[0] / n[3] + 1) / 2 * this.transform.width + mt, (-n[1] / n[3] + 1) / 2 * this.transform.height + mt),
          perspectiveRatio: Math.min(.5 + this.transform.cameraToCenterDistance / n[3] * .5, 1.5),
          signedDistanceFromCamera: n[3],
          occluded: r && n[2] > n[3] || a
        };
      }

      isOffscreen(e, t, i, o) {
        return i < mt || e >= this.screenRightBoundary || o < mt || t > this.screenBottomBoundary;
      }

      isInsideGrid(e, t, i, o) {
        return i >= 0 && e < this.gridRightBoundary && o >= 0 && t < this.gridBottomBoundary;
      }

      getViewportMatrix() {
        const t = e.identity([]);
        return e.translate(t, t, [-100, -100, 0]), t;
      }

    }

    class gt {
      constructor(e, t, i, o) {
        this.opacity = e ? Math.max(0, Math.min(1, e.opacity + (e.placed ? t : -t))) : o && i ? 1 : 0, this.placed = i;
      }

      isHidden() {
        return 0 === this.opacity && !this.placed;
      }

    }

    class vt {
      constructor(e, t, i, o, r, n = !1) {
        this.text = new gt(e ? e.text : null, t, i, r), this.icon = new gt(e ? e.icon : null, t, o, r), this.clipped = n;
      }

      isHidden() {
        return this.text.isHidden() && this.icon.isHidden();
      }

    }

    class xt {
      constructor(e, t, i, o = !1) {
        this.text = e, this.icon = t, this.skipFade = i, this.clipped = o;
      }

    }

    class yt {
      constructor() {
        this.invProjMatrix = e.create(), this.viewportMatrix = e.create(), this.circles = [];
      }

    }

    class bt {
      constructor(e, t, i, o, r) {
        this.bucketInstanceId = e, this.featureIndex = t, this.sourceLayerIndex = i, this.bucketIndex = o, this.tileID = r;
      }

    }

    class wt {
      constructor(e) {
        this.crossSourceCollisions = e, this.maxGroupID = 0, this.collisionGroups = {};
      }

      get(e) {
        if (this.crossSourceCollisions) return {
          ID: 0,
          predicate: null
        };

        if (!this.collisionGroups[e]) {
          const t = ++this.maxGroupID;
          this.collisionGroups[e] = {
            ID: t,
            predicate: e => e.collisionGroupID === t
          };
        }

        return this.collisionGroups[e];
      }

    }

    function Tt(t, i, o, r, n) {
      const {
        horizontalAlign: a,
        verticalAlign: s
      } = e.getAnchorAlignment(t),
            l = -(a - .5) * i,
            c = -(s - .5) * o,
            h = e.evaluateVariableOffset(t, r);
      return new e.pointGeometry(l + h[0] * n, c + h[1] * n);
    }

    function Et(t, i, o, r, n) {
      const a = new e.pointGeometry(t, i);
      return o && a._rotate(r ? n : -n), a;
    }

    class Ct {
      constructor(e, t, i, o, r) {
        this.transform = e.clone(), this.collisionIndex = new ft(this.transform, r), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = t, this.retainedQueryData = {}, this.collisionGroups = new wt(i), this.collisionCircleArrays = {}, this.prevPlacement = o, o && (o.prevPlacement = void 0), this.placedOrientations = {};
      }

      getBucketParts(t, i, o, r) {
        const n = o.getBucket(i),
              a = o.latestFeatureIndex;
        if (!n || !a || i.id !== n.layerIds[0]) return;

        const s = n.layers[0].layout,
              l = o.collisionBoxArray,
              c = Math.pow(2, this.transform.zoom - o.tileID.overscaledZ),
              h = o.tileSize / e.EXTENT,
              _ = o.tileID.toUnwrapped(),
              u = this.transform.calculateProjMatrix(_),
              d = "map" === s.get("text-pitch-alignment"),
              p = "map" === s.get("text-rotation-alignment");

        i.compileFilter();
        const m = i.dynamicFilter(),
              f = i.dynamicFilterNeedsFeature(),
              g = this.transform.calculatePixelsToTileUnitsMatrix(o),
              v = Qe(u, o.tileID.canonical, d, p, this.transform, g);
        let x = null;

        if (d) {
          const t = et(u, o.tileID.canonical, d, p, this.transform, g);
          x = e.multiply$1([], this.transform.labelPlaneMatrix, t);
        }

        let y = null;
        m && o.latestFeatureIndex && (y = {
          unwrappedTileID: _,
          dynamicFilter: m,
          dynamicFilterNeedsFeature: f,
          featureIndex: o.latestFeatureIndex
        }), this.retainedQueryData[n.bucketInstanceId] = new bt(n.bucketInstanceId, a, n.sourceLayerIndex, n.index, o.tileID);
        const b = {
          bucket: n,
          layout: s,
          posMatrix: u,
          textLabelPlaneMatrix: v,
          labelToScreenMatrix: x,
          clippingData: y,
          scale: c,
          textPixelRatio: h,
          holdingForFade: o.holdingForFade(),
          collisionBoxArray: l,
          partiallyEvaluatedTextSize: e.evaluateSizeForZoom(n.textSizeData, this.transform.zoom),
          partiallyEvaluatedIconSize: e.evaluateSizeForZoom(n.iconSizeData, this.transform.zoom),
          collisionGroup: this.collisionGroups.get(n.sourceID)
        };
        if (r) for (const e of n.sortKeyRanges) {
          const {
            sortKey: i,
            symbolInstanceStart: o,
            symbolInstanceEnd: r
          } = e;
          t.push({
            sortKey: i,
            symbolInstanceStart: o,
            symbolInstanceEnd: r,
            parameters: b
          });
        } else t.push({
          symbolInstanceStart: 0,
          symbolInstanceEnd: n.symbolInstances.length,
          parameters: b
        });
      }

      attemptAnchorPlacement(e, t, i, o, r, n, a, s, l, c, h, _, u, d, p, m, f, g) {
        const v = [_.textOffset0, _.textOffset1],
              x = Tt(e, i, o, v, r),
              y = this.collisionIndex.placeCollisionBox(r, t, Et(x.x, x.y, n, a, this.transform.angle), h, s, l, c.predicate);

        if ((!m || 0 !== this.collisionIndex.placeCollisionBox(d.getSymbolInstanceIconSize(g, this.transform.zoom, u), m, Et(x.x, x.y, n, a, this.transform.angle), h, s, l, c.predicate).box.length) && y.box.length > 0) {
          let t;
          return this.prevPlacement && this.prevPlacement.variableOffsets[_.crossTileID] && this.prevPlacement.placements[_.crossTileID] && this.prevPlacement.placements[_.crossTileID].text && (t = this.prevPlacement.variableOffsets[_.crossTileID].anchor), this.variableOffsets[_.crossTileID] = {
            textOffset: v,
            width: i,
            height: o,
            anchor: e,
            textScale: r,
            prevAnchor: t
          }, this.markUsedJustification(d, e, _, p), d.allowVerticalPlacement && (this.markUsedOrientation(d, p, _), this.placedOrientations[_.crossTileID] = p), {
            shift: x,
            placedGlyphBoxes: y
          };
        }
      }

      placeLayerBucketPart(t, i, o, r) {
        const {
          bucket: n,
          layout: a,
          posMatrix: s,
          textLabelPlaneMatrix: l,
          labelToScreenMatrix: c,
          clippingData: h,
          textPixelRatio: _,
          holdingForFade: u,
          collisionBoxArray: d,
          partiallyEvaluatedTextSize: p,
          partiallyEvaluatedIconSize: m,
          collisionGroup: f
        } = t.parameters,
              g = a.get("text-optional"),
              v = a.get("icon-optional"),
              x = a.get("text-allow-overlap"),
              y = a.get("icon-allow-overlap"),
              b = "map" === a.get("text-rotation-alignment"),
              w = "map" === a.get("text-pitch-alignment"),
              T = "none" !== a.get("icon-text-fit"),
              E = "viewport-y" === a.get("symbol-z-order");
        let C = x && (y || !n.hasIconData() || v),
            I = y && (x || !n.hasTextData() || g);
        !n.collisionArrays && d && n.deserializeCollisionBoxes(d), o && r && n.updateCollisionDebugBuffers(this.transform.zoom, d);

        const M = (t, r, d) => {
          if (h) {
            const o = {
              zoom: this.transform.zoom,
              pitch: this.transform.pitch
            };
            let r = null;

            if (h.dynamicFilterNeedsFeature) {
              const e = this.retainedQueryData[n.bucketInstanceId];
              r = h.featureIndex.loadFeature({
                featureIndex: t.featureIndex,
                bucketIndex: e.bucketIndex,
                sourceLayerIndex: e.sourceLayerIndex,
                layoutVertexArrayOffset: 0
              });
            }

            if (!(0, h.dynamicFilter)(o, r, this.retainedQueryData[n.bucketInstanceId].tileID.canonical, new e.pointGeometry(t.tileAnchorX, t.tileAnchorY), this.transform.calculateDistanceTileData(h.unwrappedTileID))) return this.placements[t.crossTileID] = new xt(!1, !1, !1, !0), void (i[t.crossTileID] = !0);
          }

          if (i[t.crossTileID]) return;
          if (u) return void (this.placements[t.crossTileID] = new xt(!1, !1, !1));
          let E = !1,
              M = !1,
              S = !0,
              z = !1,
              D = !1,
              P = null,
              A = {
            box: null,
            offscreen: null,
            occluded: null
          },
              L = {
            box: null,
            offscreen: null,
            occluded: null
          },
              R = null,
              k = null,
              O = null,
              B = 0,
              F = 0,
              U = 0;
          d.textFeatureIndex ? B = d.textFeatureIndex : t.useRuntimeCollisionCircles && (B = t.featureIndex), d.verticalTextFeatureIndex && (F = d.verticalTextFeatureIndex);

          const N = e => {
            e.tileID = this.retainedQueryData[n.bucketInstanceId].tileID, (this.transform.elevation || e.elevation) && (e.elevation = this.transform.elevation ? this.transform.elevation.getAtTileOffset(this.retainedQueryData[n.bucketInstanceId].tileID, e.tileAnchorX, e.tileAnchorY) : 0);
          },
                G = d.textBox;

          if (G) {
            N(G);

            const i = i => {
              let o = e.WritingMode.horizontal;

              if (n.allowVerticalPlacement && !i && this.prevPlacement) {
                const e = this.prevPlacement.placedOrientations[t.crossTileID];
                e && (this.placedOrientations[t.crossTileID] = e, o = e, this.markUsedOrientation(n, o, t));
              }

              return o;
            },
                  o = (i, o) => {
              if (n.allowVerticalPlacement && t.numVerticalGlyphVertices > 0 && d.verticalTextBox) {
                for (const t of n.writingModes) if (t === e.WritingMode.vertical ? (A = o(), L = A) : A = i(), A && A.box && A.box.length) break;
              } else A = i();
            };

            if (a.get("text-variable-anchor")) {
              let l = a.get("text-variable-anchor");

              if (this.prevPlacement && this.prevPlacement.variableOffsets[t.crossTileID]) {
                const e = this.prevPlacement.variableOffsets[t.crossTileID];
                l.indexOf(e.anchor) > 0 && (l = l.filter(t => t !== e.anchor), l.unshift(e.anchor));
              }

              const c = (e, i, o) => {
                const a = n.getSymbolInstanceTextSize(p, t, this.transform.zoom, r),
                      c = (e.x2 - e.x1) * a + 2 * e.padding,
                      h = (e.y2 - e.y1) * a + 2 * e.padding,
                      u = T && !y ? i : null;
                u && N(u);
                let d = {
                  box: [],
                  offscreen: !1,
                  occluded: !1
                };
                const g = x ? 2 * l.length : l.length;

                for (let i = 0; i < g; ++i) {
                  const g = this.attemptAnchorPlacement(l[i % l.length], e, c, h, a, b, w, _, s, f, i >= l.length, t, r, n, o, u, p, m);

                  if (g && (d = g.placedGlyphBoxes, d && d.box && d.box.length)) {
                    E = !0, P = g.shift;
                    break;
                  }
                }

                return d;
              };

              o(() => c(G, d.iconBox, e.WritingMode.horizontal), () => {
                const i = d.verticalTextBox;
                return i && N(i), n.allowVerticalPlacement && !(A && A.box && A.box.length) && t.numVerticalGlyphVertices > 0 && i ? c(i, d.verticalIconBox, e.WritingMode.vertical) : {
                  box: null,
                  offscreen: null,
                  occluded: null
                };
              }), A && (E = A.box, S = A.offscreen, z = A.occluded);
              const h = i(A && A.box);

              if (!E && this.prevPlacement) {
                const e = this.prevPlacement.variableOffsets[t.crossTileID];
                e && (this.variableOffsets[t.crossTileID] = e, this.markUsedJustification(n, e.anchor, t, h));
              }
            } else {
              const a = (i, o) => {
                const a = n.getSymbolInstanceTextSize(p, t, this.transform.zoom, r),
                      l = this.collisionIndex.placeCollisionBox(a, i, new e.pointGeometry(0, 0), x, _, s, f.predicate);
                return l && l.box && l.box.length && (this.markUsedOrientation(n, o, t), this.placedOrientations[t.crossTileID] = o), l;
              };

              o(() => a(G, e.WritingMode.horizontal), () => {
                const i = d.verticalTextBox;
                return n.allowVerticalPlacement && t.numVerticalGlyphVertices > 0 && i ? (N(i), a(i, e.WritingMode.vertical)) : {
                  box: null,
                  offscreen: null,
                  occluded: null
                };
              }), i(A && A.box && A.box.length);
            }
          }

          if (R = A, E = R && R.box && R.box.length > 0, S = R && R.offscreen, z = R && R.occluded, t.useRuntimeCollisionCircles) {
            const i = n.text.placedSymbolArray.get(t.centerJustifiedTextSymbolIndex >= 0 ? t.centerJustifiedTextSymbolIndex : t.verticalPlacedTextSymbolIndex),
                  r = e.evaluateSizeForFeature(n.textSizeData, p, i),
                  h = a.get("text-padding");
            k = this.collisionIndex.placeCollisionCircles(x, i, n.lineVertexArray, n.glyphOffsetArray, r, s, l, c, o, w, f.predicate, t.collisionCircleDiameter * r / e.ONE_EM, h, this.retainedQueryData[n.bucketInstanceId].tileID), E = x || k.circles.length > 0 && !k.collisionDetected, S = S && k.offscreen, z = k.occluded;
          }

          if (d.iconFeatureIndex && (U = d.iconFeatureIndex), d.iconBox) {
            const t = t => {
              N(t);
              const i = T && P ? Et(P.x, P.y, b, w, this.transform.angle) : new e.pointGeometry(0, 0),
                    o = n.getSymbolInstanceIconSize(m, this.transform.zoom, r);
              return this.collisionIndex.placeCollisionBox(o, t, i, y, _, s, f.predicate);
            };

            L && L.box && L.box.length && d.verticalIconBox ? (O = t(d.verticalIconBox), M = O.box.length > 0) : (O = t(d.iconBox), M = O.box.length > 0), S = S && O.offscreen, D = O.occluded;
          }

          const j = g || 0 === t.numHorizontalGlyphVertices && 0 === t.numVerticalGlyphVertices,
                Z = v || 0 === t.numIconVertices;

          if (j || Z ? Z ? j || (M = M && E) : E = M && E : M = E = M && E, E && R && R.box && this.collisionIndex.insertCollisionBox(R.box, a.get("text-ignore-placement"), n.bucketInstanceId, L && L.box && F ? F : B, f.ID), M && O && this.collisionIndex.insertCollisionBox(O.box, a.get("icon-ignore-placement"), n.bucketInstanceId, U, f.ID), k && (E && this.collisionIndex.insertCollisionCircles(k.circles, a.get("text-ignore-placement"), n.bucketInstanceId, B, f.ID), o)) {
            const e = n.bucketInstanceId;
            let t = this.collisionCircleArrays[e];
            void 0 === t && (t = this.collisionCircleArrays[e] = new yt());

            for (let e = 0; e < k.circles.length; e += 4) t.circles.push(k.circles[e + 0]), t.circles.push(k.circles[e + 1]), t.circles.push(k.circles[e + 2]), t.circles.push(k.collisionDetected ? 1 : 0);
          }

          const V = "globe" !== this.transform.projection.name;
          C = C && (V || !z), I = I && (V || !D), this.placements[t.crossTileID] = new xt(E || C, M || I, S || n.justReloaded), i[t.crossTileID] = !0;
        };

        if (E) {
          const e = n.getSortedSymbolIndexes(this.transform.angle);

          for (let t = e.length - 1; t >= 0; --t) {
            const i = e[t];
            M(n.symbolInstances.get(i), i, n.collisionArrays[i]);
          }
        } else for (let e = t.symbolInstanceStart; e < t.symbolInstanceEnd; e++) M(n.symbolInstances.get(e), e, n.collisionArrays[e]);

        if (o && n.bucketInstanceId in this.collisionCircleArrays) {
          const t = this.collisionCircleArrays[n.bucketInstanceId];
          e.invert(t.invProjMatrix, s), t.viewportMatrix = this.collisionIndex.getViewportMatrix();
        }

        n.justReloaded = !1;
      }

      markUsedJustification(t, i, o, r) {
        let n;
        n = r === e.WritingMode.vertical ? o.verticalPlacedTextSymbolIndex : {
          left: o.leftJustifiedTextSymbolIndex,
          center: o.centerJustifiedTextSymbolIndex,
          right: o.rightJustifiedTextSymbolIndex
        }[e.getAnchorJustification(i)];
        const a = [o.leftJustifiedTextSymbolIndex, o.centerJustifiedTextSymbolIndex, o.rightJustifiedTextSymbolIndex, o.verticalPlacedTextSymbolIndex];

        for (const e of a) e >= 0 && (t.text.placedSymbolArray.get(e).crossTileID = n >= 0 && e !== n ? 0 : o.crossTileID);
      }

      markUsedOrientation(t, i, o) {
        const r = i === e.WritingMode.horizontal || i === e.WritingMode.horizontalOnly ? i : 0,
              n = i === e.WritingMode.vertical ? i : 0,
              a = [o.leftJustifiedTextSymbolIndex, o.centerJustifiedTextSymbolIndex, o.rightJustifiedTextSymbolIndex];

        for (const e of a) t.text.placedSymbolArray.get(e).placedOrientation = r;

        o.verticalPlacedTextSymbolIndex && (t.text.placedSymbolArray.get(o.verticalPlacedTextSymbolIndex).placedOrientation = n);
      }

      commit(e) {
        this.commitTime = e, this.zoomAtLastRecencyCheck = this.transform.zoom;
        const t = this.prevPlacement;
        let i = !1;
        this.prevZoomAdjustment = t ? t.zoomAdjustment(this.transform.zoom) : 0;
        const o = t ? t.symbolFadeChange(e) : 1,
              r = t ? t.opacities : {},
              n = t ? t.variableOffsets : {},
              a = t ? t.placedOrientations : {};

        for (const e in this.placements) {
          const t = this.placements[e],
                n = r[e];
          n ? (this.opacities[e] = new vt(n, o, t.text, t.icon, null, t.clipped), i = i || t.text !== n.text.placed || t.icon !== n.icon.placed) : (this.opacities[e] = new vt(null, o, t.text, t.icon, t.skipFade, t.clipped), i = i || t.text || t.icon);
        }

        for (const e in r) {
          const t = r[e];

          if (!this.opacities[e]) {
            const r = new vt(t, o, !1, !1);
            r.isHidden() || (this.opacities[e] = r, i = i || t.text.placed || t.icon.placed);
          }
        }

        for (const e in n) this.variableOffsets[e] || !this.opacities[e] || this.opacities[e].isHidden() || (this.variableOffsets[e] = n[e]);

        for (const e in a) this.placedOrientations[e] || !this.opacities[e] || this.opacities[e].isHidden() || (this.placedOrientations[e] = a[e]);

        i ? this.lastPlacementChangeTime = e : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = t ? t.lastPlacementChangeTime : e);
      }

      updateLayerOpacities(e, t) {
        const i = {};

        for (const o of t) {
          const t = o.getBucket(e);
          t && o.latestFeatureIndex && e.id === t.layerIds[0] && this.updateBucketOpacities(t, i, o.collisionBoxArray);
        }
      }

      updateBucketOpacities(t, i, o) {
        t.hasTextData() && t.text.opacityVertexArray.clear(), t.hasIconData() && t.icon.opacityVertexArray.clear(), t.hasIconCollisionBoxData() && t.iconCollisionBox.collisionVertexArray.clear(), t.hasTextCollisionBoxData() && t.textCollisionBox.collisionVertexArray.clear();

        const r = t.layers[0].layout,
              n = !!t.layers[0].dynamicFilter(),
              a = new vt(null, 0, !1, !1, !0),
              s = r.get("text-allow-overlap"),
              l = r.get("icon-allow-overlap"),
              c = r.get("text-variable-anchor"),
              h = "map" === r.get("text-rotation-alignment"),
              _ = "map" === r.get("text-pitch-alignment"),
              u = "none" !== r.get("icon-text-fit"),
              d = new vt(null, 0, s && (l || !t.hasIconData() || r.get("icon-optional")), l && (s || !t.hasTextData() || r.get("text-optional")), !0);

        !t.collisionArrays && o && (t.hasIconCollisionBoxData() || t.hasTextCollisionBoxData()) && t.deserializeCollisionBoxes(o);

        const p = (e, t, i) => {
          for (let o = 0; o < t / 4; o++) e.opacityVertexArray.emplaceBack(i);
        };

        let m = 0;

        for (let o = 0; o < t.symbolInstances.length; o++) {
          const r = t.symbolInstances.get(o),
                {
            numHorizontalGlyphVertices: s,
            numVerticalGlyphVertices: l,
            crossTileID: f
          } = r;
          let g = this.opacities[f];
          i[f] ? g = a : g || (g = d, this.opacities[f] = g), i[f] = !0;
          const v = s > 0 || l > 0,
                x = r.numIconVertices > 0,
                y = this.placedOrientations[r.crossTileID],
                b = y === e.WritingMode.vertical,
                w = y === e.WritingMode.horizontal || y === e.WritingMode.horizontalOnly;

          if (!v && !x || g.isHidden() || m++, v) {
            const e = Rt(g.text);
            p(t.text, s, b ? kt : e), p(t.text, l, w ? kt : e);
            const i = g.text.isHidden();
            [r.rightJustifiedTextSymbolIndex, r.centerJustifiedTextSymbolIndex, r.leftJustifiedTextSymbolIndex].forEach(e => {
              e >= 0 && (t.text.placedSymbolArray.get(e).hidden = i || b ? 1 : 0);
            }), r.verticalPlacedTextSymbolIndex >= 0 && (t.text.placedSymbolArray.get(r.verticalPlacedTextSymbolIndex).hidden = i || w ? 1 : 0);
            const o = this.variableOffsets[r.crossTileID];
            o && this.markUsedJustification(t, o.anchor, r, y);
            const n = this.placedOrientations[r.crossTileID];
            n && (this.markUsedJustification(t, "left", r, n), this.markUsedOrientation(t, n, r));
          }

          if (x) {
            const e = Rt(g.icon);
            r.placedIconSymbolIndex >= 0 && (p(t.icon, r.numIconVertices, b ? kt : e), t.icon.placedSymbolArray.get(r.placedIconSymbolIndex).hidden = g.icon.isHidden()), r.verticalPlacedIconSymbolIndex >= 0 && (p(t.icon, r.numVerticalIconVertices, w ? kt : e), t.icon.placedSymbolArray.get(r.verticalPlacedIconSymbolIndex).hidden = g.icon.isHidden());
          }

          if (t.hasIconCollisionBoxData() || t.hasTextCollisionBoxData()) {
            const i = t.collisionArrays[o];

            if (i) {
              let o = new e.pointGeometry(0, 0),
                  r = !0;

              if (i.textBox || i.verticalTextBox) {
                if (c) {
                  const e = this.variableOffsets[f];
                  e ? (o = Tt(e.anchor, e.width, e.height, e.textOffset, e.textScale), h && o._rotate(_ ? this.transform.angle : -this.transform.angle)) : r = !1;
                }

                n && (r = !g.clipped), i.textBox && It(t.textCollisionBox.collisionVertexArray, g.text.placed, !r || b, o.x, o.y), i.verticalTextBox && It(t.textCollisionBox.collisionVertexArray, g.text.placed, !r || w, o.x, o.y);
              }

              const a = r && Boolean(!w && i.verticalIconBox);
              i.iconBox && It(t.iconCollisionBox.collisionVertexArray, g.icon.placed, a, u ? o.x : 0, u ? o.y : 0), i.verticalIconBox && It(t.iconCollisionBox.collisionVertexArray, g.icon.placed, !a, u ? o.x : 0, u ? o.y : 0);
            }
          }
        }

        if (t.fullyClipped = 0 === m, t.sortFeatures(this.transform.angle), this.retainedQueryData[t.bucketInstanceId] && (this.retainedQueryData[t.bucketInstanceId].featureSortOrder = t.featureSortOrder), t.hasTextData() && t.text.opacityVertexBuffer && t.text.opacityVertexBuffer.updateData(t.text.opacityVertexArray), t.hasIconData() && t.icon.opacityVertexBuffer && t.icon.opacityVertexBuffer.updateData(t.icon.opacityVertexArray), t.hasIconCollisionBoxData() && t.iconCollisionBox.collisionVertexBuffer && t.iconCollisionBox.collisionVertexBuffer.updateData(t.iconCollisionBox.collisionVertexArray), t.hasTextCollisionBoxData() && t.textCollisionBox.collisionVertexBuffer && t.textCollisionBox.collisionVertexBuffer.updateData(t.textCollisionBox.collisionVertexArray), t.bucketInstanceId in this.collisionCircleArrays) {
          const e = this.collisionCircleArrays[t.bucketInstanceId];
          t.placementInvProjMatrix = e.invProjMatrix, t.placementViewportMatrix = e.viewportMatrix, t.collisionCircleArray = e.circles, delete this.collisionCircleArrays[t.bucketInstanceId];
        }
      }

      symbolFadeChange(e) {
        return 0 === this.fadeDuration ? 1 : (e - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
      }

      zoomAdjustment(e) {
        return Math.max(0, (this.transform.zoom - e) / 1.5);
      }

      hasTransitions(e) {
        return this.stale || e - this.lastPlacementChangeTime < this.fadeDuration;
      }

      stillRecent(e, t) {
        const i = this.zoomAtLastRecencyCheck === t ? 1 - this.zoomAdjustment(t) : 1;
        return this.zoomAtLastRecencyCheck = t, this.commitTime + this.fadeDuration * i > e;
      }

      setStale() {
        this.stale = !0;
      }

    }

    function It(e, t, i, o, r) {
      e.emplaceBack(t ? 1 : 0, i ? 1 : 0, o || 0, r || 0), e.emplaceBack(t ? 1 : 0, i ? 1 : 0, o || 0, r || 0), e.emplaceBack(t ? 1 : 0, i ? 1 : 0, o || 0, r || 0), e.emplaceBack(t ? 1 : 0, i ? 1 : 0, o || 0, r || 0);
    }

    const Mt = Math.pow(2, 25),
          St = Math.pow(2, 24),
          zt = Math.pow(2, 17),
          Dt = Math.pow(2, 16),
          Pt = Math.pow(2, 9),
          At = Math.pow(2, 8),
          Lt = Math.pow(2, 1);

    function Rt(e) {
      if (0 === e.opacity && !e.placed) return 0;
      if (1 === e.opacity && e.placed) return 4294967295;
      const t = e.placed ? 1 : 0,
            i = Math.floor(127 * e.opacity);
      return i * Mt + t * St + i * zt + t * Dt + i * Pt + t * At + i * Lt + t;
    }

    const kt = 0;

    class Ot {
      constructor(e) {
        this._sortAcrossTiles = "viewport-y" !== e.layout.get("symbol-z-order") && void 0 !== e.layout.get("symbol-sort-key").constantOr(1), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
      }

      continuePlacement(e, t, i, o, r) {
        const n = this._bucketParts;

        for (; this._currentTileIndex < e.length;) if (t.getBucketParts(n, o, e[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, r()) return !0;

        for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, n.sort((e, t) => e.sortKey - t.sortKey)); this._currentPartIndex < n.length;) {
          const e = n[this._currentPartIndex];
          if (t.placeLayerBucketPart(e, this._seenCrossTileIDs, i, 0 === e.symbolInstanceStart), this._currentPartIndex++, r()) return !0;
        }

        return !1;
      }

    }

    class Bt {
      constructor(e, t, i, o, r, n, a, s) {
        this.placement = new Ct(e, r, n, a, s), this._currentPlacementIndex = t.length - 1, this._forceFullPlacement = i, this._showCollisionBoxes = o, this._done = !1;
      }

      isDone() {
        return this._done;
      }

      continuePlacement(t, i, o) {
        const r = e.exported.now(),
              n = () => {
          const t = e.exported.now() - r;
          return !this._forceFullPlacement && t > 2;
        };

        for (; this._currentPlacementIndex >= 0;) {
          const e = i[t[this._currentPlacementIndex]],
                r = this.placement.collisionIndex.transform.zoom;

          if ("symbol" === e.type && (!e.minzoom || e.minzoom <= r) && (!e.maxzoom || e.maxzoom > r)) {
            if (this._inProgressLayer || (this._inProgressLayer = new Ot(e)), this._inProgressLayer.continuePlacement(o[e.source], this.placement, this._showCollisionBoxes, e, n)) return;
            delete this._inProgressLayer;
          }

          this._currentPlacementIndex--;
        }

        this._done = !0;
      }

      commit(e) {
        return this.placement.commit(e), this.placement;
      }

    }

    const Ft = 512 / e.EXTENT / 2;

    class Ut {
      constructor(e, t, i) {
        this.tileID = e, this.indexedSymbolInstances = {}, this.bucketInstanceId = i;

        for (let i = 0; i < t.length; i++) {
          const o = t.get(i),
                r = o.key;
          this.indexedSymbolInstances[r] || (this.indexedSymbolInstances[r] = []), this.indexedSymbolInstances[r].push({
            crossTileID: o.crossTileID,
            coord: this.getScaledCoordinates(o, e)
          });
        }
      }

      getScaledCoordinates(t, i) {
        const o = Ft / Math.pow(2, i.canonical.z - this.tileID.canonical.z);
        return {
          x: Math.floor((i.canonical.x * e.EXTENT + t.tileAnchorX) * o),
          y: Math.floor((i.canonical.y * e.EXTENT + t.tileAnchorY) * o)
        };
      }

      findMatches(e, t, i) {
        const o = this.tileID.canonical.z < t.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - t.canonical.z);

        for (let r = 0; r < e.length; r++) {
          const n = e.get(r);
          if (n.crossTileID) continue;
          const a = this.indexedSymbolInstances[n.key];
          if (!a) continue;
          const s = this.getScaledCoordinates(n, t);

          for (const e of a) if (Math.abs(e.coord.x - s.x) <= o && Math.abs(e.coord.y - s.y) <= o && !i[e.crossTileID]) {
            i[e.crossTileID] = !0, n.crossTileID = e.crossTileID;
            break;
          }
        }
      }

    }

    class Nt {
      constructor() {
        this.maxCrossTileID = 0;
      }

      generate() {
        return ++this.maxCrossTileID;
      }

    }

    class Gt {
      constructor() {
        this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
      }

      handleWrapJump(e) {
        const t = Math.round((e - this.lng) / 360);
        if (0 !== t) for (const e in this.indexes) {
          const i = this.indexes[e],
                o = {};

          for (const e in i) {
            const r = i[e];
            r.tileID = r.tileID.unwrapTo(r.tileID.wrap + t), o[r.tileID.key] = r;
          }

          this.indexes[e] = o;
        }
        this.lng = e;
      }

      addBucket(e, t, i) {
        if (this.indexes[e.overscaledZ] && this.indexes[e.overscaledZ][e.key]) {
          if (this.indexes[e.overscaledZ][e.key].bucketInstanceId === t.bucketInstanceId) return !1;
          this.removeBucketCrossTileIDs(e.overscaledZ, this.indexes[e.overscaledZ][e.key]);
        }

        for (let e = 0; e < t.symbolInstances.length; e++) t.symbolInstances.get(e).crossTileID = 0;

        this.usedCrossTileIDs[e.overscaledZ] || (this.usedCrossTileIDs[e.overscaledZ] = {});
        const o = this.usedCrossTileIDs[e.overscaledZ];

        for (const i in this.indexes) {
          const r = this.indexes[i];
          if (Number(i) > e.overscaledZ) for (const i in r) {
            const n = r[i];
            n.tileID.isChildOf(e) && n.findMatches(t.symbolInstances, e, o);
          } else {
            const n = r[e.scaledTo(Number(i)).key];
            n && n.findMatches(t.symbolInstances, e, o);
          }
        }

        for (let e = 0; e < t.symbolInstances.length; e++) {
          const r = t.symbolInstances.get(e);
          r.crossTileID || (r.crossTileID = i.generate(), o[r.crossTileID] = !0);
        }

        return void 0 === this.indexes[e.overscaledZ] && (this.indexes[e.overscaledZ] = {}), this.indexes[e.overscaledZ][e.key] = new Ut(e, t.symbolInstances, t.bucketInstanceId), !0;
      }

      removeBucketCrossTileIDs(e, t) {
        for (const i in t.indexedSymbolInstances) for (const o of t.indexedSymbolInstances[i]) delete this.usedCrossTileIDs[e][o.crossTileID];
      }

      removeStaleBuckets(e) {
        let t = !1;

        for (const i in this.indexes) {
          const o = this.indexes[i];

          for (const r in o) e[o[r].bucketInstanceId] || (this.removeBucketCrossTileIDs(i, o[r]), delete o[r], t = !0);
        }

        return t;
      }

    }

    class jt {
      constructor() {
        this.layerIndexes = {}, this.crossTileIDs = new Nt(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
      }

      addLayer(e, t, i, o) {
        let r = this.layerIndexes[e.id];
        void 0 === r && (r = this.layerIndexes[e.id] = new Gt());
        let n = !1;
        const a = {};
        "globe" !== o.name && r.handleWrapJump(i);

        for (const i of t) {
          const t = i.getBucket(e);
          t && e.id === t.layerIds[0] && (t.bucketInstanceId || (t.bucketInstanceId = ++this.maxBucketInstanceId), r.addBucket(i.tileID, t, this.crossTileIDs) && (n = !0), a[t.bucketInstanceId] = !0);
        }

        return r.removeStaleBuckets(a) && (n = !0), n;
      }

      pruneUnusedLayers(e) {
        const t = {};
        e.forEach(e => {
          t[e] = !0;
        });

        for (const e in this.layerIndexes) t[e] || delete this.layerIndexes[e];
      }

    }

    const Zt = (t, i) => e.emitValidationErrors(t, i && i.filter(e => "source.canvas" !== e.identifier)),
          Vt = e.pick(je, ["addLayer", "removeLayer", "setPaintProperty", "setLayoutProperty", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData", "setTerrain", "setFog", "setProjection"]),
          Wt = e.pick(je, ["setCenter", "setZoom", "setBearing", "setPitch"]),
          qt = {
      version: 8,
      layers: [],
      sources: {}
    },
          Xt = {
      fill: !0,
      line: !0,
      background: !0,
      hillshade: !0,
      raster: !0
    };

    class $t extends e.Evented {
      constructor(t, i = {}) {
        super(), this.map = t, this.dispatcher = new A(Ue(), this), this.imageManager = new y(), this.imageManager.setEventedParent(this), this.glyphManager = new e.GlyphManager(t._requestManager, i.localFontFamily ? e.LocalGlyphMode.all : i.localIdeographFontFamily ? e.LocalGlyphMode.ideographs : e.LocalGlyphMode.none, i.localFontFamily || i.localIdeographFontFamily), this.lineAtlas = new e.LineAtlas(256, 512), this.crossTileSymbolIndex = new jt(), this._layers = {}, this._num3DLayers = 0, this._numSymbolLayers = 0, this._numCircleLayers = 0, this._serializedLayers = {}, this._sourceCaches = {}, this._otherSourceCaches = {}, this._symbolSourceCaches = {}, this.zoomHistory = new e.ZoomHistory(), this._loaded = !1, this._availableImages = [], this._order = [], this._drapedFirstOrder = [], this._markersNeedUpdate = !1, this._resetUpdates(), this.dispatcher.broadcast("setReferrer", e.getReferrer());
        const o = this;
        this._rtlTextPluginCallback = $t.registerForPluginStateChange(t => {
          o.dispatcher.broadcast("syncRTLPluginState", {
            pluginStatus: t.pluginStatus,
            pluginURL: t.pluginURL
          }, (t, i) => {
            if (e.triggerPluginCompletionEvent(t), i && i.every(e => e)) for (const e in o._sourceCaches) {
              const t = o._sourceCaches[e],
                    i = t.getSource().type;
              "vector" !== i && "geojson" !== i || t.reload();
            }
          });
        }), this.on("data", e => {
          if ("source" !== e.dataType || "metadata" !== e.sourceDataType) return;
          const t = this.getSource(e.sourceId);
          if (t && t.vectorLayerIds) for (const e in this._layers) {
            const i = this._layers[e];
            i.source === t.id && this._validateLayer(i);
          }
        });
      }

      loadURL(t, i = {}) {
        this.fire(new e.Event("dataloading", {
          dataType: "style"
        }));
        const o = "boolean" == typeof i.validate ? i.validate : !e.isMapboxURL(t);
        t = this.map._requestManager.normalizeStyleURL(t, i.accessToken);

        const r = this.map._requestManager.transformRequest(t, e.ResourceType.Style);

        this._request = e.getJSON(r, (t, i) => {
          this._request = null, t ? this.fire(new e.ErrorEvent(t)) : i && this._load(i, o);
        });
      }

      loadJSON(t, i = {}) {
        this.fire(new e.Event("dataloading", {
          dataType: "style"
        })), this._request = e.exported.frame(() => {
          this._request = null, this._load(t, !1 !== i.validate);
        });
      }

      loadEmpty() {
        this.fire(new e.Event("dataloading", {
          dataType: "style"
        })), this._load(qt, !1);
      }

      _updateLayerCount(e, t) {
        const i = t ? 1 : -1;
        e.is3D() && (this._num3DLayers += i), "circle" === e.type && (this._numCircleLayers += i), "symbol" === e.type && (this._numSymbolLayers += i);
      }

      _load(t, i) {
        if (i && Zt(this, e.validateStyle(t))) return;
        this._loaded = !0, this.stylesheet = t, this._updateMapProjection();

        for (const e in t.sources) this.addSource(e, t.sources[e], {
          validate: !1
        });

        this._changed = !1, t.sprite ? this._loadSprite(t.sprite) : (this.imageManager.setLoaded(!0), this.dispatcher.broadcast("spriteLoaded", !0)), this.glyphManager.setURL(t.glyphs);
        const o = Ge(this.stylesheet.layers);
        this._order = o.map(e => e.id), this._layers = {}, this._serializedLayers = {};

        for (let t of o) t = e.createStyleLayer(t), t.setEventedParent(this, {
          layer: {
            id: t.id
          }
        }), this._layers[t.id] = t, this._serializedLayers[t.id] = t.serialize(), this._updateLayerCount(t, !0);

        this.dispatcher.broadcast("setLayers", this._serializeLayers(this._order)), this.light = new T(this.stylesheet.light), this.stylesheet.terrain && !this.terrainSetForDrapingOnly() && this._createTerrain(this.stylesheet.terrain, 1), this.stylesheet.fog && this._createFog(this.stylesheet.fog), this._updateDrapeFirstLayers(), this.fire(new e.Event("data", {
          dataType: "style"
        })), this.fire(new e.Event("style.load"));
      }

      terrainSetForDrapingOnly() {
        return !!this.terrain && 0 === this.terrain.drapeRenderMode;
      }

      setProjection(e) {
        e ? this.stylesheet.projection = e : delete this.stylesheet.projection, this.map._explicitProjection || this.map._updateProjection();
      }

      _updateMapProjection() {
        this.map._explicitProjection ? this.applyProjectionUpdate() : this.map._updateProjection();
      }

      applyProjectionUpdate() {
        this._loaded && (this.dispatcher.broadcast("setProjection", this.map.transform.projectionOptions), this.map.transform.projection.requiresDraping ? this.getTerrain() || this.stylesheet.terrain || this.setTerrainForDraping() : this.terrainSetForDrapingOnly() && this.setTerrain(null));
      }

      _loadSprite(t) {
        this._spriteRequest = function (t, i, o) {
          let r, n, a;
          const s = e.exported.devicePixelRatio > 1 ? "@2x" : "";
          let l = e.getJSON(i.transformRequest(i.normalizeSpriteURL(t, s, ".json"), e.ResourceType.SpriteJSON), (e, t) => {
            l = null, a || (a = e, r = t, h());
          }),
              c = e.getImage(i.transformRequest(i.normalizeSpriteURL(t, s, ".png"), e.ResourceType.SpriteImage), (e, t) => {
            c = null, a || (a = e, n = t, h());
          });

          function h() {
            if (a) o(a);else if (r && n) {
              const t = e.exported.getImageData(n),
                    i = {};

              for (const o in r) {
                const {
                  width: n,
                  height: a,
                  x: s,
                  y: l,
                  sdf: c,
                  pixelRatio: h,
                  stretchX: _,
                  stretchY: u,
                  content: d
                } = r[o],
                      p = new e.RGBAImage({
                  width: n,
                  height: a
                });
                e.RGBAImage.copy(t, p, {
                  x: s,
                  y: l
                }, {
                  x: 0,
                  y: 0
                }, {
                  width: n,
                  height: a
                }), i[o] = {
                  data: p,
                  pixelRatio: h,
                  sdf: c,
                  stretchX: _,
                  stretchY: u,
                  content: d
                };
              }

              o(null, i);
            }
          }

          return {
            cancel() {
              l && (l.cancel(), l = null), c && (c.cancel(), c = null);
            }

          };
        }(t, this.map._requestManager, (t, i) => {
          if (this._spriteRequest = null, t) this.fire(new e.ErrorEvent(t));else if (i) for (const e in i) this.imageManager.addImage(e, i[e]);
          this.imageManager.setLoaded(!0), this._availableImages = this.imageManager.listImages(), this.dispatcher.broadcast("setImages", this._availableImages), this.dispatcher.broadcast("spriteLoaded", !0), this.fire(new e.Event("data", {
            dataType: "style"
          }));
        });
      }

      _validateLayer(t) {
        const i = this.getSource(t.source);
        if (!i) return;
        const o = t.sourceLayer;
        o && ("geojson" === i.type || i.vectorLayerIds && -1 === i.vectorLayerIds.indexOf(o)) && this.fire(new e.ErrorEvent(new Error(`Source layer "${o}" does not exist on source "${i.id}" as specified by style layer "${t.id}"`)));
      }

      loaded() {
        if (!this._loaded) return !1;
        if (Object.keys(this._updatedSources).length) return !1;

        for (const e in this._sourceCaches) if (!this._sourceCaches[e].loaded()) return !1;

        return !!this.imageManager.isLoaded();
      }

      _serializeLayers(e) {
        const t = [];

        for (const i of e) {
          const e = this._layers[i];
          "custom" !== e.type && t.push(e.serialize());
        }

        return t;
      }

      hasTransitions() {
        if (this.light && this.light.hasTransition()) return !0;
        if (this.fog && this.fog.hasTransition()) return !0;

        for (const e in this._sourceCaches) if (this._sourceCaches[e].hasTransition()) return !0;

        for (const e in this._layers) if (this._layers[e].hasTransition()) return !0;

        return !1;
      }

      get order() {
        return this.map._optimizeForTerrain && this.terrain ? this._drapedFirstOrder : this._order;
      }

      isLayerDraped(e) {
        return !!this.terrain && Xt[e.type];
      }

      _checkLoaded() {
        if (!this._loaded) throw new Error("Style is not done loading");
      }

      update(t) {
        if (!this._loaded) return;
        const i = this._changed;

        if (this._changed) {
          const e = Object.keys(this._updatedLayers),
                i = Object.keys(this._removedLayers);
          (e.length || i.length) && this._updateWorkerLayers(e, i);

          for (const e in this._updatedSources) {
            const t = this._updatedSources[e];
            "reload" === t ? this._reloadSource(e) : "clear" === t && this._clearSource(e);
          }

          this._updateTilesForChangedImages();

          for (const e in this._updatedPaintProps) this._layers[e].updateTransitions(t);

          this.light.updateTransitions(t), this.fog && this.fog.updateTransitions(t), this._resetUpdates();
        }

        const o = {};

        for (const e in this._sourceCaches) {
          const t = this._sourceCaches[e];
          o[e] = t.used, t.used = !1;
        }

        for (const e of this._order) {
          const i = this._layers[e];

          if (i.recalculate(t, this._availableImages), !i.isHidden(t.zoom)) {
            const e = this._getLayerSourceCache(i);

            e && (e.used = !0);
          }

          const o = this.map.painter;

          if (o) {
            const e = i.getProgramIds();
            if (!e) continue;
            const r = i.getProgramConfiguration(t.zoom);

            for (const t of e) o.useProgram(t, r);
          }
        }

        for (const t in o) {
          const i = this._sourceCaches[t];
          o[t] !== i.used && i.getSource().fire(new e.Event("data", {
            sourceDataType: "visibility",
            dataType: "source",
            sourceId: i.getSource().id
          }));
        }

        this.light.recalculate(t), this.terrain && this.terrain.recalculate(t), this.fog && this.fog.recalculate(t), this.z = t.zoom, this._markersNeedUpdate && (this._updateMarkersOpacity(), this._markersNeedUpdate = !1), i && this.fire(new e.Event("data", {
          dataType: "style"
        }));
      }

      _updateTilesForChangedImages() {
        const e = Object.keys(this._changedImages);

        if (e.length) {
          for (const t in this._sourceCaches) this._sourceCaches[t].reloadTilesForDependencies(["icons", "patterns"], e);

          this._changedImages = {};
        }
      }

      _updateWorkerLayers(e, t) {
        this.dispatcher.broadcast("updateLayers", {
          layers: this._serializeLayers(e),
          removedIds: t
        });
      }

      _resetUpdates() {
        this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {};
      }

      setState(t) {
        if (this._checkLoaded(), Zt(this, e.validateStyle(t))) return !1;
        (t = e.clone$1(t)).layers = Ge(t.layers);

        const i = function (e, t) {
          if (!e) return [{
            command: je.setStyle,
            args: [t]
          }];
          let i = [];

          try {
            if (!r(e.version, t.version)) return [{
              command: je.setStyle,
              args: [t]
            }];
            r(e.center, t.center) || i.push({
              command: je.setCenter,
              args: [t.center]
            }), r(e.zoom, t.zoom) || i.push({
              command: je.setZoom,
              args: [t.zoom]
            }), r(e.bearing, t.bearing) || i.push({
              command: je.setBearing,
              args: [t.bearing]
            }), r(e.pitch, t.pitch) || i.push({
              command: je.setPitch,
              args: [t.pitch]
            }), r(e.sprite, t.sprite) || i.push({
              command: je.setSprite,
              args: [t.sprite]
            }), r(e.glyphs, t.glyphs) || i.push({
              command: je.setGlyphs,
              args: [t.glyphs]
            }), r(e.transition, t.transition) || i.push({
              command: je.setTransition,
              args: [t.transition]
            }), r(e.light, t.light) || i.push({
              command: je.setLight,
              args: [t.light]
            }), r(e.fog, t.fog) || i.push({
              command: je.setFog,
              args: [t.fog]
            }), r(e.projection, t.projection) || i.push({
              command: je.setProjection,
              args: [t.projection]
            });
            const o = {},
                  n = [];
            !function (e, t, i, o) {
              let n;

              for (n in t = t || {}, e = e || {}) e.hasOwnProperty(n) && (t.hasOwnProperty(n) || Ve(n, i, o));

              for (n in t) t.hasOwnProperty(n) && (e.hasOwnProperty(n) ? r(e[n], t[n]) || ("geojson" === e[n].type && "geojson" === t[n].type && qe(e, t, n) ? i.push({
                command: je.setGeoJSONSourceData,
                args: [n, t[n].data]
              }) : We(n, t, i, o)) : Ze(n, t, i));
            }(e.sources, t.sources, n, o);
            const a = [];
            e.layers && e.layers.forEach(e => {
              e.source && o[e.source] ? i.push({
                command: je.removeLayer,
                args: [e.id]
              }) : a.push(e);
            });
            let s = e.terrain;
            s && o[s.source] && (i.push({
              command: je.setTerrain,
              args: [void 0]
            }), s = void 0), i = i.concat(n), r(s, t.terrain) || i.push({
              command: je.setTerrain,
              args: [t.terrain]
            }), function (e, t, i) {
              t = t || [];
              const o = (e = e || []).map($e),
                    n = t.map($e),
                    a = e.reduce(He, {}),
                    s = t.reduce(He, {}),
                    l = o.slice(),
                    c = Object.create(null);

              let h, _, u, d, p, m, f;

              for (h = 0, _ = 0; h < o.length; h++) u = o[h], s.hasOwnProperty(u) ? _++ : (i.push({
                command: je.removeLayer,
                args: [u]
              }), l.splice(l.indexOf(u, _), 1));

              for (h = 0, _ = 0; h < n.length; h++) u = n[n.length - 1 - h], l[l.length - 1 - h] !== u && (a.hasOwnProperty(u) ? (i.push({
                command: je.removeLayer,
                args: [u]
              }), l.splice(l.lastIndexOf(u, l.length - _), 1)) : _++, m = l[l.length - h], i.push({
                command: je.addLayer,
                args: [s[u], m]
              }), l.splice(l.length - h, 0, u), c[u] = !0);

              for (h = 0; h < n.length; h++) if (u = n[h], d = a[u], p = s[u], !c[u] && !r(d, p)) if (r(d.source, p.source) && r(d["source-layer"], p["source-layer"]) && r(d.type, p.type)) {
                for (f in Xe(d.layout, p.layout, i, u, null, je.setLayoutProperty), Xe(d.paint, p.paint, i, u, null, je.setPaintProperty), r(d.filter, p.filter) || i.push({
                  command: je.setFilter,
                  args: [u, p.filter]
                }), r(d.minzoom, p.minzoom) && r(d.maxzoom, p.maxzoom) || i.push({
                  command: je.setLayerZoomRange,
                  args: [u, p.minzoom, p.maxzoom]
                }), d) d.hasOwnProperty(f) && "layout" !== f && "paint" !== f && "filter" !== f && "metadata" !== f && "minzoom" !== f && "maxzoom" !== f && (0 === f.indexOf("paint.") ? Xe(d[f], p[f], i, u, f.slice(6), je.setPaintProperty) : r(d[f], p[f]) || i.push({
                  command: je.setLayerProperty,
                  args: [u, f, p[f]]
                }));

                for (f in p) p.hasOwnProperty(f) && !d.hasOwnProperty(f) && "layout" !== f && "paint" !== f && "filter" !== f && "metadata" !== f && "minzoom" !== f && "maxzoom" !== f && (0 === f.indexOf("paint.") ? Xe(d[f], p[f], i, u, f.slice(6), je.setPaintProperty) : r(d[f], p[f]) || i.push({
                  command: je.setLayerProperty,
                  args: [u, f, p[f]]
                }));
              } else i.push({
                command: je.removeLayer,
                args: [u]
              }), m = l[l.lastIndexOf(u) + 1], i.push({
                command: je.addLayer,
                args: [p, m]
              });
            }(a, t.layers, i);
          } catch (e) {
            console.warn("Unable to compute style diff:", e), i = [{
              command: je.setStyle,
              args: [t]
            }];
          }

          return i;
        }(this.serialize(), t).filter(e => !(e.command in Wt));

        if (0 === i.length) return !1;
        const o = i.filter(e => !(e.command in Vt));
        if (o.length > 0) throw new Error(`Unimplemented: ${o.map(e => e.command).join(", ")}.`);
        return i.forEach(e => {
          "setTransition" !== e.command && this[e.command].apply(this, e.args);
        }), this.stylesheet = t, this._updateMapProjection(), !0;
      }

      addImage(t, i) {
        return this.getImage(t) ? this.fire(new e.ErrorEvent(new Error("An image with this name already exists."))) : (this.imageManager.addImage(t, i), this._afterImageUpdated(t), this);
      }

      updateImage(e, t) {
        this.imageManager.updateImage(e, t);
      }

      getImage(e) {
        return this.imageManager.getImage(e);
      }

      removeImage(t) {
        return this.getImage(t) ? (this.imageManager.removeImage(t), this._afterImageUpdated(t), this) : this.fire(new e.ErrorEvent(new Error("No image with this name exists.")));
      }

      _afterImageUpdated(t) {
        this._availableImages = this.imageManager.listImages(), this._changedImages[t] = !0, this._changed = !0, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new e.Event("data", {
          dataType: "style"
        }));
      }

      listImages() {
        return this._checkLoaded(), this._availableImages.slice();
      }

      addSource(t, i, o = {}) {
        if (this._checkLoaded(), void 0 !== this.getSource(t)) throw new Error("There is already a source with this ID");
        if (!i.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i).join(", ")}.`);
        if (["vector", "raster", "geojson", "video", "image"].indexOf(i.type) >= 0 && this._validate(e.validateSource, `sources.${t}`, i, null, o)) return;
        this.map && this.map._collectResourceTiming && (i.collectResourceTiming = !0);
        const r = De(t, i, this.dispatcher, this);
        r.setEventedParent(this, () => ({
          isSourceLoaded: this._isSourceCacheLoaded(t),
          source: r.serialize(),
          sourceId: t
        }));

        const n = i => {
          const o = (i ? "symbol:" : "other:") + t,
                n = this._sourceCaches[o] = new e.SourceCache(o, r, i);
          (i ? this._symbolSourceCaches : this._otherSourceCaches)[t] = n, n.style = this, n.onAdd(this.map);
        };

        n(!1), "vector" !== i.type && "geojson" !== i.type || n(!0), r.onAdd && r.onAdd(this.map), this._changed = !0;
      }

      removeSource(t) {
        this._checkLoaded();

        const i = this.getSource(t);
        if (!i) throw new Error("There is no source with this ID");

        for (const i in this._layers) if (this._layers[i].source === t) return this.fire(new e.ErrorEvent(new Error(`Source "${t}" cannot be removed while layer "${i}" is using it.`)));

        if (this.terrain && this.terrain.get().source === t) return this.fire(new e.ErrorEvent(new Error(`Source "${t}" cannot be removed while terrain is using it.`)));

        const o = this._getSourceCaches(t);

        for (const t of o) delete this._sourceCaches[t.id], delete this._updatedSources[t.id], t.fire(new e.Event("data", {
          sourceDataType: "metadata",
          dataType: "source",
          sourceId: t.getSource().id
        })), t.setEventedParent(null), t.clearTiles();

        return delete this._otherSourceCaches[t], delete this._symbolSourceCaches[t], i.setEventedParent(null), i.onRemove && i.onRemove(this.map), this._changed = !0, this;
      }

      setGeoJSONSourceData(e, t) {
        this._checkLoaded(), this.getSource(e).setData(t), this._changed = !0;
      }

      getSource(e) {
        const t = this._getSourceCache(e);

        return t && t.getSource();
      }

      addLayer(t, i, o = {}) {
        this._checkLoaded();

        const r = t.id;
        if (this.getLayer(r)) return void this.fire(new e.ErrorEvent(new Error(`Layer with id "${r}" already exists on this map`)));
        let n;

        if ("custom" === t.type) {
          if (Zt(this, e.validateCustomStyleLayer(t))) return;
          n = e.createStyleLayer(t);
        } else {
          if ("object" == typeof t.source && (this.addSource(r, t.source), t = e.clone$1(t), t = e.extend(t, {
            source: r
          })), this._validate(e.validateLayer, `layers.${r}`, t, {
            arrayIndex: -1
          }, o)) return;
          n = e.createStyleLayer(t), this._validateLayer(n), n.setEventedParent(this, {
            layer: {
              id: r
            }
          }), this._serializedLayers[n.id] = n.serialize(), this._updateLayerCount(n, !0);
        }

        const a = i ? this._order.indexOf(i) : this._order.length;
        if (i && -1 === a) return void this.fire(new e.ErrorEvent(new Error(`Layer with id "${i}" does not exist on this map.`)));
        this._order.splice(a, 0, r), this._layerOrderChanged = !0, this._layers[r] = n;

        const s = this._getLayerSourceCache(n);

        if (this._removedLayers[r] && n.source && s && "custom" !== n.type) {
          const e = this._removedLayers[r];
          delete this._removedLayers[r], e.type !== n.type ? this._updatedSources[n.source] = "clear" : (this._updatedSources[n.source] = "reload", s.pause());
        }

        this._updateLayer(n), n.onAdd && n.onAdd(this.map), this._updateDrapeFirstLayers();
      }

      moveLayer(t, i) {
        if (this._checkLoaded(), this._changed = !0, !this._layers[t]) return void this.fire(new e.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style and cannot be moved.`)));
        if (t === i) return;

        const o = this._order.indexOf(t);

        this._order.splice(o, 1);

        const r = i ? this._order.indexOf(i) : this._order.length;
        i && -1 === r ? this.fire(new e.ErrorEvent(new Error(`Layer with id "${i}" does not exist on this map.`))) : (this._order.splice(r, 0, t), this._layerOrderChanged = !0, this._updateDrapeFirstLayers());
      }

      removeLayer(t) {
        this._checkLoaded();

        const i = this._layers[t];
        if (!i) return void this.fire(new e.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style and cannot be removed.`)));
        i.setEventedParent(null), this._updateLayerCount(i, !1);

        const o = this._order.indexOf(t);

        this._order.splice(o, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[t] = i, delete this._layers[t], delete this._serializedLayers[t], delete this._updatedLayers[t], delete this._updatedPaintProps[t], i.onRemove && i.onRemove(this.map), this._updateDrapeFirstLayers();
      }

      getLayer(e) {
        return this._layers[e];
      }

      hasLayer(e) {
        return e in this._layers;
      }

      hasLayerType(e) {
        for (const t in this._layers) if (this._layers[t].type === e) return !0;

        return !1;
      }

      setLayerZoomRange(t, i, o) {
        this._checkLoaded();

        const r = this.getLayer(t);
        r ? r.minzoom === i && r.maxzoom === o || (null != i && (r.minzoom = i), null != o && (r.maxzoom = o), this._updateLayer(r)) : this.fire(new e.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style and cannot have zoom extent.`)));
      }

      setFilter(t, i, o = {}) {
        this._checkLoaded();

        const n = this.getLayer(t);

        if (n) {
          if (!r(n.filter, i)) return null == i ? (n.filter = void 0, void this._updateLayer(n)) : void (this._validate(e.validateFilter, `layers.${n.id}.filter`, i, {
            layerType: n.type
          }, o) || (n.filter = e.clone$1(i), this._updateLayer(n)));
        } else this.fire(new e.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style and cannot be filtered.`)));
      }

      getFilter(t) {
        const i = this.getLayer(t);
        return i && e.clone$1(i.filter);
      }

      setLayoutProperty(t, i, o, n = {}) {
        this._checkLoaded();

        const a = this.getLayer(t);
        a ? r(a.getLayoutProperty(i), o) || (a.setLayoutProperty(i, o, n), this._updateLayer(a)) : this.fire(new e.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style and cannot be styled.`)));
      }

      getLayoutProperty(t, i) {
        const o = this.getLayer(t);
        if (o) return o.getLayoutProperty(i);
        this.fire(new e.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style.`)));
      }

      setPaintProperty(t, i, o, n = {}) {
        this._checkLoaded();

        const a = this.getLayer(t);
        a ? r(a.getPaintProperty(i), o) || (a.setPaintProperty(i, o, n) && this._updateLayer(a), this._changed = !0, this._updatedPaintProps[t] = !0) : this.fire(new e.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style and cannot be styled.`)));
      }

      getPaintProperty(e, t) {
        const i = this.getLayer(e);
        return i && i.getPaintProperty(t);
      }

      setFeatureState(t, i) {
        this._checkLoaded();

        const o = t.source,
              r = t.sourceLayer,
              n = this.getSource(o);
        if (!n) return void this.fire(new e.ErrorEvent(new Error(`The source '${o}' does not exist in the map's style.`)));
        const a = n.type;
        if ("geojson" === a && r) return void this.fire(new e.ErrorEvent(new Error("GeoJSON sources cannot have a sourceLayer parameter.")));
        if ("vector" === a && !r) return void this.fire(new e.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
        void 0 === t.id && this.fire(new e.ErrorEvent(new Error("The feature id parameter must be provided.")));

        const s = this._getSourceCaches(o);

        for (const e of s) e.setFeatureState(r, t.id, i);
      }

      removeFeatureState(t, i) {
        this._checkLoaded();

        const o = t.source,
              r = this.getSource(o);
        if (!r) return void this.fire(new e.ErrorEvent(new Error(`The source '${o}' does not exist in the map's style.`)));
        const n = r.type,
              a = "vector" === n ? t.sourceLayer : void 0;
        if ("vector" === n && !a) return void this.fire(new e.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
        if (i && "string" != typeof t.id && "number" != typeof t.id) return void this.fire(new e.ErrorEvent(new Error("A feature id is required to remove its specific state property.")));

        const s = this._getSourceCaches(o);

        for (const e of s) e.removeFeatureState(a, t.id, i);
      }

      getFeatureState(t) {
        this._checkLoaded();

        const i = t.source,
              o = t.sourceLayer,
              r = this.getSource(i);

        if (r) {
          if ("vector" !== r.type || o) return void 0 === t.id && this.fire(new e.ErrorEvent(new Error("The feature id parameter must be provided."))), this._getSourceCaches(i)[0].getFeatureState(o, t.id);
          this.fire(new e.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
        } else this.fire(new e.ErrorEvent(new Error(`The source '${i}' does not exist in the map's style.`)));
      }

      getTransition() {
        return e.extend({
          duration: 300,
          delay: 0
        }, this.stylesheet && this.stylesheet.transition);
      }

      serialize() {
        const t = {};

        for (const e in this._sourceCaches) {
          const i = this._sourceCaches[e].getSource();

          t[i.id] || (t[i.id] = i.serialize());
        }

        return e.filterObject({
          version: this.stylesheet.version,
          name: this.stylesheet.name,
          metadata: this.stylesheet.metadata,
          light: this.stylesheet.light,
          terrain: this.stylesheet.terrain,
          fog: this.stylesheet.fog,
          center: this.stylesheet.center,
          zoom: this.stylesheet.zoom,
          bearing: this.stylesheet.bearing,
          pitch: this.stylesheet.pitch,
          sprite: this.stylesheet.sprite,
          glyphs: this.stylesheet.glyphs,
          transition: this.stylesheet.transition,
          projection: this.stylesheet.projection,
          sources: t,
          layers: this._serializeLayers(this._order)
        }, e => void 0 !== e);
      }

      _updateLayer(e) {
        this._updatedLayers[e.id] = !0;

        const t = this._getLayerSourceCache(e);

        e.source && !this._updatedSources[e.source] && t && "raster" !== t.getSource().type && (this._updatedSources[e.source] = "reload", t.pause()), this._changed = !0, e.invalidateCompiledFilter();
      }

      _flattenAndSortRenderedFeatures(e) {
        const t = e => "fill-extrusion" === this._layers[e].type,
              i = {},
              o = [];

        for (let r = this._order.length - 1; r >= 0; r--) {
          const n = this._order[r];

          if (t(n)) {
            i[n] = r;

            for (const t of e) {
              const e = t[n];
              if (e) for (const t of e) o.push(t);
            }
          }
        }

        o.sort((e, t) => t.intersectionZ - e.intersectionZ);
        const r = [];

        for (let n = this._order.length - 1; n >= 0; n--) {
          const a = this._order[n];
          if (t(a)) for (let e = o.length - 1; e >= 0; e--) {
            const t = o[e].feature;
            if (i[t.layer.id] < n) break;
            r.push(t), o.pop();
          } else for (const t of e) {
            const e = t[a];
            if (e) for (const t of e) r.push(t.feature);
          }
        }

        return r;
      }

      queryRenderedFeatures(t, i, o) {
        i && i.filter && this._validate(e.validateFilter, "queryRenderedFeatures.filter", i.filter, null, i);
        const r = {};

        if (i && i.layers) {
          if (!Array.isArray(i.layers)) return this.fire(new e.ErrorEvent(new Error("parameters.layers must be an Array."))), [];

          for (const t of i.layers) {
            const i = this._layers[t];
            if (!i) return this.fire(new e.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style and cannot be queried for features.`))), [];
            r[i.source] = !0;
          }
        }

        const n = [];
        i.availableImages = this._availableImages;
        const a = i && i.layers ? i.layers.some(e => {
          const t = this.getLayer(e);
          return t && t.is3D();
        }) : this.has3DLayers(),
              s = R.createFromScreenPoints(t, o);

        for (const e in this._sourceCaches) {
          const t = this._sourceCaches[e].getSource().id;

          i.layers && !r[t] || n.push(Ae(this._sourceCaches[e], this._layers, this._serializedLayers, s, i, o, a, !!this.map._showQueryGeometry));
        }

        return this.placement && n.push(function (e, t, i, o, r, n, a) {
          const s = {},
                l = n.queryRenderedSymbols(o),
                c = [];

          for (const e of Object.keys(l).map(Number)) c.push(a[e]);

          c.sort(Re);

          for (const i of c) {
            const o = i.featureIndex.lookupSymbolFeatures(l[i.bucketInstanceId], t, i.bucketIndex, i.sourceLayerIndex, r.filter, r.layers, r.availableImages, e);

            for (const e in o) {
              const t = s[e] = s[e] || [],
                    r = o[e];
              r.sort((e, t) => {
                const o = i.featureSortOrder;

                if (o) {
                  const i = o.indexOf(e.featureIndex);
                  return o.indexOf(t.featureIndex) - i;
                }

                return t.featureIndex - e.featureIndex;
              });

              for (const e of r) t.push(e);
            }
          }

          for (const t in s) s[t].forEach(o => {
            const r = o.feature,
                  n = i(e[t]).getFeatureState(r.layer["source-layer"], r.id);
            r.source = r.layer.source, r.layer["source-layer"] && (r.sourceLayer = r.layer["source-layer"]), r.state = n;
          });

          return s;
        }(this._layers, this._serializedLayers, this._getLayerSourceCache.bind(this), s.screenGeometry, i, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(n);
      }

      querySourceFeatures(t, i) {
        i && i.filter && this._validate(e.validateFilter, "querySourceFeatures.filter", i.filter, null, i);

        const o = this._getSourceCaches(t);

        let r = [];

        for (const e of o) r = r.concat(Le(e, i));

        return r;
      }

      addSourceType(e, t, i) {
        return $t.getSourceType(e) ? i(new Error(`A source type called "${e}" already exists.`)) : ($t.setSourceType(e, t), t.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", {
          name: e,
          url: t.workerSourceURL
        }, i) : i(null, null));
      }

      getLight() {
        return this.light.getLight();
      }

      setLight(t, i = {}) {
        this._checkLoaded();

        const o = this.light.getLight();
        let n = !1;

        for (const e in t) if (!r(t[e], o[e])) {
          n = !0;
          break;
        }

        if (!n) return;
        const a = {
          now: e.exported.now(),
          transition: e.extend({
            duration: 300,
            delay: 0
          }, this.stylesheet.transition)
        };
        this.light.setLight(t, i), this.light.updateTransitions(a);
      }

      getTerrain() {
        return this.terrain && 1 === this.terrain.drapeRenderMode ? this.terrain.get() : null;
      }

      setTerrainForDraping() {
        this.setTerrain({
          source: "",
          exaggeration: 0
        }, 0);
      }

      setTerrain(t, i = 1) {
        if (this._checkLoaded(), !t) return delete this.terrain, delete this.stylesheet.terrain, this.dispatcher.broadcast("enableTerrain", !1), this._force3DLayerUpdate(), void (this._markersNeedUpdate = !0);

        if (1 === i) {
          if ("object" == typeof t.source) {
            const i = "terrain-dem-src";
            this.addSource(i, t.source), t = e.clone$1(t), t = e.extend(t, {
              source: i
            });
          }

          if (this._validate(e.validateTerrain, "terrain", t)) return;
        }

        if (!this.terrain || this.terrain && i !== this.terrain.drapeRenderMode) this._createTerrain(t, i);else {
          const i = this.terrain,
                o = i.get();

          for (const n in t) if (!r(t[n], o[n])) {
            i.set(t), this.stylesheet.terrain = t;
            const o = {
              now: e.exported.now(),
              transition: e.extend({
                duration: 0
              }, this.stylesheet.transition)
            };
            i.updateTransitions(o);
            break;
          }
        }
        this._updateDrapeFirstLayers(), this._markersNeedUpdate = !0;
      }

      _createFog(t) {
        const i = this.fog = new P(t, this.map.transform);
        this.stylesheet.fog = t;
        const o = {
          now: e.exported.now(),
          transition: e.extend({
            duration: 0
          }, this.stylesheet.transition)
        };
        i.updateTransitions(o);
      }

      _updateMarkersOpacity() {
        0 !== this.map._markers.length && this.map._requestDomTask(() => {
          for (const e of this.map._markers) e._evaluateOpacity();
        });
      }

      getFog() {
        return this.fog ? this.fog.get() : null;
      }

      setFog(t) {
        if (this._checkLoaded(), !t) return delete this.fog, delete this.stylesheet.fog, void (this._markersNeedUpdate = !0);

        if (this.fog) {
          const i = this.fog,
                o = i.get();

          for (const n in t) if (!r(t[n], o[n])) {
            i.set(t), this.stylesheet.fog = t;
            const o = {
              now: e.exported.now(),
              transition: e.extend({
                duration: 0
              }, this.stylesheet.transition)
            };
            i.updateTransitions(o);
            break;
          }
        } else this._createFog(t);

        this._markersNeedUpdate = !0;
      }

      _updateDrapeFirstLayers() {
        if (!this.map._optimizeForTerrain || !this.terrain) return;

        const e = this._order.filter(e => this.isLayerDraped(this._layers[e])),
              t = this._order.filter(e => !this.isLayerDraped(this._layers[e]));

        this._drapedFirstOrder = [], this._drapedFirstOrder.push(...e), this._drapedFirstOrder.push(...t);
      }

      _createTerrain(t, i) {
        const o = this.terrain = new I(t, i);
        this.stylesheet.terrain = t, this.dispatcher.broadcast("enableTerrain", !this.terrainSetForDrapingOnly()), this._force3DLayerUpdate();
        const r = {
          now: e.exported.now(),
          transition: e.extend({
            duration: 0
          }, this.stylesheet.transition)
        };
        o.updateTransitions(r);
      }

      _force3DLayerUpdate() {
        for (const e in this._layers) {
          const t = this._layers[e];
          "fill-extrusion" === t.type && this._updateLayer(t);
        }
      }

      _forceSymbolLayerUpdate() {
        for (const e in this._layers) {
          const t = this._layers[e];
          "symbol" === t.type && this._updateLayer(t);
        }
      }

      _validate(t, i, o, r, n = {}) {
        return (!n || !1 !== n.validate) && Zt(this, t.call(e.validateStyle, e.extend({
          key: i,
          style: this.serialize(),
          value: o,
          styleSpec: e.spec
        }, r)));
      }

      _remove() {
        this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), e.evented.off("pluginStateChange", this._rtlTextPluginCallback);

        for (const e in this._layers) this._layers[e].setEventedParent(null);

        for (const e in this._sourceCaches) this._sourceCaches[e].clearTiles(), this._sourceCaches[e].setEventedParent(null);

        this.imageManager.setEventedParent(null), this.setEventedParent(null), this.dispatcher.remove();
      }

      _clearSource(e) {
        const t = this._getSourceCaches(e);

        for (const e of t) e.clearTiles();
      }

      _reloadSource(e) {
        const t = this._getSourceCaches(e);

        for (const e of t) e.resume(), e.reload();
      }

      _updateSources(e) {
        for (const t in this._sourceCaches) this._sourceCaches[t].update(e);
      }

      _generateCollisionBoxes() {
        for (const e in this._sourceCaches) {
          const t = this._sourceCaches[e];
          t.resume(), t.reload();
        }
      }

      _updatePlacement(t, i, o, r, n = !1) {
        let a = !1,
            s = !1;
        const l = {};

        for (const e of this._order) {
          const i = this._layers[e];
          if ("symbol" !== i.type) continue;

          if (!l[i.source]) {
            const e = this._getLayerSourceCache(i);

            if (!e) continue;
            l[i.source] = e.getRenderableIds(!0).map(t => e.getTileByID(t)).sort((e, t) => t.tileID.overscaledZ - e.tileID.overscaledZ || (e.tileID.isLessThan(t.tileID) ? -1 : 1));
          }

          const o = this.crossTileSymbolIndex.addLayer(i, l[i.source], t.center.lng, t.projection);
          a = a || o;
        }

        if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), n = n || this._layerOrderChanged || 0 === o, this._layerOrderChanged && this.fire(new e.Event("neworder")), (n || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(e.exported.now(), t.zoom)) && (this.pauseablePlacement = new Bt(t, this._order, n, i, o, r, this.placement, this.fog && t.projection.supportsFog ? this.fog.state : null), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, l), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(e.exported.now()), s = !0), a && this.pauseablePlacement.placement.setStale()), s || a) for (const e of this._order) {
          const t = this._layers[e];
          "symbol" === t.type && this.placement.updateLayerOpacities(t, l[t.source]);
        }
        return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(e.exported.now());
      }

      _releaseSymbolFadeTiles() {
        for (const e in this._sourceCaches) this._sourceCaches[e].releaseSymbolFadeTiles();
      }

      getImages(e, t, i) {
        this.imageManager.getImages(t.icons, i), this._updateTilesForChangedImages();

        const o = e => {
          e && e.setDependencies(t.tileID.key, t.type, t.icons);
        };

        o(this._otherSourceCaches[t.source]), o(this._symbolSourceCaches[t.source]);
      }

      getGlyphs(e, t, i) {
        this.glyphManager.getGlyphs(t.stacks, i);
      }

      getResource(t, i, o) {
        return e.makeRequest(i, o);
      }

      _getSourceCache(e) {
        return this._otherSourceCaches[e];
      }

      _getLayerSourceCache(e) {
        return "symbol" === e.type ? this._symbolSourceCaches[e.source] : this._otherSourceCaches[e.source];
      }

      _getSourceCaches(e) {
        const t = [];
        return this._otherSourceCaches[e] && t.push(this._otherSourceCaches[e]), this._symbolSourceCaches[e] && t.push(this._symbolSourceCaches[e]), t;
      }

      _isSourceCacheLoaded(t) {
        const i = this._getSourceCaches(t);

        return 0 === i.length ? (this.fire(new e.ErrorEvent(new Error(`There is no source with ID '${t}'`))), !1) : i.every(e => e.loaded());
      }

      has3DLayers() {
        return this._num3DLayers > 0;
      }

      hasSymbolLayers() {
        return this._numSymbolLayers > 0;
      }

      hasCircleLayers() {
        return this._numCircleLayers > 0;
      }

      _clearWorkerCaches() {
        this.dispatcher.broadcast("clearCaches");
      }

      destroy() {
        this._clearWorkerCaches(), this.terrainSetForDrapingOnly() && (delete this.terrain, delete this.stylesheet.terrain);
      }

    }

    $t.getSourceType = function (e) {
      return ze[e];
    }, $t.setSourceType = function (e, t) {
      ze[e] = t;
    }, $t.registerForPluginStateChange = e.registerForPluginStateChange;
    var Ht = "\n#define EPSILON 0.0000001\n#define PI 3.141592653589793\n#define EXTENT 8192.0\n#define HALF_PI PI/2.0\n#define QUARTER_PI PI/4.0\n#define RAD_TO_DEG 180.0/PI\n#define DEG_TO_RAD PI/180.0\n#define GLOBE_RADIUS EXTENT/PI/2.0\n#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;varying vec3 v_fog_pos;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}\n#endif",
        Kt = "attribute highp vec3 a_pos_3f;uniform lowp mat4 u_matrix;varying highp vec3 v_uv;void main() {const mat3 half_neg_pi_around_x=mat3(1.0,0.0, 0.0,0.0,0.0,-1.0,0.0,1.0, 0.0);v_uv=half_neg_pi_around_x*a_pos_3f;vec4 pos=u_matrix*vec4(a_pos_3f,1.0);gl_Position=pos.xyww;}";
    let Yt = {},
        Jt = {};
    Yt = ii("", "\n#define ELEVATION_SCALE 7.0\n#define ELEVATION_OFFSET 450.0\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_tl_up;uniform vec3 u_tile_tr_up;uniform vec3 u_tile_br_up;uniform vec3 u_tile_bl_up;uniform float u_tile_up_scale;vec3 elevationVector(vec2 pos) {vec2 uv=pos/EXTENT;vec3 up=normalize(mix(\nmix(u_tile_tl_up,u_tile_tr_up,uv.xxx),mix(u_tile_bl_up,u_tile_br_up,uv.xxx),uv.yyy));return up*u_tile_up_scale;}\n#else\nvec3 elevationVector(vec2 pos) { return vec3(0,0,1); }\n#endif\n#ifdef TERRAIN\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nuniform highp sampler2D u_dem;uniform highp sampler2D u_dem_prev;\n#else\nuniform sampler2D u_dem;uniform sampler2D u_dem_prev;\n#endif\nuniform vec4 u_dem_unpack;uniform vec2 u_dem_tl;uniform vec2 u_dem_tl_prev;uniform float u_dem_scale;uniform float u_dem_scale_prev;uniform float u_dem_size;uniform float u_dem_lerp;uniform float u_exaggeration;uniform float u_meter_to_dem;uniform mat4 u_label_plane_matrix_inv;uniform sampler2D u_depth;uniform vec2 u_depth_size_inv;vec4 tileUvToDemSample(vec2 uv,float dem_size,float dem_scale,vec2 dem_tl) {vec2 pos=dem_size*(uv*dem_scale+dem_tl)+1.0;vec2 f=fract(pos);return vec4((pos-f+0.5)/(dem_size+2.0),f);}float decodeElevation(vec4 v) {return dot(vec4(v.xyz*255.0,-1.0),u_dem_unpack);}float currentElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale+u_dem_tl)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture2D(u_dem,pos).a;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale,u_dem_tl);vec2 pos=r.xy;vec2 f=r.zw;float tl=decodeElevation(texture2D(u_dem,pos));\n#ifdef TERRAIN_DEM_NEAREST_FILTER\nreturn u_exaggeration*tl;\n#endif\nfloat tr=decodeElevation(texture2D(u_dem,pos+vec2(dd,0.0)));float bl=decodeElevation(texture2D(u_dem,pos+vec2(0.0,dd)));float br=decodeElevation(texture2D(u_dem,pos+vec2(dd,dd)));return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}float prevElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale_prev+u_dem_tl_prev)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture2D(u_dem_prev,pos).a;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale_prev,u_dem_tl_prev);vec2 pos=r.xy;vec2 f=r.zw;float tl=decodeElevation(texture2D(u_dem_prev,pos));float tr=decodeElevation(texture2D(u_dem_prev,pos+vec2(dd,0.0)));float bl=decodeElevation(texture2D(u_dem_prev,pos+vec2(0.0,dd)));float br=decodeElevation(texture2D(u_dem_prev,pos+vec2(dd,dd)));return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}\n#ifdef TERRAIN_VERTEX_MORPHING\nfloat elevation(vec2 apos) {float nextElevation=currentElevation(apos);float prevElevation=prevElevation(apos);return mix(prevElevation,nextElevation,u_dem_lerp);}\n#else\nfloat elevation(vec2 apos) {return currentElevation(apos);}\n#endif\nfloat unpack_depth(vec4 rgba_depth)\n{const vec4 bit_shift=vec4(1.0/(256.0*256.0*256.0),1.0/(256.0*256.0),1.0/256.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}bool isOccluded(vec4 frag) {vec3 coord=frag.xyz/frag.w;float depth=unpack_depth(texture2D(u_depth,(coord.xy+1.0)*0.5));return coord.z > depth+0.0005;}float occlusionFade(vec4 frag) {vec3 coord=frag.xyz/frag.w;vec3 df=vec3(5.0*u_depth_size_inv,0.0);vec2 uv=0.5*coord.xy+0.5;vec4 depth=vec4(\nunpack_depth(texture2D(u_depth,uv-df.xz)),unpack_depth(texture2D(u_depth,uv+df.xz)),unpack_depth(texture2D(u_depth,uv-df.zy)),unpack_depth(texture2D(u_depth,uv+df.zy))\n);return dot(vec4(0.25),vec4(1.0)-clamp(300.0*(vec4(coord.z-0.001)-depth),0.0,1.0));}vec4 fourSample(vec2 pos,vec2 off) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nfloat tl=texture2D(u_dem,pos).a;float tr=texture2D(u_dem,pos+vec2(off.x,0.0)).a;float bl=texture2D(u_dem,pos+vec2(0.0,off.y)).a;float br=texture2D(u_dem,pos+off).a;\n#else\nvec4 demtl=vec4(texture2D(u_dem,pos).xyz*255.0,-1.0);float tl=dot(demtl,u_dem_unpack);vec4 demtr=vec4(texture2D(u_dem,pos+vec2(off.x,0.0)).xyz*255.0,-1.0);float tr=dot(demtr,u_dem_unpack);vec4 dembl=vec4(texture2D(u_dem,pos+vec2(0.0,off.y)).xyz*255.0,-1.0);float bl=dot(dembl,u_dem_unpack);vec4 dembr=vec4(texture2D(u_dem,pos+off).xyz*255.0,-1.0);float br=dot(dembr,u_dem_unpack);\n#endif\nreturn vec4(tl,tr,bl,br);}float flatElevation(vec2 pack) {vec2 apos=floor(pack/8.0);vec2 span=10.0*(pack-apos*8.0);vec2 uvTex=(apos-vec2(1.0,1.0))/8190.0;float size=u_dem_size+2.0;float dd=1.0/size;vec2 pos=u_dem_size*(uvTex*u_dem_scale+u_dem_tl)+1.0;vec2 f=fract(pos);pos=(pos-f+0.5)*dd;vec4 h=fourSample(pos,vec2(dd));float z=mix(mix(h.x,h.y,f.x),mix(h.z,h.w,f.x),f.y);vec2 w=floor(0.5*(span*u_meter_to_dem-1.0));vec2 d=dd*w;vec4 bounds=vec4(d,vec2(1.0)-d);h=fourSample(pos-d,2.0*d+vec2(dd));vec4 diff=abs(h.xzxy-h.ywzw);vec2 slope=min(vec2(0.25),u_meter_to_dem*0.5*(diff.xz+diff.yw)/(2.0*w+vec2(1.0)));vec2 fix=slope*span;float base=z+max(fix.x,fix.y);return u_exaggeration*base;}float elevationFromUint16(float word) {return u_exaggeration*(word/ELEVATION_SCALE-ELEVATION_OFFSET);}\n#else\nfloat elevation(vec2 pos) { return 0.0; }bool isOccluded(vec4 frag) { return false; }float occlusionFade(vec4 frag) { return 1.0; }\n#endif", !0), Jt = ii("#ifdef FOG\nuniform float u_fog_temporal_offset;float fog_opacity(vec3 pos) {float depth=length(pos);return fog_opacity(fog_range(depth));}vec3 fog_apply(vec3 color,vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));opacity*=fog_horizon_blending(pos/depth);return mix(color,u_fog_color.rgb,opacity);}vec4 fog_apply_from_vert(vec4 color,float fog_opac) {float alpha=EPSILON+color.a;color.rgb=mix(color.rgb/alpha,u_fog_color.rgb,fog_opac)*alpha;return color;}vec3 fog_apply_sky_gradient(vec3 camera_ray,vec3 sky_color) {float horizon_blend=fog_horizon_blending(normalize(camera_ray));return mix(sky_color,u_fog_color.rgb,horizon_blend);}vec4 fog_apply_premultiplied(vec4 color,vec3 pos) {float alpha=EPSILON+color.a;color.rgb=fog_apply(color.rgb/alpha,pos)*alpha;return color;}vec3 fog_dither(vec3 color) {vec2 dither_seed=gl_FragCoord.xy+u_fog_temporal_offset;return dither(color,dither_seed);}vec4 fog_dither(vec4 color) {return vec4(fog_dither(color.rgb),color.a);}\n#endif", "#ifdef FOG\nuniform mat4 u_fog_matrix;vec3 fog_position(vec3 pos) {return (u_fog_matrix*vec4(pos,1.0)).xyz;}vec3 fog_position(vec2 pos) {return fog_position(vec3(pos,0.0));}float fog(vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));return opacity*fog_horizon_blending(pos/depth);}\n#endif", !0);
    const Qt = ii("\nhighp vec3 hash(highp vec2 p) {highp vec3 p3=fract(p.xyx*vec3(443.8975,397.2973,491.1871));p3+=dot(p3,p3.yxz+19.19);return fract((p3.xxy+p3.yzz)*p3.zyx);}vec3 dither(vec3 color,highp vec2 seed) {vec3 rnd=hash(seed)+hash(seed+0.59374)-0.5;return color+rnd/255.0;}\n#ifdef TERRAIN\nhighp vec4 pack_depth(highp float ndc_z) {highp float depth=ndc_z*0.5+0.5;const highp vec4 bit_shift=vec4(256.0*256.0*256.0,256.0*256.0,256.0,1.0);const highp vec4 bit_mask =vec4(0.0,1.0/256.0,1.0/256.0,1.0/256.0);highp vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}\n#endif", "\nfloat wrap(float n,float min,float max) {float d=max-min;float w=mod(mod(n-min,d)+d,d)+min;return (w==min) ? max : w;}\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 mercator_tile_position(mat4 matrix,vec2 tile_anchor,vec3 tile_id,vec2 mercator_center) {\n#ifndef PROJECTED_POS_ON_VIEWPORT\nfloat tiles=tile_id.z;vec2 mercator=(tile_anchor/EXTENT+tile_id.xy)/tiles;mercator-=mercator_center;mercator.x=wrap(mercator.x,-0.5,0.5);vec4 mercator_tile=vec4(mercator.xy*EXTENT,EXTENT/(2.0*PI),1.0);mercator_tile=matrix*mercator_tile;return mercator_tile.xyz;\n#else\nreturn vec3(0.0);\n#endif\n}vec3 mix_globe_mercator(vec3 globe,vec3 mercator,float t) {return mix(globe,mercator,t);}mat3 globe_mercator_surface_vectors(vec3 pos_normal,vec3 up_dir,float zoom_transition) {vec3 normal=zoom_transition==0.0 ? pos_normal : normalize(mix(pos_normal,up_dir,zoom_transition));vec3 xAxis=normalize(vec3(normal.z,0.0,-normal.x));vec3 yAxis=normalize(cross(normal,xAxis));return mat3(xAxis,yAxis,normal);}\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(\nunpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}const vec4 AWAY=vec4(-1000.0,-1000.0,-1000.0,1);//Normalized device coordinate that is not rendered."),
          ei = Ht;
    var ti = {
      background: ii("uniform vec4 u_color;uniform float u_opacity;void main() {vec4 out_color=u_color;\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
      backgroundPattern: ii("uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 out_color=mix(color1,color2,u_mix);\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
      circle: ii("varying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(\nantialiased_blur,0.0,extrude_length-radius/(radius+stroke_width)\n);vec4 out_color=mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef FOG\nout_color=fog_apply_premultiplied(out_color,v_fog_pos);\n#endif\ngl_FragColor=out_color*(v_visibility*opacity_t);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "#define NUM_VISIBILITY_RINGS 2\n#define INV_SQRT2 0.70710678\n#define ELEVATION_BIAS 0.0001\n#define NUM_SAMPLES_PER_RING 16\nuniform mat4 u_matrix;uniform mat2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;attribute float a_scale;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nvarying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvec2 calc_offset(vec2 extrusion,float radius,float stroke_width, float view_scale) {return extrusion*(radius+stroke_width)*u_extrude_scale*view_scale;}float cantilevered_elevation(vec2 pos,float radius,float stroke_width,float view_scale) {vec2 c1=pos+calc_offset(vec2(-1,-1),radius,stroke_width,view_scale);vec2 c2=pos+calc_offset(vec2(1,-1),radius,stroke_width,view_scale);vec2 c3=pos+calc_offset(vec2(1,1),radius,stroke_width,view_scale);vec2 c4=pos+calc_offset(vec2(-1,1),radius,stroke_width,view_scale);float h1=elevation(c1)+ELEVATION_BIAS;float h2=elevation(c2)+ELEVATION_BIAS;float h3=elevation(c3)+ELEVATION_BIAS;float h4=elevation(c4)+ELEVATION_BIAS;return max(h4,max(h3,max(h1,h2)));}float circle_elevation(vec2 pos) {\n#if defined(TERRAIN)\nreturn elevation(pos)+ELEVATION_BIAS;\n#else\nreturn 0.0;\n#endif\n}vec4 project_vertex(vec2 extrusion,vec4 world_center,vec4 projected_center,float radius,float stroke_width, float view_scale,mat3 surface_vectors) {vec2 sample_offset=calc_offset(extrusion,radius,stroke_width,view_scale);\n#ifdef PITCH_WITH_MAP\n#ifdef PROJECTION_GLOBE_VIEW\nreturn u_matrix*( world_center+vec4(sample_offset.x*surface_vectors[0]+sample_offset.y*surface_vectors[1],0) );\n#else\nreturn u_matrix*( world_center+vec4(sample_offset,0,0) );\n#endif\n#else\nreturn projected_center+vec4(sample_offset,0,0);\n#endif\n}float get_sample_step() {\n#ifdef PITCH_WITH_MAP\nreturn 2.0*PI/float(NUM_SAMPLES_PER_RING);\n#else\nreturn PI/float(NUM_SAMPLES_PER_RING);\n#endif\n}void main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);\n#ifdef PROJECTION_GLOBE_VIEW\nvec2 scaled_extrude=extrude*a_scale;vec3 pos_normal_3=a_pos_normal_3/16384.0;mat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=scaled_extrude.x*surface_vectors[0]+scaled_extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(circle_center)*circle_elevation(circle_center);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*circle_elevation(circle_center);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,circle_center,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;vec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);vec4 world_center=vec4(pos,1);\n#else \nmat3 surface_vectors=mat3(1.0);float height=circle_elevation(circle_center);vec4 world_center=vec4(circle_center,height,1);\n#endif\nvec4 projected_center=u_matrix*world_center;float view_scale=0.0;\n#ifdef PITCH_WITH_MAP\n#ifdef SCALE_WITH_MAP\nview_scale=1.0;\n#else\nview_scale=projected_center.w/u_camera_to_center_distance;\n#endif\n#else\n#ifdef SCALE_WITH_MAP\nview_scale=u_camera_to_center_distance;\n#else\nview_scale=projected_center.w;\n#endif\n#endif\n#if defined(SCALE_WITH_MAP) && defined(PROJECTION_GLOBE_VIEW)\nview_scale*=a_scale;\n#endif\ngl_Position=project_vertex(extrude,world_center,projected_center,radius,stroke_width,view_scale,surface_vectors);float visibility=0.0;\n#ifdef TERRAIN\nfloat step=get_sample_step();\n#ifdef PITCH_WITH_MAP\nfloat cantilevered_height=cantilevered_elevation(circle_center,radius,stroke_width,view_scale);vec4 occlusion_world_center=vec4(circle_center,cantilevered_height,1);vec4 occlusion_projected_center=u_matrix*occlusion_world_center;\n#else\nvec4 occlusion_world_center=world_center;vec4 occlusion_projected_center=projected_center;\n#endif\nfor(int ring=0; ring < NUM_VISIBILITY_RINGS; ring++) {float scale=(float(ring)+1.0)/float(NUM_VISIBILITY_RINGS);for(int i=0; i < NUM_SAMPLES_PER_RING; i++) {vec2 extrusion=vec2(cos(step*float(i)),-sin(step*float(i)))*scale;vec4 frag_pos=project_vertex(extrusion,occlusion_world_center,occlusion_projected_center,radius,stroke_width,view_scale,surface_vectors);visibility+=float(!isOccluded(frag_pos));}}visibility/=float(NUM_VISIBILITY_RINGS)*float(NUM_SAMPLES_PER_RING);\n#else\nvisibility=1.0;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nvisibility=1.0;\n#endif\nv_visibility=visibility;lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);\n#ifdef FOG\nv_fog_pos=fog_position(world_center.xyz);\n#endif\n}"),
      clippingMask: ii("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"),
      heatmap: ii("uniform highp float u_intensity;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);\n#ifdef FOG\ngl_FragColor.r*=pow(1.0-fog_opacity(v_fog_pos),2.0);\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;attribute float a_scale;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nvarying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 tilePos=floor(a_pos*0.5);\n#ifdef PROJECTION_GLOBE_VIEW\nextrude*=a_scale;vec3 pos_normal_3=a_pos_normal_3/16384.0;mat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(tilePos)*elevation(tilePos);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*elevation(tilePos);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,tilePos,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;vec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#else\nvec3 pos=vec3(tilePos+extrude,elevation(tilePos));\n#endif\ngl_Position=u_matrix*vec4(pos,1);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"),
      heatmapTexture: ii("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(0.0);\n#endif\n}", "attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=vec4(a_pos,0,1);v_pos=a_pos*0.5+0.5;}"),
      collisionBox: ii("varying float v_placed;varying float v_notUsed;void main() {vec4 red =vec4(1.0,0.0,0.0,1.0);vec4 blue=vec4(0.0,0.0,1.0,0.5);gl_FragColor =mix(red,blue,step(0.5,v_placed))*0.5;gl_FragColor*=mix(1.0,0.1,step(0.5,v_notUsed));}", "attribute vec3 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;attribute float a_size_scale;attribute vec2 a_padding;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_pos+elevationVector(a_anchor_pos)*elevation(a_anchor_pos),1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,1.5);gl_Position=projectedPoint;gl_Position.xy+=(a_extrude*a_size_scale+a_shift+a_padding)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}"),
      collisionCircle: ii("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos_2f;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos_2f;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(\nmix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"),
      debug: ii("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;\n#endif\nvarying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {float h=elevation(a_pos);v_uv=a_pos/8192.0;\n#ifdef PROJECTION_GLOBE_VIEW\ngl_Position=u_matrix*vec4(a_pos_3+elevationVector(a_pos)*h,1);\n#else\ngl_Position=u_matrix*vec4(a_pos*u_overlay_scale,h,1);\n#endif\n}"),
      fill: ii("#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\nvec4 out_color=color;\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
      fillOutline: ii("varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=outline_color;\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
      fillOutlinePattern: ii("uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=mix(color1,color2,u_fade);\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
      fillPattern: ii("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 out_color=mix(color1,color2,u_fade);\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
      fillExtrusion: ii("varying vec4 v_color;void main() {vec4 color=v_color;\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;attribute vec4 a_pos_normal_ed;attribute vec2 a_centroid_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\nvarying vec4 v_color;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec3 pos_nx=floor(a_pos_normal_ed.xyz*0.5);mediump vec3 top_up_ny=a_pos_normal_ed.xyz-2.0*pos_nx;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;float ele=elevation(pos_nx.xy);float c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;float h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);vec3 pos=vec3(pos_nx.xy,h);\n#else\nvec3 pos=vec3(pos_nx.xy,t > 0.0 ? height : base);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*(pos.z+lift));vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,pos.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*pos.z;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;float directional=clamp(dot(normal,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.rgb+=clamp(color.rgb*directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_color*=u_opacity;\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"),
      fillExtrusionPattern: ii("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 out_color=mix(color1,color2,u_fade);out_color=out_color*v_lighting;\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec4 a_pos_normal_ed;attribute vec2 a_centroid_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\nvarying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 pos_nx=floor(a_pos_normal_ed.xyz*0.5);mediump vec3 top_up_ny=a_pos_normal_ed.xyz-2.0*pos_nx;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));float edgedistance=a_pos_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;float z=t > 0.0 ? height : base;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;float ele=elevation(pos_nx.xy);float c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;float h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);vec3 p=vec3(pos_nx.xy,h);\n#else\nvec3 p=vec3(pos_nx.xy,z);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*(p.z+lift));vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,p.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*p.z;p=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(p,1),AWAY,hidden);vec2 pos=normal.z==1.0\n? pos_nx.xy\n: vec2(edgedistance,z*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;\n#ifdef FOG\nv_fog_pos=fog_position(p);\n#endif\n}"),
      hillshadePrepare: ii("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nreturn texture2D(u_image,coord).a/4.0;\n#else\nvec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;\n#endif\n}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y));float b=getElevation(v_pos+vec2(0,-epsilon.y));float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y));float d=getElevation(v_pos+vec2(-epsilon.x,0));float e=getElevation(v_pos);float f=getElevation(v_pos+vec2(epsilon.x,0));float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y));float h=getElevation(v_pos+vec2(0,epsilon.y));float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y));float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2(\n(c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c)\n)/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(\nderiv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"),
      hillshade: ii("uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;void main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef FOG\ngl_FragColor=fog_dither(fog_apply_premultiplied(gl_FragColor,v_fog_pos));\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
      line: ii("uniform lowp float u_device_pixel_ratio;uniform float u_alpha_discard_threshold;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;\n#ifdef RENDER_LINE_DASH\nuniform sampler2D u_dash_image;uniform float u_mix;uniform vec3 u_scale;varying vec2 v_tex_a;varying vec2 v_tex_b;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform sampler2D u_gradient_image;varying highp vec2 v_uv;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash_from\n#pragma mapbox: define lowp vec4 dash_to\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash_from\n#pragma mapbox: initialize lowp vec4 dash_to\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);\n#ifdef RENDER_LINE_DASH\nfloat sdfdist_a=texture2D(u_dash_image,v_tex_a).a;float sdfdist_b=texture2D(u_dash_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);float sdfwidth=min(dash_from.z*u_scale.y,dash_to.z*u_scale.z);float sdfgamma=1.0/(2.0*u_device_pixel_ratio)/sdfwidth;alpha*=smoothstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);\n#endif\n#ifdef RENDER_LINE_GRADIENT\nvec4 out_color=texture2D(u_gradient_image,v_uv);\n#else\nvec4 out_color=color;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\n#ifdef RENDER_LINE_ALPHA_DISCARD\nif (alpha < u_alpha_discard_threshold) {discard;}\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define EXTRUDE_SCALE 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;\n#ifdef RENDER_LINE_GRADIENT\nattribute vec3 a_packed;\n#else\nattribute float a_linesofar;\n#endif\nuniform mat4 u_matrix;uniform mat2 u_pixels_to_tile_units;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;\n#ifdef RENDER_LINE_DASH\nuniform vec2 u_texsize;uniform mediump vec3 u_scale;varying vec2 v_tex_a;varying vec2 v_tex_b;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform float u_image_height;varying highp vec2 v_uv;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash_from\n#pragma mapbox: define lowp vec4 dash_to\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash_from\n#pragma mapbox: initialize lowp vec4 dash_to\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*EXTRUDE_SCALE;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*EXTRUDE_SCALE*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nfloat a_uv_x=a_packed[0];float a_split_index=a_packed[1];float a_linesofar=a_packed[2];highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);\n#endif\n#ifdef RENDER_LINE_DASH\nfloat tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;float scaleA=dash_from.z==0.0 ? 0.0 : tileZoomRatio/(dash_from.z*fromScale);float scaleB=dash_to.z==0.0 ? 0.0 : tileZoomRatio/(dash_to.z*toScale);float heightA=dash_from.y;float heightB=dash_to.y;v_tex_a=vec2(a_linesofar*scaleA/floorwidth,(-normal.y*heightA+dash_from.x+0.5)/u_texsize.y);v_tex_b=vec2(a_linesofar*scaleB/floorwidth,(-normal.y*heightB+dash_to.x+0.5)/u_texsize.y);\n#endif\nv_width2=vec2(outset,inset);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"),
      linePattern: ii("uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_linesofar;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mat2 u_pixels_to_tile_units;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"),
      raster: ii("uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(\ndot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);vec3 out_color=mix(u_high_vec,u_low_vec,rgb);\n#ifdef FOG\nout_color=fog_dither(fog_apply(out_color,v_fog_pos));\n#endif\ngl_FragColor=vec4(out_color*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform vec2 u_perspective_transform;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {float w=1.0+dot(a_texture_pos,u_perspective_transform);gl_Position=u_matrix*vec4(a_pos*w,0,w);v_pos0=a_texture_pos/8192.0;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
      symbolIcon: ii("uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_pixeloffset;attribute vec4 a_z_tile_anchor;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nvarying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_min_font_scale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}float anchor_z=a_z_tile_anchor.x;vec2 tile_anchor=a_z_tile_anchor.yz;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 mercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);vec3 world_pos=mix_globe_mercator(vec3(a_pos,anchor_z)+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;float globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nvec3 world_pos=vec3(a_pos,anchor_z)+h;float globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjected_point=u_matrix*vec4(a_pos+vec2(1,0),anchor_z,1);vec2 a=projected_point.xy/projected_point.w;vec2 b=offsetProjected_point.xy/offsetProjected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(vec3(a_projected_pos.xy,anchor_z),mercator_pos,u_zoom_transition);\n#else\nvec3 proj_pos=vec3(a_projected_pos.xy,anchor_z);\n#endif\n#ifdef PROJECTED_POS_ON_VIEWPORT\nvec4 projected_pos=u_label_plane_matrix*vec4(proj_pos.xy,0.0,1.0);\n#else\nvec4 projected_pos=u_label_plane_matrix*vec4(proj_pos.xyz+h,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*max(a_min_font_scale,font_scale)+a_pxoffset/16.0);\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;gl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nv_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;v_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change))*projection_transition_fade;}"),
      symbolSDF: ii("#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_pixeloffset;attribute vec4 a_z_tile_anchor;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nvarying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}float anchor_z=a_z_tile_anchor.x;vec2 tile_anchor=a_z_tile_anchor.yz;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 mercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);vec3 world_pos=mix_globe_mercator(vec3(a_pos,anchor_z)+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;float globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nvec3 world_pos=vec3(a_pos,anchor_z)+h;float globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetprojected_point=u_matrix*vec4(a_pos+vec2(1,0),anchor_z,1);vec2 a=projected_point.xy/projected_point.w;vec2 b=offsetprojected_point.xy/offsetprojected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(vec3(a_projected_pos.xy,anchor_z),mercator_pos,u_zoom_transition);\n#else\nvec3 proj_pos=vec3(a_projected_pos.xy,anchor_z);\n#endif\n#ifdef PROJECTED_POS_ON_VIEWPORT\nvec4 projected_pos=u_label_plane_matrix*vec4(proj_pos.xy,0.0,1.0);\n#else\nvec4 projected_pos=u_label_plane_matrix*vec4(proj_pos.xyz+h,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset);\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;gl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));float gamma_scale=gl_Position.w;float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nvec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity*projection_transition_fade);}"),
      symbolTextAndIcon: ii("#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_z_tile_anchor;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nvarying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}float anchor_z=a_z_tile_anchor.x;vec2 tile_anchor=a_z_tile_anchor.yz;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 mercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);vec3 world_pos=mix_globe_mercator(vec3(a_pos,anchor_z)+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;float globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nvec3 world_pos=vec3(a_pos,anchor_z)+h;float globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offset_projected_point=u_matrix*vec4(a_pos+vec2(1,0),anchor_z,1);vec2 a=projected_point.xy/projected_point.w;vec2 b=offset_projected_point.xy/offset_projected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(vec3(a_projected_pos.xy,anchor_z),mercator_pos,u_zoom_transition);\n#else\nvec3 proj_pos=vec3(a_projected_pos.xy,anchor_z);\n#endif\n#ifdef PROJECTED_POS_ON_VIEWPORT\nvec4 projected_pos=u_label_plane_matrix*vec4(proj_pos.xy,0.0,1.0);\n#else\nvec4 projected_pos=u_label_plane_matrix*vec4(proj_pos.xyz+h,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*font_scale);\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;gl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nv_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity*projection_transition_fade,is_sdf);}"),
      terrainRaster: ii("uniform sampler2D u_image0;varying vec2 v_pos0;\n#ifdef FOG\nvarying float v_fog_opacity;\n#endif\nvoid main() {vec4 color=texture2D(u_image0,v_pos0);\n#ifdef FOG\ncolor=fog_dither(fog_apply_from_vert(color,v_fog_opacity));\n#endif\ngl_FragColor=color;\n#ifdef TERRAIN_WIREFRAME\ngl_FragColor=vec4(1.0,0.0,0.0,0.8);\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform float u_skirt_height;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;\n#ifdef FOG\nvarying float v_fog_opacity;\n#endif\nconst float skirtOffset=24575.0;const float wireframeOffset=0.00015;void main() {v_pos0=a_texture_pos/8192.0;float skirt=float(a_pos.x >=skirtOffset);float elevation=elevation(a_texture_pos)-skirt*u_skirt_height;\n#ifdef TERRAIN_WIREFRAME\nelevation+=u_skirt_height*u_skirt_height*wireframeOffset;\n#endif\nvec2 decodedPos=a_pos-vec2(skirt*skirtOffset,0.0);gl_Position=u_matrix*vec4(decodedPos,elevation,1.0);\n#ifdef FOG\nv_fog_opacity=fog(fog_position(vec3(decodedPos,elevation)));\n#endif\n}"),
      terrainDepth: ii("#ifdef GL_ES\nprecision highp float;\n#endif\nvarying float v_depth;void main() {gl_FragColor=pack_depth(v_depth);}", "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying float v_depth;void main() {float elevation=elevation(a_texture_pos);gl_Position=u_matrix*vec4(a_pos,elevation,1.0);v_depth=gl_Position.z/gl_Position.w;}"),
      skybox: ii("\nvarying lowp vec3 v_uv;uniform lowp samplerCube u_cubemap;uniform lowp float u_opacity;uniform highp float u_temporal_offset;uniform highp vec3 u_sun_direction;float sun_disk(highp vec3 ray_direction,highp vec3 sun_direction) {highp float cos_angle=dot(normalize(ray_direction),sun_direction);const highp float cos_sun_angular_diameter=0.99996192306;const highp float smoothstep_delta=1e-5;return smoothstep(\ncos_sun_angular_diameter-smoothstep_delta,cos_sun_angular_diameter+smoothstep_delta,cos_angle);}float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec3 uv=v_uv;const float y_bias=0.015;uv.y+=y_bias;uv.y=pow(abs(uv.y),1.0/5.0);uv.y=map(uv.y,0.0,1.0,-1.0,1.0);vec3 sky_color=textureCube(u_cubemap,uv).rgb;\n#ifdef FOG\nsky_color=fog_apply_sky_gradient(v_uv.xzy,sky_color);\n#endif\nsky_color.rgb=dither(sky_color.rgb,gl_FragCoord.xy+u_temporal_offset);sky_color+=0.1*sun_disk(v_uv,u_sun_direction);gl_FragColor=vec4(sky_color*u_opacity,u_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", Kt),
      skyboxGradient: ii("varying highp vec3 v_uv;uniform lowp sampler2D u_color_ramp;uniform highp vec3 u_center_direction;uniform lowp float u_radius;uniform lowp float u_opacity;uniform highp float u_temporal_offset;void main() {float progress=acos(dot(normalize(v_uv),u_center_direction))/u_radius;vec4 color=texture2D(u_color_ramp,vec2(progress,0.5));\n#ifdef FOG\ncolor.rgb=fog_apply_sky_gradient(v_uv.xzy,color.rgb/color.a)*color.a;\n#endif\ncolor*=u_opacity;color.rgb=dither(color.rgb,gl_FragCoord.xy+u_temporal_offset);gl_FragColor=color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", Kt),
      skyboxCapture: ii("\nvarying highp vec3 v_position;uniform highp float u_sun_intensity;uniform highp float u_luminance;uniform lowp vec3 u_sun_direction;uniform highp vec4 u_color_tint_r;uniform highp vec4 u_color_tint_m;\n#ifdef GL_ES\nprecision highp float;\n#endif\n#define BETA_R                  vec3(5.5e-6,13.0e-6,22.4e-6)\n#define BETA_M                  vec3(21e-6,21e-6,21e-6)\n#define MIE_G                   0.76\n#define DENSITY_HEIGHT_SCALE_R  8000.0\n#define DENSITY_HEIGHT_SCALE_M  1200.0\n#define PLANET_RADIUS           6360e3\n#define ATMOSPHERE_RADIUS       6420e3\n#define SAMPLE_STEPS            10\n#define DENSITY_STEPS           4\nfloat ray_sphere_exit(vec3 orig,vec3 dir,float radius) {float a=dot(dir,dir);float b=2.0*dot(dir,orig);float c=dot(orig,orig)-radius*radius;float d=sqrt(b*b-4.0*a*c);return (-b+d)/(2.0*a);}vec3 extinction(vec2 density) {return exp(-vec3(BETA_R*u_color_tint_r.a*density.x+BETA_M*u_color_tint_m.a*density.y));}vec2 local_density(vec3 point) {float height=max(length(point)-PLANET_RADIUS,0.0);float exp_r=exp(-height/DENSITY_HEIGHT_SCALE_R);float exp_m=exp(-height/DENSITY_HEIGHT_SCALE_M);return vec2(exp_r,exp_m);}float phase_ray(float cos_angle) {return (3.0/(16.0*PI))*(1.0+cos_angle*cos_angle);}float phase_mie(float cos_angle) {return (3.0/(8.0*PI))*((1.0-MIE_G*MIE_G)*(1.0+cos_angle*cos_angle))/((2.0+MIE_G*MIE_G)*pow(1.0+MIE_G*MIE_G-2.0*MIE_G*cos_angle,1.5));}vec2 density_to_atmosphere(vec3 point,vec3 light_dir) {float ray_len=ray_sphere_exit(point,light_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(DENSITY_STEPS);vec2 density_point_to_atmosphere=vec2(0.0);for (int i=0; i < DENSITY_STEPS;++i) {vec3 point_on_ray=point+light_dir*((float(i)+0.5)*step_len);density_point_to_atmosphere+=local_density(point_on_ray)*step_len;;}return density_point_to_atmosphere;}vec3 atmosphere(vec3 ray_dir,vec3 sun_direction,float sun_intensity) {vec2 density_orig_to_point=vec2(0.0);vec3 scatter_r=vec3(0.0);vec3 scatter_m=vec3(0.0);vec3 origin=vec3(0.0,PLANET_RADIUS,0.0);float ray_len=ray_sphere_exit(origin,ray_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(SAMPLE_STEPS);for (int i=0; i < SAMPLE_STEPS;++i) {vec3 point_on_ray=origin+ray_dir*((float(i)+0.5)*step_len);vec2 density=local_density(point_on_ray)*step_len;density_orig_to_point+=density;vec2 density_point_to_atmosphere=density_to_atmosphere(point_on_ray,sun_direction);vec2 density_orig_to_atmosphere=density_orig_to_point+density_point_to_atmosphere;vec3 extinction=extinction(density_orig_to_atmosphere);scatter_r+=density.x*extinction;scatter_m+=density.y*extinction;}float cos_angle=dot(ray_dir,sun_direction);float phase_r=phase_ray(cos_angle);float phase_m=phase_mie(cos_angle);vec3 beta_r=BETA_R*u_color_tint_r.rgb*u_color_tint_r.a;vec3 beta_m=BETA_M*u_color_tint_m.rgb*u_color_tint_m.a;return (scatter_r*phase_r*beta_r+scatter_m*phase_m*beta_m)*sun_intensity;}const float A=0.15;const float B=0.50;const float C=0.10;const float D=0.20;const float E=0.02;const float F=0.30;vec3 uncharted2_tonemap(vec3 x) {return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}void main() {vec3 ray_direction=v_position;ray_direction.y=pow(ray_direction.y,5.0);const float y_bias=0.015;ray_direction.y+=y_bias;vec3 color=atmosphere(normalize(ray_direction),u_sun_direction,u_sun_intensity);float white_scale=1.0748724675633854;color=uncharted2_tonemap((log2(2.0/pow(u_luminance,4.0)))*color)*white_scale;gl_FragColor=vec4(color,1.0);}", "attribute highp vec3 a_pos_3f;uniform mat3 u_matrix_3f;varying highp vec3 v_position;float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec4 pos=vec4(u_matrix_3f*a_pos_3f,1.0);v_position=pos.xyz;v_position.y*=-1.0;v_position.y=map(v_position.y,-1.0,1.0,0.0,1.0);gl_Position=vec4(a_pos_3f.xy,0.0,1.0);}"),
      globeRaster: ii("uniform sampler2D u_image0;varying vec2 v_pos0;void main() {gl_FragColor=texture2D(u_image0,v_pos0);\n#ifdef TERRAIN_WIREFRAME\ngl_FragColor=vec4(1.0,0.0,0.0,0.8);\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_proj_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform float u_zoom_transition;uniform vec2 u_merc_center;uniform mat3 u_grid_matrix;\n#ifdef GLOBE_POLES\nattribute vec3 a_globe_pos;attribute vec2 a_merc_pos;attribute vec2 a_uv;\n#else\nattribute vec2 a_pos;\n#endif\nvarying vec2 v_pos0;const float wireframeOffset=1e3;float mercatorXfromLng(float lng) {return (180.0+lng)/360.0;}float mercatorYfromLat(float lat) {return (180.0-(RAD_TO_DEG*log(tan(QUARTER_PI+lat/2.0*DEG_TO_RAD))))/360.0;}vec3 latLngToECEF(vec2 latLng) {latLng=DEG_TO_RAD*latLng;float cosLat=cos(latLng[0]);float sinLat=sin(latLng[0]);float cosLng=cos(latLng[1]);float sinLng=sin(latLng[1]);float sx=cosLat*sinLng*GLOBE_RADIUS;float sy=-sinLat*GLOBE_RADIUS;float sz=cosLat*cosLng*GLOBE_RADIUS;return vec3(sx,sy,sz);}void main() {\n#ifdef GLOBE_POLES\nvec3 globe_pos=a_globe_pos;vec2 merc_pos=a_merc_pos;vec2 uv=a_uv;\n#else\nfloat tiles=u_grid_matrix[0][2];float idy=u_grid_matrix[1][2];float S=u_grid_matrix[2][2];vec3 latLng=u_grid_matrix*vec3(a_pos,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float uvY=mercatorY*tiles-idy;float mercatorX=mercatorXfromLng(latLng[1]);float uvX=a_pos[0]*S;vec3 globe_pos=latLngToECEF(latLng.xy);vec2 merc_pos=vec2(mercatorX,mercatorY);vec2 uv=vec2(uvX,uvY);\n#endif\nv_pos0=uv;uv=uv*EXTENT;vec4 up_vector=vec4(elevationVector(uv),1.0);float height=elevation(uv);\n#ifdef TERRAIN_WIREFRAME\nheight+=wireframeOffset;\n#endif\nvec4 globe=u_globe_matrix*vec4(globe_pos+up_vector.xyz*height,1.0);vec4 mercator=vec4(0.0);if (u_zoom_transition > 0.0) {mercator=vec4(merc_pos,height,1.0);mercator.xy-=u_merc_center;mercator.x=wrap(mercator.x,-0.5,0.5);mercator=u_merc_matrix*mercator;}vec3 position=mix(globe.xyz,mercator.xyz,u_zoom_transition);gl_Position=u_proj_matrix*vec4(position,1.0);}"),
      globeAtmosphere: ii("uniform float u_opacity;uniform highp float u_fadeout_range;uniform vec3 u_start_color;uniform vec3 u_end_color;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;varying highp vec3 v_ray_dir;void main() {highp vec3 dir=normalize(v_ray_dir);highp vec3 closest_point=abs(dot(u_globe_pos,dir))*dir;float norm_dist_from_center=length(closest_point-u_globe_pos)/u_globe_radius;if (norm_dist_from_center < 1.0)\ndiscard;float t=clamp(1.0-sqrt(norm_dist_from_center-1.0)/u_fadeout_range,0.0,1.0);vec3 color=mix(u_start_color,u_end_color,1.0-t);gl_FragColor=vec4(color*t*u_opacity,u_opacity);}", "attribute vec3 a_pos;attribute vec2 a_uv;uniform vec3 u_frustum_tl;uniform vec3 u_frustum_tr;uniform vec3 u_frustum_br;uniform vec3 u_frustum_bl;varying highp vec3 v_ray_dir;void main() {v_ray_dir=mix(mix(u_frustum_tl,u_frustum_tr,a_uv.x),mix(u_frustum_bl,u_frustum_br,a_uv.x),a_uv.y);gl_Position=vec4(a_pos,1.0);}")
    };

    function ii(e, t, i) {
      const o = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g,
            r = /uniform (highp |mediump |lowp )?([\w]+) ([\w]+)([\s]*)([\w]*)/g,
            n = t.match(/attribute (highp |mediump |lowp )?([\w]+) ([\w]+)/g),
            a = e.match(r),
            s = t.match(r),
            l = Ht.match(r);
      let c = s ? s.concat(a) : a;
      i || (Yt.staticUniforms && (c = Yt.staticUniforms.concat(c)), Jt.staticUniforms && (c = Jt.staticUniforms.concat(c))), c && (c = c.concat(l));
      const h = {};
      return {
        fragmentSource: e = e.replace(o, (e, t, i, o, r) => (h[r] = !0, "define" === t ? `\n#ifndef HAS_UNIFORM_u_${r}\nvarying ${i} ${o} ${r};\n#else\nuniform ${i} ${o} u_${r};\n#endif\n` : `\n#ifdef HAS_UNIFORM_u_${r}\n    ${i} ${o} ${r} = u_${r};\n#endif\n`)),
        vertexSource: t = t.replace(o, (e, t, i, o, r) => {
          const n = "float" === o ? "vec2" : "vec4",
                a = r.match(/color/) ? "color" : n;
          return h[r] ? "define" === t ? `\n#ifndef HAS_UNIFORM_u_${r}\nuniform lowp float u_${r}_t;\nattribute ${i} ${n} a_${r};\nvarying ${i} ${o} ${r};\n#else\nuniform ${i} ${o} u_${r};\n#endif\n` : "vec4" === a ? `\n#ifndef HAS_UNIFORM_u_${r}\n    ${r} = a_${r};\n#else\n    ${i} ${o} ${r} = u_${r};\n#endif\n` : `\n#ifndef HAS_UNIFORM_u_${r}\n    ${r} = unpack_mix_${a}(a_${r}, u_${r}_t);\n#else\n    ${i} ${o} ${r} = u_${r};\n#endif\n` : "define" === t ? `\n#ifndef HAS_UNIFORM_u_${r}\nuniform lowp float u_${r}_t;\nattribute ${i} ${n} a_${r};\n#else\nuniform ${i} ${o} u_${r};\n#endif\n` : "vec4" === a ? `\n#ifndef HAS_UNIFORM_u_${r}\n    ${i} ${o} ${r} = a_${r};\n#else\n    ${i} ${o} ${r} = u_${r};\n#endif\n` : `\n#ifndef HAS_UNIFORM_u_${r}\n    ${i} ${o} ${r} = unpack_mix_${a}(a_${r}, u_${r}_t);\n#else\n    ${i} ${o} ${r} = u_${r};\n#endif\n`;
        }),
        staticAttributes: n,
        staticUniforms: c
      };
    }

    class oi {
      constructor() {
        this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
      }

      bind(e, t, i, o, r, n, a, s) {
        this.context = e;
        let l = this.boundPaintVertexBuffers.length !== o.length;

        for (let e = 0; !l && e < o.length; e++) this.boundPaintVertexBuffers[e] !== o[e] && (l = !0);

        e.extVertexArrayObject && this.vao && this.boundProgram === t && this.boundLayoutVertexBuffer === i && !l && this.boundIndexBuffer === r && this.boundVertexOffset === n && this.boundDynamicVertexBuffer === a && this.boundDynamicVertexBuffer2 === s ? (e.bindVertexArrayOES.set(this.vao), a && a.bind(), r && r.dynamicDraw && r.bind(), s && s.bind()) : this.freshBind(t, i, o, r, n, a, s);
      }

      freshBind(e, t, i, o, r, n, a) {
        let s;
        const l = e.numAttributes,
              c = this.context,
              h = c.gl;
        if (c.extVertexArrayObject) this.vao && this.destroy(), this.vao = c.extVertexArrayObject.createVertexArrayOES(), c.bindVertexArrayOES.set(this.vao), s = 0, this.boundProgram = e, this.boundLayoutVertexBuffer = t, this.boundPaintVertexBuffers = i, this.boundIndexBuffer = o, this.boundVertexOffset = r, this.boundDynamicVertexBuffer = n, this.boundDynamicVertexBuffer2 = a;else {
          s = c.currentNumAttributes || 0;

          for (let e = l; e < s; e++) h.disableVertexAttribArray(e);
        }
        t.enableAttributes(h, e);

        for (const t of i) t.enableAttributes(h, e);

        n && n.enableAttributes(h, e), a && a.enableAttributes(h, e), t.bind(), t.setVertexAttribPointers(h, e, r);

        for (const t of i) t.bind(), t.setVertexAttribPointers(h, e, r);

        n && (n.bind(), n.setVertexAttribPointers(h, e, r)), o && o.bind(), a && (a.bind(), a.setVertexAttribPointers(h, e, r)), c.currentNumAttributes = l;
      }

      destroy() {
        this.vao && (this.context.extVertexArrayObject.deleteVertexArrayOES(this.vao), this.vao = null);
      }

    }

    function ri(t, i) {
      const o = Math.pow(2, i.canonical.z),
            r = i.canonical.y;
      return [new e.MercatorCoordinate(0, r / o).toLngLat().lat, new e.MercatorCoordinate(0, (r + 1) / o).toLngLat().lat];
    }

    function ni(t, i, o, r, n, a, s) {
      const l = t.context,
            c = l.gl,
            h = o.fbo;
      if (!h) return;
      t.prepareDrawTile();

      const _ = t.useProgram("hillshade");

      l.activeTexture.set(c.TEXTURE0), c.bindTexture(c.TEXTURE_2D, h.colorAttachment.get());

      const u = ((e, t, i, o) => {
        const r = i.paint.get("hillshade-shadow-color"),
              n = i.paint.get("hillshade-highlight-color"),
              a = i.paint.get("hillshade-accent-color");
        let s = i.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
        "viewport" === i.paint.get("hillshade-illumination-anchor") && (s -= e.transform.angle);
        const l = !e.options.moving;
        return {
          u_matrix: o || e.transform.calculateProjMatrix(t.tileID.toUnwrapped(), l),
          u_image: 0,
          u_latrange: ri(0, t.tileID),
          u_light: [i.paint.get("hillshade-exaggeration"), s],
          u_shadow: r,
          u_highlight: n,
          u_accent: a
        };
      })(t, o, r, t.terrain ? i.projMatrix : null);

      t.prepareDrawProgram(l, _, i.toUnwrapped());
      const {
        tileBoundsBuffer: d,
        tileBoundsIndexBuffer: p,
        tileBoundsSegments: m
      } = t.getTileBoundsBuffers(o);

      _.draw(l, c.TRIANGLES, n, a, s, e.CullFaceMode.disabled, u, r.id, d, p, m);
    }

    function ai(t, i, o) {
      if (!i.needsDEMTextureUpload) return;
      const r = t.context,
            n = r.gl;
      r.pixelStoreUnpackPremultiplyAlpha.set(!1), i.demTexture = i.demTexture || t.getTileTexture(o.stride);
      const a = o.getPixels();
      i.demTexture ? i.demTexture.update(a, {
        premultiply: !1
      }) : i.demTexture = new e.Texture(r, a, n.RGBA, {
        premultiply: !1
      }), i.needsDEMTextureUpload = !1;
    }

    function si(t, i, o, r, n, a) {
      const s = t.context,
            l = s.gl;
      if (!i.dem) return;
      const c = i.dem;
      if (s.activeTexture.set(l.TEXTURE1), ai(t, i, c), !i.demTexture) return;
      i.demTexture.bind(l.NEAREST, l.CLAMP_TO_EDGE);
      const h = c.dim;
      s.activeTexture.set(l.TEXTURE0);
      let _ = i.fbo;

      if (!_) {
        const t = new e.Texture(s, {
          width: h,
          height: h,
          data: null
        }, l.RGBA);
        t.bind(l.LINEAR, l.CLAMP_TO_EDGE), _ = i.fbo = s.createFramebuffer(h, h, !0), _.colorAttachment.set(t.texture);
      }

      s.bindFramebuffer.set(_.framebuffer), s.viewport.set([0, 0, h, h]);
      const {
        tileBoundsBuffer: u,
        tileBoundsIndexBuffer: d,
        tileBoundsSegments: p
      } = t.getMercatorTileBoundsBuffers();
      t.useProgram("hillshadePrepare").draw(s, l.TRIANGLES, r, n, a, e.CullFaceMode.disabled, ((t, i) => {
        const o = i.stride,
              r = e.create();
        return e.ortho(r, 0, e.EXTENT, -e.EXTENT, 0, 0, 1), e.translate(r, r, [0, -e.EXTENT, 0]), {
          u_matrix: r,
          u_image: 1,
          u_dimension: [o, o],
          u_zoom: t.overscaledZ,
          u_unpack: i.unpackVector
        };
      })(i.tileID, c), o.id, u, d, p), i.needsHillshadePrepare = !1;
    }

    const li = (t, i) => ({
      u_matrix: new e.UniformMatrix4f(t, i.u_matrix),
      u_image0: new e.Uniform1i(t, i.u_image0),
      u_skirt_height: new e.Uniform1f(t, i.u_skirt_height)
    }),
          ci = (e, t) => ({
      u_matrix: e,
      u_image0: 0,
      u_skirt_height: t
    }),
          hi = (e, t, i, o, r, n) => ({
      u_proj_matrix: Float32Array.from(e),
      u_globe_matrix: t,
      u_merc_matrix: i,
      u_zoom_transition: o,
      u_merc_center: r,
      u_image0: 0,
      u_grid_matrix: n ? Float32Array.from(n) : new Float32Array(9)
    });

    function _i(e, t) {
      return null != e && null != t && !(!e.hasData() || !t.hasData()) && null != e.demTexture && null != t.demTexture && e.tileID.key !== t.tileID.key;
    }

    const ui = new class {
      constructor() {
        this.operations = {};
      }

      newMorphing(e, t, i, o, r) {
        if (e in this.operations) {
          const t = this.operations[e];
          t.to.tileID.key !== i.tileID.key && (t.queued = i);
        } else this.operations[e] = {
          startTime: o,
          phase: 0,
          duration: r,
          from: t,
          to: i,
          queued: null
        };
      }

      getMorphValuesForProxy(e) {
        if (!(e in this.operations)) return null;
        const t = this.operations[e];
        return {
          from: t.from,
          to: t.to,
          phase: t.phase
        };
      }

      update(e) {
        for (const t in this.operations) {
          const i = this.operations[t];

          for (i.phase = (e - i.startTime) / i.duration; i.phase >= 1 || !this._validOp(i);) if (!this._nextOp(i, e)) {
            delete this.operations[t];
            break;
          }
        }
      }

      _nextOp(e, t) {
        return !!e.queued && (e.from = e.to, e.to = e.queued, e.queued = null, e.phase = 0, e.startTime = t, !0);
      }

      _validOp(e) {
        return e.from.hasData() && e.to.hasData();
      }

    }(),
          di = {
      0: null,
      1: "TERRAIN_VERTEX_MORPHING",
      2: "TERRAIN_WIREFRAME"
    };

    function pi(e, t) {
      const i = 1 << e.z;
      return !t && (0 === e.x || e.x === i - 1) || 0 === e.y || e.y === i - 1;
    }

    const mi = e => ({
      u_matrix: e
    });

    function fi(t, i, o, r, n) {
      if (n > 0) {
        const a = e.exported.now(),
              s = (a - t.timeAdded) / n,
              l = i ? (a - i.timeAdded) / n : -1,
              c = o.getSource(),
              h = r.coveringZoomLevel({
          tileSize: c.tileSize,
          roundZoom: c.roundZoom
        }),
              _ = !i || Math.abs(i.tileID.overscaledZ - h) > Math.abs(t.tileID.overscaledZ - h),
              u = _ && t.refreshedUponExpiration ? 1 : e.clamp(_ ? s : 1 - l, 0, 1);

        return t.refreshedUponExpiration && s >= 1 && (t.refreshedUponExpiration = !1), i ? {
          opacity: 1,
          mix: 1 - u
        } : {
          opacity: u,
          mix: 0
        };
      }

      return {
        opacity: 1,
        mix: 0
      };
    }

    const gi = 2 * e.mercatorZfromAltitude(1, 0) * e.GLOBE_RADIUS * Math.PI;

    class vi extends e.SourceCache {
      constructor(e) {
        const t = {
          type: "raster-dem",
          maxzoom: e.transform.maxZoom
        },
              i = new A(Ue(), null),
              o = De("mock-dem", t, i, e.style);
        super("mock-dem", o, !1), o.setEventedParent(this), this._sourceLoaded = !0;
      }

      _loadTile(e, t) {
        e.state = "loaded", t(null);
      }

    }

    class xi extends e.SourceCache {
      constructor(e) {
        const t = De("proxy", {
          type: "geojson",
          maxzoom: e.transform.maxZoom
        }, new A(Ue(), null), e.style);
        super("proxy", t, !1), t.setEventedParent(this), this.map = this.getSource().map = e, this.used = this._sourceLoaded = !0, this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
      }

      update(t, i, o) {
        if (t.freezeTileCoverage) return;
        this.transform = t;
        const r = t.coveringTiles({
          tileSize: this._source.tileSize,
          minzoom: this._source.minzoom,
          maxzoom: this._source.maxzoom,
          roundZoom: this._source.roundZoom,
          reparseOverscaled: this._source.reparseOverscaled
        }).reduce((i, o) => {
          if (i[o.key] = "", !this._tiles[o.key]) {
            const i = new e.Tile(o, this._source.tileSize * o.overscaleFactor(), t.tileZoom);
            i.state = "loaded", this._tiles[o.key] = i;
          }

          return i;
        }, {});

        for (const e in this._tiles) e in r || (this.freeFBO(e), this._tiles[e].unloadVectorData(), delete this._tiles[e]);
      }

      freeFBO(e) {
        const t = this.proxyCachedFBO[e];

        if (void 0 !== t) {
          const i = Object.values(t);
          this.renderCachePool.push(...i), delete this.proxyCachedFBO[e];
        }
      }

      deallocRenderCache() {
        this.renderCache.forEach(e => e.fb.destroy()), this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
      }

    }

    class yi extends e.OverscaledTileID {
      constructor(e, t, i) {
        super(e.overscaledZ, e.wrap, e.canonical.z, e.canonical.x, e.canonical.y), this.proxyTileKey = t, this.projMatrix = i;
      }

    }

    class bi extends e.Elevation {
      constructor(t, i) {
        super(), this.painter = t, this.terrainTileForTile = {}, this.prevTerrainTileForTile = {};

        const [o, r, n] = function (t) {
          const i = new e.StructArrayLayout4i8(),
                o = new e.StructArrayLayout3ui6(),
                r = 131;
          i.reserve(17161), o.reserve(33800);
          const n = e.EXTENT / 128,
                a = e.EXTENT + n / 2,
                s = a + n;

          for (let t = -n; t < s; t += n) for (let o = -n; o < s; o += n) {
            const r = o < 0 || o > a || t < 0 || t > a ? 24575 : 0,
                  n = e.clamp(Math.round(o), 0, e.EXTENT),
                  s = e.clamp(Math.round(t), 0, e.EXTENT);
            i.emplaceBack(n + r, s, n, s);
          }

          const l = (e, t) => {
            const i = t * r + e;
            o.emplaceBack(i + 1, i, i + r), o.emplaceBack(i + r, i + r + 1, i + 1);
          };

          for (let e = 1; e < 129; e++) for (let t = 1; t < 129; t++) l(t, e);

          return [0, 129].forEach(e => {
            for (let t = 0; t < 130; t++) l(t, e), l(e, t);
          }), [i, o, 32768];
        }(),
              a = t.context;

        this.gridBuffer = a.createVertexBuffer(o, e.boundsAttributes.members), this.gridIndexBuffer = a.createIndexBuffer(r), this.gridSegments = e.SegmentVector.simpleSegment(0, 0, o.length, r.length), this.gridNoSkirtSegments = e.SegmentVector.simpleSegment(0, 0, o.length, n), this.proxyCoords = [], this.proxiedCoords = {}, this._visibleDemTiles = [], this._drapedRenderBatches = [], this._sourceTilesOverlap = {}, this.proxySourceCache = new xi(i.map), this.orthoMatrix = e.create(), e.ortho(this.orthoMatrix, 0, e.EXTENT, 0, e.EXTENT, 0, 1);
        const s = a.gl;
        this._overlapStencilMode = new e.StencilMode({
          func: s.GEQUAL,
          mask: 255
        }, 0, 255, s.KEEP, s.KEEP, s.REPLACE), this._previousZoom = t.transform.zoom, this.pool = [], this._findCoveringTileCache = {}, this._tilesDirty = {}, this.style = i, this._useVertexMorphing = !0, this._exaggeration = 1, this._mockSourceCache = new vi(i.map);
      }

      set style(e) {
        e.on("data", this._onStyleDataEvent.bind(this)), e.on("neworder", this._checkRenderCacheEfficiency.bind(this)), this._style = e, this._checkRenderCacheEfficiency();
      }

      update(t, i, o) {
        if (t && t.terrain) {
          this._style !== t && (this.style = t), this.enabled = !0;
          const r = t.terrain.properties;
          this.sourceCache = 0 === t.terrain.drapeRenderMode ? this._mockSourceCache : t._getSourceCache(r.get("source")), this._exaggeration = r.get("exaggeration");

          const n = () => {
            this.sourceCache.used && e.warnOnce(`Raster DEM source '${this.sourceCache.id}' is used both for terrain and as layer source.\nThis leads to lower resolution of hillshade. For full hillshade resolution but higher memory consumption, define another raster DEM source.`);
            const t = this.getScaledDemTileSize();
            this.sourceCache.update(i, t, !0), this.resetTileLookupCache(this.sourceCache.id);
          };

          this.sourceCache.usedForTerrain || (this.resetTileLookupCache(this.sourceCache.id), this.sourceCache.usedForTerrain = !0, n(), this._initializing = !0), n(), i.updateElevation(!o), this.resetTileLookupCache(this.proxySourceCache.id), this.proxySourceCache.update(i), this._emptyDEMTextureDirty = !0;
        } else this._disable();
      }

      resetTileLookupCache(e) {
        this._findCoveringTileCache[e] = {};
      }

      getScaledDemTileSize() {
        return this.sourceCache.getSource().tileSize / 128 * this.proxySourceCache.getSource().tileSize;
      }

      _checkRenderCacheEfficiency() {
        const t = this.renderCacheEfficiency(this._style);
        this._style.map._optimizeForTerrain || 100 !== t.efficiency && e.warnOnce(`Terrain render cache efficiency is not optimal (${t.efficiency}%) and performance\n                may be affected negatively, consider placing all background, fill and line layers before layer\n                with id '${t.firstUndrapedLayer}' or create a map using optimizeForTerrain: true option.`);
      }

      _onStyleDataEvent(e) {
        e.coord && "source" === e.dataType ? this._clearRenderCacheForTile(e.sourceCacheId, e.coord) : "style" === e.dataType && (this._invalidateRenderCache = !0);
      }

      _disable() {
        if (this.enabled && (this.enabled = !1, this._sharedDepthStencil = void 0, this.proxySourceCache.deallocRenderCache(), this._style)) for (const e in this._style._sourceCaches) this._style._sourceCaches[e].usedForTerrain = !1;
      }

      destroy() {
        this._disable(), this._emptyDEMTexture && this._emptyDEMTexture.destroy(), this._emptyDepthBufferTexture && this._emptyDepthBufferTexture.destroy(), this.pool.forEach(e => e.fb.destroy()), this.pool = [], this._depthFBO && (this._depthFBO.destroy(), this._depthFBO = void 0, this._depthTexture = void 0);
      }

      _source() {
        return this.enabled ? this.sourceCache : null;
      }

      exaggeration() {
        return this._exaggeration;
      }

      get visibleDemTiles() {
        return this._visibleDemTiles;
      }

      get drapeBufferSize() {
        const e = 2 * this.proxySourceCache.getSource().tileSize;
        return [e, e];
      }

      set useVertexMorphing(e) {
        this._useVertexMorphing = e;
      }

      updateTileBinding(t) {
        if (!this.enabled) return;
        this.prevTerrainTileForTile = this.terrainTileForTile;
        const i = this.proxySourceCache,
              o = this.painter.transform;
        this._initializing && (this._initializing = 0 === o._centerAltitude && -1 === this.getAtPointOrZero(e.MercatorCoordinate.fromLngLat(o.center), -1), this._emptyDEMTextureDirty = !this._initializing);
        const r = this.proxyCoords = i.getIds().map(e => {
          const t = i.getTileByID(e).tileID;
          return t.projMatrix = o.calculateProjMatrix(t.toUnwrapped()), t;
        });
        !function (t, i) {
          const o = i.transform.pointCoordinate(i.transform.getCameraPoint()),
                r = new e.pointGeometry(o.x, o.y);
          t.sort((t, i) => {
            if (i.overscaledZ - t.overscaledZ) return i.overscaledZ - t.overscaledZ;
            const o = new e.pointGeometry(t.canonical.x + (1 << t.canonical.z) * t.wrap, t.canonical.y),
                  n = new e.pointGeometry(i.canonical.x + (1 << i.canonical.z) * i.wrap, i.canonical.y),
                  a = r.mult(1 << t.canonical.z);
            return a.x -= .5, a.y -= .5, a.distSqr(o) - a.distSqr(n);
          });
        }(r, this.painter), this._previousZoom = o.zoom;
        const n = this.proxyToSource || {};
        this.proxyToSource = {}, r.forEach(e => {
          this.proxyToSource[e.key] = {};
        }), this.terrainTileForTile = {};
        const a = this._style._sourceCaches;

        for (const e in a) {
          const i = a[e];
          if (!i.used) continue;
          if (i !== this.sourceCache && this.resetTileLookupCache(i.id), this._setupProxiedCoordsForOrtho(i, t[e], n), i.usedForTerrain) continue;
          const o = t[e];
          i.getSource().reparseOverscaled && this._assignTerrainTiles(o);
        }

        this.proxiedCoords[i.id] = r.map(e => new yi(e, e.key, this.orthoMatrix)), this._assignTerrainTiles(r), this._prepareDEMTextures(), this._setupDrapedRenderBatches(), this._initFBOPool(), this._setupRenderCache(n), this.renderingToTexture = !1, this._updateTimestamp = e.exported.now();
        const s = {};
        this._visibleDemTiles = [];

        for (const e of this.proxyCoords) {
          const t = this.terrainTileForTile[e.key];
          if (!t) continue;
          const i = t.tileID.key;
          i in s || (this._visibleDemTiles.push(t), s[i] = i);
        }
      }

      _assignTerrainTiles(e) {
        this._initializing || e.forEach(e => {
          if (this.terrainTileForTile[e.key]) return;

          const t = this._findTileCoveringTileID(e, this.sourceCache);

          t && (this.terrainTileForTile[e.key] = t);
        });
      }

      _prepareDEMTextures() {
        const e = this.painter.context,
              t = e.gl;

        for (const i in this.terrainTileForTile) {
          const o = this.terrainTileForTile[i],
                r = o.dem;
          !r || o.demTexture && !o.needsDEMTextureUpload || (e.activeTexture.set(t.TEXTURE1), ai(this.painter, o, r));
        }
      }

      _prepareDemTileUniforms(e, t, i, o) {
        if (!t || null == t.demTexture) return !1;
        const r = e.tileID.canonical,
              n = Math.pow(2, t.tileID.canonical.z - r.z),
              a = o || "";
        return i[`u_dem_tl${a}`] = [r.x * n % 1, r.y * n % 1], i[`u_dem_scale${a}`] = n, !0;
      }

      get emptyDEMTexture() {
        return !this._emptyDEMTextureDirty && this._emptyDEMTexture ? this._emptyDEMTexture : this._updateEmptyDEMTexture();
      }

      get emptyDepthBufferTexture() {
        const t = this.painter.context,
              i = t.gl;

        if (!this._emptyDepthBufferTexture) {
          const o = new e.RGBAImage({
            width: 1,
            height: 1
          }, Uint8Array.of(255, 255, 255, 255));
          this._emptyDepthBufferTexture = new e.Texture(t, o, i.RGBA, {
            premultiply: !1
          });
        }

        return this._emptyDepthBufferTexture;
      }

      _getLoadedAreaMinimum() {
        let e = 0;

        const t = this._visibleDemTiles.reduce((t, i) => {
          if (!i.dem) return t;
          const o = i.dem.tree.minimums[0];
          return o > 0 && e++, t + o;
        }, 0);

        return e ? t / e : 0;
      }

      _updateEmptyDEMTexture() {
        const t = this.painter.context,
              i = t.gl;
        t.activeTexture.set(i.TEXTURE2);

        const o = this._getLoadedAreaMinimum(),
              r = new e.RGBAImage({
          width: 1,
          height: 1
        }, new Uint8Array(e.DEMData.pack(o, this.sourceCache.getSource().encoding)));

        this._emptyDEMTextureDirty = !1;
        let n = this._emptyDEMTexture;
        return n ? n.update(r, {
          premultiply: !1
        }) : n = this._emptyDEMTexture = new e.Texture(t, r, i.RGBA, {
          premultiply: !1
        }), n;
      }

      setupElevationDraw(t, i, o) {
        const r = this.painter.context,
              n = r.gl,
              a = (s = this.sourceCache.getSource().encoding, {
          u_dem: 2,
          u_dem_prev: 4,
          u_dem_unpack: e.DEMData.getUnpackVector(s),
          u_dem_tl: [0, 0],
          u_dem_tl_prev: [0, 0],
          u_dem_scale: 0,
          u_dem_scale_prev: 0,
          u_dem_size: 0,
          u_dem_lerp: 1,
          u_depth: 3,
          u_depth_size_inv: [0, 0],
          u_exaggeration: 0,
          u_tile_tl_up: [0, 0, 1],
          u_tile_tr_up: [0, 0, 1],
          u_tile_br_up: [0, 0, 1],
          u_tile_bl_up: [0, 0, 1],
          u_tile_up_scale: 1
        });
        var s;
        a.u_dem_size = this.sourceCache.getSource().tileSize, a.u_exaggeration = this.exaggeration();
        const l = this.painter.transform,
              c = l.projection,
              h = t.tileID.canonical;
        a.u_tile_tl_up = c.upVector(h, 0, 0), a.u_tile_tr_up = c.upVector(h, e.EXTENT, 0), a.u_tile_br_up = c.upVector(h, e.EXTENT, e.EXTENT), a.u_tile_bl_up = c.upVector(h, 0, e.EXTENT), a.u_tile_up_scale = o && o.useDenormalizedUpVectorScale ? gi : c.upVectorScale(h, l.center.lat, l.worldSize).metersToTile;
        let _ = null,
            u = null,
            d = 1;

        if (o && o.morphing && this._useVertexMorphing) {
          const e = o.morphing.srcDemTile,
                i = o.morphing.dstDemTile;
          d = o.morphing.phase, e && i && (this._prepareDemTileUniforms(t, e, a, "_prev") && (u = e), this._prepareDemTileUniforms(t, i, a) && (_ = i));
        }

        if (u && _ ? (r.activeTexture.set(n.TEXTURE2), _.demTexture.bind(n.NEAREST, n.CLAMP_TO_EDGE, n.NEAREST), r.activeTexture.set(n.TEXTURE4), u.demTexture.bind(n.NEAREST, n.CLAMP_TO_EDGE, n.NEAREST), a.u_dem_lerp = d) : (_ = this.terrainTileForTile[t.tileID.key], r.activeTexture.set(n.TEXTURE2), (this._prepareDemTileUniforms(t, _, a) ? _.demTexture : this.emptyDEMTexture).bind(n.NEAREST, n.CLAMP_TO_EDGE)), r.activeTexture.set(n.TEXTURE3), o && o.useDepthForOcclusion ? (this._depthTexture && this._depthTexture.bind(n.NEAREST, n.CLAMP_TO_EDGE), this._depthFBO && (a.u_depth_size_inv = [1 / this._depthFBO.width, 1 / this._depthFBO.height])) : (this.emptyDepthBufferTexture.bind(n.NEAREST, n.CLAMP_TO_EDGE), a.u_depth_size_inv = [1, 1]), o && o.useMeterToDem && _) {
          const t = (1 << _.tileID.canonical.z) * e.mercatorZfromAltitude(1, this.painter.transform.center.lat) * this.sourceCache.getSource().tileSize;
          a.u_meter_to_dem = t;
        }

        o && o.labelPlaneMatrixInv && (a.u_label_plane_matrix_inv = o.labelPlaneMatrixInv), i.setTerrainUniformValues(r, a);
      }

      renderToBackBuffer(t) {
        const i = this.painter,
              o = this.painter.context;
        0 !== t.length && (o.bindFramebuffer.set(null), o.viewport.set([0, 0, i.width, i.height]), this.renderingToTexture = !1, function (t, i, o, r, n) {
          if ("globe" === t.transform.projection.name) !function (t, i, o, r, n) {
            const a = t.context,
                  s = a.gl;
            let l, c;

            const h = t.options.showTerrainWireframe ? 2 : 0,
                  _ = (e, i) => {
              if (c === e) return;
              const o = [di[e], "PROJECTION_GLOBE_VIEW"];
              i && o.push(di[h]), l = t.useProgram("globeRaster", null, o), c = e;
            },
                  u = t.colorModeForRenderPass(),
                  d = new e.DepthMode(s.LEQUAL, e.DepthMode.ReadWrite, t.depthRangeFor3D);

            ui.update(n);
            const p = t.transform,
                  m = e.calculateGlobeMercatorMatrix(p),
                  f = [e.mercatorXfromLng(p.center.lng), e.mercatorYfromLat(p.center.lat)],
                  g = t.globeSharedBuffers;

            if ((h ? [!1, !0] : [!1]).forEach(h => {
              c = -1;
              const v = h ? s.LINES : s.TRIANGLES;

              for (const c of r) {
                const r = o.getTile(c),
                      x = e.StencilMode.disabled,
                      y = i.prevTerrainTileForTile[c.key],
                      b = i.terrainTileForTile[c.key];
                _i(y, b) && ui.newMorphing(c.key, y, b, n, 250), a.activeTexture.set(s.TEXTURE0), r.texture.bind(s.LINEAR, s.CLAMP_TO_EDGE);
                const w = ui.getMorphValuesForProxy(c.key),
                      T = w ? 1 : 0,
                      E = {
                  useDenormalizedUpVectorScale: !0
                };
                w && e.extend$1(E, {
                  morphing: {
                    srcDemTile: w.from,
                    dstDemTile: w.to,
                    phase: e.easeCubicInOut(w.phase)
                  }
                });
                const C = Float32Array.from(p.globeMatrix),
                      I = e.globeTileLatLngCorners(c.canonical),
                      M = e.getGridMatrix(c.canonical, I),
                      S = hi(p.projMatrix, C, m, e.globeToMercatorTransition(p.zoom), f, M);

                if (_(T, h), i.setupElevationDraw(r, l, E), t.prepareDrawProgram(a, l, c.toUnwrapped()), g) {
                  const [i, o, r] = h ? g.getWirefameBuffers(t.context) : g.getGridBuffers();
                  l.draw(a, v, d, x, u, e.CullFaceMode.backCCW, S, "globe_raster", i, o, r);
                }
              }
            }), g) {
              l = t.useProgram("globeRaster", null, ["GLOBE_POLES", "PROJECTION_GLOBE_VIEW"]);

              for (const n of r) {
                const {
                  x: r,
                  y: c,
                  z: h
                } = n.canonical,
                      _ = 0 === c,
                      m = c === (1 << h) - 1,
                      [v, x, y, b] = g.getPoleBuffers(h);

                if (b && (_ || m)) {
                  const c = o.getTile(n);
                  a.activeTexture.set(s.TEXTURE0), c.texture.bind(s.LINEAR, s.CLAMP_TO_EDGE);
                  let g = e.globePoleMatrixForTile(h, r, p);

                  const w = (t, i) => t.draw(a, s.TRIANGLES, d, e.StencilMode.disabled, u, e.CullFaceMode.disabled, hi(p.projMatrix, g, g, 0, f), "globe_pole_raster", i, y, b);

                  i.setupElevationDraw(c, l, {}), t.prepareDrawProgram(a, l, n.toUnwrapped()), _ && w(l, v), m && (g = e.scale(e.create(), g, [1, -1, 1]), w(l, x));
                }
              }
            }
          }(t, i, o, r, n);else {
            const a = t.context,
                  s = a.gl;
            let l, c;

            const h = t.options.showTerrainWireframe ? 2 : 0,
                  _ = (e, i) => {
              if (c === e) return;
              const o = [di[e]];
              i && o.push(di[h]), l = t.useProgram("terrainRaster", null, o), c = e;
            },
                  u = t.colorModeForRenderPass(),
                  d = new e.DepthMode(s.LEQUAL, e.DepthMode.ReadWrite, t.depthRangeFor3D);

            ui.update(n);
            const p = t.transform,
                  m = 6 * Math.pow(1.5, 22 - p.zoom) * i.exaggeration();
            (h ? [!1, !0] : [!1]).forEach(h => {
              c = -1;
              const f = h ? s.LINES : s.TRIANGLES,
                    [g, v] = h ? i.getWirefameBuffer() : [i.gridIndexBuffer, i.gridSegments];

              for (const c of r) {
                const r = o.getTile(c),
                      x = e.StencilMode.disabled,
                      y = i.prevTerrainTileForTile[c.key],
                      b = i.terrainTileForTile[c.key];
                _i(y, b) && ui.newMorphing(c.key, y, b, n, 250), a.activeTexture.set(s.TEXTURE0), r.texture.bind(s.LINEAR, s.CLAMP_TO_EDGE, s.LINEAR_MIPMAP_NEAREST);
                const w = ui.getMorphValuesForProxy(c.key),
                      T = w ? 1 : 0;
                let E;
                w && (E = {
                  morphing: {
                    srcDemTile: w.from,
                    dstDemTile: w.to,
                    phase: e.easeCubicInOut(w.phase)
                  }
                });
                const C = ci(c.projMatrix, pi(c.canonical, p.renderWorldCopies) ? m / 10 : m);
                _(T, h), i.setupElevationDraw(r, l, E), t.prepareDrawProgram(a, l, c.toUnwrapped()), l.draw(a, f, d, x, u, e.CullFaceMode.backCCW, C, "terrain_raster", i.gridBuffer, g, v);
              }
            });
          }
        }(i, this, this.proxySourceCache, t, this._updateTimestamp), this.renderingToTexture = !0, t.splice(0, t.length));
      }

      renderBatch(t) {
        if (0 === this._drapedRenderBatches.length) return t + 1;
        this.renderingToTexture = !0;

        const i = this.painter,
              o = this.painter.context,
              r = this.proxySourceCache,
              n = this.proxiedCoords[r.id],
              a = this._drapedRenderBatches.shift(),
              s = [],
              l = i.style.order;

        let c = 0;

        for (const h of n) {
          const n = r.getTileByID(h.proxyTileKey),
                _ = r.proxyCachedFBO[h.key] ? r.proxyCachedFBO[h.key][t] : void 0,
                u = void 0 !== _ ? r.renderCache[_] : this.pool[c++],
                d = void 0 !== _;

          if (n.texture = u.tex, d && !u.dirty) {
            s.push(n.tileID);
            continue;
          }

          let p;
          o.bindFramebuffer.set(u.fb.framebuffer), this.renderedToTile = !1, u.dirty && (o.clear({
            color: e.Color.transparent,
            stencil: 0
          }), u.dirty = !1);

          for (let e = a.start; e <= a.end; ++e) {
            const t = i.style._layers[l[e]];
            if (t.isHidden(i.transform.zoom)) continue;

            const r = i.style._getLayerSourceCache(t),
                  n = r ? this.proxyToSource[h.key][r.id] : [h];

            if (!n) continue;
            const a = n;
            o.viewport.set([0, 0, u.fb.width, u.fb.height]), p !== (r ? r.id : null) && (this._setupStencil(u, n, t, r), p = r ? r.id : null), i.renderLayer(i, r, t, a);
          }

          this.renderedToTile ? (u.dirty = !0, s.push(n.tileID)) : d || --c, 5 === c && (c = 0, this.renderToBackBuffer(s));
        }

        return this.renderToBackBuffer(s), this.renderingToTexture = !1, o.bindFramebuffer.set(null), o.viewport.set([0, 0, i.width, i.height]), a.end + 1;
      }

      postRender() {}

      renderCacheEfficiency(e) {
        const t = e.order.length;
        if (0 === t) return {
          efficiency: 100
        };
        let i,
            o = 0,
            r = 0,
            n = !1;

        for (let a = 0; a < t; ++a) {
          const t = e._layers[e.order[a]];
          this._style.isLayerDraped(t) ? (n && ++o, ++r) : n || (n = !0, i = t.id);
        }

        return 0 === r ? {
          efficiency: 100
        } : {
          efficiency: 100 * (1 - o / r),
          firstUndrapedLayer: i
        };
      }

      getMinElevationBelowMSL() {
        let e = 0;
        return this._visibleDemTiles.filter(e => e.dem).forEach(t => {
          e = Math.min(e, t.dem.tree.minimums[0]);
        }), 0 === e ? e : (e - 30) * this._exaggeration;
      }

      raycast(e, t, i) {
        if (!this._visibleDemTiles) return null;

        const o = this._visibleDemTiles.filter(e => e.dem).map(o => {
          const r = o.tileID,
                n = Math.pow(2, r.overscaledZ),
                {
            x: a,
            y: s
          } = r.canonical,
                l = a / n,
                c = (a + 1) / n,
                h = s / n,
                _ = (s + 1) / n;

          return {
            minx: l,
            miny: h,
            maxx: c,
            maxy: _,
            t: o.dem.tree.raycastRoot(l, h, c, _, e, t, i),
            tile: o
          };
        });

        o.sort((e, t) => (null !== e.t ? e.t : Number.MAX_VALUE) - (null !== t.t ? t.t : Number.MAX_VALUE));

        for (const r of o) {
          if (null == r.t) return null;
          const o = r.tile.dem.tree.raycast(r.minx, r.miny, r.maxx, r.maxy, e, t, i);
          if (null != o) return o;
        }

        return null;
      }

      _createFBO() {
        const t = this.painter.context,
              i = t.gl,
              o = this.drapeBufferSize;
        t.activeTexture.set(i.TEXTURE0);
        const r = new e.Texture(t, {
          width: o[0],
          height: o[1],
          data: null
        }, i.RGBA);
        r.bind(i.LINEAR, i.CLAMP_TO_EDGE);
        const n = t.createFramebuffer(o[0], o[1], !1);
        return n.colorAttachment.set(r.texture), n.depthAttachment = new we(t, n.framebuffer), void 0 === this._sharedDepthStencil ? (this._sharedDepthStencil = t.createRenderbuffer(t.gl.DEPTH_STENCIL, o[0], o[1]), this._stencilRef = 0, n.depthAttachment.set(this._sharedDepthStencil), t.clear({
          stencil: 0
        })) : n.depthAttachment.set(this._sharedDepthStencil), t.extTextureFilterAnisotropic && !t.extTextureFilterAnisotropicForceOff && i.texParameterf(i.TEXTURE_2D, t.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, t.extTextureFilterAnisotropicMax), {
          fb: n,
          tex: r,
          dirty: !1
        };
      }

      _initFBOPool() {
        for (; this.pool.length < Math.min(5, this.proxyCoords.length);) this.pool.push(this._createFBO());
      }

      _shouldDisableRenderCache() {
        if (this._style.light && this._style.light.hasTransition()) return !0;

        for (const e in this._style._sourceCaches) if (this._style._sourceCaches[e].hasTransition()) return !0;

        return this._style.order.some(e => {
          const t = this._style._layers[e],
                i = t.isHidden(this.painter.transform.zoom),
                o = t.getCrossfadeParameters(),
                r = !!o && 1 !== o.t,
                n = t.hasTransition();
          return "custom" !== t.type && !i && (r || n);
        });
      }

      _clearRasterFadeFromRenderCache() {
        let e = !1;

        for (const t in this._style._sourceCaches) if (this._style._sourceCaches[t]._source instanceof Ce) {
          e = !0;
          break;
        }

        if (e) for (let e = 0; e < this._style.order.length; ++e) {
          const t = this._style._layers[this._style.order[e]],
                i = t.isHidden(this.painter.transform.zoom),
                o = this._style._getLayerSourceCache(t);

          if ("raster" !== t.type || i || !o) continue;
          const r = t.paint.get("raster-fade-duration");

          for (const e of this.proxyCoords) {
            const t = this.proxyToSource[e.key][o.id];
            if (t) for (const e of t) {
              const t = fi(o.getTile(e), o.findLoadedParent(e, 0), o, this.painter.transform, r);
              (1 !== t.opacity || 0 !== t.mix) && this._clearRenderCacheForTile(o.id, e);
            }
          }
        }
      }

      _setupDrapedRenderBatches() {
        const e = this._style.order,
              t = e.length;
        if (0 === t) return;
        const i = [];
        let o,
            r = 0,
            n = this._style._layers[e[r]];

        for (; !this._style.isLayerDraped(n) && n.isHidden(this.painter.transform.zoom) && ++r < t;) n = this._style._layers[e[r]];

        for (; r < t; ++r) {
          const t = this._style._layers[e[r]];
          t.isHidden(this.painter.transform.zoom) || (this._style.isLayerDraped(t) ? void 0 === o && (o = r) : void 0 !== o && (i.push({
            start: o,
            end: r - 1
          }), o = void 0));
        }

        void 0 !== o && i.push({
          start: o,
          end: r - 1
        }), this._drapedRenderBatches = i;
      }

      _setupRenderCache(e) {
        const t = this.proxySourceCache;

        if (this._shouldDisableRenderCache() || this._invalidateRenderCache) {
          if (this._invalidateRenderCache = !1, t.renderCache.length > t.renderCachePool.length) {
            const e = Object.values(t.proxyCachedFBO);
            t.proxyCachedFBO = {};

            for (let i = 0; i < e.length; ++i) {
              const o = Object.values(e[i]);
              t.renderCachePool.push(...o);
            }
          }

          return;
        }

        this._clearRasterFadeFromRenderCache();

        const i = this.proxyCoords,
              o = this._tilesDirty;

        for (let r = i.length - 1; r >= 0; r--) {
          const n = i[r];

          if (t.getTileByID(n.key), void 0 !== t.proxyCachedFBO[n.key]) {
            const i = e[n.key],
                  r = this.proxyToSource[n.key];
            let a = 0;

            for (const e in r) {
              const t = r[e],
                    n = i[e];

              if (!n || n.length !== t.length || t.some((t, i) => t !== n[i] || o[e] && o[e].hasOwnProperty(t.key))) {
                a = -1;
                break;
              }

              ++a;
            }

            for (const e in t.proxyCachedFBO[n.key]) t.renderCache[t.proxyCachedFBO[n.key][e]].dirty = a < 0 || a !== Object.values(i).length;
          }
        }

        const r = [...this._drapedRenderBatches];
        r.sort((e, t) => t.end - t.start - (e.end - e.start));

        for (const e of r) for (const o of i) {
          if (t.proxyCachedFBO[o.key]) continue;
          let i = t.renderCachePool.pop();
          void 0 === i && t.renderCache.length < 50 && (i = t.renderCache.length, t.renderCache.push(this._createFBO())), void 0 !== i && (t.proxyCachedFBO[o.key] = {}, t.proxyCachedFBO[o.key][e.start] = i, t.renderCache[i].dirty = !0);
        }

        this._tilesDirty = {};
      }

      _setupStencil(e, t, i, o) {
        if (!o || !this._sourceTilesOverlap[o.id]) return void (this._overlapStencilType && (this._overlapStencilType = !1));
        const r = this.painter.context,
              n = r.gl;
        if (t.length <= 1) return void (this._overlapStencilType = !1);
        let a;
        if (i.isTileClipped()) a = t.length, this._overlapStencilMode.test = {
          func: n.EQUAL,
          mask: 255
        }, this._overlapStencilType = "Clip";else {
          if (!(t[0].overscaledZ > t[t.length - 1].overscaledZ)) return void (this._overlapStencilType = !1);
          a = 1, this._overlapStencilMode.test = {
            func: n.GREATER,
            mask: 255
          }, this._overlapStencilType = "Mask";
        }
        this._stencilRef + a > 255 && (r.clear({
          stencil: 0
        }), this._stencilRef = 0), this._stencilRef += a, this._overlapStencilMode.ref = this._stencilRef, i.isTileClipped() && this._renderTileClippingMasks(t, this._overlapStencilMode.ref);
      }

      clipOrMaskOverlapStencilType() {
        return "Clip" === this._overlapStencilType || "Mask" === this._overlapStencilType;
      }

      stencilModeForRTTOverlap(t) {
        return this.renderingToTexture && this._overlapStencilType ? ("Clip" === this._overlapStencilType && (this._overlapStencilMode.ref = this.painter._tileClippingMaskIDs.get(t.key) || 0), this._overlapStencilMode) : e.StencilMode.disabled;
      }

      _renderTileClippingMasks(t, i) {
        const o = this.painter,
              r = this.painter.context,
              n = r.gl;
        o._tileClippingMaskIDs.clear(), r.setColorMode(e.ColorMode.disabled), r.setDepthMode(e.DepthMode.disabled);
        const a = o.useProgram("clippingMask");

        for (const s of t) {
          const t = --i;
          o._tileClippingMaskIDs.set(s.key, t), a.draw(r, n.TRIANGLES, e.DepthMode.disabled, new e.StencilMode({
            func: n.ALWAYS,
            mask: 0
          }, t, 255, n.KEEP, n.KEEP, n.REPLACE), e.ColorMode.disabled, e.CullFaceMode.disabled, mi(s.projMatrix), "$clipping", o.tileExtentBuffer, o.quadTriangleIndexBuffer, o.tileExtentSegments);
        }
      }

      pointCoordinate(t) {
        const i = this.painter.transform;
        if (t.x < 0 || t.x > i.width || t.y < 0 || t.y > i.height) return null;
        const o = [t.x, t.y, 1, 1];
        e.transformMat4$1(o, o, i.pixelMatrixInverse), e.scale$1(o, o, 1 / o[3]), o[0] /= i.worldSize, o[1] /= i.worldSize;
        const r = i._camera.position,
              n = e.mercatorZfromAltitude(1, i.center.lat),
              a = [r[0], r[1], r[2] / n, 0],
              s = e.subtract([], o.slice(0, 3), a);
        e.normalize(s, s);
        const l = this.raycast(a, s, this._exaggeration);
        return null !== l && l ? (e.scaleAndAdd(a, a, s, l), a[3] = a[2], a[2] *= n, a) : null;
      }

      drawDepth() {
        const t = this.painter,
              i = t.context,
              o = this.proxySourceCache,
              r = Math.ceil(t.width),
              n = Math.ceil(t.height);

        if (!this._depthFBO || this._depthFBO.width === r && this._depthFBO.height === n || (this._depthFBO.destroy(), this._depthFBO = void 0, this._depthTexture = void 0), !this._depthFBO) {
          const t = i.gl,
                o = i.createFramebuffer(r, n, !0);
          i.activeTexture.set(t.TEXTURE0);
          const a = new e.Texture(i, {
            width: r,
            height: n,
            data: null
          }, t.RGBA);
          a.bind(t.NEAREST, t.CLAMP_TO_EDGE), o.colorAttachment.set(a.texture);
          const s = i.createRenderbuffer(i.gl.DEPTH_COMPONENT16, r, n);
          o.depthAttachment.set(s), this._depthFBO = o, this._depthTexture = a;
        }

        i.bindFramebuffer.set(this._depthFBO.framebuffer), i.viewport.set([0, 0, r, n]), function (t, i, o, r) {
          if ("globe" === t.transform.projection.name) return;
          const n = t.context,
                a = n.gl;
          n.clear({
            depth: 1
          });
          const s = t.useProgram("terrainDepth"),
                l = new e.DepthMode(a.LESS, e.DepthMode.ReadWrite, t.depthRangeFor3D);

          for (const t of r) {
            const r = o.getTile(t),
                  c = ci(t.projMatrix, 0);
            i.setupElevationDraw(r, s), s.draw(n, a.TRIANGLES, l, e.StencilMode.disabled, e.ColorMode.unblended, e.CullFaceMode.backCCW, c, "terrain_depth", i.gridBuffer, i.gridIndexBuffer, i.gridNoSkirtSegments);
          }
        }(t, this, o, this.proxyCoords);
      }

      _setupProxiedCoordsForOrtho(e, t, i) {
        if (e.getSource() instanceof Se) return this._setupProxiedCoordsForImageSource(e, t, i);
        this._findCoveringTileCache[e.id] = this._findCoveringTileCache[e.id] || {};
        const o = this.proxiedCoords[e.id] = [],
              r = this.proxyCoords;

        for (let t = 0; t < r.length; t++) {
          const n = r[t],
                a = this._findTileCoveringTileID(n, e);

          if (a) {
            const t = this._createProxiedId(n, a, i[n.key] && i[n.key][e.id]);

            o.push(t), this.proxyToSource[n.key][e.id] = [t];
          }
        }

        let n = !1;

        for (let r = 0; r < t.length; r++) {
          const a = e.getTile(t[r]);
          if (!a || !a.hasData()) continue;

          const s = this._findTileCoveringTileID(a.tileID, this.proxySourceCache);

          if (s && s.tileID.canonical.z !== a.tileID.canonical.z) {
            const t = this.proxyToSource[s.tileID.key][e.id],
                  r = this._createProxiedId(s.tileID, a, i[s.tileID.key] && i[s.tileID.key][e.id]);

            t ? t.splice(t.length - 1, 0, r) : this.proxyToSource[s.tileID.key][e.id] = [r], o.push(r), n = !0;
          }
        }

        this._sourceTilesOverlap[e.id] = n;
      }

      _setupProxiedCoordsForImageSource(t, i, o) {
        if (!t.getSource().loaded()) return;

        const r = this.proxiedCoords[t.id] = [],
              n = this.proxyCoords,
              a = t.getSource(),
              s = new e.pointGeometry(a.tileID.x, a.tileID.y)._div(1 << a.tileID.z),
              l = a.coordinates.map(e.MercatorCoordinate.fromLngLat).reduce((e, t) => (e.min.x = Math.min(e.min.x, t.x - s.x), e.min.y = Math.min(e.min.y, t.y - s.y), e.max.x = Math.max(e.max.x, t.x - s.x), e.max.y = Math.max(e.max.y, t.y - s.y), e), {
          min: new e.pointGeometry(Number.MAX_VALUE, Number.MAX_VALUE),
          max: new e.pointGeometry(-Number.MAX_VALUE, -Number.MAX_VALUE)
        }),
              c = (t, i) => {
          const o = t.wrap + t.canonical.x / (1 << t.canonical.z),
                r = t.canonical.y / (1 << t.canonical.z),
                n = e.EXTENT / (1 << t.canonical.z),
                a = i.wrap + i.canonical.x / (1 << i.canonical.z),
                s = i.canonical.y / (1 << i.canonical.z);
          return o + n < a + l.min.x || o > a + l.max.x || r + n < s + l.min.y || r > s + l.max.y;
        };

        for (let e = 0; e < n.length; e++) {
          const a = n[e];

          for (let e = 0; e < i.length; e++) {
            const n = t.getTile(i[e]);
            if (!n || !n.hasData()) continue;
            if (c(a, n.tileID)) continue;

            const s = this._createProxiedId(a, n, o[a.key] && o[a.key][t.id]),
                  l = this.proxyToSource[a.key][t.id];

            l ? l.push(s) : this.proxyToSource[a.key][t.id] = [s], r.push(s);
          }
        }
      }

      _createProxiedId(t, i, o) {
        let r = this.orthoMatrix;

        if (o) {
          const e = o.find(e => e.key === i.tileID.key);
          if (e) return e;
        }

        if (i.tileID.key !== t.key) {
          const o = t.canonical.z - i.tileID.canonical.z;
          let n, a, s;
          r = e.create();
          const l = i.tileID.wrap - t.wrap << t.overscaledZ;
          o > 0 ? (n = e.EXTENT >> o, a = n * ((i.tileID.canonical.x << o) - t.canonical.x + l), s = n * ((i.tileID.canonical.y << o) - t.canonical.y)) : (n = e.EXTENT << -o, a = e.EXTENT * (i.tileID.canonical.x - (t.canonical.x + l << -o)), s = e.EXTENT * (i.tileID.canonical.y - (t.canonical.y << -o))), e.ortho(r, 0, n, 0, n, 0, 1), e.translate(r, r, [a, s, 0]);
        }

        return new yi(i.tileID, t.key, r);
      }

      _findTileCoveringTileID(t, i) {
        let o = i.getTile(t);
        if (o && o.hasData()) return o;
        const r = this._findCoveringTileCache[i.id],
              n = r[t.key];
        if (o = n ? i.getTileByID(n) : null, o && o.hasData() || null === n) return o;
        let a = o ? o.tileID : t,
            s = a.overscaledZ;
        const l = i.getSource().minzoom,
              c = [];

        if (!n) {
          const r = i.getSource().maxzoom;

          if (t.canonical.z >= r) {
            const o = t.canonical.z - r;
            i.getSource().reparseOverscaled ? (s = Math.max(t.canonical.z + 2, i.transform.tileZoom), a = new e.OverscaledTileID(s, t.wrap, r, t.canonical.x >> o, t.canonical.y >> o)) : 0 !== o && (s = r, a = new e.OverscaledTileID(s, t.wrap, r, t.canonical.x >> o, t.canonical.y >> o));
          }

          a.key !== t.key && (c.push(a.key), o = i.getTile(a));
        }

        const h = e => {
          c.forEach(t => {
            r[t] = e;
          }), c.length = 0;
        };

        for (s -= 1; s >= l && (!o || !o.hasData()); s--) {
          o && h(o.tileID.key);
          const e = a.calculateScaledKey(s);
          if (o = i.getTileByID(e), o && o.hasData()) break;
          const t = r[e];
          if (null === t) break;
          void 0 === t ? c.push(e) : o = i.getTileByID(t);
        }

        return h(o ? o.tileID.key : null), o && o.hasData() ? o : null;
      }

      findDEMTileFor(e) {
        return this.enabled ? this._findTileCoveringTileID(e, this.sourceCache) : null;
      }

      prepareDrawTile() {
        this.renderedToTile = !0;
      }

      _clearRenderCacheForTile(e, t) {
        let i = this._tilesDirty[e];
        i || (i = this._tilesDirty[e] = {}), i[t.key] = !0;
      }

      getWirefameBuffer() {
        if (!this.wireframeSegments) {
          const t = function (t) {
            let i = 0;
            const o = new e.StructArrayLayout2ui4(),
                  r = 131;

            for (let e = 1; e < 129; e++) {
              for (let t = 1; t < 129; t++) i = e * r + t, o.emplaceBack(i, i + 1), o.emplaceBack(i, i + r), o.emplaceBack(i + 1, i + r), 128 === e && o.emplaceBack(i + r, i + r + 1);

              o.emplaceBack(i + 1, i + 1 + r);
            }

            return o;
          }();

          this.wireframeIndexBuffer = this.painter.context.createIndexBuffer(t), this.wireframeSegments = e.SegmentVector.simpleSegment(0, 0, this.gridBuffer.length, t.length);
        }

        return [this.wireframeIndexBuffer, this.wireframeSegments];
      }

    }

    function wi(e) {
      const t = [];

      for (let i = 0; i < e.length; i++) {
        if (null === e[i]) continue;
        const o = e[i].split(" ");
        t.push(o.pop());
      }

      return t;
    }

    class Ti {
      static cacheKey(e, t, i) {
        let o = `${e}${i ? i.cacheKey : ""}`;

        for (const e of t) o += `/${e}`;

        return o;
      }

      constructor(t, i, o, r, n, a) {
        const s = t.gl;
        this.program = s.createProgram();

        const l = wi(o.staticAttributes),
              c = r ? r.getBinderAttributes() : [],
              h = l.concat(c),
              _ = o.staticUniforms ? wi(o.staticUniforms) : [],
              u = r ? r.getBinderUniforms() : [],
              d = _.concat(u),
              p = [];

        for (const e of d) p.indexOf(e) < 0 && p.push(e);

        let m = r ? r.defines() : [];
        m = m.concat(a.map(e => `#define ${e}`));
        const f = m.concat("\n#ifdef GL_ES\nprecision mediump float;\n#else\n\n#if !defined(lowp)\n#define lowp\n#endif\n\n#if !defined(mediump)\n#define mediump\n#endif\n\n#if !defined(highp)\n#define highp\n#endif\n\n#endif", ei, Qt.fragmentSource, Jt.fragmentSource, o.fragmentSource).join("\n"),
              g = m.concat("\n#ifdef GL_ES\nprecision highp float;\n#else\n\n#if !defined(lowp)\n#define lowp\n#endif\n\n#if !defined(mediump)\n#define mediump\n#endif\n\n#if !defined(highp)\n#define highp\n#endif\n\n#endif", ei, Qt.vertexSource, Jt.vertexSource, Yt.vertexSource, o.vertexSource).join("\n"),
              v = s.createShader(s.FRAGMENT_SHADER);
        if (s.isContextLost()) return void (this.failedToCreate = !0);
        s.shaderSource(v, f), s.compileShader(v), s.attachShader(this.program, v);
        const x = s.createShader(s.VERTEX_SHADER);
        if (s.isContextLost()) return void (this.failedToCreate = !0);
        s.shaderSource(x, g), s.compileShader(x), s.attachShader(this.program, x), this.attributes = {};
        const y = {};
        this.numAttributes = h.length;

        for (let e = 0; e < this.numAttributes; e++) h[e] && (s.bindAttribLocation(this.program, e, h[e]), this.attributes[h[e]] = e);

        s.linkProgram(this.program), s.deleteShader(x), s.deleteShader(v);

        for (let e = 0; e < p.length; e++) {
          const t = p[e];

          if (t && !y[t]) {
            const e = s.getUniformLocation(this.program, t);
            e && (y[t] = e);
          }
        }

        this.fixedUniforms = n(t, y), this.binderUniforms = r ? r.getUniforms(t, y) : [], -1 !== a.indexOf("TERRAIN") && (this.terrainUniforms = ((t, i) => ({
          u_dem: new e.Uniform1i(t, i.u_dem),
          u_dem_prev: new e.Uniform1i(t, i.u_dem_prev),
          u_dem_unpack: new e.Uniform4f(t, i.u_dem_unpack),
          u_dem_tl: new e.Uniform2f(t, i.u_dem_tl),
          u_dem_scale: new e.Uniform1f(t, i.u_dem_scale),
          u_dem_tl_prev: new e.Uniform2f(t, i.u_dem_tl_prev),
          u_dem_scale_prev: new e.Uniform1f(t, i.u_dem_scale_prev),
          u_dem_size: new e.Uniform1f(t, i.u_dem_size),
          u_dem_lerp: new e.Uniform1f(t, i.u_dem_lerp),
          u_exaggeration: new e.Uniform1f(t, i.u_exaggeration),
          u_depth: new e.Uniform1i(t, i.u_depth),
          u_depth_size_inv: new e.Uniform2f(t, i.u_depth_size_inv),
          u_meter_to_dem: new e.Uniform1f(t, i.u_meter_to_dem),
          u_label_plane_matrix_inv: new e.UniformMatrix4f(t, i.u_label_plane_matrix_inv),
          u_tile_tl_up: new e.Uniform3f(t, i.u_tile_tl_up),
          u_tile_tr_up: new e.Uniform3f(t, i.u_tile_tr_up),
          u_tile_br_up: new e.Uniform3f(t, i.u_tile_br_up),
          u_tile_bl_up: new e.Uniform3f(t, i.u_tile_bl_up),
          u_tile_up_scale: new e.Uniform1f(t, i.u_tile_up_scale)
        }))(t, y)), -1 !== a.indexOf("FOG") && (this.fogUniforms = ((t, i) => ({
          u_fog_matrix: new e.UniformMatrix4f(t, i.u_fog_matrix),
          u_fog_range: new e.Uniform2f(t, i.u_fog_range),
          u_fog_color: new e.Uniform4f(t, i.u_fog_color),
          u_fog_horizon_blend: new e.Uniform1f(t, i.u_fog_horizon_blend),
          u_fog_temporal_offset: new e.Uniform1f(t, i.u_fog_temporal_offset)
        }))(t, y));
      }

      setTerrainUniformValues(e, t) {
        if (!this.terrainUniforms) return;
        const i = this.terrainUniforms;

        if (!this.failedToCreate) {
          e.program.set(this.program);

          for (const e in t) i[e].set(t[e]);
        }
      }

      setFogUniformValues(e, t) {
        if (!this.fogUniforms) return;
        const i = this.fogUniforms;

        if (!this.failedToCreate) {
          e.program.set(this.program);

          for (const e in t) i[e].location && i[e].set(t[e]);
        }
      }

      draw(e, t, i, o, r, n, a, s, l, c, h, _, u, d, p, m) {
        const f = e.gl;
        if (this.failedToCreate) return;
        e.program.set(this.program), e.setDepthMode(i), e.setStencilMode(o), e.setColorMode(r), e.setCullFace(n);

        for (const e of Object.keys(this.fixedUniforms)) this.fixedUniforms[e].set(a[e]);

        d && d.setUniforms(e, this.binderUniforms, _, {
          zoom: u
        });
        const g = {
          [f.LINES]: 2,
          [f.TRIANGLES]: 3,
          [f.LINE_STRIP]: 1
        }[t];

        for (const i of h.get()) {
          const o = i.vaos || (i.vaos = {});
          (o[s] || (o[s] = new oi())).bind(e, this, l, d ? d.getPaintVertexBuffers() : [], c, i.vertexOffset, p, m), f.drawElements(t, i.primitiveLength * g, f.UNSIGNED_SHORT, i.primitiveOffset * g * 2);
        }
      }

    }

    function Ei(e, t, i) {
      const o = 1 / L(i, 1, t.transform.tileZoom),
            r = Math.pow(2, i.tileID.overscaledZ),
            n = i.tileSize * Math.pow(2, t.transform.tileZoom) / r,
            a = n * (i.tileID.canonical.x + i.tileID.wrap * r),
            s = n * i.tileID.canonical.y;
      return {
        u_image: 0,
        u_texsize: i.imageAtlasTexture.size,
        u_scale: [o, e.fromScale, e.toScale],
        u_fade: e.t,
        u_pixel_coord_upper: [a >> 16, s >> 16],
        u_pixel_coord_lower: [65535 & a, 65535 & s]
      };
    }

    const Ci = e.create(),
          Ii = (t, i, o, r, n, a, s, l, c) => {
      const h = i.style.light,
            _ = h.properties.get("position"),
            u = [_.x, _.y, _.z],
            d = e.create$1();

      "viewport" === h.properties.get("anchor") && (e.fromRotation(d, -i.transform.angle), e.transformMat3(u, u, d));
      const p = h.properties.get("color"),
            m = i.transform,
            f = {
        u_matrix: t,
        u_lightpos: u,
        u_lightintensity: h.properties.get("intensity"),
        u_lightcolor: [p.r, p.g, p.b],
        u_vertical_gradient: +o,
        u_opacity: r,
        u_tile_id: [0, 0, 0],
        u_zoom_transition: 0,
        u_inv_rot_matrix: Ci,
        u_merc_center: [0, 0],
        u_up_dir: [0, 0, 0],
        u_height_lift: 0
      };
      return "globe" === m.projection.name && (f.u_tile_id = [n.canonical.x, n.canonical.y, 1 << n.canonical.z], f.u_zoom_transition = s, f.u_inv_rot_matrix = c, f.u_merc_center = l, f.u_up_dir = m.projection.upVector(new e.CanonicalTileID(0, 0, 0), l[0] * e.EXTENT, l[1] * e.EXTENT), f.u_height_lift = a), f;
    },
          Mi = (t, i, o, r, n, a, s, l, c, h, _) => {
      const u = Ii(t, i, o, r, n, l, c, h, _),
            d = {
        u_height_factor: -Math.pow(2, n.overscaledZ) / s.tileSize / 8
      };
      return e.extend(u, Ei(a, i, s), d);
    },
          Si = e => ({
      u_matrix: e
    }),
          zi = (t, i, o, r) => e.extend(Si(t), Ei(o, i, r)),
          Di = (e, t) => ({
      u_matrix: e,
      u_world: t
    }),
          Pi = (t, i, o, r, n) => e.extend(zi(t, i, o, r), {
      u_world: n
    }),
          Ai = e.create(),
          Li = (t, i, o, r, n, a) => {
      const s = t.transform,
            l = "globe" === s.projection.name;
      let c;
      if ("map" === a.paint.get("circle-pitch-alignment")) {
        if (l) {
          const t = e.globePixelsToTileUnits(s.zoom, i.canonical);
          c = Float32Array.from([t, 0, 0, t]);
        } else c = s.calculatePixelsToTileUnitsMatrix(o);
      } else c = new Float32Array([s.pixelsToGLUnits[0], 0, 0, s.pixelsToGLUnits[1]]);
      const h = {
        u_camera_to_center_distance: s.cameraToCenterDistance,
        u_matrix: t.translatePosMatrix(i.projMatrix, o, a.paint.get("circle-translate"), a.paint.get("circle-translate-anchor")),
        u_device_pixel_ratio: e.exported.devicePixelRatio,
        u_extrude_scale: c,
        u_inv_rot_matrix: Ai,
        u_merc_center: [0, 0],
        u_tile_id: [0, 0, 0],
        u_zoom_transition: 0,
        u_up_dir: [0, 0, 0]
      };
      return l && (h.u_inv_rot_matrix = r, h.u_merc_center = n, h.u_tile_id = [i.canonical.x, i.canonical.y, 1 << i.canonical.z], h.u_zoom_transition = e.globeToMercatorTransition(s.zoom), h.u_up_dir = s.projection.upVector(i.canonical, n[0], n[1])), h;
    },
          Ri = e => {
      const t = [];
      return "map" === e.paint.get("circle-pitch-alignment") && t.push("PITCH_WITH_MAP"), "map" === e.paint.get("circle-pitch-scale") && t.push("SCALE_WITH_MAP"), t;
    },
          ki = (t, i, o) => {
      const r = e.EXTENT / o.tileSize;
      return {
        u_matrix: t,
        u_camera_to_center_distance: i.cameraToCenterDistance,
        u_extrude_scale: [i.pixelsToGLUnits[0] / r, i.pixelsToGLUnits[1] / r]
      };
    },
          Oi = (e, t, i = 1) => ({
      u_matrix: e,
      u_color: t,
      u_overlay: 0,
      u_overlay_scale: i
    }),
          Bi = e.create(),
          Fi = (t, i, o, r, n, a, s) => {
      const l = t.transform,
            c = "globe" === l.projection.name,
            h = c ? e.globePixelsToTileUnits(l.zoom, i.canonical) : L(o, 1, a),
            _ = {
        u_matrix: i.projMatrix,
        u_extrude_scale: h,
        u_intensity: s,
        u_inv_rot_matrix: Bi,
        u_merc_center: [0, 0],
        u_tile_id: [0, 0, 0],
        u_zoom_transition: 0,
        u_up_dir: [0, 0, 0]
      };
      return c && (_.u_inv_rot_matrix = r, _.u_merc_center = n, _.u_tile_id = [i.canonical.x, i.canonical.y, 1 << i.canonical.z], _.u_zoom_transition = e.globeToMercatorTransition(l.zoom), _.u_up_dir = l.projection.upVector(i.canonical, n[0], n[1])), _;
    },
          Ui = (e, t, i, o, r, n, a) => {
      const s = e.transform,
            l = s.calculatePixelsToTileUnitsMatrix(t),
            c = {
        u_matrix: ji(e, t, i, r),
        u_pixels_to_tile_units: l,
        u_device_pixel_ratio: a,
        u_units_to_pixels: [1 / s.pixelsToGLUnits[0], 1 / s.pixelsToGLUnits[1]],
        u_dash_image: 0,
        u_gradient_image: 1,
        u_image_height: n,
        u_texsize: [0, 0],
        u_scale: [0, 0, 0],
        u_mix: 0,
        u_alpha_discard_threshold: 0
      };

      if (Zi(i)) {
        const i = Gi(t, e.transform);
        c.u_texsize = t.lineAtlasTexture.size, c.u_scale = [i, o.fromScale, o.toScale], c.u_mix = o.t;
      }

      return c;
    },
          Ni = (e, t, i, o, r, n) => {
      const a = e.transform,
            s = Gi(t, a);
      return {
        u_matrix: ji(e, t, i, r),
        u_texsize: t.imageAtlasTexture.size,
        u_pixels_to_tile_units: a.calculatePixelsToTileUnitsMatrix(t),
        u_device_pixel_ratio: n,
        u_image: 0,
        u_scale: [s, o.fromScale, o.toScale],
        u_fade: o.t,
        u_units_to_pixels: [1 / a.pixelsToGLUnits[0], 1 / a.pixelsToGLUnits[1]],
        u_alpha_discard_threshold: 0
      };
    };

    function Gi(e, t) {
      return 1 / L(e, 1, t.tileZoom);
    }

    function ji(e, t, i, o) {
      return e.translatePosMatrix(o || t.tileID.projMatrix, t, i.paint.get("line-translate"), i.paint.get("line-translate-anchor"));
    }

    function Zi(e) {
      const t = e.paint.get("line-dasharray").value;
      return t.value || "constant" !== t.kind;
    }

    const Vi = (e, t, i, o, r, n) => {
      return {
        u_matrix: e,
        u_tl_parent: t,
        u_scale_parent: i,
        u_fade_t: o.mix,
        u_opacity: o.opacity * r.paint.get("raster-opacity"),
        u_image0: 0,
        u_image1: 1,
        u_brightness_low: r.paint.get("raster-brightness-min"),
        u_brightness_high: r.paint.get("raster-brightness-max"),
        u_saturation_factor: (s = r.paint.get("raster-saturation"), s > 0 ? 1 - 1 / (1.001 - s) : -s),
        u_contrast_factor: (a = r.paint.get("raster-contrast"), a > 0 ? 1 / (1 - a) : 1 + a),
        u_spin_weights: Wi(r.paint.get("raster-hue-rotate")),
        u_perspective_transform: n
      };
      var a, s;
    };

    function Wi(e) {
      e *= Math.PI / 180;
      const t = Math.sin(e),
            i = Math.cos(e);
      return [(2 * i + 1) / 3, (-Math.sqrt(3) * t - i + 1) / 3, (Math.sqrt(3) * t - i + 1) / 3];
    }

    const qi = e.create(),
          Xi = (t, i, o, r, n, a, s, l, c, h, _, u, d, p) => {
      const m = n.transform,
            f = {
        u_is_size_zoom_constant: +("constant" === t || "source" === t),
        u_is_size_feature_constant: +("constant" === t || "camera" === t),
        u_size_t: i ? i.uSizeT : 0,
        u_size: i ? i.uSize : 0,
        u_camera_to_center_distance: m.cameraToCenterDistance,
        u_rotate_symbol: +o,
        u_aspect_ratio: m.width / m.height,
        u_fade_change: n.options.fadeDuration ? n.symbolFadeChange : 1,
        u_matrix: a,
        u_label_plane_matrix: s,
        u_coord_matrix: l,
        u_is_text: +c,
        u_pitch_with_map: +r,
        u_texsize: h,
        u_texture: 0,
        u_tile_id: [0, 0, 0],
        u_zoom_transition: 0,
        u_inv_rot_matrix: qi,
        u_merc_center: [0, 0],
        u_camera_forward: [0, 0, 0],
        u_ecef_origin: [0, 0, 0],
        u_tile_matrix: qi
      };
      return "globe" === m.projection.name && (f.u_tile_id = [_.canonical.x, _.canonical.y, 1 << _.canonical.z], f.u_zoom_transition = u, f.u_inv_rot_matrix = p, f.u_merc_center = d, f.u_camera_forward = m._camera.forward(), f.u_ecef_origin = e.globeECEFOrigin(m.globeMatrix, _.toUnwrapped()), f.u_tile_matrix = Float32Array.from(m.globeMatrix)), f;
    },
          $i = (t, i, o, r, n, a, s, l, c, h, _, u, d, p, m) => {
      const {
        cameraToCenterDistance: f,
        _pitch: g
      } = n.transform;
      return e.extend(Xi(t, i, o, r, n, a, s, l, c, h, u, d, p, m), {
        u_gamma_scale: r ? f * Math.cos(n.terrain ? 0 : g) : 1,
        u_device_pixel_ratio: e.exported.devicePixelRatio,
        u_is_halo: +_
      });
    },
          Hi = (t, i, o, r, n, a, s, l, c, h, _, u, d, p) => e.extend($i(t, i, o, r, n, a, s, l, !0, c, !0, _, u, d, p), {
      u_texsize_icon: h,
      u_texture_icon: 1
    }),
          Ki = (e, t, i) => ({
      u_matrix: e,
      u_opacity: t,
      u_color: i
    }),
          Yi = (t, i, o, r, n, a) => e.extend(function (e, t, i, o) {
      const r = i.imageManager.getPattern(e.from.toString()),
            n = i.imageManager.getPattern(e.to.toString()),
            {
        width: a,
        height: s
      } = i.imageManager.getPixelSize(),
            l = Math.pow(2, o.tileID.overscaledZ),
            c = o.tileSize * Math.pow(2, i.transform.tileZoom) / l,
            h = c * (o.tileID.canonical.x + o.tileID.wrap * l),
            _ = c * o.tileID.canonical.y;

      return {
        u_image: 0,
        u_pattern_tl_a: r.tl,
        u_pattern_br_a: r.br,
        u_pattern_tl_b: n.tl,
        u_pattern_br_b: n.br,
        u_texsize: [a, s],
        u_mix: t.t,
        u_pattern_size_a: r.displaySize,
        u_pattern_size_b: n.displaySize,
        u_scale_a: t.fromScale,
        u_scale_b: t.toScale,
        u_tile_units_to_pixels: 1 / L(o, 1, i.transform.tileZoom),
        u_pixel_coord_upper: [h >> 16, _ >> 16],
        u_pixel_coord_lower: [65535 & h, 65535 & _]
      };
    }(r, a, o, n), {
      u_matrix: t,
      u_opacity: i
    }),
          Ji = {
      fillExtrusion: (t, i) => ({
        u_matrix: new e.UniformMatrix4f(t, i.u_matrix),
        u_lightpos: new e.Uniform3f(t, i.u_lightpos),
        u_lightintensity: new e.Uniform1f(t, i.u_lightintensity),
        u_lightcolor: new e.Uniform3f(t, i.u_lightcolor),
        u_vertical_gradient: new e.Uniform1f(t, i.u_vertical_gradient),
        u_opacity: new e.Uniform1f(t, i.u_opacity),
        u_tile_id: new e.Uniform3f(t, i.u_tile_id),
        u_zoom_transition: new e.Uniform1f(t, i.u_zoom_transition),
        u_inv_rot_matrix: new e.UniformMatrix4f(t, i.u_inv_rot_matrix),
        u_merc_center: new e.Uniform2f(t, i.u_merc_center),
        u_up_dir: new e.Uniform3f(t, i.u_up_dir),
        u_height_lift: new e.Uniform1f(t, i.u_height_lift)
      }),
      fillExtrusionPattern: (t, i) => ({
        u_matrix: new e.UniformMatrix4f(t, i.u_matrix),
        u_lightpos: new e.Uniform3f(t, i.u_lightpos),
        u_lightintensity: new e.Uniform1f(t, i.u_lightintensity),
        u_lightcolor: new e.Uniform3f(t, i.u_lightcolor),
        u_vertical_gradient: new e.Uniform1f(t, i.u_vertical_gradient),
        u_height_factor: new e.Uniform1f(t, i.u_height_factor),
        u_tile_id: new e.Uniform3f(t, i.u_tile_id),
        u_zoom_transition: new e.Uniform1f(t, i.u_zoom_transition),
        u_inv_rot_matrix: new e.UniformMatrix4f(t, i.u_inv_rot_matrix),
        u_merc_center: new e.Uniform2f(t, i.u_merc_center),
        u_up_dir: new e.Uniform3f(t, i.u_up_dir),
        u_height_lift: new e.Uniform1f(t, i.u_height_lift),
        u_image: new e.Uniform1i(t, i.u_image),
        u_texsize: new e.Uniform2f(t, i.u_texsize),
        u_pixel_coord_upper: new e.Uniform2f(t, i.u_pixel_coord_upper),
        u_pixel_coord_lower: new e.Uniform2f(t, i.u_pixel_coord_lower),
        u_scale: new e.Uniform3f(t, i.u_scale),
        u_fade: new e.Uniform1f(t, i.u_fade),
        u_opacity: new e.Uniform1f(t, i.u_opacity)
      }),
      fill: (t, i) => ({
        u_matrix: new e.UniformMatrix4f(t, i.u_matrix)
      }),
      fillPattern: (t, i) => ({
        u_matrix: new e.UniformMatrix4f(t, i.u_matrix),
        u_image: new e.Uniform1i(t, i.u_image),
        u_texsize: new e.Uniform2f(t, i.u_texsize),
        u_pixel_coord_upper: new e.Uniform2f(t, i.u_pixel_coord_upper),
        u_pixel_coord_lower: new e.Uniform2f(t, i.u_pixel_coord_lower),
        u_scale: new e.Uniform3f(t, i.u_scale),
        u_fade: new e.Uniform1f(t, i.u_fade)
      }),
      fillOutline: (t, i) => ({
        u_matrix: new e.UniformMatrix4f(t, i.u_matrix),
        u_world: new e.Uniform2f(t, i.u_world)
      }),
      fillOutlinePattern: (t, i) => ({
        u_matrix: new e.UniformMatrix4f(t, i.u_matrix),
        u_world: new e.Uniform2f(t, i.u_world),
        u_image: new e.Uniform1i(t, i.u_image),
        u_texsize: new e.Uniform2f(t, i.u_texsize),
        u_pixel_coord_upper: new e.Uniform2f(t, i.u_pixel_coord_upper),
        u_pixel_coord_lower: new e.Uniform2f(t, i.u_pixel_coord_lower),
        u_scale: new e.Uniform3f(t, i.u_scale),
        u_fade: new e.Uniform1f(t, i.u_fade)
      }),
      circle: (t, i) => ({
        u_camera_to_center_distance: new e.Uniform1f(t, i.u_camera_to_center_distance),
        u_extrude_scale: new e.UniformMatrix2f(t, i.u_extrude_scale),
        u_device_pixel_ratio: new e.Uniform1f(t, i.u_device_pixel_ratio),
        u_matrix: new e.UniformMatrix4f(t, i.u_matrix),
        u_inv_rot_matrix: new e.UniformMatrix4f(t, i.u_inv_rot_matrix),
        u_merc_center: new e.Uniform2f(t, i.u_merc_center),
        u_tile_id: new e.Uniform3f(t, i.u_tile_id),
        u_zoom_transition: new e.Uniform1f(t, i.u_zoom_transition),
        u_up_dir: new e.Uniform3f(t, i.u_up_dir)
      }),
      collisionBox: (t, i) => ({
        u_matrix: new e.UniformMatrix4f(t, i.u_matrix),
        u_camera_to_center_distance: new e.Uniform1f(t, i.u_camera_to_center_distance),
        u_extrude_scale: new e.Uniform2f(t, i.u_extrude_scale)
      }),
      collisionCircle: (t, i) => ({
        u_matrix: new e.UniformMatrix4f(t, i.u_matrix),
        u_inv_matrix: new e.UniformMatrix4f(t, i.u_inv_matrix),
        u_camera_to_center_distance: new e.Uniform1f(t, i.u_camera_to_center_distance),
        u_viewport_size: new e.Uniform2f(t, i.u_viewport_size)
      }),
      debug: (t, i) => ({
        u_color: new e.UniformColor(t, i.u_color),
        u_matrix: new e.UniformMatrix4f(t, i.u_matrix),
        u_overlay: new e.Uniform1i(t, i.u_overlay),
        u_overlay_scale: new e.Uniform1f(t, i.u_overlay_scale)
      }),
      clippingMask: (t, i) => ({
        u_matrix: new e.UniformMatrix4f(t, i.u_matrix)
      }),
      heatmap: (t, i) => ({
        u_extrude_scale: new e.Uniform1f(t, i.u_extrude_scale),
        u_intensity: new e.Uniform1f(t, i.u_intensity),
        u_matrix: new e.UniformMatrix4f(t, i.u_matrix),
        u_inv_rot_matrix: new e.UniformMatrix4f(t, i.u_inv_rot_matrix),
        u_merc_center: new e.Uniform2f(t, i.u_merc_center),
        u_tile_id: new e.Uniform3f(t, i.u_tile_id),
        u_zoom_transition: new e.Uniform1f(t, i.u_zoom_transition),
        u_up_dir: new e.Uniform3f(t, i.u_up_dir)
      }),
      heatmapTexture: (t, i) => ({
        u_image: new e.Uniform1i(t, i.u_image),
        u_color_ramp: new e.Uniform1i(t, i.u_color_ramp),
        u_opacity: new e.Uniform1f(t, i.u_opacity)
      }),
      hillshade: (t, i) => ({
        u_matrix: new e.UniformMatrix4f(t, i.u_matrix),
        u_image: new e.Uniform1i(t, i.u_image),
        u_latrange: new e.Uniform2f(t, i.u_latrange),
        u_light: new e.Uniform2f(t, i.u_light),
        u_shadow: new e.UniformColor(t, i.u_shadow),
        u_highlight: new e.UniformColor(t, i.u_highlight),
        u_accent: new e.UniformColor(t, i.u_accent)
      }),
      hillshadePrepare: (t, i) => ({
        u_matrix: new e.UniformMatrix4f(t, i.u_matrix),
        u_image: new e.Uniform1i(t, i.u_image),
        u_dimension: new e.Uniform2f(t, i.u_dimension),
        u_zoom: new e.Uniform1f(t, i.u_zoom),
        u_unpack: new e.Uniform4f(t, i.u_unpack)
      }),
      line: (t, i) => ({
        u_matrix: new e.UniformMatrix4f(t, i.u_matrix),
        u_pixels_to_tile_units: new e.UniformMatrix2f(t, i.u_pixels_to_tile_units),
        u_device_pixel_ratio: new e.Uniform1f(t, i.u_device_pixel_ratio),
        u_units_to_pixels: new e.Uniform2f(t, i.u_units_to_pixels),
        u_dash_image: new e.Uniform1i(t, i.u_dash_image),
        u_gradient_image: new e.Uniform1i(t, i.u_gradient_image),
        u_image_height: new e.Uniform1f(t, i.u_image_height),
        u_texsize: new e.Uniform2f(t, i.u_texsize),
        u_scale: new e.Uniform3f(t, i.u_scale),
        u_mix: new e.Uniform1f(t, i.u_mix),
        u_alpha_discard_threshold: new e.Uniform1f(t, i.u_alpha_discard_threshold)
      }),
      linePattern: (t, i) => ({
        u_matrix: new e.UniformMatrix4f(t, i.u_matrix),
        u_texsize: new e.Uniform2f(t, i.u_texsize),
        u_pixels_to_tile_units: new e.UniformMatrix2f(t, i.u_pixels_to_tile_units),
        u_device_pixel_ratio: new e.Uniform1f(t, i.u_device_pixel_ratio),
        u_image: new e.Uniform1i(t, i.u_image),
        u_units_to_pixels: new e.Uniform2f(t, i.u_units_to_pixels),
        u_scale: new e.Uniform3f(t, i.u_scale),
        u_fade: new e.Uniform1f(t, i.u_fade),
        u_alpha_discard_threshold: new e.Uniform1f(t, i.u_alpha_discard_threshold)
      }),
      raster: (t, i) => ({
        u_matrix: new e.UniformMatrix4f(t, i.u_matrix),
        u_tl_parent: new e.Uniform2f(t, i.u_tl_parent),
        u_scale_parent: new e.Uniform1f(t, i.u_scale_parent),
        u_fade_t: new e.Uniform1f(t, i.u_fade_t),
        u_opacity: new e.Uniform1f(t, i.u_opacity),
        u_image0: new e.Uniform1i(t, i.u_image0),
        u_image1: new e.Uniform1i(t, i.u_image1),
        u_brightness_low: new e.Uniform1f(t, i.u_brightness_low),
        u_brightness_high: new e.Uniform1f(t, i.u_brightness_high),
        u_saturation_factor: new e.Uniform1f(t, i.u_saturation_factor),
        u_contrast_factor: new e.Uniform1f(t, i.u_contrast_factor),
        u_spin_weights: new e.Uniform3f(t, i.u_spin_weights),
        u_perspective_transform: new e.Uniform2f(t, i.u_perspective_transform)
      }),
      symbolIcon: (t, i) => ({
        u_is_size_zoom_constant: new e.Uniform1i(t, i.u_is_size_zoom_constant),
        u_is_size_feature_constant: new e.Uniform1i(t, i.u_is_size_feature_constant),
        u_size_t: new e.Uniform1f(t, i.u_size_t),
        u_size: new e.Uniform1f(t, i.u_size),
        u_camera_to_center_distance: new e.Uniform1f(t, i.u_camera_to_center_distance),
        u_rotate_symbol: new e.Uniform1i(t, i.u_rotate_symbol),
        u_aspect_ratio: new e.Uniform1f(t, i.u_aspect_ratio),
        u_fade_change: new e.Uniform1f(t, i.u_fade_change),
        u_matrix: new e.UniformMatrix4f(t, i.u_matrix),
        u_label_plane_matrix: new e.UniformMatrix4f(t, i.u_label_plane_matrix),
        u_coord_matrix: new e.UniformMatrix4f(t, i.u_coord_matrix),
        u_is_text: new e.Uniform1i(t, i.u_is_text),
        u_pitch_with_map: new e.Uniform1i(t, i.u_pitch_with_map),
        u_texsize: new e.Uniform2f(t, i.u_texsize),
        u_tile_id: new e.Uniform3f(t, i.u_tile_id),
        u_zoom_transition: new e.Uniform1f(t, i.u_zoom_transition),
        u_inv_rot_matrix: new e.UniformMatrix4f(t, i.u_inv_rot_matrix),
        u_merc_center: new e.Uniform2f(t, i.u_merc_center),
        u_camera_forward: new e.Uniform3f(t, i.u_camera_forward),
        u_tile_matrix: new e.UniformMatrix4f(t, i.u_tile_matrix),
        u_ecef_origin: new e.Uniform3f(t, i.u_ecef_origin),
        u_texture: new e.Uniform1i(t, i.u_texture)
      }),
      symbolSDF: (t, i) => ({
        u_is_size_zoom_constant: new e.Uniform1i(t, i.u_is_size_zoom_constant),
        u_is_size_feature_constant: new e.Uniform1i(t, i.u_is_size_feature_constant),
        u_size_t: new e.Uniform1f(t, i.u_size_t),
        u_size: new e.Uniform1f(t, i.u_size),
        u_camera_to_center_distance: new e.Uniform1f(t, i.u_camera_to_center_distance),
        u_rotate_symbol: new e.Uniform1i(t, i.u_rotate_symbol),
        u_aspect_ratio: new e.Uniform1f(t, i.u_aspect_ratio),
        u_fade_change: new e.Uniform1f(t, i.u_fade_change),
        u_matrix: new e.UniformMatrix4f(t, i.u_matrix),
        u_label_plane_matrix: new e.UniformMatrix4f(t, i.u_label_plane_matrix),
        u_coord_matrix: new e.UniformMatrix4f(t, i.u_coord_matrix),
        u_is_text: new e.Uniform1i(t, i.u_is_text),
        u_pitch_with_map: new e.Uniform1i(t, i.u_pitch_with_map),
        u_texsize: new e.Uniform2f(t, i.u_texsize),
        u_texture: new e.Uniform1i(t, i.u_texture),
        u_gamma_scale: new e.Uniform1f(t, i.u_gamma_scale),
        u_device_pixel_ratio: new e.Uniform1f(t, i.u_device_pixel_ratio),
        u_tile_id: new e.Uniform3f(t, i.u_tile_id),
        u_zoom_transition: new e.Uniform1f(t, i.u_zoom_transition),
        u_inv_rot_matrix: new e.UniformMatrix4f(t, i.u_inv_rot_matrix),
        u_merc_center: new e.Uniform2f(t, i.u_merc_center),
        u_camera_forward: new e.Uniform3f(t, i.u_camera_forward),
        u_tile_matrix: new e.UniformMatrix4f(t, i.u_tile_matrix),
        u_ecef_origin: new e.Uniform3f(t, i.u_ecef_origin),
        u_is_halo: new e.Uniform1i(t, i.u_is_halo)
      }),
      symbolTextAndIcon: (t, i) => ({
        u_is_size_zoom_constant: new e.Uniform1i(t, i.u_is_size_zoom_constant),
        u_is_size_feature_constant: new e.Uniform1i(t, i.u_is_size_feature_constant),
        u_size_t: new e.Uniform1f(t, i.u_size_t),
        u_size: new e.Uniform1f(t, i.u_size),
        u_camera_to_center_distance: new e.Uniform1f(t, i.u_camera_to_center_distance),
        u_rotate_symbol: new e.Uniform1i(t, i.u_rotate_symbol),
        u_aspect_ratio: new e.Uniform1f(t, i.u_aspect_ratio),
        u_fade_change: new e.Uniform1f(t, i.u_fade_change),
        u_matrix: new e.UniformMatrix4f(t, i.u_matrix),
        u_label_plane_matrix: new e.UniformMatrix4f(t, i.u_label_plane_matrix),
        u_coord_matrix: new e.UniformMatrix4f(t, i.u_coord_matrix),
        u_is_text: new e.Uniform1i(t, i.u_is_text),
        u_pitch_with_map: new e.Uniform1i(t, i.u_pitch_with_map),
        u_texsize: new e.Uniform2f(t, i.u_texsize),
        u_texsize_icon: new e.Uniform2f(t, i.u_texsize_icon),
        u_texture: new e.Uniform1i(t, i.u_texture),
        u_texture_icon: new e.Uniform1i(t, i.u_texture_icon),
        u_gamma_scale: new e.Uniform1f(t, i.u_gamma_scale),
        u_device_pixel_ratio: new e.Uniform1f(t, i.u_device_pixel_ratio),
        u_is_halo: new e.Uniform1i(t, i.u_is_halo)
      }),
      background: (t, i) => ({
        u_matrix: new e.UniformMatrix4f(t, i.u_matrix),
        u_opacity: new e.Uniform1f(t, i.u_opacity),
        u_color: new e.UniformColor(t, i.u_color)
      }),
      backgroundPattern: (t, i) => ({
        u_matrix: new e.UniformMatrix4f(t, i.u_matrix),
        u_opacity: new e.Uniform1f(t, i.u_opacity),
        u_image: new e.Uniform1i(t, i.u_image),
        u_pattern_tl_a: new e.Uniform2f(t, i.u_pattern_tl_a),
        u_pattern_br_a: new e.Uniform2f(t, i.u_pattern_br_a),
        u_pattern_tl_b: new e.Uniform2f(t, i.u_pattern_tl_b),
        u_pattern_br_b: new e.Uniform2f(t, i.u_pattern_br_b),
        u_texsize: new e.Uniform2f(t, i.u_texsize),
        u_mix: new e.Uniform1f(t, i.u_mix),
        u_pattern_size_a: new e.Uniform2f(t, i.u_pattern_size_a),
        u_pattern_size_b: new e.Uniform2f(t, i.u_pattern_size_b),
        u_scale_a: new e.Uniform1f(t, i.u_scale_a),
        u_scale_b: new e.Uniform1f(t, i.u_scale_b),
        u_pixel_coord_upper: new e.Uniform2f(t, i.u_pixel_coord_upper),
        u_pixel_coord_lower: new e.Uniform2f(t, i.u_pixel_coord_lower),
        u_tile_units_to_pixels: new e.Uniform1f(t, i.u_tile_units_to_pixels)
      }),
      terrainRaster: li,
      terrainDepth: li,
      skybox: (t, i) => ({
        u_matrix: new e.UniformMatrix4f(t, i.u_matrix),
        u_sun_direction: new e.Uniform3f(t, i.u_sun_direction),
        u_cubemap: new e.Uniform1i(t, i.u_cubemap),
        u_opacity: new e.Uniform1f(t, i.u_opacity),
        u_temporal_offset: new e.Uniform1f(t, i.u_temporal_offset)
      }),
      skyboxGradient: (t, i) => ({
        u_matrix: new e.UniformMatrix4f(t, i.u_matrix),
        u_color_ramp: new e.Uniform1i(t, i.u_color_ramp),
        u_center_direction: new e.Uniform3f(t, i.u_center_direction),
        u_radius: new e.Uniform1f(t, i.u_radius),
        u_opacity: new e.Uniform1f(t, i.u_opacity),
        u_temporal_offset: new e.Uniform1f(t, i.u_temporal_offset)
      }),
      skyboxCapture: (t, i) => ({
        u_matrix_3f: new e.UniformMatrix3f(t, i.u_matrix_3f),
        u_sun_direction: new e.Uniform3f(t, i.u_sun_direction),
        u_sun_intensity: new e.Uniform1f(t, i.u_sun_intensity),
        u_color_tint_r: new e.Uniform4f(t, i.u_color_tint_r),
        u_color_tint_m: new e.Uniform4f(t, i.u_color_tint_m),
        u_luminance: new e.Uniform1f(t, i.u_luminance)
      }),
      globeRaster: (t, i) => ({
        u_proj_matrix: new e.UniformMatrix4f(t, i.u_proj_matrix),
        u_globe_matrix: new e.UniformMatrix4f(t, i.u_globe_matrix),
        u_merc_matrix: new e.UniformMatrix4f(t, i.u_merc_matrix),
        u_zoom_transition: new e.Uniform1f(t, i.u_zoom_transition),
        u_merc_center: new e.Uniform2f(t, i.u_merc_center),
        u_image0: new e.Uniform1i(t, i.u_image0),
        u_grid_matrix: new e.UniformMatrix3f(t, i.u_grid_matrix)
      }),
      globeAtmosphere: (t, i) => ({
        u_frustum_tl: new e.Uniform3f(t, i.u_frustum_tl),
        u_frustum_tr: new e.Uniform3f(t, i.u_frustum_tr),
        u_frustum_br: new e.Uniform3f(t, i.u_frustum_br),
        u_frustum_bl: new e.Uniform3f(t, i.u_frustum_bl),
        u_globe_pos: new e.Uniform3f(t, i.u_globe_pos),
        u_globe_radius: new e.Uniform1f(t, i.u_globe_radius),
        u_opacity: new e.Uniform1f(t, i.u_opacity),
        u_fadeout_range: new e.Uniform1f(t, i.u_fadeout_range),
        u_start_color: new e.Uniform3f(t, i.u_start_color),
        u_end_color: new e.Uniform3f(t, i.u_end_color)
      })
    };

    let Qi;

    function eo(t, i, o, r, n, a, s) {
      const l = t.context,
            c = l.gl,
            h = t.useProgram("collisionBox"),
            _ = [];
      let u = 0,
          d = 0;

      for (let p = 0; p < r.length; p++) {
        const m = r[p],
              f = i.getTile(m),
              g = f.getBucket(o);
        if (!g) continue;
        let v = m.projMatrix;
        0 === n[0] && 0 === n[1] || (v = t.translatePosMatrix(m.projMatrix, f, n, a));
        const x = s ? g.textCollisionBox : g.iconCollisionBox,
              y = g.collisionCircleArray;

        if (y.length > 0) {
          const i = e.create(),
                o = v;
          e.mul(i, g.placementInvProjMatrix, t.transform.glCoordMatrix), e.mul(i, i, g.placementViewportMatrix), _.push({
            circleArray: y,
            circleOffset: d,
            transform: o,
            invTransform: i
          }), u += y.length / 4, d = u;
        }

        x && (t.terrain && t.terrain.setupElevationDraw(f, h), h.draw(l, c.LINES, e.DepthMode.disabled, e.StencilMode.disabled, t.colorModeForRenderPass(), e.CullFaceMode.disabled, ki(v, t.transform, f), o.id, x.layoutVertexBuffer, x.indexBuffer, x.segments, null, t.transform.zoom, null, x.collisionVertexBuffer, x.collisionVertexBufferExt));
      }

      if (!s || !_.length) return;
      const p = t.useProgram("collisionCircle"),
            m = new e.StructArrayLayout2f1f2i16();
      m.resize(4 * u), m._trim();
      let f = 0;

      for (const e of _) for (let t = 0; t < e.circleArray.length / 4; t++) {
        const i = 4 * t,
              o = e.circleArray[i + 0],
              r = e.circleArray[i + 1],
              n = e.circleArray[i + 2],
              a = e.circleArray[i + 3];
        m.emplace(f++, o, r, n, a, 0), m.emplace(f++, o, r, n, a, 1), m.emplace(f++, o, r, n, a, 2), m.emplace(f++, o, r, n, a, 3);
      }

      (!Qi || Qi.length < 2 * u) && (Qi = function (t) {
        const i = 2 * t,
              o = new e.StructArrayLayout3ui6();
        o.resize(i), o._trim();

        for (let e = 0; e < i; e++) {
          const t = 6 * e;
          o.uint16[t + 0] = 4 * e + 0, o.uint16[t + 1] = 4 * e + 1, o.uint16[t + 2] = 4 * e + 2, o.uint16[t + 3] = 4 * e + 2, o.uint16[t + 4] = 4 * e + 3, o.uint16[t + 5] = 4 * e + 0;
        }

        return o;
      }(u));
      const g = l.createIndexBuffer(Qi, !0),
            v = l.createVertexBuffer(m, e.collisionCircleLayout.members, !0);

      for (const i of _) {
        const r = {
          u_matrix: i.transform,
          u_inv_matrix: i.invTransform,
          u_camera_to_center_distance: (x = t.transform).cameraToCenterDistance,
          u_viewport_size: [x.width, x.height]
        };
        p.draw(l, c.TRIANGLES, e.DepthMode.disabled, e.StencilMode.disabled, t.colorModeForRenderPass(), e.CullFaceMode.disabled, r, o.id, v, g, e.SegmentVector.simpleSegment(0, 2 * i.circleOffset, i.circleArray.length, i.circleArray.length / 2), null, t.transform.zoom, null, null, null);
      }

      var x;
      v.destroy(), g.destroy();
    }

    const to = e.create();

    function io(t, i, o, r, n, a) {
      const {
        horizontalAlign: s,
        verticalAlign: l
      } = e.getAnchorAlignment(t),
            c = -(s - .5) * i,
            h = -(l - .5) * o,
            _ = e.evaluateVariableOffset(t, r);

      return new e.pointGeometry((c / n + _[0]) * a, (h / n + _[1]) * a);
    }

    function oo(t, i, o, r, n, a, s, l, c, h, _, u) {
      const d = t.text.placedSymbolArray,
            p = t.text.dynamicLayoutVertexArray,
            m = t.icon.dynamicLayoutVertexArray,
            f = {},
            g = l.projMatrix,
            v = a.elevation,
            x = u.upVectorScale(l.canonical, a.center.lat, a.worldSize);
      p.clear();

      for (let m = 0; m < d.length; m++) {
        const y = d.get(m),
              b = t.allowVerticalPlacement && !y.placedOrientation,
              w = y.hidden || !y.crossTileID || b ? null : r[y.crossTileID];

        if (w) {
          const r = new e.pointGeometry(y.tileAnchorX, y.tileAnchorY),
                d = u.upVector(l.canonical, r.x, r.y),
                m = v ? v.getAtTileOffset(l, r.x, r.y) : 0,
                b = it([y.projectedAnchorX + m * d[0] * x.metersToTile, y.projectedAnchorY + m * d[1] * x.metersToTile, y.projectedAnchorZ + m * d[2] * x.metersToTile], o ? g : s),
                T = ot(a.cameraToCenterDistance, b.signedDistanceFromCamera);
          let E = n.evaluateSizeForFeature(t.textSizeData, h, y) * T / e.ONE_EM;
          o && (E *= t.tilePixelRatio / c);
          const {
            width: C,
            height: I,
            anchor: M,
            textOffset: S,
            textScale: z
          } = w,
                D = io(M, C, I, S, z, E),
                P = o ? tt(r.add(D), s, m * x.metersToLabelSpace).point : b.point.add(i ? D.rotate(-a.angle) : D),
                A = t.allowVerticalPlacement && y.placedOrientation === e.WritingMode.vertical ? Math.PI / 2 : 0;

          for (let t = 0; t < y.numGlyphs; t++) e.addDynamicAttributes(p, P, A);

          _ && y.associatedIconIndex >= 0 && (f[y.associatedIconIndex] = {
            shiftedAnchor: P,
            angle: A
          });
        } else dt(y.numGlyphs, p);
      }

      if (_) {
        m.clear();
        const i = t.icon.placedSymbolArray;

        for (let t = 0; t < i.length; t++) {
          const o = i.get(t);
          if (o.hidden) dt(o.numGlyphs, m);else {
            const i = f[t];
            if (i) for (let t = 0; t < o.numGlyphs; t++) e.addDynamicAttributes(m, i.shiftedAnchor, i.angle);else dt(o.numGlyphs, m);
          }
        }

        t.icon.dynamicLayoutVertexBuffer.updateData(m);
      }

      t.text.dynamicLayoutVertexBuffer.updateData(p);
    }

    function ro(e, t, i) {
      return i.iconsInText && t ? "symbolTextAndIcon" : e ? "symbolSDF" : "symbolIcon";
    }

    function no(t, i, o, r, n, a, s, l, c, h, _, u) {
      const d = t.context,
            p = d.gl,
            m = t.transform,
            f = "map" === l,
            g = "map" === c,
            v = f && "point" !== o.layout.get("symbol-placement"),
            x = f && !g && !v,
            y = void 0 !== o.layout.get("symbol-sort-key").constantOr(1);
      let b = !1;
      const w = t.depthModeForSublayer(0, e.DepthMode.ReadOnly),
            T = [e.mercatorXfromLng(m.center.lng), e.mercatorYfromLat(m.center.lat)],
            E = o.layout.get("text-variable-anchor"),
            C = "globe" === m.projection.name,
            I = C ? e.globeToMercatorTransition(m.zoom) : 0,
            M = [],
            S = [];
      t.terrain && g && S.push("PITCH_WITH_MAP_TERRAIN"), C && S.push("PROJECTION_GLOBE_VIEW");

      for (const l of r) {
        const r = i.getTile(l),
              c = r.getBucket(o);
        if (!c || c.projection !== m.projection.name) continue;

        const _ = n ? c.text : c.icon;

        if (!_ || c.fullyClipped || !_.segments.get().length) continue;

        const u = _.programConfigurations.get(o.id),
              d = n || c.sdfIcons,
              w = n ? c.textSizeData : c.iconSizeData,
              C = g || 0 !== m.pitch,
              z = e.evaluateSizeForZoom(w, m.zoom);

        let D,
            P,
            A,
            L,
            R = [0, 0],
            k = null;

        if (n) {
          if (P = r.glyphAtlasTexture, A = p.LINEAR, D = r.glyphAtlasTexture.size, c.iconsInText) {
            R = r.imageAtlasTexture.size, k = r.imageAtlasTexture;
            const e = "composite" === w.kind || "camera" === w.kind;
            L = C || t.options.rotating || t.options.zooming || e ? p.LINEAR : p.NEAREST;
          }
        } else {
          const e = 1 !== o.layout.get("icon-size").constantOr(0) || c.iconsNeedLinear;
          P = r.imageAtlasTexture, A = d || t.options.rotating || t.options.zooming || e || C ? p.LINEAR : p.NEAREST, D = r.imageAtlasTexture.size;
        }

        const O = t.transform.calculatePixelsToTileUnitsMatrix(r),
              B = Qe(l.projMatrix, r.tileID.canonical, g, f, t.transform, O),
              F = t.terrain && g && v ? e.invert(e.create(), B) : to,
              U = et(l.projMatrix, r.tileID.canonical, g, f, t.transform, O),
              N = E && c.hasTextData(),
              G = "none" !== o.layout.get("icon-text-fit") && N && c.hasIconData();

        if (v) {
          const e = m.elevation,
                i = e ? e.getAtTileOffsetFunc(l, m.center.lat, m.worldSize, m.projection) : e => [0, 0, 0];
          nt(c, l.projMatrix, t, n, B, U, g, h, i, l);
        }

        const j = v || n && E || G,
              Z = t.translatePosMatrix(l.projMatrix, r, a, s),
              V = j ? to : B,
              W = t.translatePosMatrix(U, r, a, s, !0),
              q = m.projection.createInversionMatrix(m, l.canonical),
              X = j ? S.concat(["PROJECTED_POS_ON_VIEWPORT"]) : S,
              $ = d && 0 !== o.paint.get(n ? "text-halo-width" : "icon-halo-width").constantOr(1);
        let H;
        H = d ? c.iconsInText ? Hi(w.kind, z, x, g, t, Z, V, W, D, R, l, I, T, q) : $i(w.kind, z, x, g, t, Z, V, W, n, D, !0, l, I, T, q) : Xi(w.kind, z, x, g, t, Z, V, W, n, D, l, I, T, q);
        const K = {
          program: t.useProgram(ro(d, n, c), u, X),
          buffers: _,
          uniformValues: H,
          atlasTexture: P,
          atlasTextureIcon: k,
          atlasInterpolation: A,
          atlasInterpolationIcon: L,
          isSDF: d,
          hasHalo: $,
          tile: r,
          labelPlaneMatrixInv: F
        };

        if (y && c.canOverlap) {
          b = !0;

          const t = _.segments.get();

          for (const i of t) M.push({
            segments: new e.SegmentVector([i]),
            sortKey: i.sortKey,
            state: K
          });
        } else M.push({
          segments: _.segments,
          sortKey: 0,
          state: K
        });
      }

      b && M.sort((e, t) => e.sortKey - t.sortKey);

      for (const e of M) {
        const i = e.state;

        if (t.terrain && t.terrain.setupElevationDraw(i.tile, i.program, {
          useDepthForOcclusion: !C,
          labelPlaneMatrixInv: i.labelPlaneMatrixInv
        }), d.activeTexture.set(p.TEXTURE0), i.atlasTexture.bind(i.atlasInterpolation, p.CLAMP_TO_EDGE), i.atlasTextureIcon && (d.activeTexture.set(p.TEXTURE1), i.atlasTextureIcon && i.atlasTextureIcon.bind(i.atlasInterpolationIcon, p.CLAMP_TO_EDGE)), i.isSDF) {
          const r = i.uniformValues;
          i.hasHalo && (r.u_is_halo = 1, ao(i.buffers, e.segments, o, t, i.program, w, _, u, r)), r.u_is_halo = 0;
        }

        ao(i.buffers, e.segments, o, t, i.program, w, _, u, i.uniformValues);
      }
    }

    function ao(t, i, o, r, n, a, s, l, c) {
      const h = r.context;
      n.draw(h, h.gl.TRIANGLES, a, s, l, e.CullFaceMode.disabled, c, o.id, t.layoutVertexBuffer, t.indexBuffer, i, o.paint, r.transform.zoom, t.programConfigurations.get(o.id), t.dynamicLayoutVertexBuffer, t.opacityVertexBuffer);
    }

    function so(t, i, o, r, n, a, s) {
      const l = t.context.gl,
            c = o.paint.get("fill-pattern"),
            h = c && c.constantOr(1),
            _ = o.getCrossfadeParameters();

      let u, d, p, m, f;
      s ? (d = h && !o.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", u = l.LINES) : (d = h ? "fillPattern" : "fill", u = l.TRIANGLES);

      for (const g of r) {
        const r = i.getTile(g);
        if (h && !r.patternsLoaded()) continue;
        const v = r.getBucket(o);
        if (!v) continue;
        t.prepareDrawTile();
        const x = v.programConfigurations.get(o.id),
              y = t.useProgram(d, x);
        h && (t.context.activeTexture.set(l.TEXTURE0), r.imageAtlasTexture.bind(l.LINEAR, l.CLAMP_TO_EDGE), x.updatePaintBuffers(_));
        const b = c.constantOr(null);

        if (b && r.imageAtlas) {
          const e = r.imageAtlas,
                t = e.patternPositions[b.to.toString()],
                i = e.patternPositions[b.from.toString()];
          t && i && x.setConstantPatternPositions(t, i);
        }

        const w = t.translatePosMatrix(g.projMatrix, r, o.paint.get("fill-translate"), o.paint.get("fill-translate-anchor"));

        if (s) {
          m = v.indexBuffer2, f = v.segments2;
          const e = t.terrain && t.terrain.renderingToTexture ? t.terrain.drapeBufferSize : [l.drawingBufferWidth, l.drawingBufferHeight];
          p = "fillOutlinePattern" === d && h ? Pi(w, t, _, r, e) : Di(w, e);
        } else m = v.indexBuffer, f = v.segments, p = h ? zi(w, t, _, r) : Si(w);

        t.prepareDrawProgram(t.context, y, g.toUnwrapped()), y.draw(t.context, u, n, t.stencilModeForClipping(g), a, e.CullFaceMode.disabled, p, o.id, v.layoutVertexBuffer, m, f, o.paint, t.transform.zoom, x);
      }
    }

    function lo(t, i, o, r, n, a, s) {
      const l = t.context,
            c = l.gl,
            h = t.transform,
            _ = o.paint.get("fill-extrusion-pattern"),
            u = _.constantOr(1),
            d = o.getCrossfadeParameters(),
            p = o.paint.get("fill-extrusion-opacity"),
            m = function (t) {
        if ("globe" !== t.projection.name) return 0;
        const i = Math.PI / 32,
              o = Math.tan(i),
              r = e.earthRadius;
        return r * Math.sqrt(1 + 2 * o * o) - r;
      }(h),
            f = "globe" === h.projection.name,
            g = f ? e.globeToMercatorTransition(h.zoom) : 0,
            v = [e.mercatorXfromLng(h.center.lng), e.mercatorYfromLat(h.center.lat)],
            x = [];

      f && x.push("PROJECTION_GLOBE_VIEW");

      for (const y of r) {
        const r = i.getTile(y),
              b = r.getBucket(o);
        if (!b || b.projection !== h.projection.name) continue;
        const w = b.programConfigurations.get(o.id),
              T = t.useProgram(u ? "fillExtrusionPattern" : "fillExtrusion", w, x);

        if (t.terrain) {
          const e = t.terrain;
          if (t.style.terrainSetForDrapingOnly()) e.setupElevationDraw(r, T, {
            useMeterToDem: !0
          });else {
            if (!b.enableTerrain) continue;

            if (e.setupElevationDraw(r, T, {
              useMeterToDem: !0
            }), co(l, i, y, b, o, e), !b.centroidVertexBuffer) {
              const e = T.attributes.a_centroid_pos;
              void 0 !== e && c.vertexAttrib2f(e, 0, 0);
            }
          }
        }

        u && (t.context.activeTexture.set(c.TEXTURE0), r.imageAtlasTexture.bind(c.LINEAR, c.CLAMP_TO_EDGE), w.updatePaintBuffers(d));

        const E = _.constantOr(null);

        if (E && r.imageAtlas) {
          const e = r.imageAtlas,
                t = e.patternPositions[E.to.toString()],
                i = e.patternPositions[E.from.toString()];
          t && i && w.setConstantPatternPositions(t, i);
        }

        const C = t.translatePosMatrix(y.projMatrix, r, o.paint.get("fill-extrusion-translate"), o.paint.get("fill-extrusion-translate-anchor")),
              I = h.projection.createInversionMatrix(h, y.canonical),
              M = o.paint.get("fill-extrusion-vertical-gradient"),
              S = u ? Mi(C, t, M, p, y, d, r, m, g, v, I) : Ii(C, t, M, p, y, m, g, v, I);
        t.prepareDrawProgram(l, T, y.toUnwrapped()), T.draw(l, l.gl.TRIANGLES, n, a, s, e.CullFaceMode.backCCW, S, o.id, b.layoutVertexBuffer, b.indexBuffer, b.segments, o.paint, t.transform.zoom, w, t.terrain ? b.centroidVertexBuffer : null, f ? b.layoutVertexExtBuffer : null);
      }
    }

    function co(t, i, o, r, n, a) {
      const s = [t => {
        let i = t.canonical.x - 1,
            o = t.wrap;
        return i < 0 && (i = (1 << t.canonical.z) - 1, o--), new e.OverscaledTileID(t.overscaledZ, o, t.canonical.z, i, t.canonical.y);
      }, t => {
        let i = t.canonical.x + 1,
            o = t.wrap;
        return i === 1 << t.canonical.z && (i = 0, o++), new e.OverscaledTileID(t.overscaledZ, o, t.canonical.z, i, t.canonical.y);
      }, t => new e.OverscaledTileID(t.overscaledZ, t.wrap, t.canonical.z, t.canonical.x, (0 === t.canonical.y ? 1 << t.canonical.z : t.canonical.y) - 1), t => new e.OverscaledTileID(t.overscaledZ, t.wrap, t.canonical.z, t.canonical.x, t.canonical.y === (1 << t.canonical.z) - 1 ? 0 : t.canonical.y + 1)],
            l = e => {
        const t = i.getSource().minzoom,
              o = e => {
          const t = i.getTileByID(e);
          if (t && t.hasData()) return t.getBucket(n);
        },
              r = [0, -1, 1];

        for (const i of r) {
          if (e.overscaledZ + i < t) continue;
          const r = o(e.calculateScaledKey(e.overscaledZ + i));
          if (r) return r;
        }
      },
            c = [0, 0, 0],
            h = (t, i) => (c[0] = Math.min(t.min.y, i.min.y), c[1] = Math.max(t.max.y, i.max.y), c[2] = e.EXTENT - i.min.x > t.max.x ? i.min.x - e.EXTENT : t.max.x, c),
            _ = (t, i) => (c[0] = Math.min(t.min.x, i.min.x), c[1] = Math.max(t.max.x, i.max.x), c[2] = e.EXTENT - i.min.y > t.max.y ? i.min.y - e.EXTENT : t.max.y, c),
            u = [(e, t) => h(e, t), (e, t) => h(t, e), (e, t) => _(e, t), (e, t) => _(t, e)],
            d = new e.pointGeometry(0, 0);

      let p, m, f;

      const g = (t, i, r, n, s) => {
        const l = [[n ? r : t, n ? t : r, 0], [n ? r : i, n ? i : r, 0]],
              c = s < 0 ? e.EXTENT + s : s,
              h = [n ? c : (t + i) / 2, n ? (t + i) / 2 : c, 0];
        return 0 === r && s < 0 || 0 !== r && s > 0 ? a.getForTilePoints(f, [h], !0, m) : l.push(h), a.getForTilePoints(o, l, !0, p), Math.max(l[0][2], l[1][2], h[2]) / a.exaggeration();
      };

      for (let t = 0; t < 4; t++) {
        const i = (t < 2 ? 1 : 5) - t,
              n = r.borders[t];
        if (0 === n.length) continue;
        const c = f = s[t](o),
              h = l(c);
        if (!(h && h instanceof e.FillExtrusionBucket && h.enableTerrain)) continue;
        if (r.borderDoneWithNeighborZ[t] === h.canonical.z && h.borderDoneWithNeighborZ[i] === r.canonical.z) continue;
        if (m = a.findDEMTileFor(c), !m || !m.dem) continue;

        if (!p) {
          const e = a.findDEMTileFor(o);
          if (!e || !e.dem) return;
          p = e;
        }

        const _ = h.borders[i];
        let v = 0;
        const x = h.borderDoneWithNeighborZ[i] !== r.canonical.z;

        if (r.canonical.z === h.canonical.z) {
          for (let o = 0; o < n.length; o++) {
            const a = r.featuresOnBorder[n[o]],
                  s = a.borders[t];
            let l;

            for (; v < _.length && (l = h.featuresOnBorder[_[v]], !(l.borders[i][1] > s[0] + 3));) x && h.encodeCentroid(void 0, l, !1), v++;

            if (l && v < _.length) {
              const o = v;
              let n = 0;

              for (; !(l.borders[i][0] > s[1] - 3) && (n++, ++v !== _.length);) l = h.featuresOnBorder[_[v]];

              if (l = h.featuresOnBorder[_[o]], a.intersectsCount() > 1 || l.intersectsCount() > 1 || 1 !== n) {
                1 !== n && (v = o), r.encodeCentroid(void 0, a, !1), x && h.encodeCentroid(void 0, l, !1);
                continue;
              }

              const c = u[t](a, l),
                    p = t % 2 ? e.EXTENT - 1 : 0;
              d.x = g(c[0], Math.min(e.EXTENT - 1, c[1]), p, t < 2, c[2]), d.y = 0, r.encodeCentroid(d, a, !1), x && h.encodeCentroid(d, l, !1);
            } else r.encodeCentroid(void 0, a, !1);
          }

          r.borderDoneWithNeighborZ[t] = h.canonical.z, r.needsCentroidUpdate = !0, x && (h.borderDoneWithNeighborZ[i] = r.canonical.z, h.needsCentroidUpdate = !0);
        } else {
          for (const e of n) r.encodeCentroid(void 0, r.featuresOnBorder[e], !1);

          if (x) {
            for (const e of _) h.encodeCentroid(void 0, h.featuresOnBorder[e], !1);

            h.borderDoneWithNeighborZ[i] = r.canonical.z, h.needsCentroidUpdate = !0;
          }

          r.borderDoneWithNeighborZ[t] = h.canonical.z, r.needsCentroidUpdate = !0;
        }
      }

      (r.needsCentroidUpdate || !r.centroidVertexBuffer && 0 !== r.centroidVertexArray.length) && r.uploadCentroid(t);
    }

    const ho = new e.Color(1, 0, 0, 1),
          _o = new e.Color(0, 1, 0, 1),
          uo = new e.Color(0, 0, 1, 1),
          po = new e.Color(1, 0, 1, 1),
          mo = new e.Color(0, 1, 1, 1);

    function fo(e, t, i, o) {
      vo(e, 0, t + i / 2, e.transform.width, i, o);
    }

    function go(e, t, i, o) {
      vo(e, t - i / 2, 0, i, e.transform.height, o);
    }

    function vo(t, i, o, r, n, a) {
      const s = t.context,
            l = s.gl;
      l.enable(l.SCISSOR_TEST), l.scissor(i * e.exported.devicePixelRatio, o * e.exported.devicePixelRatio, r * e.exported.devicePixelRatio, n * e.exported.devicePixelRatio), s.clear({
        color: a
      }), l.disable(l.SCISSOR_TEST);
    }

    function xo(t, i, o) {
      const r = t.context,
            n = r.gl,
            a = "globe" === t.transform.projection.name,
            s = o.projMatrix,
            l = t.useProgram("debug", null, a ? ["PROJECTION_GLOBE_VIEW"] : null),
            c = i.getTileByID(o.key);
      t.terrain && t.terrain.setupElevationDraw(c, l);
      const h = e.DepthMode.disabled,
            _ = e.StencilMode.disabled,
            u = t.colorModeForRenderPass(),
            d = "$debug";
      r.activeTexture.set(n.TEXTURE0), t.emptyTexture.bind(n.LINEAR, n.CLAMP_TO_EDGE), a ? c._makeGlobeTileDebugBuffers(t.context, t.transform.projection) : c._makeDebugTileBoundsBuffers(t.context, t.transform.projection);
      const p = c._tileDebugBuffer || t.debugBuffer,
            m = c._tileDebugIndexBuffer || t.debugIndexBuffer,
            f = c._tileDebugSegments || t.debugSegments;
      l.draw(r, n.LINE_STRIP, h, _, u, e.CullFaceMode.disabled, Oi(s, e.Color.red), d, p, m, f, null, null, null, c._globeTileDebugBorderBuffer);
      const g = c.latestRawTileData,
            v = Math.floor((g && g.byteLength || 0) / 1024),
            x = i.getTile(o).tileSize,
            y = 512 / Math.min(x, 512) * (o.overscaledZ / t.transform.zoom) * .5;
      let b = o.canonical.toString();
      o.overscaledZ !== o.canonical.z && (b += ` => ${o.overscaledZ}`), function (e, t) {
        e.initDebugOverlayCanvas();
        const i = e.debugOverlayCanvas,
              o = e.context.gl,
              r = e.debugOverlayCanvas.getContext("2d");
        r.clearRect(0, 0, i.width, i.height), r.shadowColor = "white", r.shadowBlur = 2, r.lineWidth = 1.5, r.strokeStyle = "white", r.textBaseline = "top", r.font = "bold 36px Open Sans, sans-serif", r.fillText(t, 5, 5), r.strokeText(t, 5, 5), e.debugOverlayTexture.update(i), e.debugOverlayTexture.bind(o.LINEAR, o.CLAMP_TO_EDGE);
      }(t, `${b} ${v}kb`);
      const w = c._tileDebugTextBuffer || t.debugBuffer,
            T = c._tileDebugTextIndexBuffer || t.quadTriangleIndexBuffer,
            E = c._tileDebugTextSegments || t.debugSegments;
      l.draw(r, n.TRIANGLES, h, _, e.ColorMode.alphaBlended, e.CullFaceMode.disabled, Oi(s, e.Color.transparent, y), d, w, T, E, null, null, null, c._globeTileDebugTextBuffer);
    }

    const yo = e.createLayout([{
      name: "a_pos_3f",
      components: 3,
      type: "Float32"
    }]),
          {
      members: bo
    } = yo;

    function wo(e, t, i, o) {
      e.emplaceBack(t, i, o);
    }

    class To {
      constructor(t) {
        this.vertexArray = new e.StructArrayLayout3f12(), this.indices = new e.StructArrayLayout3ui6(), wo(this.vertexArray, -1, -1, 1), wo(this.vertexArray, 1, -1, 1), wo(this.vertexArray, -1, 1, 1), wo(this.vertexArray, 1, 1, 1), wo(this.vertexArray, -1, -1, -1), wo(this.vertexArray, 1, -1, -1), wo(this.vertexArray, -1, 1, -1), wo(this.vertexArray, 1, 1, -1), this.indices.emplaceBack(5, 1, 3), this.indices.emplaceBack(3, 7, 5), this.indices.emplaceBack(6, 2, 0), this.indices.emplaceBack(0, 4, 6), this.indices.emplaceBack(2, 6, 7), this.indices.emplaceBack(7, 3, 2), this.indices.emplaceBack(5, 4, 0), this.indices.emplaceBack(0, 1, 5), this.indices.emplaceBack(0, 2, 3), this.indices.emplaceBack(3, 1, 0), this.indices.emplaceBack(7, 6, 4), this.indices.emplaceBack(4, 5, 7), this.vertexBuffer = t.createVertexBuffer(this.vertexArray, bo), this.indexBuffer = t.createIndexBuffer(this.indices), this.segment = e.SegmentVector.simpleSegment(0, 0, 36, 12);
      }

    }

    function Eo(t, i, o, r, n, a) {
      const s = t.gl,
            l = i.paint.get("sky-atmosphere-color"),
            c = i.paint.get("sky-atmosphere-halo-color"),
            h = i.paint.get("sky-atmosphere-sun-intensity"),
            _ = ((e, t, i, o, r) => ({
        u_matrix_3f: e,
        u_sun_direction: t,
        u_sun_intensity: i,
        u_color_tint_r: [o.r, o.g, o.b, o.a],
        u_color_tint_m: [r.r, r.g, r.b, r.a],
        u_luminance: 5e-5
      }))(e.fromMat4(e.create$1(), r), n, h, l, c);

      s.framebufferTexture2D(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.TEXTURE_CUBE_MAP_POSITIVE_X + a, i.skyboxTexture, 0), o.draw(t, s.TRIANGLES, e.DepthMode.disabled, e.StencilMode.disabled, e.ColorMode.unblended, e.CullFaceMode.frontCW, _, "skyboxCapture", i.skyboxGeometry.vertexBuffer, i.skyboxGeometry.indexBuffer, i.skyboxGeometry.segment);
    }

    function Co(t, i) {
      return e.transformMat4(t, t, i);
    }

    const Io = {
      symbol: function (t, i, o, r, n) {
        if ("translucent" !== t.renderPass) return;
        const a = e.StencilMode.disabled,
              s = t.colorModeForRenderPass();
        o.layout.get("text-variable-anchor") && function (t, i, o, r, n, a, s) {
          const l = i.transform,
                c = "map" === n,
                h = "map" === a;

          for (const n of t) {
            const t = r.getTile(n),
                  a = t.getBucket(o);
            if (!a || a.projection !== l.projection.name || !a.text || !a.text.segments.get().length) continue;

            const _ = e.evaluateSizeForZoom(a.textSizeData, l.zoom),
                  u = i.transform.calculatePixelsToTileUnitsMatrix(t),
                  d = Qe(n.projMatrix, t.tileID.canonical, h, c, i.transform, u),
                  p = "none" !== o.layout.get("icon-text-fit") && a.hasIconData();

            if (_) {
              const i = Math.pow(2, l.zoom - t.tileID.overscaledZ);
              oo(a, c, h, s, e.symbolSize, l, d, n, i, _, p, l.projection);
            }
          }
        }(r, t, o, i, o.layout.get("text-rotation-alignment"), o.layout.get("text-pitch-alignment"), n), 0 !== o.paint.get("icon-opacity").constantOr(1) && no(t, i, o, r, !1, o.paint.get("icon-translate"), o.paint.get("icon-translate-anchor"), o.layout.get("icon-rotation-alignment"), o.layout.get("icon-pitch-alignment"), o.layout.get("icon-keep-upright"), a, s), 0 !== o.paint.get("text-opacity").constantOr(1) && no(t, i, o, r, !0, o.paint.get("text-translate"), o.paint.get("text-translate-anchor"), o.layout.get("text-rotation-alignment"), o.layout.get("text-pitch-alignment"), o.layout.get("text-keep-upright"), a, s), i.map.showCollisionBoxes && (eo(t, i, o, r, o.paint.get("text-translate"), o.paint.get("text-translate-anchor"), !0), eo(t, i, o, r, o.paint.get("icon-translate"), o.paint.get("icon-translate-anchor"), !1));
      },
      circle: function (t, i, o, r) {
        if ("translucent" !== t.renderPass) return;
        const n = o.paint.get("circle-opacity"),
              a = o.paint.get("circle-stroke-width"),
              s = o.paint.get("circle-stroke-opacity"),
              l = void 0 !== o.layout.get("circle-sort-key").constantOr(1);
        if (0 === n.constantOr(1) && (0 === a.constantOr(1) || 0 === s.constantOr(1))) return;
        const c = t.context,
              h = c.gl,
              _ = t.transform,
              u = t.depthModeForSublayer(0, e.DepthMode.ReadOnly),
              d = e.StencilMode.disabled,
              p = t.colorModeForRenderPass(),
              m = "globe" === _.projection.name,
              f = [e.mercatorXfromLng(_.center.lng), e.mercatorYfromLat(_.center.lat)],
              g = [];

        for (let n = 0; n < r.length; n++) {
          const a = r[n],
                s = i.getTile(a),
                c = s.getBucket(o);
          if (!c) continue;
          const h = c.programConfigurations.get(o.id),
                u = Ri(o);
          m && u.push("PROJECTION_GLOBE_VIEW");

          const d = t.useProgram("circle", h, u),
                p = c.layoutVertexBuffer,
                v = c.globeExtVertexBuffer,
                x = c.indexBuffer,
                y = _.projection.createInversionMatrix(_, a.canonical),
                b = {
            programConfiguration: h,
            program: d,
            layoutVertexBuffer: p,
            globeExtVertexBuffer: v,
            indexBuffer: x,
            uniformValues: Li(t, a, s, y, f, o),
            tile: s
          };

          if (l) {
            const t = c.segments.get();

            for (const i of t) g.push({
              segments: new e.SegmentVector([i]),
              sortKey: i.sortKey,
              state: b
            });
          } else g.push({
            segments: c.segments,
            sortKey: 0,
            state: b
          });
        }

        l && g.sort((e, t) => e.sortKey - t.sortKey);
        const v = {
          useDepthForOcclusion: !m
        };

        for (const i of g) {
          const {
            programConfiguration: r,
            program: n,
            layoutVertexBuffer: a,
            globeExtVertexBuffer: s,
            indexBuffer: l,
            uniformValues: f,
            tile: g
          } = i.state,
                x = i.segments;
          t.terrain && t.terrain.setupElevationDraw(g, n, v), t.prepareDrawProgram(c, n, g.tileID.toUnwrapped()), n.draw(c, h.TRIANGLES, u, d, p, e.CullFaceMode.disabled, f, o.id, a, l, x, o.paint, _.zoom, r, m ? s : null);
        }
      },
      heatmap: function (t, i, o, r) {
        if (0 !== o.paint.get("heatmap-opacity")) if ("offscreen" === t.renderPass) {
          const n = t.context,
                a = n.gl,
                s = e.StencilMode.disabled,
                l = new e.ColorMode([a.ONE, a.ONE], e.Color.transparent, [!0, !0, !0, !0]);
          !function (e, t, i) {
            const o = e.gl;
            e.activeTexture.set(o.TEXTURE1), e.viewport.set([0, 0, t.width / 4, t.height / 4]);
            let r = i.heatmapFbo;
            if (r) o.bindTexture(o.TEXTURE_2D, r.colorAttachment.get()), e.bindFramebuffer.set(r.framebuffer);else {
              const n = o.createTexture();
              o.bindTexture(o.TEXTURE_2D, n), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_S, o.CLAMP_TO_EDGE), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_T, o.CLAMP_TO_EDGE), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MIN_FILTER, o.LINEAR), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MAG_FILTER, o.LINEAR), r = i.heatmapFbo = e.createFramebuffer(t.width / 4, t.height / 4, !1), function (e, t, i, o) {
                const r = e.gl;
                r.texImage2D(r.TEXTURE_2D, 0, r.RGBA, t.width / 4, t.height / 4, 0, r.RGBA, e.extRenderToTextureHalfFloat ? e.extTextureHalfFloat.HALF_FLOAT_OES : r.UNSIGNED_BYTE, null), o.colorAttachment.set(i);
              }(e, t, n, r);
            }
          }(n, t, o), n.clear({
            color: e.Color.transparent
          });

          const c = t.transform,
                h = "globe" === c.projection.name,
                _ = h ? ["PROJECTION_GLOBE_VIEW"] : null,
                u = [e.mercatorXfromLng(c.center.lng), e.mercatorYfromLat(c.center.lat)];

          for (let d = 0; d < r.length; d++) {
            const p = r[d];
            if (i.hasRenderableParent(p)) continue;
            const m = i.getTile(p),
                  f = m.getBucket(o);
            if (!f) continue;
            const g = f.programConfigurations.get(o.id),
                  v = t.useProgram("heatmap", g, _),
                  {
              zoom: x
            } = t.transform;
            t.terrain && t.terrain.setupElevationDraw(m, v), t.prepareDrawProgram(n, v, p.toUnwrapped());
            const y = c.projection.createInversionMatrix(c, p.canonical);
            v.draw(n, a.TRIANGLES, e.DepthMode.disabled, s, l, e.CullFaceMode.disabled, Fi(t, p, m, y, u, x, o.paint.get("heatmap-intensity")), o.id, f.layoutVertexBuffer, f.indexBuffer, f.segments, o.paint, t.transform.zoom, g, h ? f.globeExtVertexBuffer : null);
          }

          n.viewport.set([0, 0, t.width, t.height]);
        } else "translucent" === t.renderPass && (t.context.setColorMode(t.colorModeForRenderPass()), function (t, i) {
          const o = t.context,
                r = o.gl,
                n = i.heatmapFbo;
          if (!n) return;
          o.activeTexture.set(r.TEXTURE0), r.bindTexture(r.TEXTURE_2D, n.colorAttachment.get()), o.activeTexture.set(r.TEXTURE1);
          let a = i.colorRampTexture;
          a || (a = i.colorRampTexture = new e.Texture(o, i.colorRamp, r.RGBA)), a.bind(r.LINEAR, r.CLAMP_TO_EDGE), t.useProgram("heatmapTexture").draw(o, r.TRIANGLES, e.DepthMode.disabled, e.StencilMode.disabled, t.colorModeForRenderPass(), e.CullFaceMode.disabled, ((e, t, i, o) => ({
            u_image: 0,
            u_color_ramp: 1,
            u_opacity: t.paint.get("heatmap-opacity")
          }))(0, i), i.id, t.viewportBuffer, t.quadTriangleIndexBuffer, t.viewportSegments, i.paint, t.transform.zoom);
        }(t, o));
      },
      line: function (t, i, o, r) {
        if ("translucent" !== t.renderPass) return;
        const n = o.paint.get("line-opacity"),
              a = o.paint.get("line-width");
        if (0 === n.constantOr(1) || 0 === a.constantOr(1)) return;

        const s = t.depthModeForSublayer(0, e.DepthMode.ReadOnly),
              l = t.colorModeForRenderPass(),
              c = t.terrain && t.terrain.renderingToTexture ? 1 : e.exported.devicePixelRatio,
              h = o.paint.get("line-dasharray"),
              _ = h.constantOr(1),
              u = o.layout.get("line-cap"),
              d = o.paint.get("line-pattern"),
              p = d.constantOr(1),
              m = o.paint.get("line-gradient"),
              f = o.getCrossfadeParameters(),
              g = p ? "linePattern" : "line",
              v = t.context,
              x = v.gl,
              y = (e => {
          const t = [];
          Zi(e) && t.push("RENDER_LINE_DASH"), e.paint.get("line-gradient") && t.push("RENDER_LINE_GRADIENT");
          const i = e.paint.get("line-pattern").constantOr(1),
                o = 1 !== e.paint.get("line-opacity").constantOr(1);
          return !i && o && t.push("RENDER_LINE_ALPHA_DISCARD"), t;
        })(o);

        let b = y.includes("RENDER_LINE_ALPHA_DISCARD");
        t.terrain && t.terrain.clipOrMaskOverlapStencilType() && (b = !1);

        for (const n of r) {
          const r = i.getTile(n);
          if (p && !r.patternsLoaded()) continue;
          const a = r.getBucket(o);
          if (!a) continue;
          t.prepareDrawTile();
          const w = a.programConfigurations.get(o.id),
                T = t.useProgram(g, w, y),
                E = d.constantOr(null);

          if (E && r.imageAtlas) {
            const e = r.imageAtlas,
                  t = e.patternPositions[E.to.toString()],
                  i = e.patternPositions[E.from.toString()];
            t && i && w.setConstantPatternPositions(t, i);
          }

          const C = h.constantOr(null),
                I = u.constantOr(null);

          if (!p && C && I && r.lineAtlas) {
            const e = r.lineAtlas,
                  t = e.getDash(C.to, I),
                  i = e.getDash(C.from, I);
            t && i && w.setConstantPatternPositions(t, i);
          }

          const M = t.terrain ? n.projMatrix : null,
                S = p ? Ni(t, r, o, f, M, c) : Ui(t, r, o, f, M, a.lineClipsArray.length, c);

          if (m) {
            const r = a.gradients[o.id];
            let s = r.texture;

            if (o.gradientVersion !== r.version) {
              let l = 256;

              if (o.stepInterpolant) {
                const o = i.getSource().maxzoom,
                      r = n.canonical.z === o ? Math.ceil(1 << t.transform.maxZoom - n.canonical.z) : 1;
                l = e.clamp(e.nextPowerOfTwo(a.maxLineLength / e.EXTENT * 1024 * r), 256, v.maxTextureSize);
              }

              r.gradient = e.renderColorRamp({
                expression: o.gradientExpression(),
                evaluationKey: "lineProgress",
                resolution: l,
                image: r.gradient || void 0,
                clips: a.lineClipsArray
              }), r.texture ? r.texture.update(r.gradient) : r.texture = new e.Texture(v, r.gradient, x.RGBA), r.version = o.gradientVersion, s = r.texture;
            }

            v.activeTexture.set(x.TEXTURE1), s.bind(o.stepInterpolant ? x.NEAREST : x.LINEAR, x.CLAMP_TO_EDGE);
          }

          _ && (v.activeTexture.set(x.TEXTURE0), r.lineAtlasTexture.bind(x.LINEAR, x.REPEAT), w.updatePaintBuffers(f)), p && (v.activeTexture.set(x.TEXTURE0), r.imageAtlasTexture.bind(x.LINEAR, x.CLAMP_TO_EDGE), w.updatePaintBuffers(f)), t.prepareDrawProgram(v, T, n.toUnwrapped());

          const z = i => {
            T.draw(v, x.TRIANGLES, s, i, l, e.CullFaceMode.disabled, S, o.id, a.layoutVertexBuffer, a.indexBuffer, a.segments, o.paint, t.transform.zoom, w, a.layoutVertexBuffer2);
          };

          if (b) {
            const i = t.stencilModeForClipping(n).ref;
            0 === i && t.terrain && v.clear({
              stencil: 0
            });
            const o = {
              func: x.EQUAL,
              mask: 255
            };
            S.u_alpha_discard_threshold = .8, z(new e.StencilMode(o, i, 255, x.KEEP, x.KEEP, x.INVERT)), S.u_alpha_discard_threshold = 0, z(new e.StencilMode(o, i, 255, x.KEEP, x.KEEP, x.KEEP));
          } else z(t.stencilModeForClipping(n));
        }

        b && (t.resetStencilClippingMasks(), t.terrain && v.clear({
          stencil: 0
        }));
      },
      fill: function (t, i, o, r) {
        const n = o.paint.get("fill-color"),
              a = o.paint.get("fill-opacity");
        if (0 === a.constantOr(1)) return;
        const s = t.colorModeForRenderPass(),
              l = o.paint.get("fill-pattern"),
              c = t.opaquePassEnabledForLayer() && !l.constantOr(1) && 1 === n.constantOr(e.Color.transparent).a && 1 === a.constantOr(0) ? "opaque" : "translucent";

        if (t.renderPass === c) {
          const n = t.depthModeForSublayer(1, "opaque" === t.renderPass ? e.DepthMode.ReadWrite : e.DepthMode.ReadOnly);
          so(t, i, o, r, n, s, !1);
        }

        if ("translucent" === t.renderPass && o.paint.get("fill-antialias")) {
          const n = t.depthModeForSublayer(o.getPaintProperty("fill-outline-color") ? 2 : 0, e.DepthMode.ReadOnly);
          so(t, i, o, r, n, s, !0);
        }
      },
      "fill-extrusion": function (t, i, o, r) {
        const n = o.paint.get("fill-extrusion-opacity");

        if (0 !== n && "translucent" === t.renderPass) {
          const a = new e.DepthMode(t.context.gl.LEQUAL, e.DepthMode.ReadWrite, t.depthRangeFor3D);
          if (1 !== n || o.paint.get("fill-extrusion-pattern").constantOr(1)) lo(t, i, o, r, a, e.StencilMode.disabled, e.ColorMode.disabled), lo(t, i, o, r, a, t.stencilModeFor3D(), t.colorModeForRenderPass()), t.resetStencilClippingMasks();else {
            const n = t.colorModeForRenderPass();
            lo(t, i, o, r, a, e.StencilMode.disabled, n);
          }
        }
      },
      hillshade: function (t, i, o, r) {
        if ("offscreen" !== t.renderPass && "translucent" !== t.renderPass) return;
        const n = t.context,
              a = t.depthModeForSublayer(0, e.DepthMode.ReadOnly),
              s = t.colorModeForRenderPass(),
              l = t.terrain && t.terrain.renderingToTexture,
              [c, h] = "translucent" !== t.renderPass || l ? [{}, r] : t.stencilConfigForOverlap(r);

        for (const r of h) {
          const n = i.getTile(r);
          if (n.needsHillshadePrepare && "offscreen" === t.renderPass) si(t, n, o, a, e.StencilMode.disabled, s);else if ("translucent" === t.renderPass) {
            const e = l && t.terrain ? t.terrain.stencilModeForRTTOverlap(r) : c[r.overscaledZ];
            ni(t, r, n, o, a, e, s);
          }
        }

        n.viewport.set([0, 0, t.width, t.height]), t.resetStencilClippingMasks();
      },
      raster: function (t, i, o, r, n, a) {
        if ("translucent" !== t.renderPass) return;
        if (0 === o.paint.get("raster-opacity")) return;
        if (!r.length) return;

        const s = t.context,
              l = s.gl,
              c = i.getSource(),
              h = t.useProgram("raster"),
              _ = t.colorModeForRenderPass(),
              u = t.terrain && t.terrain.renderingToTexture,
              [d, p] = c instanceof Se || u ? [{}, r] : t.stencilConfigForOverlap(r),
              m = p[p.length - 1].overscaledZ,
              f = !t.options.moving;

        for (const r of p) {
          const n = u ? e.DepthMode.disabled : t.depthModeForSublayer(r.overscaledZ - m, 1 === o.paint.get("raster-opacity") ? e.DepthMode.ReadWrite : e.DepthMode.ReadOnly, l.LESS),
                p = r.toUnwrapped(),
                g = i.getTile(r);
          if (u && (!g || !g.hasData())) continue;
          const v = u ? r.projMatrix : t.transform.calculateProjMatrix(p, f),
                x = t.terrain && u ? t.terrain.stencilModeForRTTOverlap(r) : d[r.overscaledZ],
                y = a ? 0 : o.paint.get("raster-fade-duration");
          g.registerFadeDuration(y);
          const b = i.findLoadedParent(r, 0),
                w = fi(g, b, i, t.transform, y);
          let T, E;
          t.terrain && t.terrain.prepareDrawTile();
          const C = "nearest" === o.paint.get("raster-resampling") ? l.NEAREST : l.LINEAR;
          s.activeTexture.set(l.TEXTURE0), g.texture.bind(C, l.CLAMP_TO_EDGE), s.activeTexture.set(l.TEXTURE1), b ? (b.texture.bind(C, l.CLAMP_TO_EDGE), T = Math.pow(2, b.tileID.overscaledZ - g.tileID.overscaledZ), E = [g.tileID.canonical.x * T % 1, g.tileID.canonical.y * T % 1]) : g.texture.bind(C, l.CLAMP_TO_EDGE);
          const I = Vi(v, E || [0, 0], T || 1, w, o, c instanceof Se ? c.perspectiveTransform : [0, 0]);
          if (t.prepareDrawProgram(s, h, p), c instanceof Se) c.boundsBuffer && c.boundsSegments && h.draw(s, l.TRIANGLES, n, e.StencilMode.disabled, _, e.CullFaceMode.disabled, I, o.id, c.boundsBuffer, t.quadTriangleIndexBuffer, c.boundsSegments);else {
            const {
              tileBoundsBuffer: i,
              tileBoundsIndexBuffer: r,
              tileBoundsSegments: a
            } = t.getTileBoundsBuffers(g);
            h.draw(s, l.TRIANGLES, n, x, _, e.CullFaceMode.disabled, I, o.id, i, r, a);
          }
        }

        t.resetStencilClippingMasks();
      },
      background: function (t, i, o, r) {
        const n = o.paint.get("background-color"),
              a = o.paint.get("background-opacity");
        if (0 === a) return;

        const s = t.context,
              l = s.gl,
              c = t.transform,
              h = c.tileSize,
              _ = o.paint.get("background-pattern");

        if (t.isPatternMissing(_)) return;
        const u = !_ && 1 === n.a && 1 === a && t.opaquePassEnabledForLayer() ? "opaque" : "translucent";
        if (t.renderPass !== u) return;
        const d = e.StencilMode.disabled,
              p = t.depthModeForSublayer(0, "opaque" === u ? e.DepthMode.ReadWrite : e.DepthMode.ReadOnly),
              m = t.colorModeForRenderPass(),
              f = t.useProgram(_ ? "backgroundPattern" : "background");
        let g,
            v = r;
        v || (g = t.getBackgroundTiles(), v = Object.values(g).map(e => e.tileID)), _ && (s.activeTexture.set(l.TEXTURE0), t.imageManager.bind(t.context));
        const x = o.getCrossfadeParameters();

        for (const u of v) {
          const v = u.toUnwrapped(),
                y = r ? u.projMatrix : t.transform.calculateProjMatrix(v);
          t.prepareDrawTile();
          const b = i ? i.getTile(u) : g ? g[u.key] : new e.Tile(u, h, c.zoom, t),
                w = _ ? Yi(y, a, t, _, {
            tileID: u,
            tileSize: h
          }, x) : Ki(y, a, n);
          t.prepareDrawProgram(s, f, v);
          const {
            tileBoundsBuffer: T,
            tileBoundsIndexBuffer: E,
            tileBoundsSegments: C
          } = t.getTileBoundsBuffers(b);
          f.draw(s, l.TRIANGLES, p, d, m, e.CullFaceMode.disabled, w, o.id, T, E, C);
        }
      },
      sky: function (t, i, o) {
        const r = t.transform,
              n = "mercator" === r.projection.name || "globe" === r.projection.name ? 1 : e.smoothstep(7, 8, r.zoom),
              a = o.paint.get("sky-opacity") * n;
        if (0 === a) return;
        const s = t.context,
              l = o.paint.get("sky-type"),
              c = new e.DepthMode(s.gl.LEQUAL, e.DepthMode.ReadOnly, [0, 1]),
              h = t.frameCounter / 1e3 % 1;
        "atmosphere" === l ? "offscreen" === t.renderPass ? o.needsSkyboxCapture(t) && (function (t, i, o, r) {
          const n = t.context,
                a = n.gl;
          let s = i.skyboxFbo;

          if (!s) {
            s = i.skyboxFbo = n.createFramebuffer(32, 32, !1), i.skyboxGeometry = new To(n), i.skyboxTexture = n.gl.createTexture(), a.bindTexture(a.TEXTURE_CUBE_MAP, i.skyboxTexture), a.texParameteri(a.TEXTURE_CUBE_MAP, a.TEXTURE_WRAP_S, a.CLAMP_TO_EDGE), a.texParameteri(a.TEXTURE_CUBE_MAP, a.TEXTURE_WRAP_T, a.CLAMP_TO_EDGE), a.texParameteri(a.TEXTURE_CUBE_MAP, a.TEXTURE_MIN_FILTER, a.LINEAR), a.texParameteri(a.TEXTURE_CUBE_MAP, a.TEXTURE_MAG_FILTER, a.LINEAR);

            for (let e = 0; e < 6; ++e) a.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, a.RGBA, 32, 32, 0, a.RGBA, a.UNSIGNED_BYTE, null);
          }

          n.bindFramebuffer.set(s.framebuffer), n.viewport.set([0, 0, 32, 32]);
          const l = i.getCenter(t, !0),
                c = t.useProgram("skyboxCapture"),
                h = new Float64Array(16);
          e.identity(h), e.rotateY(h, h, .5 * -Math.PI), Eo(n, i, c, h, l, 0), e.identity(h), e.rotateY(h, h, .5 * Math.PI), Eo(n, i, c, h, l, 1), e.identity(h), e.rotateX(h, h, .5 * -Math.PI), Eo(n, i, c, h, l, 2), e.identity(h), e.rotateX(h, h, .5 * Math.PI), Eo(n, i, c, h, l, 3), e.identity(h), Eo(n, i, c, h, l, 4), e.identity(h), e.rotateY(h, h, Math.PI), Eo(n, i, c, h, l, 5), n.viewport.set([0, 0, t.width, t.height]);
        }(t, o), o.markSkyboxValid(t)) : "sky" === t.renderPass && function (t, i, o, r, n) {
          const a = t.context,
                s = a.gl,
                l = t.transform,
                c = t.useProgram("skybox");
          a.activeTexture.set(s.TEXTURE0), s.bindTexture(s.TEXTURE_CUBE_MAP, i.skyboxTexture);

          const h = ((e, t, i, o, r) => ({
            u_matrix: e,
            u_sun_direction: t,
            u_cubemap: 0,
            u_opacity: o,
            u_temporal_offset: r
          }))(l.skyboxMatrix, i.getCenter(t, !1), 0, r, n);

          t.prepareDrawProgram(a, c), c.draw(a, s.TRIANGLES, o, e.StencilMode.disabled, t.colorModeForRenderPass(), e.CullFaceMode.backCW, h, "skybox", i.skyboxGeometry.vertexBuffer, i.skyboxGeometry.indexBuffer, i.skyboxGeometry.segment);
        }(t, o, c, a, h) : "gradient" === l && "sky" === t.renderPass && function (t, i, o, r, n) {
          const a = t.context,
                s = a.gl,
                l = t.transform,
                c = t.useProgram("skyboxGradient");
          i.skyboxGeometry || (i.skyboxGeometry = new To(a)), a.activeTexture.set(s.TEXTURE0);
          let h = i.colorRampTexture;
          h || (h = i.colorRampTexture = new e.Texture(a, i.colorRamp, s.RGBA)), h.bind(s.LINEAR, s.CLAMP_TO_EDGE);

          const _ = ((t, i, o, r, n) => ({
            u_matrix: t,
            u_color_ramp: 0,
            u_center_direction: i,
            u_radius: e.degToRad(o),
            u_opacity: r,
            u_temporal_offset: n
          }))(l.skyboxMatrix, i.getCenter(t, !1), i.paint.get("sky-gradient-radius"), r, n);

          t.prepareDrawProgram(a, c), c.draw(a, s.TRIANGLES, o, e.StencilMode.disabled, t.colorModeForRenderPass(), e.CullFaceMode.backCW, _, "skyboxGradient", i.skyboxGeometry.vertexBuffer, i.skyboxGeometry.indexBuffer, i.skyboxGeometry.segment);
        }(t, o, c, a, h);
      },
      debug: function (e, t, i) {
        for (let o = 0; o < i.length; o++) xo(e, t, i[o]);
      },
      custom: function (t, i, o) {
        const r = t.context,
              n = o.implementation;
        if (t.transform.projection.unsupportedLayers && t.transform.projection.unsupportedLayers.includes("custom")) e.warnOnce("Custom layers are not yet supported with non-mercator projections. Use mercator to enable custom layers.");else if ("offscreen" === t.renderPass) {
          const e = n.prerender;
          e && (t.setCustomLayerDefaults(), r.setColorMode(t.colorModeForRenderPass()), e.call(n, r.gl, t.transform.customLayerMatrix()), r.setDirty(), t.setBaseState());
        } else if ("translucent" === t.renderPass) {
          t.setCustomLayerDefaults(), r.setColorMode(t.colorModeForRenderPass()), r.setStencilMode(e.StencilMode.disabled);
          const i = "3d" === n.renderingMode ? new e.DepthMode(t.context.gl.LEQUAL, e.DepthMode.ReadWrite, t.depthRangeFor3D) : t.depthModeForSublayer(0, e.DepthMode.ReadOnly);
          r.setDepthMode(i), n.render(r.gl, t.transform.customLayerMatrix()), r.setDirty(), t.setBaseState(), r.bindFramebuffer.set(null);
        }
      }
    };

    class Mo {
      constructor(t, i) {
        this.context = new Ee(t), this.transform = i, this._tileTextures = {}, this.frameCopies = [], this.loadTimeStamps = [], this.setup(), this.numSublayers = e.SourceCache.maxUnderzooming + e.SourceCache.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new jt(), this.gpuTimers = {}, this.frameCounter = 0, this._backgroundTiles = {}, this._tileClippingMaskIDs = new Map(), this._skippedStencilTileIDs = new Set();
      }

      updateTerrain(e, t) {
        const i = !!e && !!e.terrain && this.transform.projection.supportsTerrain;
        if (!(i || this._terrain && this._terrain.enabled)) return;
        this._terrain || (this._terrain = new bi(this, e));
        const o = this._terrain;
        this.transform.elevation = i ? o : null, o.update(e, this.transform, t);
      }

      _updateFog(e) {
        const t = e.fog;
        if (!t || t.getOpacity(this.transform.pitch) < 1 || t.properties.get("horizon-blend") < .03) return void (this.transform.fogCullDistSq = null);
        const [i, o] = t.getFovAdjustedRange(this.transform._fov);
        if (i > o) return void (this.transform.fogCullDistSq = null);
        const r = i + .78 * (o - i);
        this.transform.fogCullDistSq = r * r;
      }

      get terrain() {
        return this.transform._terrainEnabled() && this._terrain && this._terrain.enabled ? this._terrain : null;
      }

      resize(t, i) {
        if (this.width = t * e.exported.devicePixelRatio, this.height = i * e.exported.devicePixelRatio, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (const e of this.style.order) this.style._layers[e].resize();
      }

      setup() {
        const t = this.context,
              i = new e.StructArrayLayout2i4();
        i.emplaceBack(0, 0), i.emplaceBack(e.EXTENT, 0), i.emplaceBack(0, e.EXTENT), i.emplaceBack(e.EXTENT, e.EXTENT), this.tileExtentBuffer = t.createVertexBuffer(i, e.posAttributes.members), this.tileExtentSegments = e.SegmentVector.simpleSegment(0, 0, 4, 2);
        const o = new e.StructArrayLayout2i4();
        o.emplaceBack(0, 0), o.emplaceBack(e.EXTENT, 0), o.emplaceBack(0, e.EXTENT), o.emplaceBack(e.EXTENT, e.EXTENT), this.debugBuffer = t.createVertexBuffer(o, e.posAttributes.members), this.debugSegments = e.SegmentVector.simpleSegment(0, 0, 4, 5);
        const r = new e.StructArrayLayout2i4();
        r.emplaceBack(-1, -1), r.emplaceBack(1, -1), r.emplaceBack(-1, 1), r.emplaceBack(1, 1), this.viewportBuffer = t.createVertexBuffer(r, e.posAttributes.members), this.viewportSegments = e.SegmentVector.simpleSegment(0, 0, 4, 2);
        const n = new e.StructArrayLayout4i8();
        n.emplaceBack(0, 0, 0, 0), n.emplaceBack(e.EXTENT, 0, e.EXTENT, 0), n.emplaceBack(0, e.EXTENT, 0, e.EXTENT), n.emplaceBack(e.EXTENT, e.EXTENT, e.EXTENT, e.EXTENT), this.mercatorBoundsBuffer = t.createVertexBuffer(n, e.boundsAttributes.members), this.mercatorBoundsSegments = e.SegmentVector.simpleSegment(0, 0, 4, 2);
        const a = new e.StructArrayLayout3ui6();
        a.emplaceBack(0, 1, 2), a.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = t.createIndexBuffer(a);
        const s = new e.StructArrayLayout1ui2();

        for (const e of [0, 1, 3, 2, 0]) s.emplaceBack(e);

        this.debugIndexBuffer = t.createIndexBuffer(s), this.emptyTexture = new e.Texture(t, new e.RGBAImage({
          width: 1,
          height: 1
        }, Uint8Array.of(0, 0, 0, 0)), t.gl.RGBA), this.identityMat = e.create();
        const l = this.context.gl;
        this.stencilClearMode = new e.StencilMode({
          func: l.ALWAYS,
          mask: 0
        }, 0, 255, l.ZERO, l.ZERO, l.ZERO), this.loadTimeStamps.push(e.window.performance.now());
      }

      getMercatorTileBoundsBuffers() {
        return {
          tileBoundsBuffer: this.mercatorBoundsBuffer,
          tileBoundsIndexBuffer: this.quadTriangleIndexBuffer,
          tileBoundsSegments: this.mercatorBoundsSegments
        };
      }

      getTileBoundsBuffers(e) {
        return e._makeTileBoundsBuffers(this.context, this.transform.projection), e._tileBoundsBuffer ? {
          tileBoundsBuffer: e._tileBoundsBuffer,
          tileBoundsIndexBuffer: e._tileBoundsIndexBuffer,
          tileBoundsSegments: e._tileBoundsSegments
        } : this.getMercatorTileBoundsBuffers();
      }

      clearStencil() {
        const t = this.context,
              i = t.gl;
        this.nextStencilID = 1, this.currentStencilSource = void 0, this._tileClippingMaskIDs.clear(), this._skippedStencilTileIDs.clear(), this.useProgram("clippingMask").draw(t, i.TRIANGLES, e.DepthMode.disabled, this.stencilClearMode, e.ColorMode.disabled, e.CullFaceMode.disabled, mi(this.identityMat), "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
      }

      resetStencilClippingMasks() {
        this.terrain || (this.currentStencilSource = void 0, this._tileClippingMaskIDs.clear(), this._skippedStencilTileIDs.clear());
      }

      _renderTileClippingMasks(t, i, o) {
        if (!i || this.currentStencilSource === i.id || !t.isTileClipped() || !o || 0 === o.length) return;
        const r = [];
        let n = !1;

        if (this._tileClippingMaskIDs && !this.terrain) {
          for (const e of o) if (this._tileClippingMaskIDs.has(e.key) || (n = !0), this._skippedStencilTileIDs.has(e.key)) {
            if (!i.getTile(e).getBucket(t)) continue;
            this._skippedStencilTileIDs.delete(e.key), r.push(e);
          }

          if (!n && 0 === r.length) return;
        }

        const a = this.context,
              s = a.gl;
        a.setColorMode(e.ColorMode.disabled), a.setDepthMode(e.DepthMode.disabled);

        const l = this.useProgram("clippingMask"),
              c = t => {
          const o = i.getTile(t),
                {
            tileBoundsBuffer: r,
            tileBoundsIndexBuffer: n,
            tileBoundsSegments: c
          } = this.getTileBoundsBuffers(o);
          l.draw(a, s.TRIANGLES, e.DepthMode.disabled, new e.StencilMode({
            func: s.GREATER,
            mask: 255
          }, this._tileClippingMaskIDs.get(t.key) || 0, 255, s.KEEP, s.KEEP, s.REPLACE), e.ColorMode.disabled, e.CullFaceMode.disabled, mi(t.projMatrix), "$clipping", r, n, c);
        };

        if (!n && r.length > 0) for (const e of r) c(e);else {
          (0 === this._tileClippingMaskIDs.size || this.nextStencilID + o.length > 256) && this.clearStencil(), this._tileClippingMaskIDs.clear(), this._skippedStencilTileIDs.clear();

          for (const e of o) this._tileClippingMaskIDs.set(e.key, this.nextStencilID++), i.getTile(e).getBucket(t) ? c(e) : this._skippedStencilTileIDs.add(e.key);
        }
        0 === this._skippedStencilTileIDs.size && (this.currentStencilSource = i.id);
      }

      stencilModeFor3D() {
        this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
        const t = this.nextStencilID++,
              i = this.context.gl;
        return new e.StencilMode({
          func: i.NOTEQUAL,
          mask: 255
        }, t, 255, i.KEEP, i.KEEP, i.REPLACE);
      }

      stencilModeForClipping(t) {
        if (this.terrain) return this.terrain.stencilModeForRTTOverlap(t);
        const i = this.context.gl;
        return new e.StencilMode({
          func: i.EQUAL,
          mask: 255
        }, this._tileClippingMaskIDs.get(t.key) || 0, 0, i.KEEP, i.KEEP, i.REPLACE);
      }

      stencilConfigForOverlap(t) {
        const i = this.context.gl,
              o = t.sort((e, t) => t.overscaledZ - e.overscaledZ),
              r = o[o.length - 1].overscaledZ,
              n = o[0].overscaledZ - r + 1;

        if (n > 1) {
          this.currentStencilSource = void 0, this.nextStencilID + n > 256 && this.clearStencil();
          const t = {};

          for (let o = 0; o < n; o++) t[o + r] = new e.StencilMode({
            func: i.GEQUAL,
            mask: 255
          }, o + this.nextStencilID, 255, i.KEEP, i.KEEP, i.REPLACE);

          return this.nextStencilID += n, [t, o];
        }

        return [{
          [r]: e.StencilMode.disabled
        }, o];
      }

      colorModeForRenderPass() {
        const t = this.context.gl;

        if (this._showOverdrawInspector) {
          const i = 1 / 8;
          return new e.ColorMode([t.CONSTANT_COLOR, t.ONE], new e.Color(i, i, i, 0), [!0, !0, !0, !0]);
        }

        return "opaque" === this.renderPass ? e.ColorMode.unblended : e.ColorMode.alphaBlended;
      }

      depthModeForSublayer(t, i, o) {
        if (!this.opaquePassEnabledForLayer()) return e.DepthMode.disabled;
        const r = 1 - ((1 + this.currentLayer) * this.numSublayers + t) * this.depthEpsilon;
        return new e.DepthMode(o || this.context.gl.LEQUAL, i, [r, r]);
      }

      opaquePassEnabledForLayer() {
        return this.currentLayer < this.opaquePassCutoff;
      }

      render(t, i) {
        this.style = t, this.options = i, this.lineAtlas = t.lineAtlas, this.imageManager = t.imageManager, this.glyphManager = t.glyphManager, this.symbolFadeChange = t.placement.symbolFadeChange(e.exported.now()), this.imageManager.beginFrame();
        const o = this.style.order,
              r = this.style._sourceCaches;

        for (const e in r) {
          const t = r[e];
          t.used && t.prepare(this.context);
        }

        const n = {},
              a = {},
              s = {};

        for (const e in r) {
          const t = r[e];
          n[e] = t.getVisibleCoordinates(), a[e] = n[e].slice().reverse(), s[e] = t.getVisibleCoordinates(!0).reverse();
        }

        this.opaquePassCutoff = 1 / 0;

        for (let e = 0; e < o.length; e++) if (this.style._layers[o[e]].is3D()) {
          this.opaquePassCutoff = e;
          break;
        }

        if (this.terrain && (this.terrain.updateTileBinding(s), this.opaquePassCutoff = 0), "globe" !== this.transform.projection.name || this.globeSharedBuffers || (this.globeSharedBuffers = new e.GlobeSharedBuffers(this.context)), !e.isMapAuthenticated(this.context.gl)) return;
        this.renderPass = "offscreen";

        for (const e of o) {
          const i = this.style._layers[e],
                o = t._getLayerSourceCache(i);

          if (!i.hasOffscreenPass() || i.isHidden(this.transform.zoom)) continue;
          const r = o ? a[o.id] : void 0;
          ("custom" === i.type || i.isSky() || r && r.length) && this.renderLayer(this, o, i, r);
        }

        this.depthRangeFor3D = [0, 1 - (t.order.length + 2) * this.numSublayers * this.depthEpsilon], this.terrain && (this.style.hasSymbolLayers() || this.style.hasCircleLayers()) && this.terrain.drawDepth(), this.context.bindFramebuffer.set(null), this.context.viewport.set([0, 0, this.width, this.height]);
        let l = e.Color.transparent;
        if (this.style.fog && this.style.fog.getOpacity(this.transform.pitch) && (l = this.style.fog.properties.get("color")), this.context.clear({
          color: i.showOverdrawInspector ? e.Color.black : l,
          depth: 1
        }), this.clearStencil(), this._showOverdrawInspector = i.showOverdrawInspector, this.renderPass = "opaque", !this.terrain) for (this.currentLayer = o.length - 1; this.currentLayer >= 0; this.currentLayer--) {
          const e = this.style._layers[o[this.currentLayer]],
                i = t._getLayerSourceCache(e);

          if (e.isSky()) continue;
          const r = i ? a[i.id] : void 0;
          this._renderTileClippingMasks(e, i, r), this.renderLayer(this, i, e, r);
        }
        if (this.renderPass = "sky", (e.globeToMercatorTransition(this.transform.zoom) > 0 || "globe" !== this.transform.projection.name) && this.transform.isHorizonVisible()) for (this.currentLayer = 0; this.currentLayer < o.length; this.currentLayer++) {
          const e = this.style._layers[o[this.currentLayer]],
                i = t._getLayerSourceCache(e);

          e.isSky() && this.renderLayer(this, i, e, i ? a[i.id] : void 0);
        }

        for ("globe" === this.transform.projection.name && function (t) {
          const i = t.context,
                o = i.gl,
                r = t.transform,
                n = new e.DepthMode(o.LEQUAL, e.DepthMode.ReadOnly, [0, 1]),
                a = t.useProgram("globeAtmosphere"),
                s = r.centerOffset,
                l = r._camera.getCameraToClipPerspective(r._fov, r.width / r.height, r._nearZ, r._farZ);

          l[8] = 2 * -s.x / r.width, l[9] = 2 * s.y / r.height;
          const c = e.invert([], l),
                h = e.mul([], c, r.projMatrix),
                _ = {
            u_frustum_tl: Co([-1, 1, 1], c),
            u_frustum_tr: Co([1, 1, 1], c),
            u_frustum_br: Co([1, -1, 1], c),
            u_frustum_bl: Co([-1, -1, 1], c),
            u_globe_pos: Co([r.globeMatrix[12], r.globeMatrix[13], r.globeMatrix[14]], h),
            u_globe_radius: r.worldSize / 2 / Math.PI - 1,
            u_opacity: 1 - e.globeToMercatorTransition(r.zoom),
            u_fadeout_range: 2,
            u_start_color: [1, 1, 1],
            u_end_color: [.0118, .7451, .9882]
          };
          t.prepareDrawProgram(i, a);
          const u = t.globeSharedBuffers;
          u && a.draw(i, o.TRIANGLES, n, e.StencilMode.disabled, e.ColorMode.alphaBlended, e.CullFaceMode.backCW, _, "skybox", u.atmosphereVertexBuffer, u.atmosphereIndexBuffer, u.atmosphereSegments);
        }(this), this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < o.length;) {
          const e = this.style._layers[o[this.currentLayer]],
                i = t._getLayerSourceCache(e);

          if (e.isSky()) {
            ++this.currentLayer;
            continue;
          }

          if (this.terrain && this.style.isLayerDraped(e)) {
            if (e.isHidden(this.transform.zoom)) {
              ++this.currentLayer;
              continue;
            }

            this.currentLayer = this.terrain.renderBatch(this.currentLayer);
            continue;
          }

          const r = i ? ("symbol" === e.type ? s : a)[i.id] : void 0;
          this._renderTileClippingMasks(e, i, i ? n[i.id] : void 0), this.renderLayer(this, i, e, r), ++this.currentLayer;
        }

        if (this.terrain && this.terrain.postRender(), this.options.showTileBoundaries || this.options.showQueryGeometry) {
          let i = null;
          e.values(this.style._layers).forEach(e => {
            const o = t._getLayerSourceCache(e);

            o && !e.isHidden(this.transform.zoom) && (!i || i.getSource().maxzoom < o.getSource().maxzoom) && (i = o);
          }), i && this.options.showTileBoundaries && Io.debug(this, i, i.getVisibleCoordinates());
        }

        this.options.showPadding && function (e) {
          const t = e.transform.padding;
          fo(e, e.transform.height - (t.top || 0), 3, ho), fo(e, t.bottom || 0, 3, _o), go(e, t.left || 0, 3, uo), go(e, e.transform.width - (t.right || 0), 3, po);
          const i = e.transform.centerPoint;
          !function (e, t, i, o) {
            vo(e, t - 1, i - 10, 2, 20, o), vo(e, t - 10, i - 1, 20, 2, o);
          }(e, i.x, e.transform.height - i.y, mo);
        }(this), this.context.setDefault(), this.frameCounter = (this.frameCounter + 1) % Number.MAX_SAFE_INTEGER, this.tileLoaded && this.options.speedIndexTiming && (this.loadTimeStamps.push(e.window.performance.now()), this.saveCanvasCopy());
      }

      renderLayer(e, t, i, o) {
        i.isHidden(this.transform.zoom) || ("background" === i.type || "sky" === i.type || "custom" === i.type || o && o.length) && (this.id = i.id, this.gpuTimingStart(i), e.transform.projection.unsupportedLayers && e.transform.projection.unsupportedLayers.includes(i.type) || Io[i.type](e, t, i, o, this.style.placement.variableOffsets, this.options.isInitialLoad), this.gpuTimingEnd());
      }

      gpuTimingStart(e) {
        if (!this.options.gpuTiming) return;
        const t = this.context.extTimerQuery;
        let i = this.gpuTimers[e.id];
        i || (i = this.gpuTimers[e.id] = {
          calls: 0,
          cpuTime: 0,
          query: t.createQueryEXT()
        }), i.calls++, t.beginQueryEXT(t.TIME_ELAPSED_EXT, i.query);
      }

      gpuTimingEnd() {
        if (!this.options.gpuTiming) return;
        const e = this.context.extTimerQuery;
        e.endQueryEXT(e.TIME_ELAPSED_EXT);
      }

      collectGpuTimers() {
        const e = this.gpuTimers;
        return this.gpuTimers = {}, e;
      }

      queryGpuTimers(e) {
        const t = {};

        for (const i in e) {
          const o = e[i],
                r = this.context.extTimerQuery,
                n = r.getQueryObjectEXT(o.query, r.QUERY_RESULT_EXT) / 1e6;
          r.deleteQueryEXT(o.query), t[i] = n;
        }

        return t;
      }

      translatePosMatrix(t, i, o, r, n) {
        if (!o[0] && !o[1]) return t;
        const a = n ? "map" === r ? this.transform.angle : 0 : "viewport" === r ? -this.transform.angle : 0;

        if (a) {
          const e = Math.sin(a),
                t = Math.cos(a);
          o = [o[0] * t - o[1] * e, o[0] * e + o[1] * t];
        }

        const s = [n ? o[0] : L(i, o[0], this.transform.zoom), n ? o[1] : L(i, o[1], this.transform.zoom), 0],
              l = new Float32Array(16);
        return e.translate(l, t, s), l;
      }

      saveTileTexture(e) {
        const t = this._tileTextures[e.size[0]];
        t ? t.push(e) : this._tileTextures[e.size[0]] = [e];
      }

      getTileTexture(e) {
        const t = this._tileTextures[e];
        return t && t.length > 0 ? t.pop() : null;
      }

      isPatternMissing(e) {
        if (!e) return !1;
        if (!e.from || !e.to) return !0;
        const t = this.imageManager.getPattern(e.from.toString()),
              i = this.imageManager.getPattern(e.to.toString());
        return !t || !i;
      }

      currentGlobalDefines() {
        const e = this.terrain && this.terrain.renderingToTexture,
              t = this.style && this.style.fog,
              i = [];
        return this.terrain && !this.terrain.renderingToTexture && i.push("TERRAIN"), t && !e && 0 !== t.getOpacity(this.transform.pitch) && i.push("FOG"), e && i.push("RENDER_TO_TEXTURE"), this._showOverdrawInspector && i.push("OVERDRAW_INSPECTOR"), i;
      }

      useProgram(e, t, i) {
        this.cache = this.cache || {};
        const o = i || [],
              r = this.currentGlobalDefines().concat(o),
              n = Ti.cacheKey(e, r, t);
        return this.cache[n] || (this.cache[n] = new Ti(this.context, e, ti[e], t, Ji[e], r)), this.cache[n];
      }

      setCustomLayerDefaults() {
        this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.frontFace.setDefault(), this.context.cullFaceSide.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
      }

      setBaseState() {
        const e = this.context.gl;
        this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e.FUNC_ADD);
      }

      initDebugOverlayCanvas() {
        null == this.debugOverlayCanvas && (this.debugOverlayCanvas = e.window.document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new e.Texture(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
      }

      destroy() {
        this._terrain && this._terrain.destroy(), this.globeSharedBuffers && this.globeSharedBuffers.destroy(), this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy();
      }

      prepareDrawTile() {
        this.terrain && this.terrain.prepareDrawTile();
      }

      prepareDrawProgram(e, t, i) {
        if (this.terrain && this.terrain.renderingToTexture) return;
        const o = this.style.fog;

        if (o) {
          const r = o.getOpacity(this.transform.pitch);
          0 !== r && t.setFogUniformValues(e, ((e, t, i, o) => {
            const r = t.properties.get("color"),
                  n = e.frameCounter / 1e3 % 1,
                  a = [r.r / r.a, r.g / r.a, r.b / r.a, o];
            return {
              u_fog_matrix: i ? e.transform.calculateFogTileMatrix(i) : e.identityMat,
              u_fog_range: t.getFovAdjustedRange(e.transform._fov),
              u_fog_color: a,
              u_fog_horizon_blend: t.properties.get("horizon-blend"),
              u_fog_temporal_offset: n
            };
          })(this, o, i, r));
        }
      }

      setTileLoadedFlag(e) {
        this.tileLoaded = e;
      }

      saveCanvasCopy() {
        this.frameCopies.push(this.canvasCopy()), this.tileLoaded = !1;
      }

      canvasCopy() {
        const e = this.context.gl,
              t = e.createTexture();
        return e.bindTexture(e.TEXTURE_2D, t), e.copyTexImage2D(e.TEXTURE_2D, 0, e.RGBA, 0, 0, e.drawingBufferWidth, e.drawingBufferHeight, 0), t;
      }

      getCanvasCopiesAndTimestamps() {
        return {
          canvasCopies: this.frameCopies,
          timeStamps: this.loadTimeStamps
        };
      }

      averageElevationNeedsEasing() {
        if (!this.transform._elevation) return !1;
        const e = this.style && this.style.fog;
        return !!e && 0 !== e.getOpacity(this.transform.pitch);
      }

      getBackgroundTiles() {
        const t = this._backgroundTiles,
              i = this._backgroundTiles = {},
              o = this.transform.coveringTiles({
          tileSize: 512
        });

        for (const r of o) i[r.key] = t[r.key] || new e.Tile(r, 512, this.transform.tileZoom, this);

        return i;
      }

      clearBackgroundTiles() {
        this._backgroundTiles = {};
      }

    }

    class So {
      constructor(e = 0, t = 0, i = 0, o = 0) {
        if (isNaN(e) || e < 0 || isNaN(t) || t < 0 || isNaN(i) || i < 0 || isNaN(o) || o < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
        this.top = e, this.bottom = t, this.left = i, this.right = o;
      }

      interpolate(t, i, o) {
        return null != i.top && null != t.top && (this.top = e.number(t.top, i.top, o)), null != i.bottom && null != t.bottom && (this.bottom = e.number(t.bottom, i.bottom, o)), null != i.left && null != t.left && (this.left = e.number(t.left, i.left, o)), null != i.right && null != t.right && (this.right = e.number(t.right, i.right, o)), this;
      }

      getCenter(t, i) {
        const o = e.clamp((this.left + t - this.right) / 2, 0, t),
              r = e.clamp((this.top + i - this.bottom) / 2, 0, i);
        return new e.pointGeometry(o, r);
      }

      equals(e) {
        return this.top === e.top && this.bottom === e.bottom && this.left === e.left && this.right === e.right;
      }

      clone() {
        return new So(this.top, this.bottom, this.left, this.right);
      }

      toJSON() {
        return {
          top: this.top,
          bottom: this.bottom,
          left: this.left,
          right: this.right
        };
      }

    }

    function zo(t, i) {
      const o = e.getColumn(t, 3);
      e.fromQuat(t, i), e.setColumn(t, 3, o);
    }

    function Do(t, i) {
      const o = e.identity$1([]);
      return e.rotateZ$1(o, o, -i), e.rotateX$1(o, o, -t), o;
    }

    function Po(t, i) {
      const o = [t[0], t[1], 0],
            r = [i[0], i[1], 0];

      if (e.length(o) >= 1e-15) {
        const t = e.normalize([], o);
        e.scale$2(r, t, e.dot(r, t)), i[0] = r[0], i[1] = r[1];
      }

      const n = e.cross([], i, t);
      if (e.len(n) < 1e-15) return null;
      const a = Math.atan2(-n[1], n[0]);
      return Do(Math.atan2(Math.sqrt(t[0] * t[0] + t[1] * t[1]), -t[2]), a);
    }

    class Ao {
      constructor(e, t) {
        this.position = e, this.orientation = t;
      }

      get position() {
        return this._position;
      }

      set position(t) {
        if (t) {
          const i = t instanceof e.MercatorCoordinate ? t : new e.MercatorCoordinate(t[0], t[1], t[2]);
          this._renderWorldCopies && (i.x = e.wrap(i.x, 0, 1)), this._position = i;
        } else this._position = null;
      }

      lookAtPoint(t, i) {
        if (this.orientation = null, !this.position) return;
        const o = this._elevation ? this._elevation.getAtPointOrZero(e.MercatorCoordinate.fromLngLat(t)) : 0,
              r = this.position,
              n = e.MercatorCoordinate.fromLngLat(t, o),
              a = [n.x - r.x, n.y - r.y, n.z - r.z];
        i || (i = [0, 0, 1]), i[2] = Math.abs(i[2]), this.orientation = Po(a, i);
      }

      setPitchBearing(t, i) {
        this.orientation = Do(e.degToRad(t), e.degToRad(-i));
      }

    }

    class Lo {
      constructor(t, i) {
        this._transform = e.identity([]), this.orientation = i, this.position = t;
      }

      get mercatorPosition() {
        const t = this.position;
        return new e.MercatorCoordinate(t[0], t[1], t[2]);
      }

      get position() {
        const t = e.getColumn(this._transform, 3);
        return [t[0], t[1], t[2]];
      }

      set position(t) {
        var i;
        t && e.setColumn(this._transform, 3, [(i = t)[0], i[1], i[2], 1]);
      }

      get orientation() {
        return this._orientation;
      }

      set orientation(t) {
        this._orientation = t || e.identity$1([]), t && zo(this._transform, this._orientation);
      }

      getPitchBearing() {
        const e = this.forward(),
              t = this.right();
        return {
          bearing: Math.atan2(-t[1], t[0]),
          pitch: Math.atan2(Math.sqrt(e[0] * e[0] + e[1] * e[1]), -e[2])
        };
      }

      setPitchBearing(e, t) {
        this._orientation = Do(e, t), zo(this._transform, this._orientation);
      }

      forward() {
        const t = e.getColumn(this._transform, 2);
        return [-t[0], -t[1], -t[2]];
      }

      up() {
        const t = e.getColumn(this._transform, 1);
        return [-t[0], -t[1], -t[2]];
      }

      right() {
        const t = e.getColumn(this._transform, 0);
        return [t[0], t[1], t[2]];
      }

      getCameraToWorld(t, i) {
        const o = new Float64Array(16);
        return e.invert(o, this.getWorldToCamera(t, i)), o;
      }

      getWorldToCameraPosition(t, i, o) {
        const r = this.position;
        e.scale$2(r, r, -t);
        const n = new Float64Array(16);
        return e.fromScaling(n, [o, o, o]), e.translate(n, n, r), n[10] *= i, n;
      }

      getWorldToCamera(t, i) {
        const o = new Float64Array(16),
              r = new Float64Array(4),
              n = this.position;
        return e.conjugate(r, this._orientation), e.scale$2(n, n, -t), e.fromQuat(o, r), e.translate(o, o, n), o[1] *= -1, o[5] *= -1, o[9] *= -1, o[13] *= -1, o[8] *= i, o[9] *= i, o[10] *= i, o[11] *= i, o;
      }

      getCameraToClipPerspective(t, i, o, r) {
        const n = new Float64Array(16);
        return e.perspective(n, t, i, o, r), n;
      }

      getDistanceToElevation(t) {
        const i = 0 === t ? 0 : e.mercatorZfromAltitude(t, this.position[1]),
              o = this.forward();
        return (i - this.position[2]) / o[2];
      }

      clone() {
        return new Lo([...this.position], [...this.orientation]);
      }

    }

    function Ro(t, i) {
      const o = Oo(t),
            r = function (t, i, o, r, n) {
        const a = new e.LngLat(o.lng - 180 * Bo, o.lat),
              s = new e.LngLat(o.lng + 180 * Bo, o.lat),
              l = t.project(a.lng, a.lat),
              c = t.project(s.lng, s.lat),
              h = -Math.atan2(c.y - l.y, c.x - l.x),
              _ = e.MercatorCoordinate.fromLngLat(o);

        _.y = e.clamp(_.y, -.999975, .999975);

        const u = _.toLngLat(),
              d = t.project(u.lng, u.lat),
              p = e.MercatorCoordinate.fromLngLat(u);

        p.x += Bo;
        const m = p.toLngLat(),
              f = t.project(m.lng, m.lat),
              g = Uo(f.x - d.x, f.y - d.y, h),
              v = e.MercatorCoordinate.fromLngLat(u);
        v.y += Bo;
        const x = v.toLngLat(),
              y = t.project(x.lng, x.lat),
              b = Uo(y.x - d.x, y.y - d.y, h),
              w = Math.abs(g.x) / Math.abs(b.y),
              T = e.identity([]);
        e.rotateZ(T, T, -h * (1 - (n ? 0 : r)));
        const E = e.identity([]);
        return e.scale(E, E, [1, 1 - (1 - w) * r, 1]), E[4] = -b.x / b.y * r, e.rotateZ(E, E, h), e.multiply$1(E, T, E), E;
      }(t.projection, 0, t.center, o, i),
            n = ko(t);

      return e.scale(r, r, [n, n, 1]), r;
    }

    function ko(t) {
      const i = t.projection,
            o = Oo(t),
            r = Fo(i, t.center),
            n = Fo(i, e.LngLat.convert(i.center));
      return Math.pow(2, r * o + (1 - o) * n);
    }

    function Oo(t) {
      const i = t.projection.range;
      if (!i) return 0;
      const o = Math.max(t.width, t.height),
            r = Math.log(o / 1024) / Math.LN2;
      return e.smoothstep(i[0] + r, i[1] + r, t.zoom);
    }

    const Bo = 1 / 4e4;

    function Fo(t, i) {
      const o = e.clamp(i.lat, -e.MAX_MERCATOR_LATITUDE, e.MAX_MERCATOR_LATITUDE),
            r = new e.LngLat(i.lng - 180 * Bo, o),
            n = new e.LngLat(i.lng + 180 * Bo, o),
            a = t.project(r.lng, o),
            s = t.project(n.lng, o),
            l = e.MercatorCoordinate.fromLngLat(r),
            c = e.MercatorCoordinate.fromLngLat(n),
            h = s.x - a.x,
            _ = s.y - a.y,
            u = c.x - l.x,
            d = c.y - l.y,
            p = Math.sqrt((u * u + d * d) / (h * h + _ * _));

      return Math.log(p) / Math.LN2;
    }

    function Uo(e, t, i) {
      const o = Math.cos(i),
            r = Math.sin(i);
      return {
        x: e * o - t * r,
        y: e * r + t * o
      };
    }

    class No {
      constructor(t, i, o, r, n, a, s) {
        this.tileSize = 512, this._renderWorldCopies = void 0 === n || n, this._minZoom = t || 0, this._maxZoom = i || 22, this._minPitch = null == o ? 0 : o, this._maxPitch = null == r ? 60 : r, this.setProjection(a), this.setMaxBounds(s), this.width = 0, this.height = 0, this._center = new e.LngLat(0, 0), this.zoom = 0, this.angle = 0, this._fov = .6435011087932844, this._pitch = 0, this._nearZ = 0, this._farZ = 0, this._unmodified = !0, this._edgeInsets = new So(), this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._fogTileMatrixCache = {}, this._distanceTileDataCache = {}, this._camera = new Lo(), this._centerAltitude = 0, this._centerAltitudeValidForExaggeration = 0, this._averageElevation = 0, this.cameraElevationReference = "ground", this._projectionScaler = 1, this._horizonShift = .1;
      }

      clone() {
        const e = new No(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies, this.getProjection());
        return e._elevation = this._elevation, e._centerAltitude = this._centerAltitude, e._centerAltitudeValidForExaggeration = this._centerAltitudeValidForExaggeration, e.tileSize = this.tileSize, e.width = this.width, e.height = this.height, e.cameraElevationReference = this.cameraElevationReference, e._center = this._center, e._setZoom(this.zoom), e._seaLevelZoom = this._seaLevelZoom, e.angle = this.angle, e._fov = this._fov, e._pitch = this._pitch, e._nearZ = this._nearZ, e._farZ = this._farZ, e._averageElevation = this._averageElevation, e._unmodified = this._unmodified, e._edgeInsets = this._edgeInsets.clone(), e._camera = this._camera.clone(), e._calcMatrices(), e.freezeTileCoverage = this.freezeTileCoverage, e;
      }

      get elevation() {
        return this._elevation;
      }

      set elevation(e) {
        this._elevation !== e && (this._elevation = e, this._updateCameraOnTerrain(), this._calcMatrices());
      }

      updateElevation(e) {
        const t = this._elevation && this._elevation.exaggeration() !== this._centerAltitudeValidForExaggeration;

        (null == this._seaLevelZoom || t) && this._updateCameraOnTerrain(), (e || t) && this._constrainCameraAltitude(), this._calcMatrices();
      }

      getProjection() {
        return e.pick(this.projection, ["name", "center", "parallels"]);
      }

      setProjection(t) {
        null == t && (t = {
          name: "mercator"
        }), this.projectionOptions = t;
        const i = this.projection ? this.getProjection() : void 0;
        this.projection = e.getProjection(t);
        const o = this.getProjection();
        return r(i, o) ? null : (this._calcMatrices(), o);
      }

      get minZoom() {
        return this._minZoom;
      }

      set minZoom(e) {
        this._minZoom !== e && (this._minZoom = e, this.zoom = Math.max(this.zoom, e));
      }

      get maxZoom() {
        return this._maxZoom;
      }

      set maxZoom(e) {
        this._maxZoom !== e && (this._maxZoom = e, this.zoom = Math.min(this.zoom, e));
      }

      get minPitch() {
        return this._minPitch;
      }

      set minPitch(e) {
        this._minPitch !== e && (this._minPitch = e, this.pitch = Math.max(this.pitch, e));
      }

      get maxPitch() {
        return this._maxPitch;
      }

      set maxPitch(e) {
        this._maxPitch !== e && (this._maxPitch = e, this.pitch = Math.min(this.pitch, e));
      }

      get renderWorldCopies() {
        return this._renderWorldCopies && !0 === this.projection.supportsWorldCopies;
      }

      set renderWorldCopies(e) {
        void 0 === e ? e = !0 : null === e && (e = !1), this._renderWorldCopies = e;
      }

      get worldSize() {
        return this.tileSize * this.scale;
      }

      get cameraWorldSize() {
        const e = Math.max(this._camera.getDistanceToElevation(this._averageElevation), Number.EPSILON);
        return this._worldSizeFromZoom(this._zoomFromMercatorZ(e));
      }

      get pixelsPerMeter() {
        return this.projection.pixelsPerMeter(this.center.lat, this.worldSize);
      }

      get cameraPixelsPerMeter() {
        return this.projection.pixelsPerMeter(this.center.lat, this.cameraWorldSize);
      }

      get centerOffset() {
        return this.centerPoint._sub(this.size._div(2));
      }

      get size() {
        return new e.pointGeometry(this.width, this.height);
      }

      get bearing() {
        return e.wrap(this.rotation, -180, 180);
      }

      set bearing(e) {
        this.rotation = e;
      }

      get rotation() {
        return -this.angle / Math.PI * 180;
      }

      set rotation(t) {
        const i = -t * Math.PI / 180;
        var o;
        this.angle !== i && (this._unmodified = !1, this.angle = i, this._calcMatrices(), this.rotationMatrix = (o = new e.ARRAY_TYPE(4), e.ARRAY_TYPE != Float32Array && (o[1] = 0, o[2] = 0), o[0] = 1, o[3] = 1, o), function (e, t, i) {
          var o = t[0],
              r = t[1],
              n = t[2],
              a = t[3],
              s = Math.sin(i),
              l = Math.cos(i);
          e[0] = o * l + n * s, e[1] = r * l + a * s, e[2] = o * -s + n * l, e[3] = r * -s + a * l;
        }(this.rotationMatrix, this.rotationMatrix, this.angle));
      }

      get pitch() {
        return this._pitch / Math.PI * 180;
      }

      set pitch(t) {
        const i = e.clamp(t, this.minPitch, this.maxPitch) / 180 * Math.PI;
        this._pitch !== i && (this._unmodified = !1, this._pitch = i, this._calcMatrices());
      }

      get fov() {
        return this._fov / Math.PI * 180;
      }

      set fov(e) {
        e = Math.max(.01, Math.min(60, e)), this._fov !== e && (this._unmodified = !1, this._fov = e / 180 * Math.PI, this._calcMatrices());
      }

      get averageElevation() {
        return this._averageElevation;
      }

      set averageElevation(e) {
        this._averageElevation = e, this._calcFogMatrices(), this._distanceTileDataCache = {};
      }

      get zoom() {
        return this._zoom;
      }

      set zoom(e) {
        const t = Math.min(Math.max(e, this.minZoom), this.maxZoom);
        this._zoom !== t && (this._unmodified = !1, this._setZoom(t), this._updateSeaLevelZoom(), this._constrain(), this._calcMatrices());
      }

      _setZoom(e) {
        this._zoom = e, this.scale = this.zoomScale(e), this.tileZoom = Math.floor(e), this.zoomFraction = e - this.tileZoom;
      }

      _updateCameraOnTerrain() {
        if (!this._elevation || !this._elevation.isDataAvailableAtPoint(this.locationCoordinate(this.center))) return this._centerAltitude = 0, this._seaLevelZoom = null, void (this._centerAltitudeValidForExaggeration = 0);
        const e = this._elevation;
        this._centerAltitude = e.getAtPointOrZero(this.locationCoordinate(this.center)), this._centerAltitudeValidForExaggeration = e.exaggeration(), this._updateSeaLevelZoom();
      }

      _updateSeaLevelZoom() {
        0 !== this._centerAltitudeValidForExaggeration && (this._seaLevelZoom = this._zoomFromMercatorZ((this.pixelsPerMeter * this._centerAltitude + this.cameraToCenterDistance) / this.worldSize));
      }

      sampleAverageElevation() {
        if (!this._elevation) return 0;
        const t = this._elevation,
              i = [[.5, .2], [.3, .5], [.5, .5], [.7, .5], [.5, .8]],
              o = this.horizonLineFromTop();
        let r = 0,
            n = 0;

        for (let a = 0; a < i.length; a++) {
          const s = new e.pointGeometry(i[a][0] * this.width, o + i[a][1] * (this.height - o)),
                l = t.pointCoordinate(s);
          if (!l) continue;
          const c = 1 / Math.hypot(l[0] - this._camera.position[0], l[1] - this._camera.position[1]);
          r += l[3] * c, n += c;
        }

        return 0 === n ? NaN : r / n;
      }

      get center() {
        return this._center;
      }

      set center(e) {
        e.lat === this._center.lat && e.lng === this._center.lng || (this._unmodified = !1, this._center = e, this._terrainEnabled() && ("ground" === this.cameraElevationReference ? this._updateCameraOnTerrain() : this._updateZoomFromElevation()), this._constrain(), this._calcMatrices());
      }

      _updateZoomFromElevation() {
        if (null == this._seaLevelZoom || !this._elevation) return;

        const e = this._seaLevelZoom,
              t = this._elevation.getAtPointOrZero(this.locationCoordinate(this.center)),
              i = this.pixelsPerMeter / this.worldSize * t,
              o = this._mercatorZfromZoom(e),
              r = this._mercatorZfromZoom(this._maxZoom),
              n = Math.max(o - i, r);

        this._setZoom(this._zoomFromMercatorZ(n));
      }

      get padding() {
        return this._edgeInsets.toJSON();
      }

      set padding(e) {
        this._edgeInsets.equals(e) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, e, 1), this._calcMatrices());
      }

      computeZoomRelativeTo(t) {
        const i = this.rayIntersectionCoordinate(this.pointRayIntersection(this.centerPoint, t.toAltitude()));
        let o;
        o = t.z < this._camera.position[2] ? [i.x, i.y, i.z] : [t.x, t.y, t.z];
        const r = e.length(e.sub([], this._camera.position, o));
        return e.clamp(this._zoomFromMercatorZ(r), this._minZoom, this._maxZoom);
      }

      setFreeCameraOptions(t) {
        if (!this.height) return;
        if (!t.position && !t.orientation) return;

        this._updateCameraState();

        let i = !1;

        if (t.orientation && !e.exactEquals(t.orientation, this._camera.orientation) && (i = this._setCameraOrientation(t.orientation)), t.position) {
          const o = [t.position.x, t.position.y, t.position.z];
          e.exactEquals$1(o, this._camera.position) || (this._setCameraPosition(o), i = !0);
        }

        i && (this._updateStateFromCamera(), this.recenterOnTerrain());
      }

      getFreeCameraOptions() {
        this._updateCameraState();

        const t = this._camera.position,
              i = new Ao();
        return i.position = new e.MercatorCoordinate(t[0], t[1], t[2]), i.orientation = this._camera.orientation, i._elevation = this.elevation, i._renderWorldCopies = this.renderWorldCopies, i;
      }

      _setCameraOrientation(t) {
        if (!e.length$1(t)) return !1;
        e.normalize$1(t, t);
        const i = e.transformQuat([], [0, 0, -1], t),
              o = e.transformQuat([], [0, -1, 0], t);
        if (o[2] < 0) return !1;
        const r = Po(i, o);
        return !!r && (this._camera.orientation = r, !0);
      }

      _setCameraPosition(t) {
        const i = this.zoomScale(this.minZoom) * this.tileSize,
              o = this.zoomScale(this.maxZoom) * this.tileSize,
              r = this.cameraToCenterDistance;
        t[2] = e.clamp(t[2], r / o, r / i), this._camera.position = t;
      }

      get centerPoint() {
        return this._edgeInsets.getCenter(this.width, this.height);
      }

      get fovAboveCenter() {
        return this._fov * (.5 + this.centerOffset.y / this.height);
      }

      isPaddingEqual(e) {
        return this._edgeInsets.equals(e);
      }

      interpolatePadding(e, t, i) {
        this._unmodified = !1, this._edgeInsets.interpolate(e, t, i), this._constrain(), this._calcMatrices();
      }

      coveringZoomLevel(e) {
        const t = (e.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / e.tileSize));
        return Math.max(0, t);
      }

      getVisibleUnwrappedCoordinates(t) {
        const i = [new e.UnwrappedTileID(0, t)];

        if (this.renderWorldCopies) {
          const o = this.pointCoordinate(new e.pointGeometry(0, 0)),
                r = this.pointCoordinate(new e.pointGeometry(this.width, 0)),
                n = this.pointCoordinate(new e.pointGeometry(this.width, this.height)),
                a = this.pointCoordinate(new e.pointGeometry(0, this.height)),
                s = Math.floor(Math.min(o.x, r.x, n.x, a.x)),
                l = Math.floor(Math.max(o.x, r.x, n.x, a.x)),
                c = 1;

          for (let o = s - c; o <= l + c; o++) 0 !== o && i.push(new e.UnwrappedTileID(o, t));
        }

        return i;
      }

      coveringTiles(t) {
        let i = this.coveringZoomLevel(t);
        const o = i,
              r = this.elevation && !t.isTerrainDEM,
              n = "mercator" === this.projection.name;
        if (void 0 !== t.minzoom && i < t.minzoom) return [];
        void 0 !== t.maxzoom && i > t.maxzoom && (i = t.maxzoom);

        const a = this.locationCoordinate(this.center),
              s = this.center.lat,
              l = 1 << i,
              c = [l * a.x, l * a.y, 0],
              h = "globe" === this.projection.name,
              _ = !h,
              u = e.Frustum.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, i, _),
              d = h ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint()),
              p = l * e.mercatorZfromAltitude(1, this.center.lat),
              m = this._camera.position[2] / e.mercatorZfromAltitude(1, this.center.lat),
              f = [l * d.x, l * d.y, m * (_ ? 1 : p)],
              g = this.cameraToCenterDistance / t.tileSize * (t.roundZoom ? 1 : .502),
              v = this.pitch <= 60 && this._edgeInsets.top <= this._edgeInsets.bottom && !this._elevation && !this.projection.isReprojectedInTileSpace ? i : 0,
              x = t.isTerrainDEM && this._elevation ? 1e4 * this._elevation.exaggeration() : this._centerAltitude,
              y = t.isTerrainDEM ? -x : this._elevation ? this._elevation.getMinElevationBelowMSL() : 0,
              b = this.projection.isReprojectedInTileSpace ? ko(this) : 1,
              w = t => {
          const i = 1 / 4e4,
                o = new e.MercatorCoordinate(t.x + i, t.y, t.z),
                r = new e.MercatorCoordinate(t.x, t.y + i, t.z),
                n = t.toLngLat(),
                a = o.toLngLat(),
                s = r.toLngLat(),
                l = this.locationCoordinate(n),
                c = this.locationCoordinate(a),
                h = this.locationCoordinate(s),
                _ = Math.hypot(c.x - l.x, c.y - l.y),
                u = Math.hypot(h.x - l.x, h.y - l.y);

          return Math.sqrt(_ * u) * b / i;
        },
              T = t => {
          const i = x,
                o = y;
          return {
            aabb: e.tileAABB(this, l, 0, 0, 0, t, o, i, this.projection),
            zoom: 0,
            x: 0,
            y: 0,
            minZ: o,
            maxZ: i,
            wrap: t,
            fullyVisible: !1
          };
        },
              E = [];

        let C = [];

        const I = i,
              M = t.reparseOverscaled ? o : i,
              S = e => e * e,
              z = S((m - this._centerAltitude) * p),
              D = e => {
          if (!this._elevation || !e.tileID || !n) return;

          const t = this._elevation.getMinMaxForTile(e.tileID),
                i = e.aabb;

          t ? (i.min[2] = t.min, i.max[2] = t.max, i.center[2] = (i.min[2] + i.max[2]) / 2) : (e.shouldSplit = P(e), e.shouldSplit || (i.min[2] = i.max[2] = i.center[2] = this._centerAltitude));
        },
              P = t => {
          if (t.zoom < v) return !0;
          if (t.zoom === I) return !1;
          if (null != t.shouldSplit) return t.shouldSplit;
          const i = t.aabb.distanceX(f),
                n = t.aabb.distanceY(f);
          let a = z,
              l = 1;

          if (h) {
            a = S(t.aabb.distanceZ(f));
            const i = Math.pow(2, t.zoom),
                  o = e.latFromMercatorY((t.y + 1) / i),
                  r = e.latFromMercatorY(t.y / i),
                  n = Math.min(Math.max(s, o), r),
                  c = e.circumferenceAtLatitude(n) / e.circumferenceAtLatitude(s);
            l = Math.min(c, 1);
          } else if (r && (a = S(t.aabb.distanceZ(f) * p)), this.projection.isReprojectedInTileSpace && o <= 5) {
            const i = Math.pow(2, t.zoom),
                  o = w(new e.MercatorCoordinate((t.x + .5) / i, (t.y + .5) / i));
            l = o > .85 ? 1 : o;
          }

          const c = i * i + n * n + a;
          return c < S((1 << I - t.zoom) * g * l * ((e, t) => {
            if (t * S(.707) < e) return 1;
            const i = Math.sqrt(t / e);
            return i / (1.4144271570014144 + (Math.pow(1.1, i - 1.4144271570014144 + 1) - 1) / (1.1 - 1) - 1);
          })(Math.max(a, z), c));
        };

        if (this.renderWorldCopies) for (let e = 1; e <= 3; e++) E.push(T(-e)), E.push(T(e));

        for (E.push(T(0)); E.length > 0;) {
          const o = E.pop(),
                a = o.x,
                s = o.y;
          let _ = o.fullyVisible;

          if (!_) {
            const e = o.aabb.intersects(u);
            if (0 === e) continue;
            _ = 2 === e;
          }

          if (o.zoom !== I && P(o)) for (let t = 0; t < 4; t++) {
            const i = (a << 1) + t % 2,
                  c = (s << 1) + (t >> 1),
                  u = {
              aabb: n ? o.aabb.quadrant(t) : e.tileAABB(this, l, o.zoom + 1, i, c, o.wrap, o.minZ, o.maxZ, this.projection),
              zoom: o.zoom + 1,
              x: i,
              y: c,
              wrap: o.wrap,
              fullyVisible: _,
              tileID: void 0,
              shouldSplit: void 0,
              minZ: o.minZ,
              maxZ: o.maxZ
            };
            r && !h && (u.tileID = new e.OverscaledTileID(o.zoom + 1 === I ? M : o.zoom + 1, o.wrap, o.zoom + 1, i, c), D(u)), E.push(u);
          } else {
            const r = o.zoom === I ? M : o.zoom;
            if (t.minzoom && t.minzoom > r) continue;
            const n = c[0] - (.5 + a + (o.wrap << o.zoom)) * (1 << i - o.zoom),
                  l = c[1] - .5 - s,
                  h = o.tileID ? o.tileID : new e.OverscaledTileID(r, o.wrap, o.zoom, a, s);
            C.push({
              tileID: h,
              distanceSq: n * n + l * l
            });
          }
        }

        if (this.fogCullDistSq) {
          const i = this.fogCullDistSq,
                o = this.horizonLineFromTop();
          C = C.filter(r => {
            const n = [0, 0, 0, 1],
                  a = [e.EXTENT, e.EXTENT, 0, 1],
                  s = this.calculateFogTileMatrix(r.tileID.toUnwrapped());
            e.transformMat4$1(n, n, s), e.transformMat4$1(a, a, s);
            const l = e.getAABBPointSquareDist(n, a);
            if (0 === l) return !0;
            let c = !1;
            const h = this._elevation;

            if (h && l > i && 0 !== o) {
              const i = this.calculateProjMatrix(r.tileID.toUnwrapped());
              let n;
              t.isTerrainDEM || (n = h.getMinMaxForTile(r.tileID)), n || (n = {
                min: y,
                max: x
              });
              const a = e.furthestTileCorner(this.rotation),
                    s = [a[0] * e.EXTENT, a[1] * e.EXTENT, n.max];
              e.transformMat4(s, s, i), c = (1 - s[1]) * this.height * .5 < o;
            }

            return l < i || c;
          });
        }

        return C.sort((e, t) => e.distanceSq - t.distanceSq).map(e => e.tileID);
      }

      resize(e, t) {
        this.width = e, this.height = t, this.pixelsToGLUnits = [2 / e, -2 / t], this._constrain(), this._calcMatrices();
      }

      get unmodified() {
        return this._unmodified;
      }

      zoomScale(e) {
        return Math.pow(2, e);
      }

      scaleZoom(e) {
        return Math.log(e) / Math.LN2;
      }

      project(t) {
        const i = e.clamp(t.lat, -e.MAX_MERCATOR_LATITUDE, e.MAX_MERCATOR_LATITUDE),
              o = this.projection.project(t.lng, i);
        return new e.pointGeometry(o.x * this.worldSize, o.y * this.worldSize);
      }

      unproject(e) {
        return this.projection.unproject(e.x / this.worldSize, e.y / this.worldSize);
      }

      get point() {
        return this.project(this.center);
      }

      setLocationAtPoint(t, i) {
        let o, r;
        const n = this.centerPoint;

        if ("globe" === this.projection.name) {
          const e = this.worldSize;
          o = (i.x - n.x) / e, r = (i.y - n.y) / e;
        } else {
          const e = this.pointCoordinate(i),
                t = this.pointCoordinate(n);
          o = e.x - t.x, r = e.y - t.y;
        }

        const a = this.locationCoordinate(t);
        this.setLocation(new e.MercatorCoordinate(a.x - o, a.y - r));
      }

      setLocation(e) {
        this.center = this.coordinateLocation(e), this.projection.wrap && (this.center = this.center.wrap());
      }

      locationPoint(e) {
        return this.projection.locationPoint(this, e);
      }

      locationPoint3D(e) {
        return this._coordinatePoint(this.locationCoordinate(e), !0);
      }

      pointLocation(e) {
        return this.coordinateLocation(this.pointCoordinate(e));
      }

      pointLocation3D(e) {
        return this.coordinateLocation(this.pointCoordinate3D(e));
      }

      locationCoordinate(t, i) {
        const o = i ? e.mercatorZfromAltitude(i, t.lat) : void 0,
              r = this.projection.project(t.lng, t.lat);
        return new e.MercatorCoordinate(r.x, r.y, o);
      }

      coordinateLocation(e) {
        return this.projection.unproject(e.x, e.y);
      }

      pointRayIntersection(t, i) {
        const o = null != i ? i : this._centerAltitude,
              r = [t.x, t.y, 0, 1],
              n = [t.x, t.y, 1, 1];
        e.transformMat4$1(r, r, this.pixelMatrixInverse), e.transformMat4$1(n, n, this.pixelMatrixInverse);
        const a = n[3];
        e.scale$1(r, r, 1 / r[3]), e.scale$1(n, n, 1 / a);
        const s = r[2],
              l = n[2];
        return {
          p0: r,
          p1: n,
          t: s === l ? 0 : (o - s) / (l - s)
        };
      }

      screenPointToMercatorRay(t) {
        const i = [t.x, t.y, 0, 1],
              o = [t.x, t.y, 1, 1];
        return e.transformMat4$1(i, i, this.pixelMatrixInverse), e.transformMat4$1(o, o, this.pixelMatrixInverse), e.scale$1(i, i, 1 / i[3]), e.scale$1(o, o, 1 / o[3]), i[2] = e.mercatorZfromAltitude(i[2], this._center.lat) * this.worldSize, o[2] = e.mercatorZfromAltitude(o[2], this._center.lat) * this.worldSize, e.scale$1(i, i, 1 / this.worldSize), e.scale$1(o, o, 1 / this.worldSize), new e.Ray([i[0], i[1], i[2]], e.normalize([], e.sub([], o, i)));
      }

      rayIntersectionCoordinate(t) {
        const {
          p0: i,
          p1: o,
          t: r
        } = t,
              n = e.mercatorZfromAltitude(i[2], this._center.lat),
              a = e.mercatorZfromAltitude(o[2], this._center.lat);
        return new e.MercatorCoordinate(e.number(i[0], o[0], r) / this.worldSize, e.number(i[1], o[1], r) / this.worldSize, e.number(n, a, r));
      }

      pointCoordinate(e, t = this._centerAltitude) {
        return this.projection.pointCoordinate(this, e.x, e.y, t);
      }

      pointCoordinate3D(t) {
        if (!this.elevation) return this.pointCoordinate(t);
        const i = this.elevation;
        let o = this.elevation.pointCoordinate(t);
        if (o) return new e.MercatorCoordinate(o[0], o[1], o[2]);
        let r = 0,
            n = this.horizonLineFromTop();
        if (t.y > n) return this.pointCoordinate(t);
        const a = .02 * n,
              s = t.clone();

        for (let t = 0; t < 10 && n - r > a; t++) {
          s.y = e.number(r, n, .66);
          const t = i.pointCoordinate(s);
          t ? (n = s.y, o = t) : r = s.y;
        }

        return o ? new e.MercatorCoordinate(o[0], o[1], o[2]) : this.pointCoordinate(t);
      }

      isPointAboveHorizon(e) {
        if (this.elevation) return !this.elevation.pointCoordinate(e);
        {
          const t = this.horizonLineFromTop();
          return e.y < t;
        }
      }

      _coordinatePoint(t, i) {
        const o = i && this.elevation ? this.elevation.getAtPointOrZero(t, this._centerAltitude) : this._centerAltitude,
              r = [t.x * this.worldSize, t.y * this.worldSize, o + t.toAltitude(), 1];
        return e.transformMat4$1(r, r, this.pixelMatrix), r[3] > 0 ? new e.pointGeometry(r[0] / r[3], r[1] / r[3]) : new e.pointGeometry(Number.MAX_VALUE, Number.MAX_VALUE);
      }

      _getBounds(t, i) {
        const o = new e.pointGeometry(this._edgeInsets.left, this._edgeInsets.top),
              r = new e.pointGeometry(this.width - this._edgeInsets.right, this._edgeInsets.top),
              n = new e.pointGeometry(this.width - this._edgeInsets.right, this.height - this._edgeInsets.bottom),
              a = new e.pointGeometry(this._edgeInsets.left, this.height - this._edgeInsets.bottom);
        let s = this.pointCoordinate(o, t),
            l = this.pointCoordinate(r, t);

        const c = this.pointCoordinate(n, i),
              h = this.pointCoordinate(a, i),
              _ = (e, t) => (t.y - e.y) / (t.x - e.x);

        return s.y > 1 && l.y >= 0 ? s = new e.MercatorCoordinate((1 - h.y) / _(h, s) + h.x, 1) : s.y < 0 && l.y <= 1 && (s = new e.MercatorCoordinate(-h.y / _(h, s) + h.x, 0)), l.y > 1 && s.y >= 0 ? l = new e.MercatorCoordinate((1 - c.y) / _(c, l) + c.x, 1) : l.y < 0 && s.y <= 1 && (l = new e.MercatorCoordinate(-c.y / _(c, l) + c.x, 0)), new e.LngLatBounds().extend(this.coordinateLocation(s)).extend(this.coordinateLocation(l)).extend(this.coordinateLocation(h)).extend(this.coordinateLocation(c));
      }

      _getBounds3D() {
        const e = this.elevation;
        if (!e.visibleDemTiles.length) return this._getBounds(0, 0);
        const t = e.visibleDemTiles.reduce((e, t) => {
          if (t.dem) {
            const i = t.dem.tree;
            e.min = Math.min(e.min, i.minimums[0]), e.max = Math.max(e.max, i.maximums[0]);
          }

          return e;
        }, {
          min: Number.MAX_VALUE,
          max: 0
        });
        return this._getBounds(t.min * e.exaggeration(), t.max * e.exaggeration());
      }

      getBounds() {
        return this._terrainEnabled() ? this._getBounds3D() : this._getBounds(0, 0);
      }

      horizonLineFromTop(e = !0) {
        const t = this.height / 2 / Math.tan(this._fov / 2) / Math.tan(Math.max(this._pitch, .1)) + this.centerOffset.y,
              i = this.height / 2 - t * (1 - this._horizonShift);
        return e ? Math.max(0, i) : i;
      }

      getMaxBounds() {
        return this.maxBounds;
      }

      setMaxBounds(t) {
        this.maxBounds = t, this.minLat = -e.MAX_MERCATOR_LATITUDE, this.maxLat = e.MAX_MERCATOR_LATITUDE, this.minLng = -180, this.maxLng = 180, t && (this.minLat = t.getSouth(), this.maxLat = t.getNorth(), this.minLng = t.getWest(), this.maxLng = t.getEast(), this.maxLng < this.minLng && (this.maxLng += 360)), this.worldMinX = e.mercatorXfromLng(this.minLng) * this.tileSize, this.worldMaxX = e.mercatorXfromLng(this.maxLng) * this.tileSize, this.worldMinY = e.mercatorYfromLat(this.maxLat) * this.tileSize, this.worldMaxY = e.mercatorYfromLat(this.minLat) * this.tileSize, this._constrain();
      }

      calculatePosMatrix(e, t) {
        return this.projection.createTileMatrix(this, t, e);
      }

      calculateDistanceTileData(t) {
        const i = t.key,
              o = this._distanceTileDataCache;
        if (o[i]) return o[i];

        const r = t.canonical,
              n = 1 / this.height,
              a = this.cameraWorldSize / this.zoomScale(r.z),
              s = (r.x + Math.pow(2, r.z) * t.wrap) * a,
              l = r.y * a,
              c = this.point,
              h = this.angle,
              _ = Math.sin(-h),
              u = -Math.cos(-h);

        return o[i] = {
          bearing: [_, u],
          center: [(c.x - s) * n, (c.y - l) * n],
          scale: a / e.EXTENT * n
        }, o[i];
      }

      calculateFogTileMatrix(t) {
        const i = t.key,
              o = this._fogTileMatrixCache;
        if (o[i]) return o[i];
        const r = this.calculatePosMatrix(t, this.cameraWorldSize);
        return e.multiply$1(r, this.worldToFogMatrix, r), o[i] = new Float32Array(r), o[i];
      }

      calculateProjMatrix(t, i = !1) {
        const o = t.key,
              r = i ? this._alignedProjMatrixCache : this._projMatrixCache;
        if (r[o]) return r[o];
        const n = this.calculatePosMatrix(t, this.worldSize);
        return e.multiply$1(n, this.projection.isReprojectedInTileSpace ? this.mercatorMatrix : i ? this.alignedProjMatrix : this.projMatrix, n), r[o] = new Float32Array(n), r[o];
      }

      calculatePixelsToTileUnitsMatrix(t) {
        const i = t.tileID.key,
              o = this._pixelsToTileUnitsCache;
        if (o[i]) return o[i];

        const r = function (t, i) {
          const {
            scale: o
          } = t.tileTransform,
                r = o * e.EXTENT / (t.tileSize * Math.pow(2, i.zoom - t.tileID.overscaledZ + t.tileID.canonical.z));
          return n = new Float32Array(4), l = (a = i.inverseAdjustmentMatrix)[1], c = a[2], h = a[3], u = (s = [r, r])[1], n[0] = a[0] * (_ = s[0]), n[1] = l * _, n[2] = c * u, n[3] = h * u, n;

          var n, a, s, l, c, h, _, u;
        }(t, this);

        return o[i] = r, o[i];
      }

      customLayerMatrix() {
        return this.mercatorMatrix.slice();
      }

      recenterOnTerrain() {
        if (!this._elevation) return;
        const t = this._elevation;

        this._updateCameraState();

        const i = e.mercatorZfromAltitude(1, this._center.lat) * this.worldSize,
              o = this._computeCameraPosition(i),
              r = this._camera.forward(),
              n = e.mercatorZfromAltitude(1, this._center.lat);

        o[2] /= n, r[2] /= n, e.normalize(r, r);
        const a = t.raycast(o, r, t.exaggeration());

        if (a) {
          const t = e.scaleAndAdd([], o, r, a),
                i = new e.MercatorCoordinate(t[0], t[1], e.mercatorZfromAltitude(t[2], e.latFromMercatorY(t[1]))),
                s = (i.z + e.length([i.x - o[0], i.y - o[1], i.z - o[2] * n])) * this._projectionScaler;

          this._seaLevelZoom = this._zoomFromMercatorZ(s), this._centerAltitude = i.toAltitude(), this._center = this.coordinateLocation(i), this._updateZoomFromElevation(), this._constrain(), this._calcMatrices();
        }
      }

      _constrainCameraAltitude() {
        if (!this._elevation) return;
        const t = this._elevation;

        this._updateCameraState();

        const i = e.mercatorZfromAltitude(1, this._center.lat) * this.worldSize,
              o = this._computeCameraPosition(i),
              r = t.getAtPointOrZero(new e.MercatorCoordinate(...o)),
              n = this._minimumHeightOverTerrain() * Math.cos(e.degToRad(this._maxPitch)),
              a = this._camera.position[2] - this.pixelsPerMeter / this.worldSize * r;

        if (a < n) {
          const t = this.locationCoordinate(this._center, this._centerAltitude),
                i = [t.x - o[0], t.y - o[1], t.z - o[2]],
                r = e.length(i);
          i[2] -= (n - a) / this._projectionScaler;
          const s = e.length(i);
          if (0 === s) return;
          e.scale$2(i, i, r / s * this._projectionScaler), this._camera.position = [t.x - i[0], t.y - i[1], t.z * this._projectionScaler - i[2]], this._camera.orientation = Po(i, this._camera.up()), this._updateStateFromCamera();
        }
      }

      _constrain() {
        if (!this.center || !this.width || !this.height || this._constraining) return;

        if (this._constraining = !0, this.projection.isReprojectedInTileSpace) {
          const t = this.center;
          return t.lat = e.clamp(t.lat, this.minLat, this.maxLat), !this.maxBounds && this.renderWorldCopies || (t.lng = e.clamp(t.lng, this.minLng, this.maxLng)), this.center = t, void (this._constraining = !1);
        }

        const t = this._unmodified,
              {
          x: i,
          y: o
        } = this.point;
        let r = 0,
            n = i,
            a = o;
        const s = this.width / 2,
              l = this.height / 2,
              c = this.worldMinY * this.scale,
              h = this.worldMaxY * this.scale;

        if (o - l < c && (a = c + l), o + l > h && (a = h - l), h - c < this.height && (r = Math.max(r, this.height / (h - c)), a = (h + c) / 2), this.maxBounds || !this._renderWorldCopies || !this.projection.wrap) {
          const e = this.worldMinX * this.scale,
                t = this.worldMaxX * this.scale,
                o = this.worldSize / 2 - (e + t) / 2;
          n = (i + o + this.worldSize) % this.worldSize - o, n - s < e && (n = e + s), n + s > t && (n = t - s), t - e < this.width && (r = Math.max(r, this.width / (t - e)), n = (t + e) / 2);
        }

        n === i && a === o || (this.center = this.unproject(new e.pointGeometry(n, a))), r && (this.zoom += this.scaleZoom(r)), this._constrainCameraAltitude(), this._unmodified = t, this._constraining = !1;
      }

      _minZoomForBounds() {
        let e = Math.max(0, this.scaleZoom(this.height / (this.worldMaxY - this.worldMinY)));
        return this.maxBounds && (e = Math.max(e, this.scaleZoom(this.width / (this.worldMaxX - this.worldMinX)))), e;
      }

      _maxCameraBoundsDistance() {
        return this._mercatorZfromZoom(this._minZoomForBounds());
      }

      _calcMatrices() {
        if (!this.height) return;
        const t = this._fov / 2,
              i = this.centerOffset,
              o = this.pixelsPerMeter;
        this._projectionScaler = o / (e.mercatorZfromAltitude(1, this.center.lat) * this.worldSize), this.cameraToCenterDistance = .5 / Math.tan(t) * this.height * this._projectionScaler, this._updateCameraState(), this._farZ = this.projection.farthestPixelDistance(this), this._nearZ = this.height / 50;

        const r = this._camera.getWorldToCamera(this.worldSize, "meters" === this.projection.zAxisUnit ? o : 1),
              n = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, this._farZ);

        n[8] = 2 * -i.x / this.width, n[9] = 2 * i.y / this.height;
        let a = e.mul([], n, r);

        if (this.projection.isReprojectedInTileSpace) {
          const t = this.locationCoordinate(this.center),
                i = e.identity([]);
          e.translate(i, i, [t.x * this.worldSize, t.y * this.worldSize, 0]), e.multiply$1(i, i, Ro(this)), e.translate(i, i, [-t.x * this.worldSize, -t.y * this.worldSize, 0]), e.multiply$1(a, a, i), this.inverseAdjustmentMatrix = function (e) {
            const t = Ro(e, !0);
            return v([], [t[0], t[1], t[4], t[5]]);
          }(this);
        } else this.inverseAdjustmentMatrix = [1, 0, 0, 1];

        this.mercatorMatrix = e.scale([], a, [this.worldSize, this.worldSize, this.worldSize / o, 1]), this.projMatrix = a, this.invProjMatrix = e.invert(new Float64Array(16), this.projMatrix);
        const s = new Float32Array(16);
        e.identity(s), e.scale(s, s, [1, -1, 1]), e.rotateX(s, s, this._pitch), e.rotateZ(s, s, this.angle);
        const l = e.perspective(new Float32Array(16), this._fov, this.width / this.height, this._nearZ, this._farZ),
              c = (Math.PI / 2 - this._pitch) * (this.height / this._fov) * this._horizonShift;
        l[8] = 2 * -i.x / this.width, l[9] = 2 * (i.y + c) / this.height, this.skyboxMatrix = e.multiply$1(s, l, s);
        const h = this.point,
              _ = h.x,
              u = h.y,
              d = this.width % 2 / 2,
              p = this.height % 2 / 2,
              m = Math.cos(this.angle),
              f = Math.sin(this.angle),
              g = _ - Math.round(_) + m * d + f * p,
              x = u - Math.round(u) + m * p + f * d,
              y = new Float64Array(a);
        if (e.translate(y, y, [g > .5 ? g - 1 : g, x > .5 ? x - 1 : x, 0]), this.alignedProjMatrix = y, a = e.create(), e.scale(a, a, [this.width / 2, -this.height / 2, 1]), e.translate(a, a, [1, -1, 0]), this.labelPlaneMatrix = a, a = e.create(), e.scale(a, a, [1, -1, 1]), e.translate(a, a, [-1, -1, 0]), e.scale(a, a, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = a, this.pixelMatrix = e.multiply$1(new Float64Array(16), this.labelPlaneMatrix, this.projMatrix), this._calcFogMatrices(), this._distanceTileDataCache = {}, a = e.invert(new Float64Array(16), this.pixelMatrix), !a) throw new Error("failed to invert matrix");
        this.pixelMatrixInverse = a, this.globeMatrix = "globe" === this.projection.name ? e.calculateGlobeMatrix(this) : a, this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._pixelsToTileUnitsCache = {};
      }

      _calcFogMatrices() {
        this._fogTileMatrixCache = {};
        const t = this.cameraWorldSize,
              i = this.cameraPixelsPerMeter,
              o = this._camera.position,
              r = 1 / this.height,
              n = [t, t, i];
        e.scale$2(n, n, r), e.scale$2(o, o, -1), e.multiply$2(o, o, n);
        const a = e.create();
        e.translate(a, a, o), e.scale(a, a, n), this.mercatorFogMatrix = a, this.worldToFogMatrix = this._camera.getWorldToCameraPosition(t, i, r);
      }

      _computeCameraPosition(e) {
        const t = (e = e || this.pixelsPerMeter) / this.pixelsPerMeter,
              i = this._camera.forward(),
              o = this.point,
              r = this._mercatorZfromZoom(this._seaLevelZoom ? this._seaLevelZoom : this._zoom) * t - e / this.worldSize * this._centerAltitude;

        return [o.x / this.worldSize - i[0] * r, o.y / this.worldSize - i[1] * r, e / this.worldSize * this._centerAltitude - i[2] * r];
      }

      _updateCameraState() {
        this.height && (this._camera.setPitchBearing(this._pitch, this.angle), this._camera.position = this._computeCameraPosition());
      }

      _translateCameraConstrained(t) {
        const i = this._maxCameraBoundsDistance() * Math.cos(this._pitch),
              o = t[2];
        let r = 1;
        o > 0 && (r = Math.min((i - this._camera.position[2]) / o, 1)), this._camera.position = e.scaleAndAdd([], this._camera.position, t, r), this._updateStateFromCamera(), this.projection.wrap && (this.center = this.center.wrap());
      }

      _updateStateFromCamera() {
        const t = this._camera.position,
              i = this._camera.forward(),
              {
          pitch: o,
          bearing: r
        } = this._camera.getPitchBearing(),
              n = e.mercatorZfromAltitude(this._centerAltitude, this.center.lat) * this._projectionScaler,
              a = this._mercatorZfromZoom(this._maxZoom) * Math.cos(e.degToRad(this._maxPitch)),
              s = Math.max((t[2] - n) / Math.cos(o), a),
              l = this._zoomFromMercatorZ(s);

        e.scaleAndAdd(t, t, i, s), this._pitch = e.clamp(o, e.degToRad(this.minPitch), e.degToRad(this.maxPitch)), this.angle = e.wrap(r, -Math.PI, Math.PI), this._setZoom(e.clamp(l, this._minZoom, this._maxZoom)), this._updateSeaLevelZoom(), this._center = this.coordinateLocation(new e.MercatorCoordinate(t[0], t[1], t[2])), this._unmodified = !1, this._constrain(), this._calcMatrices();
      }

      _worldSizeFromZoom(e) {
        return Math.pow(2, e) * this.tileSize;
      }

      _mercatorZfromZoom(e) {
        return this.cameraToCenterDistance / this._worldSizeFromZoom(e);
      }

      _minimumHeightOverTerrain() {
        const e = Math.min((null != this._seaLevelZoom ? this._seaLevelZoom : this._zoom) + 2, this._maxZoom);
        return this._mercatorZfromZoom(e);
      }

      _zoomFromMercatorZ(e) {
        return this.scaleZoom(this.cameraToCenterDistance / (e * this.tileSize));
      }

      _terrainEnabled() {
        return !(!this._elevation || !this.projection.supportsTerrain && (e.warnOnce("Terrain is not yet supported with alternate projections. Use mercator to enable terrain."), 1));
      }

      anyCornerOffEdge(t, i) {
        const o = Math.min(t.x, i.x),
              r = Math.max(t.x, i.x),
              n = Math.min(t.y, i.y),
              a = Math.max(t.y, i.y);
        if (n < this.horizonLineFromTop(!1)) return !0;
        if ("mercator" !== this.projection.name) return !1;
        const s = [new e.pointGeometry(o, n), new e.pointGeometry(r, a), new e.pointGeometry(o, a), new e.pointGeometry(r, n)],
              l = this.renderWorldCopies ? -3 : 0,
              c = this.renderWorldCopies ? 4 : 1;

        for (const e of s) {
          const t = this.pointRayIntersection(e);
          if (t.t < 0) return !0;
          const i = this.rayIntersectionCoordinate(t);
          if (i.x < l || i.y < 0 || i.x > c || i.y > 1) return !0;
        }

        return !1;
      }

      isHorizonVisible() {
        return this.pitch + e.radToDeg(this.fovAboveCenter) > 88 || this.anyCornerOffEdge(new e.pointGeometry(0, 0), new e.pointGeometry(this.width, this.height));
      }

      zoomDeltaToMovement(t, i) {
        const o = e.length(e.sub([], this._camera.position, t)),
              r = this._zoomFromMercatorZ(o) + i;
        return o - this._mercatorZfromZoom(r);
      }

      getCameraPoint() {
        const t = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
        return this.centerPoint.add(new e.pointGeometry(0, t));
      }

    }

    function Go(e, t) {
      let i = !1,
          o = null;

      const r = () => {
        o = null, i && (e(), o = setTimeout(r, t), i = !1);
      };

      return () => (i = !0, o || r(), o);
    }

    class jo {
      constructor(t) {
        this._hashName = t && encodeURIComponent(t), e.bindAll(["_getCurrentHash", "_onHashChange", "_updateHash"], this), this._updateHash = Go(this._updateHashUnthrottled.bind(this), 300);
      }

      addTo(t) {
        return this._map = t, e.window.addEventListener("hashchange", this._onHashChange, !1), t.on("moveend", this._updateHash), this;
      }

      remove() {
        return this._map ? (this._map.off("moveend", this._updateHash), e.window.removeEventListener("hashchange", this._onHashChange, !1), clearTimeout(this._updateHash()), this._map = void 0, this) : this;
      }

      getHashString(t) {
        const i = this._map;
        if (!i) return "";
        const o = i.getCenter(),
              r = Math.round(100 * i.getZoom()) / 100,
              n = Math.ceil((r * Math.LN2 + Math.log(512 / 360 / .5)) / Math.LN10),
              a = Math.pow(10, n),
              s = Math.round(o.lng * a) / a,
              l = Math.round(o.lat * a) / a,
              c = i.getBearing(),
              h = i.getPitch();
        let _ = "";

        if (_ += t ? `/${s}/${l}/${r}` : `${r}/${l}/${s}`, (c || h) && (_ += "/" + Math.round(10 * c) / 10), h && (_ += `/${Math.round(h)}`), this._hashName) {
          const t = this._hashName;
          let i = !1;
          const o = e.window.location.hash.slice(1).split("&").map(e => {
            const o = e.split("=")[0];
            return o === t ? (i = !0, `${o}=${_}`) : e;
          }).filter(e => e);
          return i || o.push(`${t}=${_}`), `#${o.join("&")}`;
        }

        return `#${_}`;
      }

      _getCurrentHash() {
        const t = e.window.location.hash.replace("#", "");

        if (this._hashName) {
          let e;
          return t.split("&").map(e => e.split("=")).forEach(t => {
            t[0] === this._hashName && (e = t);
          }), (e && e[1] || "").split("/");
        }

        return t.split("/");
      }

      _onHashChange() {
        const e = this._map;
        if (!e) return !1;

        const t = this._getCurrentHash();

        if (t.length >= 3 && !t.some(e => isNaN(e))) {
          const i = e.dragRotate.isEnabled() && e.touchZoomRotate.isEnabled() ? +(t[3] || 0) : e.getBearing();
          return e.jumpTo({
            center: [+t[2], +t[1]],
            zoom: +t[0],
            bearing: i,
            pitch: +(t[4] || 0)
          }), !0;
        }

        return !1;
      }

      _updateHashUnthrottled() {
        const t = e.window.location.href.replace(/(#.+)?$/, this.getHashString());
        e.window.history.replaceState(e.window.history.state, null, t);
      }

    }

    const Zo = {
      linearity: .3,
      easing: e.bezier(0, 0, .3, 1)
    },
          Vo = e.extend({
      deceleration: 2500,
      maxSpeed: 1400
    }, Zo),
          Wo = e.extend({
      deceleration: 20,
      maxSpeed: 1400
    }, Zo),
          qo = e.extend({
      deceleration: 1e3,
      maxSpeed: 360
    }, Zo),
          Xo = e.extend({
      deceleration: 1e3,
      maxSpeed: 90
    }, Zo);

    class $o {
      constructor(e) {
        this._map = e, this.clear();
      }

      clear() {
        this._inertiaBuffer = [];
      }

      record(t) {
        this._drainInertiaBuffer(), this._inertiaBuffer.push({
          time: e.exported.now(),
          settings: t
        });
      }

      _drainInertiaBuffer() {
        const t = this._inertiaBuffer,
              i = e.exported.now();

        for (; t.length > 0 && i - t[0].time > 160;) t.shift();
      }

      _onMoveEnd(t) {
        if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
        const i = {
          zoom: 0,
          bearing: 0,
          pitch: 0,
          pan: new e.pointGeometry(0, 0),
          pinchAround: void 0,
          around: void 0
        };

        for (const {
          settings: e
        } of this._inertiaBuffer) i.zoom += e.zoomDelta || 0, i.bearing += e.bearingDelta || 0, i.pitch += e.pitchDelta || 0, e.panDelta && i.pan._add(e.panDelta), e.around && (i.around = e.around), e.pinchAround && (i.pinchAround = e.pinchAround);

        const o = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time,
              r = {};

        if (i.pan.mag()) {
          const n = Ko(i.pan.mag(), o, e.extend({}, Vo, t || {}));
          r.offset = i.pan.mult(n.amount / i.pan.mag()), r.center = this._map.transform.center, Ho(r, n);
        }

        if (i.zoom) {
          const e = Ko(i.zoom, o, Wo);
          r.zoom = this._map.transform.zoom + e.amount, Ho(r, e);
        }

        if (i.bearing) {
          const t = Ko(i.bearing, o, qo);
          r.bearing = this._map.transform.bearing + e.clamp(t.amount, -179, 179), Ho(r, t);
        }

        if (i.pitch) {
          const e = Ko(i.pitch, o, Xo);
          r.pitch = this._map.transform.pitch + e.amount, Ho(r, e);
        }

        if (r.zoom || r.bearing) {
          const e = void 0 === i.pinchAround ? i.around : i.pinchAround;
          r.around = e ? this._map.unproject(e) : this._map.getCenter();
        }

        return this.clear(), r.noMoveStart = !0, r;
      }

    }

    function Ho(e, t) {
      (!e.duration || e.duration < t.duration) && (e.duration = t.duration, e.easing = t.easing);
    }

    function Ko(t, i, o) {
      const {
        maxSpeed: r,
        linearity: n,
        deceleration: a
      } = o,
            s = e.clamp(t * n / (i / 1e3), -r, r),
            l = Math.abs(s) / (a * n);
      return {
        easing: o.easing,
        duration: 1e3 * l,
        amount: s * (l / 2)
      };
    }

    class Yo extends e.Event {
      preventDefault() {
        this._defaultPrevented = !0;
      }

      get defaultPrevented() {
        return this._defaultPrevented;
      }

      constructor(t, i, o, r = {}) {
        const n = p(i.getCanvasContainer(), o),
              a = i.unproject(n);
        super(t, e.extend({
          point: n,
          lngLat: a,
          originalEvent: o
        }, r)), this._defaultPrevented = !1, this.target = i;
      }

    }

    class Jo extends e.Event {
      preventDefault() {
        this._defaultPrevented = !0;
      }

      get defaultPrevented() {
        return this._defaultPrevented;
      }

      constructor(t, i, o) {
        const r = "touchend" === t ? o.changedTouches : o.touches,
              n = m(i.getCanvasContainer(), r),
              a = n.map(e => i.unproject(e)),
              s = n.reduce((e, t, i, o) => e.add(t.div(o.length)), new e.pointGeometry(0, 0));
        super(t, {
          points: n,
          point: s,
          lngLats: a,
          lngLat: i.unproject(s),
          originalEvent: o
        }), this._defaultPrevented = !1;
      }

    }

    class Qo extends e.Event {
      preventDefault() {
        this._defaultPrevented = !0;
      }

      get defaultPrevented() {
        return this._defaultPrevented;
      }

      constructor(e, t, i) {
        super(e, {
          originalEvent: i
        }), this._defaultPrevented = !1;
      }

    }

    class er {
      constructor(e, t) {
        this._map = e, this._clickTolerance = t.clickTolerance;
      }

      reset() {
        this._mousedownPos = void 0;
      }

      wheel(e) {
        return this._firePreventable(new Qo(e.type, this._map, e));
      }

      mousedown(e, t) {
        return this._mousedownPos = t, this._firePreventable(new Yo(e.type, this._map, e));
      }

      mouseup(e) {
        this._map.fire(new Yo(e.type, this._map, e));
      }

      preclick(t) {
        const i = e.extend({}, t);
        i.type = "preclick", this._map.fire(new Yo(i.type, this._map, i));
      }

      click(e, t) {
        this._mousedownPos && this._mousedownPos.dist(t) >= this._clickTolerance || (this.preclick(e), this._map.fire(new Yo(e.type, this._map, e)));
      }

      dblclick(e) {
        return this._firePreventable(new Yo(e.type, this._map, e));
      }

      mouseover(e) {
        this._map.fire(new Yo(e.type, this._map, e));
      }

      mouseout(e) {
        this._map.fire(new Yo(e.type, this._map, e));
      }

      touchstart(e) {
        return this._firePreventable(new Jo(e.type, this._map, e));
      }

      touchmove(e) {
        this._map.fire(new Jo(e.type, this._map, e));
      }

      touchend(e) {
        this._map.fire(new Jo(e.type, this._map, e));
      }

      touchcancel(e) {
        this._map.fire(new Jo(e.type, this._map, e));
      }

      _firePreventable(e) {
        if (this._map.fire(e), e.defaultPrevented) return {};
      }

      isEnabled() {
        return !0;
      }

      isActive() {
        return !1;
      }

      enable() {}

      disable() {}

    }

    class tr {
      constructor(e) {
        this._map = e;
      }

      reset() {
        this._delayContextMenu = !1, this._contextMenuEvent = void 0;
      }

      mousemove(e) {
        this._map.fire(new Yo(e.type, this._map, e));
      }

      mousedown() {
        this._delayContextMenu = !0;
      }

      mouseup() {
        this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new Yo("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
      }

      contextmenu(e) {
        this._delayContextMenu ? this._contextMenuEvent = e : this._map.fire(new Yo(e.type, this._map, e)), this._map.listens("contextmenu") && e.preventDefault();
      }

      isEnabled() {
        return !0;
      }

      isActive() {
        return !1;
      }

      enable() {}

      disable() {}

    }

    class ir {
      constructor(e, t) {
        this._map = e, this._el = e.getCanvasContainer(), this._container = e.getContainer(), this._clickTolerance = t.clickTolerance || 1;
      }

      isEnabled() {
        return !!this._enabled;
      }

      isActive() {
        return !!this._active;
      }

      enable() {
        this.isEnabled() || (this._enabled = !0);
      }

      disable() {
        this.isEnabled() && (this._enabled = !1);
      }

      mousedown(e, t) {
        this.isEnabled() && e.shiftKey && 0 === e.button && (h(), this._startPos = this._lastPos = t, this._active = !0);
      }

      mousemoveWindow(e, t) {
        if (!this._active) return;
        const i = t;
        if (this._lastPos.equals(i) || !this._box && i.dist(this._startPos) < this._clickTolerance) return;
        const o = this._startPos;
        this._lastPos = i, this._box || (this._box = n("div", "mapboxgl-boxzoom", this._container), this._container.classList.add("mapboxgl-crosshair"), this._fireEvent("boxzoomstart", e));
        const r = Math.min(o.x, i.x),
              a = Math.max(o.x, i.x),
              s = Math.min(o.y, i.y),
              l = Math.max(o.y, i.y);

        this._map._requestDomTask(() => {
          this._box && (this._box.style.transform = `translate(${r}px,${s}px)`, this._box.style.width = a - r + "px", this._box.style.height = l - s + "px");
        });
      }

      mouseupWindow(t, i) {
        if (!this._active) return;
        if (0 !== t.button) return;
        const o = this._startPos,
              r = i;
        if (this.reset(), d(), o.x !== r.x || o.y !== r.y) return this._map.fire(new e.Event("boxzoomend", {
          originalEvent: t
        })), {
          cameraAnimation: e => e.fitScreenCoordinates(o, r, this._map.getBearing(), {
            linear: !1
          })
        };

        this._fireEvent("boxzoomcancel", t);
      }

      keydown(e) {
        this._active && 27 === e.keyCode && (this.reset(), this._fireEvent("boxzoomcancel", e));
      }

      blur() {
        this.reset();
      }

      reset() {
        this._active = !1, this._container.classList.remove("mapboxgl-crosshair"), this._box && (this._box.remove(), this._box = null), _(), delete this._startPos, delete this._lastPos;
      }

      _fireEvent(t, i) {
        return this._map.fire(new e.Event(t, {
          originalEvent: i
        }));
      }

    }

    function or(e, t) {
      const i = {};

      for (let o = 0; o < e.length; o++) i[e[o].identifier] = t[o];

      return i;
    }

    class rr {
      constructor(e) {
        this.reset(), this.numTouches = e.numTouches;
      }

      reset() {
        this.centroid = void 0, this.startTime = 0, this.touches = {}, this.aborted = !1;
      }

      touchstart(t, i, o) {
        (this.centroid || o.length > this.numTouches) && (this.aborted = !0), this.aborted || (0 === this.startTime && (this.startTime = t.timeStamp), o.length === this.numTouches && (this.centroid = function (t) {
          const i = new e.pointGeometry(0, 0);

          for (const e of t) i._add(e);

          return i.div(t.length);
        }(i), this.touches = or(o, i)));
      }

      touchmove(e, t, i) {
        if (this.aborted || !this.centroid) return;
        const o = or(i, t);

        for (const e in this.touches) {
          const t = this.touches[e],
                i = o[e];
          (!i || i.dist(t) > 30) && (this.aborted = !0);
        }
      }

      touchend(e, t, i) {
        if ((!this.centroid || e.timeStamp - this.startTime > 500) && (this.aborted = !0), 0 === i.length) {
          const e = !this.aborted && this.centroid;
          if (this.reset(), e) return e;
        }
      }

    }

    class nr {
      constructor(e) {
        this.singleTap = new rr(e), this.numTaps = e.numTaps, this.reset();
      }

      reset() {
        this.lastTime = 1 / 0, this.lastTap = void 0, this.count = 0, this.singleTap.reset();
      }

      touchstart(e, t, i) {
        this.singleTap.touchstart(e, t, i);
      }

      touchmove(e, t, i) {
        this.singleTap.touchmove(e, t, i);
      }

      touchend(e, t, i) {
        const o = this.singleTap.touchend(e, t, i);

        if (o) {
          const t = e.timeStamp - this.lastTime < 500,
                i = !this.lastTap || this.lastTap.dist(o) < 30;
          if (t && i || this.reset(), this.count++, this.lastTime = e.timeStamp, this.lastTap = o, this.count === this.numTaps) return this.reset(), o;
        }
      }

    }

    class ar {
      constructor() {
        this._zoomIn = new nr({
          numTouches: 1,
          numTaps: 2
        }), this._zoomOut = new nr({
          numTouches: 2,
          numTaps: 1
        }), this.reset();
      }

      reset() {
        this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();
      }

      touchstart(e, t, i) {
        this._zoomIn.touchstart(e, t, i), this._zoomOut.touchstart(e, t, i);
      }

      touchmove(e, t, i) {
        this._zoomIn.touchmove(e, t, i), this._zoomOut.touchmove(e, t, i);
      }

      touchend(e, t, i) {
        const o = this._zoomIn.touchend(e, t, i),
              r = this._zoomOut.touchend(e, t, i);

        return o ? (this._active = !0, e.preventDefault(), setTimeout(() => this.reset(), 0), {
          cameraAnimation: t => t.easeTo({
            duration: 300,
            zoom: t.getZoom() + 1,
            around: t.unproject(o)
          }, {
            originalEvent: e
          })
        }) : r ? (this._active = !0, e.preventDefault(), setTimeout(() => this.reset(), 0), {
          cameraAnimation: t => t.easeTo({
            duration: 300,
            zoom: t.getZoom() - 1,
            around: t.unproject(r)
          }, {
            originalEvent: e
          })
        }) : void 0;
      }

      touchcancel() {
        this.reset();
      }

      enable() {
        this._enabled = !0;
      }

      disable() {
        this._enabled = !1, this.reset();
      }

      isEnabled() {
        return this._enabled;
      }

      isActive() {
        return this._active;
      }

    }

    const sr = {
      0: 1,
      2: 2
    };

    class lr {
      constructor(e) {
        this.reset(), this._clickTolerance = e.clickTolerance || 1;
      }

      blur() {
        this.reset();
      }

      reset() {
        this._active = !1, this._moved = !1, this._lastPoint = void 0, this._eventButton = void 0;
      }

      _correctButton(e, t) {
        return !1;
      }

      _move(e, t) {
        return {};
      }

      mousedown(e, t) {
        if (this._lastPoint) return;
        const i = f(e);
        this._correctButton(e, i) && (this._lastPoint = t, this._eventButton = i);
      }

      mousemoveWindow(e, t) {
        const i = this._lastPoint;
        if (i) if (e.preventDefault(), null != this._eventButton && function (e, t) {
          const i = sr[t];
          return void 0 === e.buttons || (e.buttons & i) !== i;
        }(e, this._eventButton)) this.reset();else if (this._moved || !(t.dist(i) < this._clickTolerance)) return this._moved = !0, this._lastPoint = t, this._move(i, t);
      }

      mouseupWindow(e) {
        this._lastPoint && f(e) === this._eventButton && (this._moved && d(), this.reset());
      }

      enable() {
        this._enabled = !0;
      }

      disable() {
        this._enabled = !1, this.reset();
      }

      isEnabled() {
        return this._enabled;
      }

      isActive() {
        return this._active;
      }

    }

    class cr extends lr {
      mousedown(e, t) {
        super.mousedown(e, t), this._lastPoint && (this._active = !0);
      }

      _correctButton(e, t) {
        return 0 === t && !e.ctrlKey;
      }

      _move(e, t) {
        return {
          around: t,
          panDelta: t.sub(e)
        };
      }

    }

    class hr extends lr {
      _correctButton(e, t) {
        return 0 === t && e.ctrlKey || 2 === t;
      }

      _move(e, t) {
        const i = .8 * (t.x - e.x);
        if (i) return this._active = !0, {
          bearingDelta: i
        };
      }

      contextmenu(e) {
        e.preventDefault();
      }

    }

    class _r extends lr {
      _correctButton(e, t) {
        return 0 === t && e.ctrlKey || 2 === t;
      }

      _move(e, t) {
        const i = -.5 * (t.y - e.y);
        if (i) return this._active = !0, {
          pitchDelta: i
        };
      }

      contextmenu(e) {
        e.preventDefault();
      }

    }

    class ur {
      constructor(t, i) {
        this._map = t, this._el = t.getCanvasContainer(), this._minTouches = 1, this._clickTolerance = i.clickTolerance || 1, this.reset(), e.bindAll(["_addTouchPanBlocker", "_showTouchPanBlockerAlert"], this);
      }

      reset() {
        this._active = !1, this._touches = {}, this._sum = new e.pointGeometry(0, 0);
      }

      touchstart(e, t, i) {
        return this._calculateTransform(e, t, i);
      }

      touchmove(e, t, i) {
        if (this._active && !(i.length < this._minTouches)) {
          if (this._map._cooperativeGestures && !this._map.isMoving()) {
            if (1 === i.length) return void this._showTouchPanBlockerAlert();
            "hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
          }

          return e.preventDefault(), this._calculateTransform(e, t, i);
        }
      }

      touchend(e, t, i) {
        this._calculateTransform(e, t, i), this._active && i.length < this._minTouches && this.reset();
      }

      touchcancel() {
        this.reset();
      }

      _calculateTransform(t, i, o) {
        o.length > 0 && (this._active = !0);
        const r = or(o, i),
              n = new e.pointGeometry(0, 0),
              a = new e.pointGeometry(0, 0);
        let s = 0;

        for (const e in r) {
          const t = r[e],
                i = this._touches[e];
          i && (n._add(t), a._add(t.sub(i)), s++, r[e] = t);
        }

        if (this._touches = r, s < this._minTouches || !a.mag()) return;
        const l = a.div(s);
        return this._sum._add(l), this._sum.mag() < this._clickTolerance ? void 0 : {
          around: n.div(s),
          panDelta: l
        };
      }

      enable() {
        this._enabled = !0, this._map._cooperativeGestures && (this._addTouchPanBlocker(), this._el.classList.add("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page"));
      }

      disable() {
        this._enabled = !1, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove(), this._el.classList.remove("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page")), this.reset();
      }

      isEnabled() {
        return this._enabled;
      }

      isActive() {
        return this._active;
      }

      _addTouchPanBlocker() {
        this._map && !this._alertContainer && (this._alertContainer = n("div", "mapboxgl-touch-pan-blocker", this._map._container), this._alertContainer.textContent = this._map._getUIString("TouchPanBlocker.Message"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(.05 * this._el.clientWidth)))}px`);
      }

      _showTouchPanBlockerAlert() {
        "hidden" === this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "visible"), this._alertContainer.classList.add("mapboxgl-touch-pan-blocker-show"), clearTimeout(this._alertTimer), this._alertTimer = setTimeout(() => {
          this._alertContainer.classList.remove("mapboxgl-touch-pan-blocker-show");
        }, 500);
      }

    }

    class dr {
      constructor() {
        this.reset();
      }

      reset() {
        this._active = !1, this._firstTwoTouches = void 0;
      }

      _start(e) {}

      _move(e, t, i) {
        return {};
      }

      touchstart(e, t, i) {
        this._firstTwoTouches || i.length < 2 || (this._firstTwoTouches = [i[0].identifier, i[1].identifier], this._start([t[0], t[1]]));
      }

      touchmove(e, t, i) {
        const o = this._firstTwoTouches;
        if (!o) return;
        e.preventDefault();
        const [r, n] = o,
              a = pr(i, t, r),
              s = pr(i, t, n);
        if (!a || !s) return;
        const l = this._aroundCenter ? null : a.add(s).div(2);
        return this._move([a, s], l, e);
      }

      touchend(e, t, i) {
        if (!this._firstTwoTouches) return;
        const [o, r] = this._firstTwoTouches,
              n = pr(i, t, o),
              a = pr(i, t, r);
        n && a || (this._active && d(), this.reset());
      }

      touchcancel() {
        this.reset();
      }

      enable(e) {
        this._enabled = !0, this._aroundCenter = !!e && "center" === e.around;
      }

      disable() {
        this._enabled = !1, this.reset();
      }

      isEnabled() {
        return this._enabled;
      }

      isActive() {
        return this._active;
      }

    }

    function pr(e, t, i) {
      for (let o = 0; o < e.length; o++) if (e[o].identifier === i) return t[o];
    }

    function mr(e, t) {
      return Math.log(e / t) / Math.LN2;
    }

    class fr extends dr {
      reset() {
        super.reset(), this._distance = 0, this._startDistance = 0;
      }

      _start(e) {
        this._startDistance = this._distance = e[0].dist(e[1]);
      }

      _move(e, t) {
        const i = this._distance;
        if (this._distance = e[0].dist(e[1]), this._active || !(Math.abs(mr(this._distance, this._startDistance)) < .1)) return this._active = !0, {
          zoomDelta: mr(this._distance, i),
          pinchAround: t
        };
      }

    }

    function gr(e, t) {
      return 180 * e.angleWith(t) / Math.PI;
    }

    class vr extends dr {
      reset() {
        super.reset(), this._minDiameter = 0, this._startVector = void 0, this._vector = void 0;
      }

      _start(e) {
        this._startVector = this._vector = e[0].sub(e[1]), this._minDiameter = e[0].dist(e[1]);
      }

      _move(e, t) {
        const i = this._vector;
        if (this._vector = e[0].sub(e[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = !0, {
          bearingDelta: gr(this._vector, i),
          pinchAround: t
        };
      }

      _isBelowThreshold(e) {
        this._minDiameter = Math.min(this._minDiameter, e.mag());
        const t = 25 / (Math.PI * this._minDiameter) * 360,
              i = gr(e, this._startVector);
        return Math.abs(i) < t;
      }

    }

    function xr(e) {
      return Math.abs(e.y) > Math.abs(e.x);
    }

    class yr extends dr {
      constructor(e) {
        super(), this._map = e;
      }

      reset() {
        super.reset(), this._valid = void 0, this._firstMove = void 0, this._lastPoints = void 0;
      }

      _start(e) {
        this._lastPoints = e, xr(e[0].sub(e[1])) && (this._valid = !1);
      }

      _move(e, t, i) {
        const o = this._lastPoints;
        if (!o) return;
        const r = e[0].sub(o[0]),
              n = e[1].sub(o[1]);
        return this._map._cooperativeGestures && i.touches.length < 3 || (this._valid = this.gestureBeginsVertically(r, n, i.timeStamp), !this._valid) ? void 0 : (this._lastPoints = e, this._active = !0, {
          pitchDelta: (r.y + n.y) / 2 * -.5
        });
      }

      gestureBeginsVertically(e, t, i) {
        if (void 0 !== this._valid) return this._valid;
        const o = e.mag() >= 2,
              r = t.mag() >= 2;
        if (!o && !r) return;
        if (!o || !r) return null == this._firstMove && (this._firstMove = i), i - this._firstMove < 100 && void 0;
        const n = e.y > 0 == t.y > 0;
        return xr(e) && xr(t) && n;
      }

    }

    const br = {
      panStep: 100,
      bearingStep: 15,
      pitchStep: 10
    };

    class wr {
      constructor() {
        const e = br;
        this._panStep = e.panStep, this._bearingStep = e.bearingStep, this._pitchStep = e.pitchStep, this._rotationDisabled = !1;
      }

      blur() {
        this.reset();
      }

      reset() {
        this._active = !1;
      }

      keydown(e) {
        if (e.altKey || e.ctrlKey || e.metaKey) return;
        let t = 0,
            i = 0,
            o = 0,
            r = 0,
            n = 0;

        switch (e.keyCode) {
          case 61:
          case 107:
          case 171:
          case 187:
            t = 1;
            break;

          case 189:
          case 109:
          case 173:
            t = -1;
            break;

          case 37:
            e.shiftKey ? i = -1 : (e.preventDefault(), r = -1);
            break;

          case 39:
            e.shiftKey ? i = 1 : (e.preventDefault(), r = 1);
            break;

          case 38:
            e.shiftKey ? o = 1 : (e.preventDefault(), n = -1);
            break;

          case 40:
            e.shiftKey ? o = -1 : (e.preventDefault(), n = 1);
            break;

          default:
            return;
        }

        return this._rotationDisabled && (i = 0, o = 0), {
          cameraAnimation: a => {
            const s = a.getZoom();
            a.easeTo({
              duration: 300,
              easeId: "keyboardHandler",
              easing: Tr,
              zoom: t ? Math.round(s) + t * (e.shiftKey ? 2 : 1) : s,
              bearing: a.getBearing() + i * this._bearingStep,
              pitch: a.getPitch() + o * this._pitchStep,
              offset: [-r * this._panStep, -n * this._panStep],
              center: a.getCenter()
            }, {
              originalEvent: e
            });
          }
        };
      }

      enable() {
        this._enabled = !0;
      }

      disable() {
        this._enabled = !1, this.reset();
      }

      isEnabled() {
        return this._enabled;
      }

      isActive() {
        return this._active;
      }

      disableRotation() {
        this._rotationDisabled = !0;
      }

      enableRotation() {
        this._rotationDisabled = !1;
      }

    }

    function Tr(e) {
      return e * (2 - e);
    }

    const Er = 4.000244140625;

    class Cr {
      constructor(t, i) {
        this._map = t, this._el = t.getCanvasContainer(), this._handler = i, this._delta = 0, this._defaultZoomRate = .01, this._wheelZoomRate = .0022222222222222222, e.bindAll(["_onTimeout", "_addScrollZoomBlocker", "_showBlockerAlert", "_isFullscreen"], this);
      }

      setZoomRate(e) {
        this._defaultZoomRate = e;
      }

      setWheelZoomRate(e) {
        this._wheelZoomRate = e;
      }

      isEnabled() {
        return !!this._enabled;
      }

      isActive() {
        return !!this._active || void 0 !== this._finishTimeout;
      }

      isZooming() {
        return !!this._zooming;
      }

      enable(e) {
        this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!e && "center" === e.around, this._map._cooperativeGestures && this._addScrollZoomBlocker());
      }

      disable() {
        this.isEnabled() && (this._enabled = !1, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove()));
      }

      wheel(t) {
        if (!this.isEnabled()) return;

        if (this._map._cooperativeGestures) {
          if (!(t.ctrlKey || t.metaKey || this.isZooming() || this._isFullscreen())) return void this._showBlockerAlert();
          "hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
        }

        let i = t.deltaMode === e.window.WheelEvent.DOM_DELTA_LINE ? 40 * t.deltaY : t.deltaY;
        const o = e.exported.now(),
              r = o - (this._lastWheelEventTime || 0);
        this._lastWheelEventTime = o, 0 !== i && i % Er == 0 ? this._type = "wheel" : 0 !== i && Math.abs(i) < 4 ? this._type = "trackpad" : r > 400 ? (this._type = null, this._lastValue = i, this._timeout = setTimeout(this._onTimeout, 40, t)) : this._type || (this._type = Math.abs(r * i) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i += this._lastValue)), t.shiftKey && i && (i /= 4), this._type && (this._lastWheelEvent = t, this._delta -= i, this._active || this._start(t)), t.preventDefault();
      }

      _onTimeout(e) {
        this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(e);
      }

      _start(e) {
        if (!this._delta) return;
        this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
        const t = p(this._el, e);
        this._aroundPoint = this._aroundCenter ? this._map.transform.centerPoint : t, this._aroundCoord = this._map.transform.pointCoordinate3D(this._aroundPoint), this._targetZoom = void 0, this._frameId || (this._frameId = !0, this._handler._triggerRenderFrame());
      }

      renderFrame() {
        if (!this._frameId) return;
        if (this._frameId = null, !this.isActive()) return;

        const t = this._map.transform,
              i = () => t._terrainEnabled() && this._aroundCoord ? t.computeZoomRelativeTo(this._aroundCoord) : t.zoom;

        if (0 !== this._delta) {
          const e = "wheel" === this._type && Math.abs(this._delta) > Er ? this._wheelZoomRate : this._defaultZoomRate;
          let o = 2 / (1 + Math.exp(-Math.abs(this._delta * e)));
          this._delta < 0 && 0 !== o && (o = 1 / o);
          const r = i(),
                n = Math.pow(2, r),
                a = "number" == typeof this._targetZoom ? t.zoomScale(this._targetZoom) : n;
          this._targetZoom = Math.min(t.maxZoom, Math.max(t.minZoom, t.scaleZoom(a * o))), "wheel" === this._type && (this._startZoom = i(), this._easing = this._smoothOutEasing(200)), this._delta = 0;
        }

        const o = "number" == typeof this._targetZoom ? this._targetZoom : i(),
              r = this._startZoom,
              n = this._easing;
        let a,
            s = !1;

        if ("wheel" === this._type && r && n) {
          const t = Math.min((e.exported.now() - this._lastWheelEventTime) / 200, 1),
                i = n(t);
          a = e.number(r, o, i), t < 1 ? this._frameId || (this._frameId = !0) : s = !0;
        } else a = o, s = !0;

        return this._active = !0, s && (this._active = !1, this._finishTimeout = setTimeout(() => {
          this._zooming = !1, this._handler._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
        }, 200)), {
          noInertia: !0,
          needsRenderFrame: !s,
          zoomDelta: a - i(),
          around: this._aroundPoint,
          aroundCoord: this._aroundCoord,
          originalEvent: this._lastWheelEvent
        };
      }

      _smoothOutEasing(t) {
        let i = e.ease;

        if (this._prevEase) {
          const t = this._prevEase,
                o = (e.exported.now() - t.start) / t.duration,
                r = t.easing(o + .01) - t.easing(o),
                n = .27 / Math.sqrt(r * r + 1e-4) * .01,
                a = Math.sqrt(.0729 - n * n);
          i = e.bezier(n, a, .25, 1);
        }

        return this._prevEase = {
          start: e.exported.now(),
          duration: t,
          easing: i
        }, i;
      }

      blur() {
        this.reset();
      }

      reset() {
        this._active = !1;
      }

      _addScrollZoomBlocker() {
        this._map && !this._alertContainer && (this._alertContainer = n("div", "mapboxgl-scroll-zoom-blocker", this._map._container), this._alertContainer.textContent = /(Mac|iPad)/i.test(e.window.navigator.userAgent) ? this._map._getUIString("ScrollZoomBlocker.CmdMessage") : this._map._getUIString("ScrollZoomBlocker.CtrlMessage"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(.05 * this._el.clientWidth)))}px`);
      }

      _isFullscreen() {
        return !!e.window.document.fullscreenElement || !!e.window.document.webkitFullscreenElement;
      }

      _showBlockerAlert() {
        "hidden" === this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "visible"), this._alertContainer.classList.add("mapboxgl-scroll-zoom-blocker-show"), clearTimeout(this._alertTimer), this._alertTimer = setTimeout(() => {
          this._alertContainer.classList.remove("mapboxgl-scroll-zoom-blocker-show");
        }, 200);
      }

    }

    class Ir {
      constructor(e, t) {
        this._clickZoom = e, this._tapZoom = t;
      }

      enable() {
        this._clickZoom.enable(), this._tapZoom.enable();
      }

      disable() {
        this._clickZoom.disable(), this._tapZoom.disable();
      }

      isEnabled() {
        return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
      }

      isActive() {
        return this._clickZoom.isActive() || this._tapZoom.isActive();
      }

    }

    class Mr {
      constructor() {
        this.reset();
      }

      reset() {
        this._active = !1;
      }

      blur() {
        this.reset();
      }

      dblclick(e, t) {
        return e.preventDefault(), {
          cameraAnimation: i => {
            i.easeTo({
              duration: 300,
              zoom: i.getZoom() + (e.shiftKey ? -1 : 1),
              around: i.unproject(t)
            }, {
              originalEvent: e
            });
          }
        };
      }

      enable() {
        this._enabled = !0;
      }

      disable() {
        this._enabled = !1, this.reset();
      }

      isEnabled() {
        return this._enabled;
      }

      isActive() {
        return this._active;
      }

    }

    class Sr {
      constructor() {
        this._tap = new nr({
          numTouches: 1,
          numTaps: 1
        }), this.reset();
      }

      reset() {
        this._active = !1, this._swipePoint = void 0, this._swipeTouch = 0, this._tapTime = 0, this._tap.reset();
      }

      touchstart(e, t, i) {
        this._swipePoint || (this._tapTime && e.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? i.length > 0 && (this._swipePoint = t[0], this._swipeTouch = i[0].identifier) : this._tap.touchstart(e, t, i));
      }

      touchmove(e, t, i) {
        if (this._tapTime) {
          if (this._swipePoint) {
            if (i[0].identifier !== this._swipeTouch) return;
            const o = t[0],
                  r = o.y - this._swipePoint.y;
            return this._swipePoint = o, e.preventDefault(), this._active = !0, {
              zoomDelta: r / 128
            };
          }
        } else this._tap.touchmove(e, t, i);
      }

      touchend(e, t, i) {
        this._tapTime ? this._swipePoint && 0 === i.length && this.reset() : this._tap.touchend(e, t, i) && (this._tapTime = e.timeStamp);
      }

      touchcancel() {
        this.reset();
      }

      enable() {
        this._enabled = !0;
      }

      disable() {
        this._enabled = !1, this.reset();
      }

      isEnabled() {
        return this._enabled;
      }

      isActive() {
        return this._active;
      }

    }

    class zr {
      constructor(e, t, i) {
        this._el = e, this._mousePan = t, this._touchPan = i;
      }

      enable(e) {
        this._inertiaOptions = e || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("mapboxgl-touch-drag-pan");
      }

      disable() {
        this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("mapboxgl-touch-drag-pan");
      }

      isEnabled() {
        return this._mousePan.isEnabled() && this._touchPan.isEnabled();
      }

      isActive() {
        return this._mousePan.isActive() || this._touchPan.isActive();
      }

    }

    class Dr {
      constructor(e, t, i) {
        this._pitchWithRotate = e.pitchWithRotate, this._mouseRotate = t, this._mousePitch = i;
      }

      enable() {
        this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
      }

      disable() {
        this._mouseRotate.disable(), this._mousePitch.disable();
      }

      isEnabled() {
        return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
      }

      isActive() {
        return this._mouseRotate.isActive() || this._mousePitch.isActive();
      }

    }

    class Pr {
      constructor(e, t, i, o) {
        this._el = e, this._touchZoom = t, this._touchRotate = i, this._tapDragZoom = o, this._rotationDisabled = !1, this._enabled = !0;
      }

      enable(e) {
        this._touchZoom.enable(e), this._rotationDisabled || this._touchRotate.enable(e), this._tapDragZoom.enable(), this._el.classList.add("mapboxgl-touch-zoom-rotate");
      }

      disable() {
        this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("mapboxgl-touch-zoom-rotate");
      }

      isEnabled() {
        return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
      }

      isActive() {
        return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
      }

      disableRotation() {
        this._rotationDisabled = !0, this._touchRotate.disable();
      }

      enableRotation() {
        this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();
      }

    }

    const Ar = e => e.zoom || e.drag || e.pitch || e.rotate;

    class Lr extends e.Event {}

    class Rr {
      constructor() {
        this.constants = [1, 1, .01], this.radius = 0;
      }

      setup(t, i) {
        const o = e.sub([], i, t);
        this.radius = e.length(o[2] < 0 ? e.div([], o, this.constants) : [o[0], o[1], 0]);
      }

      projectRay(t) {
        e.div(t, t, this.constants), e.normalize(t, t), e.mul$1(t, t, this.constants);
        const i = e.scale$2([], t, this.radius);

        if (i[2] > 0) {
          const t = e.scale$2([], [0, 0, 1], e.dot(i, [0, 0, 1])),
                o = e.scale$2([], e.normalize([], [i[0], i[1], 0]), this.radius),
                r = e.add([], i, e.scale$2([], e.sub([], e.add([], o, t), i), 2));
          i[0] = r[0], i[1] = r[1];
        }

        return i;
      }

    }

    function kr(e) {
      return e.panDelta && e.panDelta.mag() || e.zoomDelta || e.bearingDelta || e.pitchDelta;
    }

    class Or {
      constructor(t, i) {
        this._map = t, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new $o(t), this._bearingSnap = i.bearingSnap, this._previousActiveHandlers = {}, this._trackingEllipsoid = new Rr(), this._dragOrigin = null, this._eventsInProgress = {}, this._addDefaultHandlers(i), e.bindAll(["handleEvent", "handleWindowEvent"], this);
        const o = this._el;
        this._listeners = [[o, "touchstart", {
          passive: !0
        }], [o, "touchmove", {
          passive: !1
        }], [o, "touchend", void 0], [o, "touchcancel", void 0], [o, "mousedown", void 0], [o, "mousemove", void 0], [o, "mouseup", void 0], [e.window.document, "mousemove", {
          capture: !0
        }], [e.window.document, "mouseup", void 0], [o, "mouseover", void 0], [o, "mouseout", void 0], [o, "dblclick", void 0], [o, "click", void 0], [o, "keydown", {
          capture: !1
        }], [o, "keyup", void 0], [o, "wheel", {
          passive: !1
        }], [o, "contextmenu", void 0], [e.window, "blur", void 0]];

        for (const [t, i, o] of this._listeners) t.addEventListener(i, t === e.window.document ? this.handleWindowEvent : this.handleEvent, o);
      }

      destroy() {
        for (const [t, i, o] of this._listeners) t.removeEventListener(i, t === e.window.document ? this.handleWindowEvent : this.handleEvent, o);
      }

      _addDefaultHandlers(e) {
        const t = this._map,
              i = t.getCanvasContainer();

        this._add("mapEvent", new er(t, e));

        const o = t.boxZoom = new ir(t, e);

        this._add("boxZoom", o);

        const r = new ar(),
              n = new Mr();
        t.doubleClickZoom = new Ir(n, r), this._add("tapZoom", r), this._add("clickZoom", n);
        const a = new Sr();

        this._add("tapDragZoom", a);

        const s = t.touchPitch = new yr(t);

        this._add("touchPitch", s);

        const l = new hr(e),
              c = new _r(e);
        t.dragRotate = new Dr(e, l, c), this._add("mouseRotate", l, ["mousePitch"]), this._add("mousePitch", c, ["mouseRotate"]);

        const h = new cr(e),
              _ = new ur(t, e);

        t.dragPan = new zr(i, h, _), this._add("mousePan", h), this._add("touchPan", _, ["touchZoom", "touchRotate"]);
        const u = new vr(),
              d = new fr();
        t.touchZoomRotate = new Pr(i, d, u, a), this._add("touchRotate", u, ["touchPan", "touchZoom"]), this._add("touchZoom", d, ["touchPan", "touchRotate"]), this._add("blockableMapEvent", new tr(t));
        const p = t.scrollZoom = new Cr(t, this);

        this._add("scrollZoom", p, ["mousePan"]);

        const m = t.keyboard = new wr();

        this._add("keyboard", m);

        for (const i of ["boxZoom", "doubleClickZoom", "tapDragZoom", "touchPitch", "dragRotate", "dragPan", "touchZoomRotate", "scrollZoom", "keyboard"]) e.interactive && e[i] && t[i].enable(e[i]);
      }

      _add(e, t, i) {
        this._handlers.push({
          handlerName: e,
          handler: t,
          allowed: i
        }), this._handlersById[e] = t;
      }

      stop(e) {
        if (!this._updatingCamera) {
          for (const {
            handler: e
          } of this._handlers) e.reset();

          this._inertia.clear(), this._fireEvents({}, {}, e), this._changes = [];
        }
      }

      isActive() {
        for (const {
          handler: e
        } of this._handlers) if (e.isActive()) return !0;

        return !1;
      }

      isZooming() {
        return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
      }

      isRotating() {
        return !!this._eventsInProgress.rotate;
      }

      isMoving() {
        return !!Ar(this._eventsInProgress) || this.isZooming();
      }

      _blockedByActive(e, t, i) {
        for (const o in e) if (o !== i && (!t || t.indexOf(o) < 0)) return !0;

        return !1;
      }

      handleWindowEvent(e) {
        this.handleEvent(e, `${e.type}Window`);
      }

      _getMapTouches(e) {
        const t = [];

        for (const i of e) this._el.contains(i.target) && t.push(i);

        return t;
      }

      handleEvent(e, t) {
        this._updatingCamera = !0;
        const i = "renderFrame" === e.type,
              o = i ? void 0 : e,
              r = {
          needsRenderFrame: !1
        },
              n = {},
              a = {},
              s = e.touches ? this._getMapTouches(e.touches) : void 0,
              l = s ? m(this._el, s) : i ? void 0 : p(this._el, e);

        for (const {
          handlerName: i,
          handler: c,
          allowed: h
        } of this._handlers) {
          if (!c.isEnabled()) continue;

          let _;

          this._blockedByActive(a, h, i) ? c.reset() : c[t || e.type] && (_ = c[t || e.type](e, l, s), this.mergeHandlerResult(r, n, _, i, o), _ && _.needsRenderFrame && this._triggerRenderFrame()), (_ || c.isActive()) && (a[i] = c);
        }

        const c = {};

        for (const e in this._previousActiveHandlers) a[e] || (c[e] = o);

        this._previousActiveHandlers = a, (Object.keys(c).length || kr(r)) && (this._changes.push([r, n, c]), this._triggerRenderFrame()), (Object.keys(a).length || kr(r)) && this._map._stop(!0), this._updatingCamera = !1;
        const {
          cameraAnimation: h
        } = r;
        h && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], h(this._map));
      }

      mergeHandlerResult(t, i, o, r, n) {
        if (!o) return;
        e.extend(t, o);
        const a = {
          handlerName: r,
          originalEvent: o.originalEvent || n
        };
        void 0 !== o.zoomDelta && (i.zoom = a), void 0 !== o.panDelta && (i.drag = a), void 0 !== o.pitchDelta && (i.pitch = a), void 0 !== o.bearingDelta && (i.rotate = a);
      }

      _applyChanges() {
        const t = {},
              i = {},
              o = {};

        for (const [r, n, a] of this._changes) r.panDelta && (t.panDelta = (t.panDelta || new e.pointGeometry(0, 0))._add(r.panDelta)), r.zoomDelta && (t.zoomDelta = (t.zoomDelta || 0) + r.zoomDelta), r.bearingDelta && (t.bearingDelta = (t.bearingDelta || 0) + r.bearingDelta), r.pitchDelta && (t.pitchDelta = (t.pitchDelta || 0) + r.pitchDelta), void 0 !== r.around && (t.around = r.around), void 0 !== r.aroundCoord && (t.aroundCoord = r.aroundCoord), void 0 !== r.pinchAround && (t.pinchAround = r.pinchAround), r.noInertia && (t.noInertia = r.noInertia), e.extend(i, n), e.extend(o, a);

        this._updateMapTransform(t, i, o), this._changes = [];
      }

      _updateMapTransform(t, i, o) {
        const r = this._map,
              n = r.transform,
              a = e => [e.x, e.y, e.z];

        if ((e => {
          const t = this._eventsInProgress.drag;
          return t && !this._handlersById[t.handlerName].isActive();
        })() && !kr(t)) {
          const e = n.zoom;
          n.cameraElevationReference = "sea", n.recenterOnTerrain(), n.cameraElevationReference = "ground", e !== n.zoom && this._map._update(!0);
        }

        if (!kr(t)) return void this._fireEvents(i, o, !0);
        let {
          panDelta: s,
          zoomDelta: l,
          bearingDelta: c,
          pitchDelta: h,
          around: _,
          aroundCoord: u,
          pinchAround: d
        } = t;
        void 0 !== d && (_ = d), (e => i.drag && !this._eventsInProgress.drag)() && _ && (this._dragOrigin = a(n.pointCoordinate3D(_)), this._trackingEllipsoid.setup(n._camera.position, this._dragOrigin)), n.cameraElevationReference = "sea", r._stop(!0), _ = _ || r.transform.centerPoint, c && (n.bearing += c), h && (n.pitch += h), n._updateCameraState();
        const p = [0, 0, 0];

        if (s) {
          const t = n.pointCoordinate(_);

          if ("globe" === n.projection.name) {
            const i = e.latFromMercatorY(t.y),
                  o = n.center.lat,
                  r = Math.min(e.mercatorZfromAltitude(1, i) / e.mercatorZfromAltitude(1, o), 2);
            s = s.rotate(-n.angle), p[0] = -s.x / n.worldSize * r, p[1] = -s.y / n.worldSize * r;
          } else {
            const e = n.pointCoordinate(_.sub(s));
            t && e && (p[0] = e.x - t.x, p[1] = e.y - t.y);
          }
        }

        const m = n.zoom,
              f = [0, 0, 0];

        if (l) {
          const t = a(u || n.pointCoordinate3D(_)),
                i = {
            dir: e.normalize([], e.sub([], t, n._camera.position))
          };

          if (i.dir[2] < 0) {
            const o = n.zoomDeltaToMovement(t, l);
            e.scale$2(f, i.dir, o);
          }
        }

        const g = e.add(p, p, f);
        n._translateCameraConstrained(g), l && Math.abs(n.zoom - m) > 1e-4 && n.recenterOnTerrain(), n.cameraElevationReference = "ground", this._map._update(), t.noInertia || this._inertia.record(t), this._fireEvents(i, o, !0);
      }

      _fireEvents(t, i, o) {
        const r = Ar(this._eventsInProgress),
              n = Ar(t),
              a = {};

        for (const e in t) {
          const {
            originalEvent: i
          } = t[e];
          this._eventsInProgress[e] || (a[`${e}start`] = i), this._eventsInProgress[e] = t[e];
        }

        !r && n && this._fireEvent("movestart", n.originalEvent);

        for (const e in a) this._fireEvent(e, a[e]);

        n && this._fireEvent("move", n.originalEvent);

        for (const e in t) {
          const {
            originalEvent: i
          } = t[e];

          this._fireEvent(e, i);
        }

        const s = {};
        let l;

        for (const e in this._eventsInProgress) {
          const {
            handlerName: t,
            originalEvent: o
          } = this._eventsInProgress[e];
          this._handlersById[t].isActive() || (delete this._eventsInProgress[e], l = i[t] || o, s[`${e}end`] = l);
        }

        for (const e in s) this._fireEvent(e, s[e]);

        const c = Ar(this._eventsInProgress);

        if (o && (r || n) && !c) {
          this._updatingCamera = !0;

          const t = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions),
                i = e => 0 !== e && -this._bearingSnap < e && e < this._bearingSnap;

          t ? (i(t.bearing || this._map.getBearing()) && (t.bearing = 0), this._map.easeTo(t, {
            originalEvent: l
          })) : (this._map.fire(new e.Event("moveend", {
            originalEvent: l
          })), i(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = !1;
        }
      }

      _fireEvent(t, i) {
        this._map.fire(new e.Event(t, i ? {
          originalEvent: i
        } : {}));
      }

      _requestFrame() {
        return this._map.triggerRepaint(), this._map._renderTaskQueue.add(e => {
          this._frameId = void 0, this.handleEvent(new Lr("renderFrame", {
            timeStamp: e
          })), this._applyChanges();
        });
      }

      _triggerRenderFrame() {
        void 0 === this._frameId && (this._frameId = this._requestFrame());
      }

    }

    const Br = "map.setFreeCameraOptions(...) and map.getFreeCameraOptions() are not yet supported for non-mercator projections.";

    class Fr extends e.Evented {
      constructor(t, i) {
        super(), this._moving = !1, this._zooming = !1, this.transform = t, this._bearingSnap = i.bearingSnap, e.bindAll(["_renderFrameCallback"], this);
      }

      getCenter() {
        return new e.LngLat(this.transform.center.lng, this.transform.center.lat);
      }

      setCenter(e, t) {
        return this.jumpTo({
          center: e
        }, t);
      }

      panBy(t, i, o) {
        return t = e.pointGeometry.convert(t).mult(-1), this.panTo(this.transform.center, e.extend({
          offset: t
        }, i), o);
      }

      panTo(t, i, o) {
        return this.easeTo(e.extend({
          center: t
        }, i), o);
      }

      getZoom() {
        return this.transform.zoom;
      }

      setZoom(e, t) {
        return this.jumpTo({
          zoom: e
        }, t), this;
      }

      zoomTo(t, i, o) {
        return this.easeTo(e.extend({
          zoom: t
        }, i), o);
      }

      zoomIn(e, t) {
        return this.zoomTo(this.getZoom() + 1, e, t), this;
      }

      zoomOut(e, t) {
        return this.zoomTo(this.getZoom() - 1, e, t), this;
      }

      getBearing() {
        return this.transform.bearing;
      }

      setBearing(e, t) {
        return this.jumpTo({
          bearing: e
        }, t), this;
      }

      getPadding() {
        return this.transform.padding;
      }

      setPadding(e, t) {
        return this.jumpTo({
          padding: e
        }, t), this;
      }

      rotateTo(t, i, o) {
        return this.easeTo(e.extend({
          bearing: t
        }, i), o);
      }

      resetNorth(t, i) {
        return this.rotateTo(0, e.extend({
          duration: 1e3
        }, t), i), this;
      }

      resetNorthPitch(t, i) {
        return this.easeTo(e.extend({
          bearing: 0,
          pitch: 0,
          duration: 1e3
        }, t), i), this;
      }

      snapToNorth(e, t) {
        return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e, t) : this;
      }

      getPitch() {
        return this.transform.pitch;
      }

      setPitch(e, t) {
        return this.jumpTo({
          pitch: e
        }, t), this;
      }

      cameraForBounds(t, i) {
        t = e.LngLatBounds.convert(t);
        const o = i && i.bearing || 0;
        return this._cameraForBoxAndBearing(t.getNorthWest(), t.getSouthEast(), o, i);
      }

      _extendCameraOptions(t) {
        const i = {
          top: 0,
          bottom: 0,
          right: 0,
          left: 0
        };

        if ("number" == typeof (t = e.extend({
          padding: i,
          offset: [0, 0],
          maxZoom: this.transform.maxZoom
        }, t)).padding) {
          const e = t.padding;
          t.padding = {
            top: e,
            bottom: e,
            right: e,
            left: e
          };
        }

        return t.padding = e.extend(i, t.padding), t;
      }

      _cameraForBoxAndBearing(t, i, o, r) {
        const n = this._extendCameraOptions(r),
              a = this.transform,
              s = a.padding,
              l = a.project(e.LngLat.convert(t)),
              c = a.project(e.LngLat.convert(i)),
              h = new e.pointGeometry(l.x, c.y),
              _ = new e.pointGeometry(c.x, l.y),
              u = -e.degToRad(o),
              d = l.rotate(u),
              p = c.rotate(u),
              m = h.rotate(u),
              f = _.rotate(u),
              g = new e.pointGeometry(Math.max(d.x, p.x, m.x, f.x), Math.max(d.y, p.y, m.y, f.y)),
              v = new e.pointGeometry(Math.min(d.x, p.x, m.x, f.x), Math.min(d.y, p.y, m.y, f.y)),
              x = g.sub(v),
              y = (a.width - ((s.left || 0) + (s.right || 0) + n.padding.left + n.padding.right)) / x.x,
              b = (a.height - ((s.top || 0) + (s.bottom || 0) + n.padding.top + n.padding.bottom)) / x.y;

        if (b < 0 || y < 0) return void e.warnOnce("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
        const w = Math.min(a.scaleZoom(a.scale * Math.min(y, b)), n.maxZoom),
              T = "number" == typeof n.offset.x && "number" == typeof n.offset.y ? new e.pointGeometry(n.offset.x, n.offset.y) : e.pointGeometry.convert(n.offset),
              E = new e.pointGeometry((n.padding.left - n.padding.right) / 2, (n.padding.top - n.padding.bottom) / 2).rotate(o * Math.PI / 180),
              C = T.add(E).mult(a.scale / a.zoomScale(w));
        return {
          center: a.unproject(l.add(c).div(2).sub(C)),
          zoom: w,
          bearing: o
        };
      }

      _cameraForBox(t, i, o, r, n) {
        const a = this._extendCameraOptions(n);

        o = o || 0, r = r || 0, t = e.LngLat.convert(t), i = e.LngLat.convert(i);
        const s = this.transform.clone();
        s.padding = a.padding;
        const l = this.getFreeCameraOptions(),
              c = new e.LngLat(.5 * (t.lng + i.lng), .5 * (t.lat + i.lat)),
              h = .5 * (o + r);
        if (s._camera.position[2] < e.mercatorZfromAltitude(h, c.lat)) return void e.warnOnce("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
        l.lookAtPoint(c), s.setFreeCameraOptions(l);

        const _ = e.MercatorCoordinate.fromLngLat(t),
              u = e.MercatorCoordinate.fromLngLat(i),
              d = s.pointRayIntersection(s.centerPoint, h),
              p = [(m = s.rayIntersectionCoordinate(d)).x, m.y, m.z];

        var m;
        const f = s.screenPointToMercatorRay(s.centerPoint),
              g = "globe" !== s.projection.name;
        let v,
            x = 0;

        do {
          const t = Math.floor(s.zoom),
                i = 1 << t,
                n = Math.min(i * _.x, i * u.x),
                a = Math.min(i * _.y, i * u.y),
                l = Math.max(i * _.x, i * u.x),
                c = Math.max(i * _.y, i * u.y),
                h = new e.Aabb([n, a, o], [l, c, r]),
                d = e.Frustum.fromInvProjectionMatrix(s.invProjMatrix, s.worldSize, t, g);

          if (2 !== h.intersects(d)) {
            v && (s._camera.position = e.scaleAndAdd([], s._camera.position, f.dir, -v), s._updateStateFromCamera());
            break;
          }

          const m = e.sub([], s._camera.position, p);
          v = .5 * e.length(m), s._camera.position = e.scaleAndAdd([], s._camera.position, f.dir, v);

          try {
            s._updateStateFromCamera();
          } catch (t) {
            return void e.warnOnce("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
          }
        } while (++x < 10);

        return {
          center: s.center,
          zoom: s.zoom,
          bearing: s.bearing,
          pitch: s.pitch
        };
      }

      fitBounds(e, t, i) {
        return this._fitInternal(this.cameraForBounds(e, t), t, i);
      }

      _raycastElevationBox(t, i) {
        const o = this.transform.elevation;
        if (!o) return;
        const r = new e.pointGeometry(t.x, i.y),
              n = new e.pointGeometry(i.x, t.y),
              a = o.pointCoordinate(t);
        if (!a) return;
        const s = o.pointCoordinate(i);
        if (!s) return;
        const l = o.pointCoordinate(r);
        if (!l) return;
        const c = o.pointCoordinate(n);
        if (!c) return;

        const h = new e.MercatorCoordinate(a[0], a[1]).toLngLat(),
              _ = new e.MercatorCoordinate(s[0], s[1]).toLngLat(),
              u = new e.MercatorCoordinate(l[0], l[1]).toLngLat(),
              d = new e.MercatorCoordinate(c[0], c[1]).toLngLat(),
              p = Math.min(h.lng, Math.min(_.lng, Math.min(u.lng, d.lng))),
              m = Math.min(h.lat, Math.min(_.lat, Math.min(u.lat, d.lat))),
              f = Math.max(h.lng, Math.max(_.lng, Math.max(u.lng, d.lng))),
              g = Math.max(h.lat, Math.max(_.lat, Math.max(u.lat, d.lat))),
              v = Math.min(a[3], Math.min(s[3], Math.min(l[3], c[3]))),
              x = Math.max(a[3], Math.max(s[3], Math.max(l[3], c[3])));

        return {
          minLngLat: new e.LngLat(p, m),
          maxLngLat: new e.LngLat(f, g),
          minAltitude: v,
          maxAltitude: x
        };
      }

      fitScreenCoordinates(t, i, o, r, n) {
        let a, s, l, c;

        const h = e.pointGeometry.convert(t),
              _ = e.pointGeometry.convert(i),
              u = this._raycastElevationBox(h, _);

        if (u) a = u.minLngLat, s = u.maxLngLat, l = u.minAltitude, c = u.maxAltitude;else {
          if (this.transform.anyCornerOffEdge(h, _)) return this;
          a = this.transform.pointLocation(h), s = this.transform.pointLocation(_);
        }
        return this._fitInternal(0 === this.transform.pitch ? this._cameraForBoxAndBearing(this.transform.pointLocation(e.pointGeometry.convert(t)), this.transform.pointLocation(e.pointGeometry.convert(i)), o, r) : this._cameraForBox(a, s, l, c, r), r, n);
      }

      _fitInternal(t, i, o) {
        return t ? (delete (i = e.extend(t, i)).padding, i.linear ? this.easeTo(i, o) : this.flyTo(i, o)) : this;
      }

      jumpTo(t, i) {
        this.stop();
        const o = t.preloadOnly ? this.transform.clone() : this.transform;
        let r = !1,
            n = !1,
            a = !1;
        return "zoom" in t && o.zoom !== +t.zoom && (r = !0, o.zoom = +t.zoom), void 0 !== t.center && (o.center = e.LngLat.convert(t.center)), "bearing" in t && o.bearing !== +t.bearing && (n = !0, o.bearing = +t.bearing), "pitch" in t && o.pitch !== +t.pitch && (a = !0, o.pitch = +t.pitch), null == t.padding || o.isPaddingEqual(t.padding) || (o.padding = t.padding), t.preloadOnly ? (this._preloadTiles(o), this) : (this.fire(new e.Event("movestart", i)).fire(new e.Event("move", i)), r && this.fire(new e.Event("zoomstart", i)).fire(new e.Event("zoom", i)).fire(new e.Event("zoomend", i)), n && this.fire(new e.Event("rotatestart", i)).fire(new e.Event("rotate", i)).fire(new e.Event("rotateend", i)), a && this.fire(new e.Event("pitchstart", i)).fire(new e.Event("pitch", i)).fire(new e.Event("pitchend", i)), this.fire(new e.Event("moveend", i)));
      }

      getFreeCameraOptions() {
        return this.transform.projection.supportsFreeCamera || e.warnOnce(Br), this.transform.getFreeCameraOptions();
      }

      setFreeCameraOptions(t, i) {
        const o = this.transform;
        if (!o.projection.supportsFreeCamera) return e.warnOnce(Br), this;
        this.stop();
        const r = o.zoom,
              n = o.pitch,
              a = o.bearing;
        o.setFreeCameraOptions(t);
        const s = r !== o.zoom,
              l = n !== o.pitch,
              c = a !== o.bearing;
        return this.fire(new e.Event("movestart", i)).fire(new e.Event("move", i)), s && this.fire(new e.Event("zoomstart", i)).fire(new e.Event("zoom", i)).fire(new e.Event("zoomend", i)), c && this.fire(new e.Event("rotatestart", i)).fire(new e.Event("rotate", i)).fire(new e.Event("rotateend", i)), l && this.fire(new e.Event("pitchstart", i)).fire(new e.Event("pitch", i)).fire(new e.Event("pitchend", i)), this.fire(new e.Event("moveend", i)), this;
      }

      easeTo(t, i) {
        this._stop(!1, t.easeId), (!1 === (t = e.extend({
          offset: [0, 0],
          duration: 500,
          easing: e.ease
        }, t)).animate || !t.essential && e.exported.prefersReducedMotion) && (t.duration = 0);

        const o = this.transform,
              r = this.getZoom(),
              n = this.getBearing(),
              a = this.getPitch(),
              s = this.getPadding(),
              l = "zoom" in t ? +t.zoom : r,
              c = "bearing" in t ? this._normalizeBearing(t.bearing, n) : n,
              h = "pitch" in t ? +t.pitch : a,
              _ = "padding" in t ? t.padding : o.padding,
              u = e.pointGeometry.convert(t.offset);

        let d, p, m;

        if ("globe" === o.projection.name) {
          const i = e.MercatorCoordinate.fromLngLat(o.center),
                r = u.rotate(-o.angle);
          i.x += r.x / o.worldSize, i.y += r.y / o.worldSize;
          const n = i.toLngLat(),
                a = e.LngLat.convert(t.center || n);
          this._normalizeCenter(a), d = o.centerPoint.add(r), p = new e.pointGeometry(i.x, i.y).mult(o.worldSize), m = new e.pointGeometry(e.mercatorXfromLng(a.lng), e.mercatorYfromLat(a.lat)).mult(o.worldSize).sub(p);
        } else {
          d = o.centerPoint.add(u);
          const i = o.pointLocation(d),
                r = e.LngLat.convert(t.center || i);
          this._normalizeCenter(r), p = o.project(i), m = o.project(r).sub(p);
        }

        const f = o.zoomScale(l - r);
        let g, v;
        t.around && (g = e.LngLat.convert(t.around), v = o.locationPoint(g));

        const x = this._zooming || l !== r,
              y = this._rotating || n !== c,
              b = this._pitching || h !== a,
              w = !o.isPaddingEqual(_),
              T = o => T => {
          if (x && (o.zoom = e.number(r, l, T)), y && (o.bearing = e.number(n, c, T)), b && (o.pitch = e.number(a, h, T)), w && (o.interpolatePadding(s, _, T), d = o.centerPoint.add(u)), g) o.setLocationAtPoint(g, v);else {
            const e = o.zoomScale(o.zoom - r),
                  t = l > r ? Math.min(2, f) : Math.max(.5, f),
                  i = Math.pow(t, 1 - T),
                  n = o.unproject(p.add(m.mult(T * i)).mult(e));
            o.setLocationAtPoint(o.renderWorldCopies ? n.wrap() : n, d);
          }
          return t.preloadOnly || this._fireMoveEvents(i), o;
        };

        if (t.preloadOnly) {
          const e = this._emulate(T, t.duration, o);

          return this._preloadTiles(e), this;
        }

        const E = {
          moving: this._moving,
          zooming: this._zooming,
          rotating: this._rotating,
          pitching: this._pitching
        };
        return this._zooming = x, this._rotating = y, this._pitching = b, this._padding = w, this._easeId = t.easeId, this._prepareEase(i, t.noMoveStart, E), this._ease(T(o), e => {
          o.recenterOnTerrain(), this._afterEase(i, e);
        }, t), this;
      }

      _prepareEase(t, i, o = {}) {
        this._moving = !0, this.transform.cameraElevationReference = "sea", i || o.moving || this.fire(new e.Event("movestart", t)), this._zooming && !o.zooming && this.fire(new e.Event("zoomstart", t)), this._rotating && !o.rotating && this.fire(new e.Event("rotatestart", t)), this._pitching && !o.pitching && this.fire(new e.Event("pitchstart", t));
      }

      _fireMoveEvents(t) {
        this.fire(new e.Event("move", t)), this._zooming && this.fire(new e.Event("zoom", t)), this._rotating && this.fire(new e.Event("rotate", t)), this._pitching && this.fire(new e.Event("pitch", t));
      }

      _afterEase(t, i) {
        if (this._easeId && i && this._easeId === i) return;
        this._easeId = void 0, this.transform.cameraElevationReference = "ground";
        const o = this._zooming,
              r = this._rotating,
              n = this._pitching;
        this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._padding = !1, o && this.fire(new e.Event("zoomend", t)), r && this.fire(new e.Event("rotateend", t)), n && this.fire(new e.Event("pitchend", t)), this.fire(new e.Event("moveend", t));
      }

      flyTo(t, i) {
        if (!t.essential && e.exported.prefersReducedMotion) {
          const o = e.pick(t, ["center", "zoom", "bearing", "pitch", "around"]);
          return this.jumpTo(o, i);
        }

        this.stop(), t = e.extend({
          offset: [0, 0],
          speed: 1.2,
          curve: 1.42,
          easing: e.ease
        }, t);

        const o = this.transform,
              r = this.getZoom(),
              n = this.getBearing(),
              a = this.getPitch(),
              s = this.getPadding(),
              l = "zoom" in t ? e.clamp(+t.zoom, o.minZoom, o.maxZoom) : r,
              c = "bearing" in t ? this._normalizeBearing(t.bearing, n) : n,
              h = "pitch" in t ? +t.pitch : a,
              _ = "padding" in t ? t.padding : o.padding,
              u = o.zoomScale(l - r),
              d = e.pointGeometry.convert(t.offset);

        let p = o.centerPoint.add(d);
        const m = o.pointLocation(p),
              f = e.LngLat.convert(t.center || m);

        this._normalizeCenter(f);

        const g = o.project(m),
              v = o.project(f).sub(g);
        let x = t.curve;
        const y = Math.max(o.width, o.height),
              b = y / u,
              w = v.mag();

        if ("minZoom" in t) {
          const i = e.clamp(Math.min(t.minZoom, r, l), o.minZoom, o.maxZoom),
                n = y / o.zoomScale(i - r);
          x = Math.sqrt(n / w * 2);
        }

        const T = x * x;

        function E(e) {
          const t = (b * b - y * y + (e ? -1 : 1) * T * T * w * w) / (2 * (e ? b : y) * T * w);
          return Math.log(Math.sqrt(t * t + 1) - t);
        }

        function C(e) {
          return (Math.exp(e) - Math.exp(-e)) / 2;
        }

        function I(e) {
          return (Math.exp(e) + Math.exp(-e)) / 2;
        }

        const M = E(0);

        let S = function (e) {
          return I(M) / I(M + x * e);
        },
            z = function (e) {
          return y * ((I(M) * (C(t = M + x * e) / I(t)) - C(M)) / T) / w;
          var t;
        },
            D = (E(1) - M) / x;

        if (Math.abs(w) < 1e-6 || !isFinite(D)) {
          if (Math.abs(y - b) < 1e-6) return this.easeTo(t, i);
          const e = b < y ? -1 : 1;
          D = Math.abs(Math.log(b / y)) / x, z = function () {
            return 0;
          }, S = function (t) {
            return Math.exp(e * x * t);
          };
        }

        t.duration = "duration" in t ? +t.duration : 1e3 * D / ("screenSpeed" in t ? +t.screenSpeed / x : +t.speed), t.maxDuration && t.duration > t.maxDuration && (t.duration = 0);

        const P = n !== c,
              A = h !== a,
              L = !o.isPaddingEqual(_),
              R = o => u => {
          const m = u * D,
                x = 1 / S(m);
          o.zoom = 1 === u ? l : r + o.scaleZoom(x), P && (o.bearing = e.number(n, c, u)), A && (o.pitch = e.number(a, h, u)), L && (o.interpolatePadding(s, _, u), p = o.centerPoint.add(d));
          const y = 1 === u ? f : o.unproject(g.add(v.mult(z(m))).mult(x));
          return o.setLocationAtPoint(o.renderWorldCopies ? y.wrap() : y, p), o._updateCameraOnTerrain(), t.preloadOnly || this._fireMoveEvents(i), o;
        };

        if (t.preloadOnly) {
          const e = this._emulate(R, t.duration, o);

          return this._preloadTiles(e), this;
        }

        return this._zooming = !0, this._rotating = P, this._pitching = A, this._padding = L, this._prepareEase(i, !1), this._ease(R(o), () => this._afterEase(i), t), this;
      }

      isEasing() {
        return !!this._easeFrameId;
      }

      stop() {
        return this._stop();
      }

      _stop(e, t) {
        if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), this._easeFrameId = void 0, this._onEaseFrame = void 0), this._onEaseEnd) {
          const e = this._onEaseEnd;
          this._onEaseEnd = void 0, e.call(this, t);
        }

        if (!e) {
          const e = this.handlers;
          e && e.stop(!1);
        }

        return this;
      }

      _ease(t, i, o) {
        !1 === o.animate || 0 === o.duration ? (t(1), i()) : (this._easeStart = e.exported.now(), this._easeOptions = o, this._onEaseFrame = t, this._onEaseEnd = i, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
      }

      _renderFrameCallback() {
        const t = Math.min((e.exported.now() - this._easeStart) / this._easeOptions.duration, 1),
              i = this._onEaseFrame;
        i && i(this._easeOptions.easing(t)), t < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
      }

      _normalizeBearing(t, i) {
        t = e.wrap(t, -180, 180);
        const o = Math.abs(t - i);
        return Math.abs(t - 360 - i) < o && (t -= 360), Math.abs(t + 360 - i) < o && (t += 360), t;
      }

      _normalizeCenter(e) {
        const t = this.transform;
        if (!t.renderWorldCopies || t.maxBounds) return;
        const i = e.lng - t.center.lng;
        e.lng += i > 180 ? -360 : i < -180 ? 360 : 0;
      }

      _emulate(e, t, i) {
        const o = Math.ceil(15 * t / 1e3),
              r = [],
              n = e(i.clone());

        for (let e = 0; e <= o; e++) {
          const t = n(e / o);
          r.push(t.clone());
        }

        return r;
      }

    }

    class Ur {
      constructor(t = {}) {
        this.options = t, e.bindAll(["_toggleAttribution", "_updateEditLink", "_updateData", "_updateCompact"], this);
      }

      getDefaultPosition() {
        return "bottom-right";
      }

      onAdd(e) {
        const t = this.options && this.options.compact;
        return this._map = e, this._container = n("div", "mapboxgl-ctrl mapboxgl-ctrl-attrib"), this._compactButton = n("button", "mapboxgl-ctrl-attrib-button", this._container), n("span", "mapboxgl-ctrl-icon", this._compactButton).setAttribute("aria-hidden", "true"), this._compactButton.type = "button", this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = n("div", "mapboxgl-ctrl-attrib-inner", this._container), this._innerContainer.setAttribute("role", "list"), t && this._container.classList.add("mapboxgl-compact"), this._updateAttributions(), this._updateEditLink(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("moveend", this._updateEditLink), void 0 === t && (this._map.on("resize", this._updateCompact), this._updateCompact()), this._container;
      }

      onRemove() {
        this._container.remove(), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("moveend", this._updateEditLink), this._map.off("resize", this._updateCompact), this._map = void 0, this._attribHTML = void 0;
      }

      _setElementTitle(e, t) {
        const i = this._map._getUIString(`AttributionControl.${t}`);

        e.setAttribute("aria-label", i), e.removeAttribute("title"), e.firstElementChild && e.firstElementChild.setAttribute("title", i);
      }

      _toggleAttribution() {
        this._container.classList.contains("mapboxgl-compact-show") ? (this._container.classList.remove("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "false")) : (this._container.classList.add("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "true"));
      }

      _updateEditLink() {
        let t = this._editLink;
        t || (t = this._editLink = this._container.querySelector(".mapbox-improve-map"));
        const i = [{
          key: "owner",
          value: this.styleOwner
        }, {
          key: "id",
          value: this.styleId
        }, {
          key: "access_token",
          value: this._map._requestManager._customAccessToken || e.config.ACCESS_TOKEN
        }];

        if (t) {
          const o = i.reduce((e, t, o) => (t.value && (e += `${t.key}=${t.value}${o < i.length - 1 ? "&" : ""}`), e), "?");
          t.href = `${e.config.FEEDBACK_URL}/${o}${this._map._hash ? this._map._hash.getHashString(!0) : ""}`, t.rel = "noopener nofollow", this._setElementTitle(t, "MapFeedback");
        }
      }

      _updateData(e) {
        !e || "metadata" !== e.sourceDataType && "visibility" !== e.sourceDataType && "style" !== e.dataType || (this._updateAttributions(), this._updateEditLink());
      }

      _updateAttributions() {
        if (!this._map.style) return;
        let e = [];

        if (this._map.style.stylesheet) {
          const e = this._map.style.stylesheet;
          this.styleOwner = e.owner, this.styleId = e.id;
        }

        const t = this._map.style._sourceCaches;

        for (const i in t) {
          const o = t[i];

          if (o.used) {
            const t = o.getSource();
            t.attribution && e.indexOf(t.attribution) < 0 && e.push(t.attribution);
          }
        }

        e.sort((e, t) => e.length - t.length), e = e.filter((t, i) => {
          for (let o = i + 1; o < e.length; o++) if (e[o].indexOf(t) >= 0) return !1;

          return !0;
        }), this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e = [...this.options.customAttribution, ...e] : e.unshift(this.options.customAttribution));
        const i = e.join(" | ");
        i !== this._attribHTML && (this._attribHTML = i, e.length ? (this._innerContainer.innerHTML = i, this._container.classList.remove("mapboxgl-attrib-empty")) : this._container.classList.add("mapboxgl-attrib-empty"), this._editLink = null);
      }

      _updateCompact() {
        this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add("mapboxgl-compact") : this._container.classList.remove("mapboxgl-compact", "mapboxgl-compact-show");
      }

    }

    class Nr {
      constructor() {
        e.bindAll(["_updateLogo", "_updateCompact"], this);
      }

      onAdd(e) {
        this._map = e, this._container = n("div", "mapboxgl-ctrl");
        const t = n("a", "mapboxgl-ctrl-logo");
        return t.target = "_blank", t.rel = "noopener nofollow", t.href = "https://www.mapbox.com/", t.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), t.setAttribute("rel", "noopener nofollow"), this._container.appendChild(t), this._container.style.display = "none", this._map.on("sourcedata", this._updateLogo), this._updateLogo(), this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
      }

      onRemove() {
        this._container.remove(), this._map.off("sourcedata", this._updateLogo), this._map.off("resize", this._updateCompact);
      }

      getDefaultPosition() {
        return "bottom-left";
      }

      _updateLogo(e) {
        e && "metadata" !== e.sourceDataType || (this._container.style.display = this._logoRequired() ? "block" : "none");
      }

      _logoRequired() {
        if (!this._map.style) return !0;
        const e = this._map.style._sourceCaches;
        if (0 === Object.entries(e).length) return !0;

        for (const t in e) {
          const i = e[t].getSource();
          if (i.hasOwnProperty("mapbox_logo") && !i.mapbox_logo) return !1;
        }

        return !0;
      }

      _updateCompact() {
        const e = this._container.children;

        if (e.length) {
          const t = e[0];
          this._map.getCanvasContainer().offsetWidth < 250 ? t.classList.add("mapboxgl-compact") : t.classList.remove("mapboxgl-compact");
        }
      }

    }

    class Gr {
      constructor() {
        this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;
      }

      add(e) {
        const t = ++this._id;
        return this._queue.push({
          callback: e,
          id: t,
          cancelled: !1
        }), t;
      }

      remove(e) {
        const t = this._currentlyRunning,
              i = t ? this._queue.concat(t) : this._queue;

        for (const t of i) if (t.id === e) return void (t.cancelled = !0);
      }

      run(e = 0) {
        const t = this._currentlyRunning = this._queue;
        this._queue = [];

        for (const i of t) if (!i.cancelled && (i.callback(e), this._cleared)) break;

        this._cleared = !1, this._currentlyRunning = !1;
      }

      clear() {
        this._currentlyRunning && (this._cleared = !0), this._queue = [];
      }

    }

    function jr(t, i, o) {
      if (t = new e.LngLat(t.lng, t.lat), i) {
        const r = new e.LngLat(t.lng - 360, t.lat),
              n = new e.LngLat(t.lng + 360, t.lat),
              a = 360 * Math.ceil(Math.abs(t.lng - o.center.lng) / 360),
              s = o.locationPoint(t).distSqr(i),
              l = i.x < 0 || i.y < 0 || i.x > o.width || i.y > o.height;
        o.locationPoint(r).distSqr(i) < s && (l || Math.abs(r.lng - o.center.lng) < a) ? t = r : o.locationPoint(n).distSqr(i) < s && (l || Math.abs(n.lng - o.center.lng) < a) && (t = n);
      }

      for (; Math.abs(t.lng - o.center.lng) > 180;) {
        const e = o.locationPoint(t);
        if (e.x >= 0 && e.y >= 0 && e.x <= o.width && e.y <= o.height) break;
        t.lng > o.center.lng ? t.lng -= 360 : t.lng += 360;
      }

      return t;
    }

    const Zr = {
      center: "translate(-50%,-50%)",
      top: "translate(-50%,0)",
      "top-left": "translate(0,0)",
      "top-right": "translate(-100%,0)",
      bottom: "translate(-50%,-100%)",
      "bottom-left": "translate(0,-100%)",
      "bottom-right": "translate(-100%,-100%)",
      left: "translate(0,-50%)",
      right: "translate(-100%,-50%)"
    };

    class Vr extends e.Evented {
      constructor(t, i) {
        if (super(), (t instanceof e.window.HTMLElement || i) && (t = e.extend({
          element: t
        }, i)), e.bindAll(["_update", "_onMove", "_onUp", "_addDragHandler", "_onMapClick", "_onKeyPress", "_clearFadeTimer"], this), this._anchor = t && t.anchor || "center", this._color = t && t.color || "#3FB1CE", this._scale = t && t.scale || 1, this._draggable = t && t.draggable || !1, this._clickTolerance = t && t.clickTolerance || 0, this._isDragging = !1, this._state = "inactive", this._rotation = t && t.rotation || 0, this._rotationAlignment = t && t.rotationAlignment || "auto", this._pitchAlignment = t && t.pitchAlignment && "auto" !== t.pitchAlignment ? t.pitchAlignment : this._rotationAlignment, this._updateMoving = () => this._update(!0), t && t.element) this._element = t.element, this._offset = e.pointGeometry.convert(t && t.offset || [0, 0]);else {
          this._defaultMarker = !0, this._element = n("div");
          const i = 41,
                o = 27,
                r = a("svg", {
            display: "block",
            height: i * this._scale + "px",
            width: o * this._scale + "px",
            viewBox: `0 0 ${o} ${i}`
          }, this._element),
                s = a("radialGradient", {
            id: "shadowGradient"
          }, a("defs", {}, r));
          a("stop", {
            offset: "10%",
            "stop-opacity": .4
          }, s), a("stop", {
            offset: "100%",
            "stop-opacity": .05
          }, s), a("ellipse", {
            cx: 13.5,
            cy: 34.8,
            rx: 10.5,
            ry: 5.25,
            fill: "url(#shadowGradient)"
          }, r), a("path", {
            fill: this._color,
            d: "M27,13.5C27,19.07 20.25,27 14.75,34.5C14.02,35.5 12.98,35.5 12.25,34.5C6.75,27 0,19.22 0,13.5C0,6.04 6.04,0 13.5,0C20.96,0 27,6.04 27,13.5Z"
          }, r), a("path", {
            opacity: .25,
            d: "M13.5,0C6.04,0 0,6.04 0,13.5C0,19.22 6.75,27 12.25,34.5C13,35.52 14.02,35.5 14.75,34.5C20.25,27 27,19.07 27,13.5C27,6.04 20.96,0 13.5,0ZM13.5,1C20.42,1 26,6.58 26,13.5C26,15.9 24.5,19.18 22.22,22.74C19.95,26.3 16.71,30.14 13.94,33.91C13.74,34.18 13.61,34.32 13.5,34.44C13.39,34.32 13.26,34.18 13.06,33.91C10.28,30.13 7.41,26.31 5.02,22.77C2.62,19.23 1,15.95 1,13.5C1,6.58 6.58,1 13.5,1Z"
          }, r), a("circle", {
            fill: "white",
            cx: 13.5,
            cy: 13.5,
            r: 5.5
          }, r), this._offset = e.pointGeometry.convert(t && t.offset || [0, -14]);
        }
        this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", "Map marker"), this._element.classList.add("mapboxgl-marker"), this._element.addEventListener("dragstart", e => {
          e.preventDefault();
        }), this._element.addEventListener("mousedown", e => {
          e.preventDefault();
        });
        const o = this._element.classList;

        for (const e in Zr) o.remove(`mapboxgl-marker-anchor-${e}`);

        o.add(`mapboxgl-marker-anchor-${this._anchor}`), this._popup = null;
      }

      addTo(e) {
        return e === this._map || (this.remove(), this._map = e, e.getCanvasContainer().appendChild(this._element), e.on("move", this._updateMoving), e.on("moveend", this._update), e.on("remove", this._clearFadeTimer), e._addMarker(this), this.setDraggable(this._draggable), this._update(), e.on("click", this._onMapClick)), this;
      }

      remove() {
        const e = this._map;
        return e && (e.off("click", this._onMapClick), e.off("move", this._updateMoving), e.off("moveend", this._update), e.off("mousedown", this._addDragHandler), e.off("touchstart", this._addDragHandler), e.off("mouseup", this._onUp), e.off("touchend", this._onUp), e.off("mousemove", this._onMove), e.off("touchmove", this._onMove), e.off("remove", this._clearFadeTimer), e._removeMarker(this), this._map = void 0), this._clearFadeTimer(), this._element.remove(), this._popup && this._popup.remove(), this;
      }

      getLngLat() {
        return this._lngLat;
      }

      setLngLat(t) {
        return this._lngLat = e.LngLat.convert(t), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(!0), this;
      }

      getElement() {
        return this._element;
      }

      setPopup(e) {
        if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeAttribute("role"), this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e) {
          if (!("offset" in e.options)) {
            const t = 38.1,
                  i = 13.5,
                  o = Math.sqrt(Math.pow(i, 2) / 2);
            e.options.offset = this._defaultMarker ? {
              top: [0, 0],
              "top-left": [0, 0],
              "top-right": [0, 0],
              bottom: [0, -t],
              "bottom-left": [o, -1 * (t - i + o)],
              "bottom-right": [-o, -1 * (t - i + o)],
              left: [i, -1 * (t - i)],
              right: [-i, -1 * (t - i)]
            } : this._offset;
          }

          this._popup = e, this._lngLat && this._popup.setLngLat(this._lngLat), this._element.setAttribute("role", "button"), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress), this._element.setAttribute("aria-expanded", "false");
        }

        return this;
      }

      _onKeyPress(e) {
        const t = e.code,
              i = e.charCode || e.keyCode;
        "Space" !== t && "Enter" !== t && 32 !== i && 13 !== i || this.togglePopup();
      }

      _onMapClick(e) {
        const t = e.originalEvent.target,
              i = this._element;
        this._popup && (t === i || i.contains(t)) && this.togglePopup();
      }

      getPopup() {
        return this._popup;
      }

      togglePopup() {
        const e = this._popup;
        return e ? (e.isOpen() ? (e.remove(), this._element.setAttribute("aria-expanded", "false")) : this._map && (e.addTo(this._map), this._element.setAttribute("aria-expanded", "true")), this) : this;
      }

      _evaluateOpacity() {
        const e = this._map;
        if (!e) return;
        const t = this._pos;
        if (!t || t.x < 0 || t.x > e.transform.width || t.y < 0 || t.y > e.transform.height) return void this._clearFadeTimer();
        const i = e.unproject(t);
        let o = !1;

        if (e.transform._terrainEnabled() && e.getTerrain()) {
          const t = e.getFreeCameraOptions();

          if (t.position) {
            const e = t.position.toLngLat();
            o = e.distanceTo(i) < .9 * e.distanceTo(this._lngLat);
          }
        }

        const r = (1 - e._queryFogOpacity(i)) * (o ? .2 : 1);
        this._element.style.opacity = `${r}`, this._popup && this._popup._setOpacity(`${r}`), this._fadeTimer = null;
      }

      _clearFadeTimer() {
        this._fadeTimer && (clearTimeout(this._fadeTimer), this._fadeTimer = null);
      }

      _updateDOM() {
        const e = this._pos;
        if (!e) return;

        const t = this._offset.mult(this._scale),
              i = this._calculatePitch(),
              o = this._calculateRotation();

        this._element.style.transform = `\n            translate(${e.x}px, ${e.y}px) ${Zr[this._anchor]}\n            rotateX(${i}deg) rotateZ(${o}deg)\n            translate(${t.x}px, ${t.y}px)\n        `;
      }

      _calculatePitch() {
        return "viewport" === this._pitchAlignment || "auto" === this._pitchAlignment ? 0 : this._map && "map" === this._pitchAlignment ? this._map.getPitch() : 0;
      }

      _calculateRotation() {
        return "viewport" === this._rotationAlignment || "auto" === this._rotationAlignment ? this._rotation : this._map && "map" === this._rotationAlignment ? this._rotation - this._map.getBearing() : 0;
      }

      _update(t) {
        e.window.cancelAnimationFrame(this._updateFrameId);
        const i = this._map;
        i && (i.transform.renderWorldCopies && (this._lngLat = jr(this._lngLat, this._pos, i.transform)), this._pos = i.project(this._lngLat), !0 === t ? this._updateFrameId = e.window.requestAnimationFrame(() => {
          this._element && this._pos && this._anchor && (this._pos = this._pos.round(), this._updateDOM());
        }) : this._pos = this._pos.round(), i._requestDomTask(() => {
          this._map && (this._element && this._pos && this._anchor && this._updateDOM(), !i.getTerrain() && !i.getFog() || this._fadeTimer || (this._fadeTimer = setTimeout(this._evaluateOpacity.bind(this), 60)));
        }));
      }

      getOffset() {
        return this._offset;
      }

      setOffset(t) {
        return this._offset = e.pointGeometry.convert(t), this._update(), this;
      }

      _onMove(t) {
        const i = this._map;

        if (i) {
          if (!this._isDragging) {
            const e = this._clickTolerance || i._clickTolerance;
            this._isDragging = t.point.dist(this._pointerdownPos) >= e;
          }

          this._isDragging && (this._pos = t.point.sub(this._positionDelta), this._lngLat = i.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new e.Event("dragstart"))), this.fire(new e.Event("drag")));
        }
      }

      _onUp() {
        this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1;
        const t = this._map;
        t && (t.off("mousemove", this._onMove), t.off("touchmove", this._onMove)), "active" === this._state && this.fire(new e.Event("dragend")), this._state = "inactive";
      }

      _addDragHandler(e) {
        const t = this._map;
        t && this._element.contains(e.originalEvent.target) && (e.preventDefault(), this._positionDelta = e.point.sub(this._pos), this._pointerdownPos = e.point, this._state = "pending", t.on("mousemove", this._onMove), t.on("touchmove", this._onMove), t.once("mouseup", this._onUp), t.once("touchend", this._onUp));
      }

      setDraggable(e) {
        this._draggable = !!e;
        const t = this._map;
        return t && (e ? (t.on("mousedown", this._addDragHandler), t.on("touchstart", this._addDragHandler)) : (t.off("mousedown", this._addDragHandler), t.off("touchstart", this._addDragHandler))), this;
      }

      isDraggable() {
        return this._draggable;
      }

      setRotation(e) {
        return this._rotation = e || 0, this._update(), this;
      }

      getRotation() {
        return this._rotation;
      }

      setRotationAlignment(e) {
        return this._rotationAlignment = e || "auto", this._update(), this;
      }

      getRotationAlignment() {
        return this._rotationAlignment;
      }

      setPitchAlignment(e) {
        return this._pitchAlignment = e && "auto" !== e ? e : this._rotationAlignment, this._update(), this;
      }

      getPitchAlignment() {
        return this._pitchAlignment;
      }

    }

    class Wr {
      constructor(e) {
        this.jumpTo(e);
      }

      getValue(t) {
        if (t <= this._startTime) return this._start;
        if (t >= this._endTime) return this._end;
        const i = e.easeCubicInOut((t - this._startTime) / (this._endTime - this._startTime));
        return this._start * (1 - i) + this._end * i;
      }

      isEasing(e) {
        return e >= this._startTime && e <= this._endTime;
      }

      jumpTo(e) {
        this._startTime = -1 / 0, this._endTime = -1 / 0, this._start = e, this._end = e;
      }

      easeTo(e, t, i) {
        this._start = this.getValue(t), this._end = e, this._startTime = t, this._endTime = t + i;
      }

    }

    const qr = {
      "AttributionControl.ToggleAttribution": "Toggle attribution",
      "AttributionControl.MapFeedback": "Map feedback",
      "FullscreenControl.Enter": "Enter fullscreen",
      "FullscreenControl.Exit": "Exit fullscreen",
      "GeolocateControl.FindMyLocation": "Find my location",
      "GeolocateControl.LocationNotAvailable": "Location not available",
      "LogoControl.Title": "Mapbox logo",
      "NavigationControl.ResetBearing": "Reset bearing to north",
      "NavigationControl.ZoomIn": "Zoom in",
      "NavigationControl.ZoomOut": "Zoom out",
      "ScaleControl.Feet": "ft",
      "ScaleControl.Meters": "m",
      "ScaleControl.Kilometers": "km",
      "ScaleControl.Miles": "mi",
      "ScaleControl.NauticalMiles": "nm",
      "ScrollZoomBlocker.CtrlMessage": "Use ctrl + scroll to zoom the map",
      "ScrollZoomBlocker.CmdMessage": "Use ⌘ + scroll to zoom the map",
      "TouchPanBlocker.Message": "Use two fingers to move the map"
    },
          Xr = {
      center: [0, 0],
      zoom: 0,
      bearing: 0,
      pitch: 0,
      minZoom: -2,
      maxZoom: 22,
      minPitch: 0,
      maxPitch: 85,
      interactive: !0,
      scrollZoom: !0,
      boxZoom: !0,
      dragRotate: !0,
      dragPan: !0,
      keyboard: !0,
      doubleClickZoom: !0,
      touchZoomRotate: !0,
      touchPitch: !0,
      cooperativeGestures: !1,
      bearingSnap: 7,
      clickTolerance: 3,
      pitchWithRotate: !0,
      hash: !1,
      attributionControl: !0,
      failIfMajorPerformanceCaveat: !1,
      preserveDrawingBuffer: !1,
      trackResize: !0,
      optimizeForTerrain: !0,
      renderWorldCopies: !0,
      refreshExpiredTiles: !0,
      minTileCacheSize: null,
      maxTileCacheSize: null,
      localIdeographFontFamily: "sans-serif",
      localFontFamily: null,
      transformRequest: null,
      accessToken: null,
      fadeDuration: 300,
      crossSourceCollisions: !0
    };

    function $r(e) {
      e.parentNode && e.parentNode.removeChild(e);
    }

    const Hr = {
      showCompass: !0,
      showZoom: !0,
      visualizePitch: !1
    };

    class Kr {
      constructor(t, i, o = !1) {
        this._clickTolerance = 10, this.element = i, this.mouseRotate = new hr({
          clickTolerance: t.dragRotate._mouseRotate._clickTolerance
        }), this.map = t, o && (this.mousePitch = new _r({
          clickTolerance: t.dragRotate._mousePitch._clickTolerance
        })), e.bindAll(["mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "reset"], this), i.addEventListener("mousedown", this.mousedown), i.addEventListener("touchstart", this.touchstart, {
          passive: !1
        }), i.addEventListener("touchmove", this.touchmove), i.addEventListener("touchend", this.touchend), i.addEventListener("touchcancel", this.reset);
      }

      down(e, t) {
        this.mouseRotate.mousedown(e, t), this.mousePitch && this.mousePitch.mousedown(e, t), h();
      }

      move(e, t) {
        const i = this.map,
              o = this.mouseRotate.mousemoveWindow(e, t),
              r = o && o.bearingDelta;

        if (r && i.setBearing(i.getBearing() + r), this.mousePitch) {
          const o = this.mousePitch.mousemoveWindow(e, t),
                r = o && o.pitchDelta;
          r && i.setPitch(i.getPitch() + r);
        }
      }

      off() {
        const e = this.element;
        e.removeEventListener("mousedown", this.mousedown), e.removeEventListener("touchstart", this.touchstart, {
          passive: !1
        }), e.removeEventListener("touchmove", this.touchmove), e.removeEventListener("touchend", this.touchend), e.removeEventListener("touchcancel", this.reset), this.offTemp();
      }

      offTemp() {
        _(), e.window.removeEventListener("mousemove", this.mousemove), e.window.removeEventListener("mouseup", this.mouseup);
      }

      mousedown(t) {
        this.down(e.extend({}, t, {
          ctrlKey: !0,
          preventDefault: () => t.preventDefault()
        }), p(this.element, t)), e.window.addEventListener("mousemove", this.mousemove), e.window.addEventListener("mouseup", this.mouseup);
      }

      mousemove(e) {
        this.move(e, p(this.element, e));
      }

      mouseup(e) {
        this.mouseRotate.mouseupWindow(e), this.mousePitch && this.mousePitch.mouseupWindow(e), this.offTemp();
      }

      touchstart(e) {
        1 !== e.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = m(this.element, e.targetTouches)[0], this.down({
          type: "mousedown",
          button: 0,
          ctrlKey: !0,
          preventDefault: () => e.preventDefault()
        }, this._startPos));
      }

      touchmove(e) {
        1 !== e.targetTouches.length ? this.reset() : (this._lastPos = m(this.element, e.targetTouches)[0], this.move({
          preventDefault: () => e.preventDefault()
        }, this._lastPos));
      }

      touchend(e) {
        0 === e.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset();
      }

      reset() {
        this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
      }

    }

    const Yr = {
      positionOptions: {
        enableHighAccuracy: !1,
        maximumAge: 0,
        timeout: 6e3
      },
      fitBoundsOptions: {
        maxZoom: 15
      },
      trackUserLocation: !1,
      showAccuracyCircle: !0,
      showUserLocation: !0,
      showUserHeading: !1
    };
    let Jr,
        Qr = 0,
        en = !1;
    const tn = {
      maxWidth: 100,
      unit: "metric"
    };

    function on(e, t, i) {
      const o = i && i.maxWidth || 100,
            r = e._containerHeight / 2,
            n = e._containerWidth / 2 - o / 2,
            a = e.unproject([n, r]),
            s = e.unproject([n + o, r]),
            l = a.distanceTo(s);

      if (i && "imperial" === i.unit) {
        const i = 3.2808 * l;
        i > 5280 ? rn(t, o, i / 5280, e._getUIString("ScaleControl.Miles"), e) : rn(t, o, i, e._getUIString("ScaleControl.Feet"), e);
      } else i && "nautical" === i.unit ? rn(t, o, l / 1852, e._getUIString("ScaleControl.NauticalMiles"), e) : l >= 1e3 ? rn(t, o, l / 1e3, e._getUIString("ScaleControl.Kilometers"), e) : rn(t, o, l, e._getUIString("ScaleControl.Meters"), e);
    }

    function rn(e, t, i, o, r) {
      const n = function (e) {
        const t = Math.pow(10, `${Math.floor(e)}`.length - 1);
        let i = e / t;
        return i = i >= 10 ? 10 : i >= 5 ? 5 : i >= 3 ? 3 : i >= 2 ? 2 : i >= 1 ? 1 : function (e) {
          const t = Math.pow(10, Math.ceil(-Math.log(e) / Math.LN10));
          return Math.round(e * t) / t;
        }(i), t * i;
      }(i),
            a = n / i;

      r._requestDomTask(() => {
        e.style.width = t * a + "px", e.innerHTML = `${n}&nbsp;${o}`;
      });
    }

    const nn = {
      closeButton: !0,
      closeOnClick: !0,
      focusAfterOpen: !0,
      className: "",
      maxWidth: "240px"
    },
          an = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");

    function sn(t = new e.pointGeometry(0, 0), i = "bottom") {
      if ("number" == typeof t) {
        const o = Math.round(Math.sqrt(.5 * Math.pow(t, 2)));

        switch (i) {
          case "top":
            return new e.pointGeometry(0, t);

          case "top-left":
            return new e.pointGeometry(o, o);

          case "top-right":
            return new e.pointGeometry(-o, o);

          case "bottom":
            return new e.pointGeometry(0, -t);

          case "bottom-left":
            return new e.pointGeometry(o, -o);

          case "bottom-right":
            return new e.pointGeometry(-o, -o);

          case "left":
            return new e.pointGeometry(t, 0);

          case "right":
            return new e.pointGeometry(-t, 0);
        }

        return new e.pointGeometry(0, 0);
      }

      return t instanceof e.pointGeometry || Array.isArray(t) ? e.pointGeometry.convert(t) : e.pointGeometry.convert(t[i] || [0, 0]);
    }

    const ln = {
      version: e.version,
      supported: t,
      setRTLTextPlugin: e.setRTLTextPlugin,
      getRTLTextPluginStatus: e.getRTLTextPluginStatus,
      Map: class extends Fr {
        constructor(t) {
          if (null != (t = e.extend({}, Xr, t)).minZoom && null != t.maxZoom && t.minZoom > t.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
          if (null != t.minPitch && null != t.maxPitch && t.minPitch > t.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
          if (null != t.minPitch && t.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
          if (null != t.maxPitch && t.maxPitch > 85) throw new Error("maxPitch must be less than or equal to 85");

          if (t.antialias && e.isSafariWithAntialiasingBug(e.window) && (t.antialias = !1, e.warnOnce("Antialiasing is disabled for this WebGL context to avoid browser bug: https://github.com/mapbox/mapbox-gl-js/issues/11609")), super(new No(t.minZoom, t.maxZoom, t.minPitch, t.maxPitch, t.renderWorldCopies), t), this._interactive = t.interactive, this._minTileCacheSize = t.minTileCacheSize, this._maxTileCacheSize = t.maxTileCacheSize, this._failIfMajorPerformanceCaveat = t.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = t.preserveDrawingBuffer, this._antialias = t.antialias, this._trackResize = t.trackResize, this._bearingSnap = t.bearingSnap, this._refreshExpiredTiles = t.refreshExpiredTiles, this._fadeDuration = t.fadeDuration, this._isInitialLoad = !0, this._crossSourceCollisions = t.crossSourceCollisions, this._crossFadingFactor = 1, this._collectResourceTiming = t.collectResourceTiming, this._optimizeForTerrain = t.optimizeForTerrain, this._renderTaskQueue = new Gr(), this._domRenderTaskQueue = new Gr(), this._controls = [], this._markers = [], this._mapId = e.uniqueId(), this._locale = e.extend({}, qr, t.locale), this._clickTolerance = t.clickTolerance, this._cooperativeGestures = t.cooperativeGestures, this._containerWidth = 0, this._containerHeight = 0, this._averageElevationLastSampledAt = -1 / 0, this._averageElevationExaggeration = 0, this._averageElevation = new Wr(0), this._explicitProjection = null, this._requestManager = new e.RequestManager(t.transformRequest, t.accessToken, t.testMode), this._silenceAuthErrors = !!t.testMode, "string" == typeof t.container) {
            if (this._container = e.window.document.getElementById(t.container), !this._container) throw new Error(`Container '${t.container}' not found.`);
          } else {
            if (!(t.container instanceof e.window.HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
            this._container = t.container;
          }

          if (this._container.childNodes.length > 0 && e.warnOnce("The map container element should be empty, otherwise the map's interactivity will be negatively impacted. If you want to display a message when WebGL is not supported, use the Mapbox GL Supported plugin instead."), t.maxBounds && this.setMaxBounds(t.maxBounds), e.bindAll(["_onWindowOnline", "_onWindowResize", "_onMapScroll", "_contextLost", "_contextRestored"], this), this._setupContainer(), this._setupPainter(), void 0 === this.painter) throw new Error("Failed to initialize WebGL.");
          this.on("move", () => this._update(!1)), this.on("moveend", () => this._update(!1)), this.on("zoom", () => this._update(!0)), void 0 !== e.window && (e.window.addEventListener("online", this._onWindowOnline, !1), e.window.addEventListener("resize", this._onWindowResize, !1), e.window.addEventListener("orientationchange", this._onWindowResize, !1), e.window.addEventListener("webkitfullscreenchange", this._onWindowResize, !1)), this.handlers = new Or(this, t), this._localFontFamily = t.localFontFamily, this._localIdeographFontFamily = t.localIdeographFontFamily, t.style && this.setStyle(t.style, {
            localFontFamily: this._localFontFamily,
            localIdeographFontFamily: this._localIdeographFontFamily
          }), t.projection && this.setProjection(t.projection), this._hash = t.hash && new jo("string" == typeof t.hash && t.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({
            center: t.center,
            zoom: t.zoom,
            bearing: t.bearing,
            pitch: t.pitch
          }), t.bounds && (this.resize(), this.fitBounds(t.bounds, e.extend({}, t.fitBoundsOptions, {
            duration: 0
          })))), this.resize(), t.attributionControl && this.addControl(new Ur({
            customAttribution: t.customAttribution
          })), this._logoControl = new Nr(), this.addControl(this._logoControl, t.logoPosition), this.on("style.load", () => {
            this.transform.unmodified && this.jumpTo(this.style.stylesheet);
          }), this.on("data", t => {
            this._update("style" === t.dataType), this.fire(new e.Event(`${t.dataType}data`, t));
          }), this.on("dataloading", t => {
            this.fire(new e.Event(`${t.dataType}dataloading`, t));
          });
        }

        _getMapId() {
          return this._mapId;
        }

        addControl(t, i) {
          if (void 0 === i && (i = t.getDefaultPosition ? t.getDefaultPosition() : "top-right"), !t || !t.onAdd) return this.fire(new e.ErrorEvent(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
          const o = t.onAdd(this);

          this._controls.push(t);

          const r = this._controlPositions[i];
          return -1 !== i.indexOf("bottom") ? r.insertBefore(o, r.firstChild) : r.appendChild(o), this;
        }

        removeControl(t) {
          if (!t || !t.onRemove) return this.fire(new e.ErrorEvent(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));

          const i = this._controls.indexOf(t);

          return i > -1 && this._controls.splice(i, 1), t.onRemove(this), this;
        }

        hasControl(e) {
          return this._controls.indexOf(e) > -1;
        }

        getContainer() {
          return this._container;
        }

        getCanvasContainer() {
          return this._canvasContainer;
        }

        getCanvas() {
          return this._canvas;
        }

        resize(t) {
          if (this._updateContainerDimensions(), this._containerWidth === this.transform.width && this._containerHeight === this.transform.height) return this;
          this._resizeCanvas(this._containerWidth, this._containerHeight), this.transform.resize(this._containerWidth, this._containerHeight), this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight));
          const i = !this._moving;
          return i && this.fire(new e.Event("movestart", t)).fire(new e.Event("move", t)), this.fire(new e.Event("resize", t)), i && this.fire(new e.Event("moveend", t)), this;
        }

        getBounds() {
          return this.transform.getBounds();
        }

        getMaxBounds() {
          return this.transform.getMaxBounds() || null;
        }

        setMaxBounds(t) {
          return this.transform.setMaxBounds(e.LngLatBounds.convert(t)), this._update();
        }

        setMinZoom(t) {
          if ((t = null == t ? -2 : t) >= -2 && t <= this.transform.maxZoom) return this.transform.minZoom = t, this._update(), this.getZoom() < t ? this.setZoom(t) : this.fire(new e.Event("zoomstart")).fire(new e.Event("zoom")).fire(new e.Event("zoomend")), this;
          throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
        }

        getMinZoom() {
          return this.transform.minZoom;
        }

        setMaxZoom(t) {
          if ((t = null == t ? 22 : t) >= this.transform.minZoom) return this.transform.maxZoom = t, this._update(), this.getZoom() > t ? this.setZoom(t) : this.fire(new e.Event("zoomstart")).fire(new e.Event("zoom")).fire(new e.Event("zoomend")), this;
          throw new Error("maxZoom must be greater than the current minZoom");
        }

        getMaxZoom() {
          return this.transform.maxZoom;
        }

        setMinPitch(t) {
          if ((t = null == t ? 0 : t) < 0) throw new Error("minPitch must be greater than or equal to 0");
          if (t >= 0 && t <= this.transform.maxPitch) return this.transform.minPitch = t, this._update(), this.getPitch() < t ? this.setPitch(t) : this.fire(new e.Event("pitchstart")).fire(new e.Event("pitch")).fire(new e.Event("pitchend")), this;
          throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
        }

        getMinPitch() {
          return this.transform.minPitch;
        }

        setMaxPitch(t) {
          if ((t = null == t ? 85 : t) > 85) throw new Error("maxPitch must be less than or equal to 85");
          if (t >= this.transform.minPitch) return this.transform.maxPitch = t, this._update(), this.getPitch() > t ? this.setPitch(t) : this.fire(new e.Event("pitchstart")).fire(new e.Event("pitch")).fire(new e.Event("pitchend")), this;
          throw new Error("maxPitch must be greater than the current minPitch");
        }

        getMaxPitch() {
          return this.transform.maxPitch;
        }

        getRenderWorldCopies() {
          return this.transform.renderWorldCopies;
        }

        setRenderWorldCopies(e) {
          return this.transform.renderWorldCopies = e, this._update();
        }

        getProjection() {
          return this._explicitProjection ? this._explicitProjection : this.style && this.style.stylesheet && this.style.stylesheet.projection ? this.style.stylesheet.projection : {
            name: "mercator",
            center: [0, 0]
          };
        }

        setProjection(e) {
          return this._lazyInitEmptyStyle(), e ? "string" == typeof e && (e = {
            name: e
          }) : e = null, this._updateProjection(e);
        }

        _updateProjection(e) {
          null === e && (this._explicitProjection = null);
          const t = e || this.getProjection(),
                i = this.transform.setProjection(t);

          if (e && (this._explicitProjection = this.transform.getProjection()), i) {
            this.painter.clearBackgroundTiles();

            for (const e in this.style._sourceCaches) this.style._sourceCaches[e].clearTiles();

            this.style.applyProjectionUpdate(), this._update(!0);
          }

          return this;
        }

        project(t) {
          return this.transform.locationPoint3D(e.LngLat.convert(t));
        }

        unproject(t) {
          return this.transform.pointLocation3D(e.pointGeometry.convert(t));
        }

        isMoving() {
          return this._moving || this.handlers && this.handlers.isMoving() || !1;
        }

        isZooming() {
          return this._zooming || this.handlers && this.handlers.isZooming() || !1;
        }

        isRotating() {
          return this._rotating || this.handlers && this.handlers.isRotating() || !1;
        }

        _createDelegatedListener(e, t, i) {
          if ("mouseenter" === e || "mouseover" === e) {
            let o = !1;

            const r = r => {
              const n = t.filter(e => this.getLayer(e)),
                    a = n.length ? this.queryRenderedFeatures(r.point, {
                layers: n
              }) : [];
              a.length ? o || (o = !0, i.call(this, new Yo(e, this, r.originalEvent, {
                features: a
              }))) : o = !1;
            },
                  n = () => {
              o = !1;
            };

            return {
              layers: new Set(t),
              listener: i,
              delegates: {
                mousemove: r,
                mouseout: n
              }
            };
          }

          if ("mouseleave" === e || "mouseout" === e) {
            let o = !1;

            const r = r => {
              const n = t.filter(e => this.getLayer(e));
              (n.length ? this.queryRenderedFeatures(r.point, {
                layers: n
              }) : []).length ? o = !0 : o && (o = !1, i.call(this, new Yo(e, this, r.originalEvent)));
            },
                  n = t => {
              o && (o = !1, i.call(this, new Yo(e, this, t.originalEvent)));
            };

            return {
              layers: new Set(t),
              listener: i,
              delegates: {
                mousemove: r,
                mouseout: n
              }
            };
          }

          {
            const o = e => {
              const o = t.filter(e => this.getLayer(e)),
                    r = o.length ? this.queryRenderedFeatures(e.point, {
                layers: o
              }) : [];
              r.length && (e.features = r, i.call(this, e), delete e.features);
            };

            return {
              layers: new Set(t),
              listener: i,
              delegates: {
                [e]: o
              }
            };
          }
        }

        on(e, t, i) {
          if (void 0 === i) return super.on(e, t);
          Array.isArray(t) || (t = [t]);

          const o = this._createDelegatedListener(e, t, i);

          this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[e] = this._delegatedListeners[e] || [], this._delegatedListeners[e].push(o);

          for (const e in o.delegates) this.on(e, o.delegates[e]);

          return this;
        }

        once(e, t, i) {
          if (void 0 === i) return super.once(e, t);
          Array.isArray(t) || (t = [t]);

          const o = this._createDelegatedListener(e, t, i);

          for (const e in o.delegates) this.once(e, o.delegates[e]);

          return this;
        }

        off(e, t, i) {
          if (void 0 === i) return super.off(e, t);
          t = new Set(Array.isArray(t) ? t : [t]);

          const o = (e, t) => {
            if (e.size !== t.size) return !1;

            for (const i of e) if (!t.has(i)) return !1;

            return !0;
          },
                r = this._delegatedListeners ? this._delegatedListeners[e] : void 0;

          return r && (e => {
            for (let r = 0; r < e.length; r++) {
              const n = e[r];

              if (n.listener === i && o(n.layers, t)) {
                for (const e in n.delegates) this.off(e, n.delegates[e]);

                return e.splice(r, 1), this;
              }
            }
          })(r), this;
        }

        queryRenderedFeatures(t, i) {
          return this.style ? (void 0 !== i || void 0 === t || t instanceof e.pointGeometry || Array.isArray(t) || (i = t, t = void 0), this.style.queryRenderedFeatures(t = t || [[0, 0], [this.transform.width, this.transform.height]], i = i || {}, this.transform)) : [];
        }

        querySourceFeatures(e, t) {
          return this.style.querySourceFeatures(e, t);
        }

        queryTerrainElevation(t, i) {
          const o = this.transform.elevation;
          return o ? (i = e.extend({}, {
            exaggerated: !0
          }, i), o.getAtPoint(e.MercatorCoordinate.fromLngLat(t), null, i.exaggerated)) : null;
        }

        setStyle(t, i) {
          return !1 !== (i = e.extend({}, {
            localIdeographFontFamily: this._localIdeographFontFamily,
            localFontFamily: this._localFontFamily
          }, i)).diff && i.localIdeographFontFamily === this._localIdeographFontFamily && i.localFontFamily === this._localFontFamily && this.style && t ? (this._diffStyle(t, i), this) : (this._localIdeographFontFamily = i.localIdeographFontFamily, this._localFontFamily = i.localFontFamily, this._updateStyle(t, i));
        }

        _getUIString(e) {
          const t = this._locale[e];
          if (null == t) throw new Error(`Missing UI string '${e}'`);
          return t;
        }

        _updateStyle(e, t) {
          return this.style && (this.style.setEventedParent(null), this.style._remove(), this.style = void 0), e && (this.style = new $t(this, t || {}), this.style.setEventedParent(this, {
            style: this.style
          }), "string" == typeof e ? this.style.loadURL(e) : this.style.loadJSON(e)), this._updateTerrain(), this;
        }

        _lazyInitEmptyStyle() {
          this.style || (this.style = new $t(this, {}), this.style.setEventedParent(this, {
            style: this.style
          }), this.style.loadEmpty());
        }

        _diffStyle(t, i) {
          if ("string" == typeof t) {
            const o = this._requestManager.normalizeStyleURL(t),
                  r = this._requestManager.transformRequest(o, e.ResourceType.Style);

            e.getJSON(r, (t, o) => {
              t ? this.fire(new e.ErrorEvent(t)) : o && this._updateDiff(o, i);
            });
          } else "object" == typeof t && this._updateDiff(t, i);
        }

        _updateDiff(t, i) {
          try {
            this.style.setState(t) && this._update(!0);
          } catch (o) {
            e.warnOnce(`Unable to perform style diff: ${o.message || o.error || o}.  Rebuilding the style from scratch.`), this._updateStyle(t, i);
          }
        }

        getStyle() {
          if (this.style) return this.style.serialize();
        }

        isStyleLoaded() {
          return this.style ? this.style.loaded() : (e.warnOnce("There is no style added to the map."), !1);
        }

        addSource(e, t) {
          return this._lazyInitEmptyStyle(), this.style.addSource(e, t), this._update(!0);
        }

        isSourceLoaded(e) {
          return !!this.style && this.style._isSourceCacheLoaded(e);
        }

        areTilesLoaded() {
          const e = this.style && this.style._sourceCaches;

          for (const t in e) {
            const i = e[t]._tiles;

            for (const e in i) {
              const t = i[e];
              if ("loaded" !== t.state && "errored" !== t.state) return !1;
            }
          }

          return !0;
        }

        addSourceType(e, t, i) {
          this._lazyInitEmptyStyle(), this.style.addSourceType(e, t, i);
        }

        removeSource(e) {
          return this.style.removeSource(e), this._updateTerrain(), this._update(!0);
        }

        getSource(e) {
          return this.style.getSource(e);
        }

        addImage(t, i, {
          pixelRatio: o = 1,
          sdf: r = !1,
          stretchX: n,
          stretchY: a,
          content: s
        } = {}) {
          if (this._lazyInitEmptyStyle(), i instanceof e.window.HTMLImageElement || e.window.ImageBitmap && i instanceof e.window.ImageBitmap) {
            const {
              width: l,
              height: c,
              data: h
            } = e.exported.getImageData(i);
            this.style.addImage(t, {
              data: new e.RGBAImage({
                width: l,
                height: c
              }, h),
              pixelRatio: o,
              stretchX: n,
              stretchY: a,
              content: s,
              sdf: r,
              version: 0
            });
          } else if (void 0 === i.width || void 0 === i.height) this.fire(new e.ErrorEvent(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));else {
            const {
              width: l,
              height: c
            } = i,
                  h = i;
            this.style.addImage(t, {
              data: new e.RGBAImage({
                width: l,
                height: c
              }, new Uint8Array(h.data)),
              pixelRatio: o,
              stretchX: n,
              stretchY: a,
              content: s,
              sdf: r,
              version: 0,
              userImage: h
            }), h.onAdd && h.onAdd(this, t);
          }
        }

        updateImage(t, i) {
          const o = this.style.getImage(t);
          if (!o) return void this.fire(new e.ErrorEvent(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
          const r = i instanceof e.window.HTMLImageElement || e.window.ImageBitmap && i instanceof e.window.ImageBitmap ? e.exported.getImageData(i) : i,
                {
            width: n,
            height: a
          } = r;
          void 0 !== n && void 0 !== a ? n === o.data.width && a === o.data.height ? (o.data.replace(r.data, !(i instanceof e.window.HTMLImageElement || e.window.ImageBitmap && i instanceof e.window.ImageBitmap)), this.style.updateImage(t, o)) : this.fire(new e.ErrorEvent(new Error("The width and height of the updated image must be that same as the previous version of the image"))) : this.fire(new e.ErrorEvent(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
        }

        hasImage(t) {
          return t ? !!this.style.getImage(t) : (this.fire(new e.ErrorEvent(new Error("Missing required image id"))), !1);
        }

        removeImage(e) {
          this.style.removeImage(e);
        }

        loadImage(t, i) {
          e.getImage(this._requestManager.transformRequest(t, e.ResourceType.Image), (t, o) => {
            i(t, o instanceof e.window.HTMLImageElement ? e.exported.getImageData(o) : o);
          });
        }

        listImages() {
          return this.style.listImages();
        }

        addLayer(e, t) {
          return this._lazyInitEmptyStyle(), this.style.addLayer(e, t), this._update(!0);
        }

        moveLayer(e, t) {
          return this.style.moveLayer(e, t), this._update(!0);
        }

        removeLayer(e) {
          return this.style.removeLayer(e), this._update(!0);
        }

        getLayer(e) {
          return this.style.getLayer(e);
        }

        setLayerZoomRange(e, t, i) {
          return this.style.setLayerZoomRange(e, t, i), this._update(!0);
        }

        setFilter(e, t, i = {}) {
          return this.style.setFilter(e, t, i), this._update(!0);
        }

        getFilter(e) {
          return this.style.getFilter(e);
        }

        setPaintProperty(e, t, i, o = {}) {
          return this.style.setPaintProperty(e, t, i, o), this._update(!0);
        }

        getPaintProperty(e, t) {
          return this.style.getPaintProperty(e, t);
        }

        setLayoutProperty(e, t, i, o = {}) {
          return this.style.setLayoutProperty(e, t, i, o), this._update(!0);
        }

        getLayoutProperty(e, t) {
          return this.style.getLayoutProperty(e, t);
        }

        setLight(e, t = {}) {
          return this._lazyInitEmptyStyle(), this.style.setLight(e, t), this._update(!0);
        }

        getLight() {
          return this.style.getLight();
        }

        setTerrain(e) {
          return this._lazyInitEmptyStyle(), !e && this.transform.projection.requiresDraping ? this.style.setTerrainForDraping() : this.style.setTerrain(e), this._averageElevationLastSampledAt = -1 / 0, this._update(!0);
        }

        getTerrain() {
          return this.style ? this.style.getTerrain() : null;
        }

        setFog(e) {
          return this._lazyInitEmptyStyle(), this.style.setFog(e), this._update(!0);
        }

        getFog() {
          return this.style ? this.style.getFog() : null;
        }

        _queryFogOpacity(t) {
          return this.style && this.style.fog ? this.style.fog.getOpacityAtLatLng(e.LngLat.convert(t), this.transform) : 0;
        }

        setFeatureState(e, t) {
          return this.style.setFeatureState(e, t), this._update();
        }

        removeFeatureState(e, t) {
          return this.style.removeFeatureState(e, t), this._update();
        }

        getFeatureState(e) {
          return this.style.getFeatureState(e);
        }

        _updateContainerDimensions() {
          if (!this._container) return;
          const t = this._container.getBoundingClientRect().width || 400,
                i = this._container.getBoundingClientRect().height || 300;
          let o,
              r,
              n,
              a = this._container;

          for (; a && (!r || !n);) {
            const t = e.window.getComputedStyle(a).transform;
            t && "none" !== t && (o = t.match(/matrix.*\((.+)\)/)[1].split(", "), o[0] && "0" !== o[0] && "1" !== o[0] && (r = o[0]), o[3] && "0" !== o[3] && "1" !== o[3] && (n = o[3])), a = a.parentElement;
          }

          this._containerWidth = r ? Math.abs(t / r) : t, this._containerHeight = n ? Math.abs(i / n) : i;
        }

        _detectMissingCSS() {
          "rgb(250, 128, 114)" !== e.window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color") && e.warnOnce("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.");
        }

        _setupContainer() {
          const e = this._container;
          e.classList.add("mapboxgl-map"), (this._missingCSSCanary = n("div", "mapboxgl-canary", e)).style.visibility = "hidden", this._detectMissingCSS();
          const t = this._canvasContainer = n("div", "mapboxgl-canvas-container", e);
          this._interactive && t.classList.add("mapboxgl-interactive"), this._canvas = n("canvas", "mapboxgl-canvas", t), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", "0"), this._canvas.setAttribute("aria-label", "Map"), this._canvas.setAttribute("role", "region"), this._updateContainerDimensions(), this._resizeCanvas(this._containerWidth, this._containerHeight);
          const i = this._controlContainer = n("div", "mapboxgl-control-container", e),
                o = this._controlPositions = {};
          ["top-left", "top-right", "bottom-left", "bottom-right"].forEach(e => {
            o[e] = n("div", `mapboxgl-ctrl-${e}`, i);
          }), this._container.addEventListener("scroll", this._onMapScroll, !1);
        }

        _resizeCanvas(t, i) {
          const o = e.exported.devicePixelRatio || 1;
          this._canvas.width = o * Math.ceil(t), this._canvas.height = o * Math.ceil(i), this._canvas.style.width = `${t}px`, this._canvas.style.height = `${i}px`;
        }

        _addMarker(e) {
          this._markers.push(e);
        }

        _removeMarker(e) {
          const t = this._markers.indexOf(e);

          -1 !== t && this._markers.splice(t, 1);
        }

        _setupPainter() {
          const i = e.extend({}, t.webGLContextAttributes, {
            failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat,
            preserveDrawingBuffer: this._preserveDrawingBuffer,
            antialias: this._antialias || !1
          }),
                o = this._canvas.getContext("webgl", i) || this._canvas.getContext("experimental-webgl", i);

          o ? (e.storeAuthState(o, !0), this.painter = new Mo(o, this.transform), this.on("data", e => {
            "source" === e.dataType && this.painter.setTileLoadedFlag(!0);
          }), e.exported$1.testSupport(o)) : this.fire(new e.ErrorEvent(new Error("Failed to initialize WebGL")));
        }

        _contextLost(t) {
          t.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new e.Event("webglcontextlost", {
            originalEvent: t
          }));
        }

        _contextRestored(t) {
          this._setupPainter(), this.resize(), this._update(), this.fire(new e.Event("webglcontextrestored", {
            originalEvent: t
          }));
        }

        _onMapScroll(e) {
          if (e.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;
        }

        loaded() {
          return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
        }

        _update(e) {
          return this.style ? (this._styleDirty = this._styleDirty || e, this._sourcesDirty = !0, this.triggerRepaint(), this) : this;
        }

        _requestRenderFrame(e) {
          return this._update(), this._renderTaskQueue.add(e);
        }

        _cancelRenderFrame(e) {
          this._renderTaskQueue.remove(e);
        }

        _requestDomTask(e) {
          !this.loaded() || this.loaded() && !this.isMoving() ? e() : this._domRenderTaskQueue.add(e);
        }

        _render(t) {
          let i;
          const o = this.painter.context.extTimerQuery,
                r = e.exported.now();
          if (this.listens("gpu-timing-frame") && (i = o.createQueryEXT(), o.beginQueryEXT(o.TIME_ELAPSED_EXT, i)), this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(t), this._domRenderTaskQueue.run(t), this._removed) return;
          let n = !1;
          const a = this._isInitialLoad ? 0 : this._fadeDuration;

          if (this.style && this._styleDirty) {
            this._styleDirty = !1;
            const t = this.transform.zoom,
                  i = this.transform.pitch,
                  o = e.exported.now();
            this.style.zoomHistory.update(t, o);
            const r = new e.EvaluationParameters(t, {
              now: o,
              fadeDuration: a,
              pitch: i,
              zoomHistory: this.style.zoomHistory,
              transition: this.style.getTransition()
            }),
                  s = r.crossFadingFactor();
            1 === s && s === this._crossFadingFactor || (n = !0, this._crossFadingFactor = s), this.style.update(r);
          }

          this.style && this.style.fog && this.style.fog.hasTransition() && (this.style._markersNeedUpdate = !0, this._sourcesDirty = !0);
          let s = !1;

          if (this.style && this._sourcesDirty ? (this._sourcesDirty = !1, this.painter._updateFog(this.style), this._updateTerrain(), s = this._updateAverageElevation(r), this.style._updateSources(this.transform), this._forceMarkerUpdate()) : s = this._updateAverageElevation(r), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, a, this._crossSourceCollisions), this.style && this.painter.render(this.style, {
            showTileBoundaries: this.showTileBoundaries,
            showTerrainWireframe: this.showTerrainWireframe,
            showOverdrawInspector: this._showOverdrawInspector,
            showQueryGeometry: !!this._showQueryGeometry,
            rotating: this.isRotating(),
            zooming: this.isZooming(),
            moving: this.isMoving(),
            fadeDuration: a,
            isInitialLoad: this._isInitialLoad,
            showPadding: this.showPadding,
            gpuTiming: !!this.listens("gpu-timing-layer"),
            speedIndexTiming: this.speedIndexTiming
          }), this.fire(new e.Event("render")), this.loaded() && !this._loaded && (this._loaded = !0, this.fire(new e.Event("load"))), this.style && (this.style.hasTransitions() || n) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), this.listens("gpu-timing-frame")) {
            const t = e.exported.now() - r;
            o.endQueryEXT(o.TIME_ELAPSED_EXT, i), setTimeout(() => {
              const r = o.getQueryObjectEXT(i, o.QUERY_RESULT_EXT) / 1e6;
              o.deleteQueryEXT(i), this.fire(new e.Event("gpu-timing-frame", {
                cpuTime: t,
                gpuTime: r
              }));
            }, 50);
          }

          if (this.listens("gpu-timing-layer")) {
            const t = this.painter.collectGpuTimers();
            setTimeout(() => {
              const i = this.painter.queryGpuTimers(t);
              this.fire(new e.Event("gpu-timing-layer", {
                layerTimes: i
              }));
            }, 50);
          }

          const l = this._sourcesDirty || this._styleDirty || this._placementDirty || s;
          if (l || this._repaint) this.triggerRepaint();else {
            const t = !this.isMoving() && this.loaded();
            if (t && (s = this._updateAverageElevation(r, !0)), s) this.triggerRepaint();else if (this._triggerFrame(!1), t && (this.fire(new e.Event("idle")), this._isInitialLoad = !1, this.speedIndexTiming)) {
              const t = this._calculateSpeedIndex();

              this.fire(new e.Event("speedindexcompleted", {
                speedIndex: t
              })), this.speedIndexTiming = !1;
            }
          }
          !this._loaded || this._fullyLoaded || l || (this._fullyLoaded = !0, this._authenticate());
        }

        _forceMarkerUpdate() {
          for (const e of this._markers) e._update();
        }

        _updateAverageElevation(e, t = !1) {
          const i = e => (this.transform.averageElevation = e, this._update(!1), !0);

          if (!this.painter.averageElevationNeedsEasing()) return 0 !== this.transform.averageElevation && i(0);

          if ((t || e - this._averageElevationLastSampledAt > 500) && !this._averageElevation.isEasing(e)) {
            const t = this.transform.averageElevation;
            let o = this.transform.sampleAverageElevation(),
                r = !1;
            this.transform.elevation && (r = this.transform.elevation.exaggeration() !== this._averageElevationExaggeration, this._averageElevationExaggeration = this.transform.elevation.exaggeration()), isNaN(o) ? o = 0 : this._averageElevationLastSampledAt = e;
            const n = Math.abs(t - o);

            if (n > 1) {
              if (this._isInitialLoad || r) return this._averageElevation.jumpTo(o), i(o);

              this._averageElevation.easeTo(o, e, 300);
            } else if (n > 1e-4) return this._averageElevation.jumpTo(o), i(o);
          }

          return !!this._averageElevation.isEasing(e) && i(this._averageElevation.getValue(e));
        }

        _authenticate() {
          e.getMapSessionAPI(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, t => {
            if (t && (t.message === e.AUTH_ERR_MSG || 401 === t.status)) {
              const t = this.painter.context.gl;
              e.storeAuthState(t, !1), this._logoControl instanceof Nr && this._logoControl._updateLogo(), t && t.clear(t.DEPTH_BUFFER_BIT | t.COLOR_BUFFER_BIT | t.STENCIL_BUFFER_BIT), this._silenceAuthErrors || this.fire(new e.ErrorEvent(new Error("A valid Mapbox access token is required to use Mapbox GL JS. To create an account or a new access token, visit https://account.mapbox.com/")));
            }
          }), e.postMapLoadEvent(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, () => {});
        }

        _updateTerrain() {
          this.painter.updateTerrain(this.style, this.isMoving() || this.isRotating() || this.isZooming());
        }

        _calculateSpeedIndex() {
          const e = this.painter.canvasCopy(),
                t = this.painter.getCanvasCopiesAndTimestamps();
          t.timeStamps.push(performance.now());
          const i = this.painter.context.gl,
                o = i.createFramebuffer();

          function r(e) {
            i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, e, 0);
            const t = new Uint8Array(i.drawingBufferWidth * i.drawingBufferHeight * 4);
            return i.readPixels(0, 0, i.drawingBufferWidth, i.drawingBufferHeight, i.RGBA, i.UNSIGNED_BYTE, t), t;
          }

          return i.bindFramebuffer(i.FRAMEBUFFER, o), this._canvasPixelComparison(r(e), t.canvasCopies.map(r), t.timeStamps);
        }

        _canvasPixelComparison(e, t, i) {
          let o = i[1] - i[0];
          const r = e.length / 4;

          for (let n = 0; n < t.length; n++) {
            const a = t[n];
            let s = 0;

            for (let t = 0; t < a.length; t += 4) a[t] === e[t] && a[t + 1] === e[t + 1] && a[t + 2] === e[t + 2] && a[t + 3] === e[t + 3] && (s += 1);

            o += (i[n + 2] - i[n + 1]) * (1 - s / r);
          }

          return o;
        }

        remove() {
          this._hash && this._hash.remove();

          for (const e of this._controls) e.onRemove(this);

          this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this._domRenderTaskQueue.clear(), this.style && this.style.destroy(), this.painter.destroy(), this.handlers && this.handlers.destroy(), this.handlers = void 0, this.setStyle(null), void 0 !== e.window && (e.window.removeEventListener("resize", this._onWindowResize, !1), e.window.removeEventListener("orientationchange", this._onWindowResize, !1), e.window.removeEventListener("webkitfullscreenchange", this._onWindowResize, !1), e.window.removeEventListener("online", this._onWindowOnline, !1));
          const t = this.painter.context.gl.getExtension("WEBGL_lose_context");
          t && t.loseContext(), $r(this._canvasContainer), $r(this._controlContainer), $r(this._missingCSSCanary), this._container.classList.remove("mapboxgl-map"), e.removeAuthState(this.painter.context.gl), this._removed = !0, this.fire(new e.Event("remove"));
        }

        triggerRepaint() {
          this._triggerFrame(!0);
        }

        _triggerFrame(t) {
          this._renderNextFrame = this._renderNextFrame || t, this.style && !this._frame && (this._frame = e.exported.frame(e => {
            const t = !!this._renderNextFrame;
            this._frame = null, this._renderNextFrame = null, t && this._render(e);
          }));
        }

        _preloadTiles(t) {
          const i = this.style ? Object.values(this.style._sourceCaches) : [];
          return e.asyncAll(i, (e, i) => e._preloadTiles(t, i), () => {
            this.triggerRepaint();
          }), this;
        }

        _onWindowOnline() {
          this._update();
        }

        _onWindowResize(e) {
          this._trackResize && this.resize({
            originalEvent: e
          })._update();
        }

        get showTileBoundaries() {
          return !!this._showTileBoundaries;
        }

        set showTileBoundaries(e) {
          this._showTileBoundaries !== e && (this._showTileBoundaries = e, this._update());
        }

        get showTerrainWireframe() {
          return !!this._showTerrainWireframe;
        }

        set showTerrainWireframe(e) {
          this._showTerrainWireframe !== e && (this._showTerrainWireframe = e, this._update());
        }

        get speedIndexTiming() {
          return !!this._speedIndexTiming;
        }

        set speedIndexTiming(e) {
          this._speedIndexTiming !== e && (this._speedIndexTiming = e, this._update());
        }

        get showPadding() {
          return !!this._showPadding;
        }

        set showPadding(e) {
          this._showPadding !== e && (this._showPadding = e, this._update());
        }

        get showCollisionBoxes() {
          return !!this._showCollisionBoxes;
        }

        set showCollisionBoxes(e) {
          this._showCollisionBoxes !== e && (this._showCollisionBoxes = e, e ? this.style._generateCollisionBoxes() : this._update());
        }

        get showOverdrawInspector() {
          return !!this._showOverdrawInspector;
        }

        set showOverdrawInspector(e) {
          this._showOverdrawInspector !== e && (this._showOverdrawInspector = e, this._update());
        }

        get repaint() {
          return !!this._repaint;
        }

        set repaint(e) {
          this._repaint !== e && (this._repaint = e, this.triggerRepaint());
        }

        get vertices() {
          return !!this._vertices;
        }

        set vertices(e) {
          this._vertices = e, this._update();
        }

        _setCacheLimits(t, i) {
          e.setCacheLimits(t, i);
        }

        get version() {
          return e.version;
        }

      },
      NavigationControl: class {
        constructor(t) {
          this.options = e.extend({}, Hr, t), this._container = n("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._container.addEventListener("contextmenu", e => e.preventDefault()), this.options.showZoom && (e.bindAll(["_setButtonTitle", "_updateZoomButtons"], this), this._zoomInButton = this._createButton("mapboxgl-ctrl-zoom-in", e => {
            this._map && this._map.zoomIn({}, {
              originalEvent: e
            });
          }), n("span", "mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("mapboxgl-ctrl-zoom-out", e => {
            this._map && this._map.zoomOut({}, {
              originalEvent: e
            });
          }), n("span", "mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (e.bindAll(["_rotateCompassArrow"], this), this._compass = this._createButton("mapboxgl-ctrl-compass", e => {
            const t = this._map;
            t && (this.options.visualizePitch ? t.resetNorthPitch({}, {
              originalEvent: e
            }) : t.resetNorth({}, {
              originalEvent: e
            }));
          }), this._compassIcon = n("span", "mapboxgl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
        }

        _updateZoomButtons() {
          const e = this._map;
          if (!e) return;
          const t = e.getZoom(),
                i = t === e.getMaxZoom(),
                o = t === e.getMinZoom();
          this._zoomInButton.disabled = i, this._zoomOutButton.disabled = o, this._zoomInButton.setAttribute("aria-disabled", i.toString()), this._zoomOutButton.setAttribute("aria-disabled", o.toString());
        }

        _rotateCompassArrow() {
          const e = this._map;
          if (!e) return;
          const t = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(e.transform.pitch * (Math.PI / 180)), .5)}) rotateX(${e.transform.pitch}deg) rotateZ(${e.transform.angle * (180 / Math.PI)}deg)` : `rotate(${e.transform.angle * (180 / Math.PI)}deg)`;

          e._requestDomTask(() => {
            this._compassIcon && (this._compassIcon.style.transform = t);
          });
        }

        onAdd(e) {
          return this._map = e, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), e.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && e.on("pitch", this._rotateCompassArrow), e.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new Kr(e, this._compass, this.options.visualizePitch)), this._container;
        }

        onRemove() {
          const e = this._map;
          e && (this._container.remove(), this.options.showZoom && e.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && e.off("pitch", this._rotateCompassArrow), e.off("rotate", this._rotateCompassArrow), this._handler && this._handler.off(), this._handler = void 0), this._map = void 0);
        }

        _createButton(e, t) {
          const i = n("button", e, this._container);
          return i.type = "button", i.addEventListener("click", t), i;
        }

        _setButtonTitle(e, t) {
          if (!this._map) return;

          const i = this._map._getUIString(`NavigationControl.${t}`);

          e.setAttribute("aria-label", i), e.firstElementChild && e.firstElementChild.setAttribute("title", i);
        }

      },
      GeolocateControl: class extends e.Evented {
        constructor(t) {
          super(), this.options = e.extend({}, Yr, t), e.bindAll(["_onSuccess", "_onError", "_onZoom", "_finish", "_setupUI", "_updateCamera", "_updateMarker", "_updateMarkerRotation", "_onDeviceOrientation"], this), this._updateMarkerRotationThrottled = Go(this._updateMarkerRotation, 20);
        }

        onAdd(t) {
          var i;
          return this._map = t, this._container = n("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), i = this._setupUI, void 0 !== Jr ? i(Jr) : void 0 !== e.window.navigator.permissions ? e.window.navigator.permissions.query({
            name: "geolocation"
          }).then(e => {
            Jr = "denied" !== e.state, i(Jr);
          }) : (Jr = !!e.window.navigator.geolocation, i(Jr)), this._container;
        }

        onRemove() {
          void 0 !== this._geolocationWatchID && (e.window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), this._container.remove(), this._map.off("zoom", this._onZoom), this._map = void 0, Qr = 0, en = !1;
        }

        _isOutOfMapMaxBounds(e) {
          const t = this._map.getMaxBounds(),
                i = e.coords;

          return !!t && (i.longitude < t.getWest() || i.longitude > t.getEast() || i.latitude < t.getSouth() || i.latitude > t.getNorth());
        }

        _setErrorState() {
          switch (this._watchState) {
            case "WAITING_ACTIVE":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
              break;

            case "ACTIVE_LOCK":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
              break;

            case "BACKGROUND":
              this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
          }
        }

        _onSuccess(t) {
          if (this._map) {
            if (this._isOutOfMapMaxBounds(t)) return this._setErrorState(), this.fire(new e.Event("outofmaxbounds", t)), this._updateMarker(), void this._finish();
            if (this.options.trackUserLocation) switch (this._lastKnownPosition = t, this._watchState) {
              case "WAITING_ACTIVE":
              case "ACTIVE_LOCK":
              case "ACTIVE_ERROR":
                this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                break;

              case "BACKGROUND":
              case "BACKGROUND_ERROR":
                this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
            }
            this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(t), this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(t), this.options.showUserLocation && this._dotElement.classList.remove("mapboxgl-user-location-dot-stale"), this.fire(new e.Event("geolocate", t)), this._finish();
          }
        }

        _updateCamera(t) {
          const i = new e.LngLat(t.coords.longitude, t.coords.latitude),
                o = t.coords.accuracy,
                r = this._map.getBearing(),
                n = e.extend({
            bearing: r
          }, this.options.fitBoundsOptions);

          this._map.fitBounds(i.toBounds(o), n, {
            geolocateSource: !0
          });
        }

        _updateMarker(t) {
          if (t) {
            const i = new e.LngLat(t.coords.longitude, t.coords.latitude);
            this._accuracyCircleMarker.setLngLat(i).addTo(this._map), this._userLocationDotMarker.setLngLat(i).addTo(this._map), this._accuracy = t.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
          } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
        }

        _updateCircleRadius() {
          const e = this._map._containerHeight / 2,
                t = this._map.unproject([0, e]),
                i = this._map.unproject([100, e]),
                o = t.distanceTo(i) / 100,
                r = Math.ceil(2 * this._accuracy / o);

          this._circleElement.style.width = `${r}px`, this._circleElement.style.height = `${r}px`;
        }

        _onZoom() {
          this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
        }

        _updateMarkerRotation() {
          this._userLocationDotMarker && "number" == typeof this._heading ? (this._userLocationDotMarker.setRotation(this._heading), this._dotElement.classList.add("mapboxgl-user-location-show-heading")) : (this._dotElement.classList.remove("mapboxgl-user-location-show-heading"), this._userLocationDotMarker.setRotation(0));
        }

        _onError(t) {
          if (this._map) {
            if (this.options.trackUserLocation) if (1 === t.code) {
              this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;

              const e = this._map._getUIString("GeolocateControl.LocationNotAvailable");

              this._geolocateButton.setAttribute("aria-label", e), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e), void 0 !== this._geolocationWatchID && this._clearWatch();
            } else {
              if (3 === t.code && en) return;

              this._setErrorState();
            }
            "OFF" !== this._watchState && this.options.showUserLocation && this._dotElement.classList.add("mapboxgl-user-location-dot-stale"), this.fire(new e.Event("error", t)), this._finish();
          }
        }

        _finish() {
          this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
        }

        _setupUI(t) {
          if (this._container.addEventListener("contextmenu", e => e.preventDefault()), this._geolocateButton = n("button", "mapboxgl-ctrl-geolocate", this._container), n("span", "mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", !1 === t) {
            e.warnOnce("Geolocation support is not available so the GeolocateControl will be disabled.");

            const t = this._map._getUIString("GeolocateControl.LocationNotAvailable");

            this._geolocateButton.disabled = !0, this._geolocateButton.setAttribute("aria-label", t), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", t);
          } else {
            const e = this._map._getUIString("GeolocateControl.FindMyLocation");

            this._geolocateButton.setAttribute("aria-label", e), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e);
          }

          this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = n("div", "mapboxgl-user-location"), this._dotElement.appendChild(n("div", "mapboxgl-user-location-dot")), this._dotElement.appendChild(n("div", "mapboxgl-user-location-heading")), this._userLocationDotMarker = new Vr({
            element: this._dotElement,
            rotationAlignment: "map",
            pitchAlignment: "map"
          }), this._circleElement = n("div", "mapboxgl-user-location-accuracy-circle"), this._accuracyCircleMarker = new Vr({
            element: this._circleElement,
            pitchAlignment: "map"
          }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", t => {
            t.geolocateSource || "ACTIVE_LOCK" !== this._watchState || t.originalEvent && "resize" === t.originalEvent.type || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this.fire(new e.Event("trackuserlocationend")));
          });
        }

        _onDeviceOrientation(e) {
          this._userLocationDotMarker && (e.webkitCompassHeading ? this._heading = e.webkitCompassHeading : !0 === e.absolute && (this._heading = -1 * e.alpha), this._updateMarkerRotationThrottled());
        }

        trigger() {
          if (!this._setup) return e.warnOnce("Geolocate control triggered before added to a map"), !1;

          if (this.options.trackUserLocation) {
            switch (this._watchState) {
              case "OFF":
                this._watchState = "WAITING_ACTIVE", this.fire(new e.Event("trackuserlocationstart"));
                break;

              case "WAITING_ACTIVE":
              case "ACTIVE_LOCK":
              case "ACTIVE_ERROR":
              case "BACKGROUND_ERROR":
                Qr--, en = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this.fire(new e.Event("trackuserlocationend"));
                break;

              case "BACKGROUND":
                this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new e.Event("trackuserlocationstart"));
            }

            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                break;

              case "ACTIVE_LOCK":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");

                break;

              case "ACTIVE_ERROR":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                break;

              case "BACKGROUND":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");

                break;

              case "BACKGROUND_ERROR":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error");
            }

            if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID) this._clearWatch();else if (void 0 === this._geolocationWatchID) {
              let t;
              this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), Qr++, Qr > 1 ? (t = {
                maximumAge: 6e5,
                timeout: 0
              }, en = !0) : (t = this.options.positionOptions, en = !1), this._geolocationWatchID = e.window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, t), this.options.showUserHeading && this._addDeviceOrientationListener();
            }
          } else e.window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);

          return !0;
        }

        _addDeviceOrientationListener() {
          const t = () => {
            e.window.addEventListener("ondeviceorientationabsolute" in e.window ? "deviceorientationabsolute" : "deviceorientation", this._onDeviceOrientation);
          };

          void 0 !== e.window.DeviceMotionEvent && "function" == typeof e.window.DeviceMotionEvent.requestPermission ? DeviceOrientationEvent.requestPermission().then(e => {
            "granted" === e && t();
          }).catch(console.error) : t();
        }

        _clearWatch() {
          e.window.navigator.geolocation.clearWatch(this._geolocationWatchID), e.window.removeEventListener("deviceorientation", this._onDeviceOrientation), e.window.removeEventListener("deviceorientationabsolute", this._onDeviceOrientation), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
        }

      },
      AttributionControl: Ur,
      ScaleControl: class {
        constructor(t) {
          this.options = e.extend({}, tn, t), e.bindAll(["_onMove", "setUnit"], this);
        }

        getDefaultPosition() {
          return "bottom-left";
        }

        _onMove() {
          on(this._map, this._container, this.options);
        }

        onAdd(e) {
          return this._map = e, this._container = n("div", "mapboxgl-ctrl mapboxgl-ctrl-scale", e.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
        }

        onRemove() {
          this._container.remove(), this._map.off("move", this._onMove), this._map = void 0;
        }

        setUnit(e) {
          this.options.unit = e, on(this._map, this._container, this.options);
        }

      },
      FullscreenControl: class {
        constructor(t) {
          this._fullscreen = !1, t && t.container && (t.container instanceof e.window.HTMLElement ? this._container = t.container : e.warnOnce("Full screen control 'container' must be a DOM element.")), e.bindAll(["_onClickFullscreen", "_changeIcon"], this), "onfullscreenchange" in e.window.document ? this._fullscreenchange = "fullscreenchange" : "onwebkitfullscreenchange" in e.window.document && (this._fullscreenchange = "webkitfullscreenchange");
        }

        onAdd(t) {
          return this._map = t, this._container || (this._container = this._map.getContainer()), this._controlContainer = n("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none", e.warnOnce("This device does not support fullscreen mode.")), this._controlContainer;
        }

        onRemove() {
          this._controlContainer.remove(), this._map = null, e.window.document.removeEventListener(this._fullscreenchange, this._changeIcon);
        }

        _checkFullscreenSupport() {
          return !(!e.window.document.fullscreenEnabled && !e.window.document.webkitFullscreenEnabled);
        }

        _setupUI() {
          const t = this._fullscreenButton = n("button", "mapboxgl-ctrl-fullscreen", this._controlContainer);
          n("span", "mapboxgl-ctrl-icon", t).setAttribute("aria-hidden", "true"), t.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), e.window.document.addEventListener(this._fullscreenchange, this._changeIcon);
        }

        _updateTitle() {
          const e = this._getTitle();

          this._fullscreenButton.setAttribute("aria-label", e), this._fullscreenButton.firstElementChild && this._fullscreenButton.firstElementChild.setAttribute("title", e);
        }

        _getTitle() {
          return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
        }

        _isFullscreen() {
          return this._fullscreen;
        }

        _changeIcon() {
          (e.window.document.fullscreenElement || e.window.document.webkitFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"), this._updateTitle());
        }

        _onClickFullscreen() {
          this._isFullscreen() ? e.window.document.exitFullscreen ? e.window.document.exitFullscreen() : e.window.document.webkitCancelFullScreen && e.window.document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();
        }

      },
      Popup: class extends e.Evented {
        constructor(t) {
          super(), this.options = e.extend(Object.create(nn), t), e.bindAll(["_update", "_onClose", "remove", "_onMouseEvent"], this), this._classList = new Set(t && t.className ? t.className.trim().split(/\s+/) : []);
        }

        addTo(t) {
          return this._map && this.remove(), this._map = t, this.options.closeOnClick && t.on("preclick", this._onClose), this.options.closeOnMove && t.on("move", this._onClose), t.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (t.on("mousemove", this._onMouseEvent), t.on("mouseup", this._onMouseEvent), t._canvasContainer.classList.add("mapboxgl-track-pointer")) : t.on("move", this._update), this.fire(new e.Event("open")), this;
        }

        isOpen() {
          return !!this._map;
        }

        remove() {
          this._content && this._content.remove(), this._container && (this._container.remove(), this._container = void 0);
          const t = this._map;
          return t && (t.off("move", this._update), t.off("move", this._onClose), t.off("preclick", this._onClose), t.off("click", this._onClose), t.off("remove", this.remove), t.off("mousemove", this._onMouseEvent), t.off("mouseup", this._onMouseEvent), t.off("drag", this._onMouseEvent), this._map = void 0), this.fire(new e.Event("close")), this;
        }

        getLngLat() {
          return this._lngLat;
        }

        setLngLat(t) {
          this._lngLat = e.LngLat.convert(t), this._pos = null, this._trackPointer = !1, this._update();
          const i = this._map;
          return i && (i.on("move", this._update), i.off("mousemove", this._onMouseEvent), i._canvasContainer.classList.remove("mapboxgl-track-pointer")), this;
        }

        trackPointer() {
          this._trackPointer = !0, this._pos = null, this._update();
          const e = this._map;
          return e && (e.off("move", this._update), e.on("mousemove", this._onMouseEvent), e.on("drag", this._onMouseEvent), e._canvasContainer.classList.add("mapboxgl-track-pointer")), this;
        }

        getElement() {
          return this._container;
        }

        setText(t) {
          return this.setDOMContent(e.window.document.createTextNode(t));
        }

        setHTML(t) {
          const i = e.window.document.createDocumentFragment(),
                o = e.window.document.createElement("body");
          let r;

          for (o.innerHTML = t; r = o.firstChild, r;) i.appendChild(r);

          return this.setDOMContent(i);
        }

        getMaxWidth() {
          return this._container && this._container.style.maxWidth;
        }

        setMaxWidth(e) {
          return this.options.maxWidth = e, this._update(), this;
        }

        setDOMContent(e) {
          let t = this._content;
          if (t) for (; t.hasChildNodes();) t.firstChild && t.removeChild(t.firstChild);else t = this._content = n("div", "mapboxgl-popup-content", this._container || void 0);

          if (t.appendChild(e), this.options.closeButton) {
            const e = this._closeButton = n("button", "mapboxgl-popup-close-button", t);
            e.type = "button", e.setAttribute("aria-label", "Close popup"), e.setAttribute("aria-hidden", "true"), e.innerHTML = "&#215;", e.addEventListener("click", this._onClose);
          }

          return this._update(), this._focusFirstElement(), this;
        }

        addClassName(e) {
          return this._classList.add(e), this._updateClassList(), this;
        }

        removeClassName(e) {
          return this._classList.delete(e), this._updateClassList(), this;
        }

        setOffset(e) {
          return this.options.offset = e, this._update(), this;
        }

        toggleClassName(e) {
          let t;
          return this._classList.delete(e) ? t = !1 : (this._classList.add(e), t = !0), this._updateClassList(), t;
        }

        _onMouseEvent(e) {
          this._update(e.point);
        }

        _getAnchor(e) {
          if (this.options.anchor) return this.options.anchor;
          const t = this._map,
                i = this._container,
                o = this._pos;
          if (!t || !i || !o) return "bottom";
          const r = i.offsetWidth,
                n = i.offsetHeight,
                a = o.x < r / 2,
                s = o.x > t.transform.width - r / 2;
          if (o.y + e < n) return a ? "top-left" : s ? "top-right" : "top";

          if (o.y > t.transform.height - n) {
            if (a) return "bottom-left";
            if (s) return "bottom-right";
          }

          return a ? "left" : s ? "right" : "bottom";
        }

        _updateClassList() {
          const e = this._container;
          if (!e) return;
          const t = [...this._classList];
          t.push("mapboxgl-popup"), this._anchor && t.push(`mapboxgl-popup-anchor-${this._anchor}`), this._trackPointer && t.push("mapboxgl-popup-track-pointer"), e.className = t.join(" ");
        }

        _update(e) {
          const t = this._map,
                i = this._content;
          if (!t || !this._lngLat && !this._trackPointer || !i) return;
          let o = this._container;

          if (o || (o = this._container = n("div", "mapboxgl-popup", t.getContainer()), this._tip = n("div", "mapboxgl-popup-tip", o), o.appendChild(i)), this.options.maxWidth && o.style.maxWidth !== this.options.maxWidth && (o.style.maxWidth = this.options.maxWidth), t.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = jr(this._lngLat, this._pos, t.transform)), !this._trackPointer || e) {
            const i = this._pos = this._trackPointer && e ? e : t.project(this._lngLat),
                  o = sn(this.options.offset),
                  r = this._anchor = this._getAnchor(o.y),
                  n = sn(this.options.offset, r),
                  a = i.add(n).round();

            t._requestDomTask(() => {
              this._container && r && (this._container.style.transform = `${Zr[r]} translate(${a.x}px,${a.y}px)`);
            });
          }

          this._updateClassList();
        }

        _focusFirstElement() {
          if (!this.options.focusAfterOpen || !this._container) return;

          const e = this._container.querySelector(an);

          e && e.focus();
        }

        _onClose() {
          this.remove();
        }

        _setOpacity(e) {
          this._content && (this._content.style.opacity = e), this._tip && (this._tip.style.opacity = e);
        }

      },
      Marker: Vr,
      Style: $t,
      LngLat: e.LngLat,
      LngLatBounds: e.LngLatBounds,
      Point: e.pointGeometry,
      MercatorCoordinate: e.MercatorCoordinate,
      FreeCameraOptions: Ao,
      Evented: e.Evented,
      config: e.config,
      prewarm: function () {
        Ue().acquire(Oe);
      },
      clearPrewarmedResources: function () {
        const e = Fe;
        e && (e.isPreloaded() && 1 === e.numActive() ? (e.release(Oe), Fe = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
      },

      get accessToken() {
        return e.config.ACCESS_TOKEN;
      },

      set accessToken(t) {
        e.config.ACCESS_TOKEN = t;
      },

      get baseApiUrl() {
        return e.config.API_URL;
      },

      set baseApiUrl(t) {
        e.config.API_URL = t;
      },

      get workerCount() {
        return Be.workerCount;
      },

      set workerCount(e) {
        Be.workerCount = e;
      },

      get maxParallelImageRequests() {
        return e.config.MAX_PARALLEL_IMAGE_REQUESTS;
      },

      set maxParallelImageRequests(t) {
        e.config.MAX_PARALLEL_IMAGE_REQUESTS = t;
      },

      clearStorage(t) {
        e.clearTileCache(t);
      },

      workerUrl: "",
      workerClass: null,
      setNow: e.exported.setNow,
      restoreNow: e.exported.restoreNow
    };
    return ln;
  }); //

  var mapboxgl$1 = mapboxgl;
  return mapboxgl$1;
});
},{}],"index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deck = void 0;

var _core = require("@deck.gl/core");

var _layers = require("@deck.gl/layers");

var _mapboxGl = _interopRequireDefault(require("mapbox-gl"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// source: Natural Earth http://www.naturalearthdata.com/ via geojson.xyz
var AIR_PORTS = 'https://d2ad6b4ur7yvpq.cloudfront.net/naturalearth-3.3.0/ne_10m_airports.geojson';
var INITIAL_VIEW_STATE = {
  latitude: 51.47,
  longitude: 0.45,
  zoom: 4,
  bearing: 0,
  pitch: 30
};
var MAP_STYLE = 'https://basemaps.cartocdn.com/gl/positron-nolabels-gl-style/style.json';
_mapboxGl.default.accessToken = 'pk.eyJ1Ijoic21ldWVsZW5hIiwiYSI6ImNreWVmZjRuZjBlNG4ybnFwcGhlN3R5MWEifQ.74pQn39jtMpuSw647TLAFA';
var map = new _mapboxGl.default.Map({
  container: 'map',
  style: MAP_STYLE,
  // Note: deck.gl will be in charge of interaction and event handling
  interactive: false,
  center: [INITIAL_VIEW_STATE.longitude, INITIAL_VIEW_STATE.latitude],
  zoom: INITIAL_VIEW_STATE.zoom,
  bearing: INITIAL_VIEW_STATE.bearing,
  pitch: INITIAL_VIEW_STATE.pitch
});
var deck = new _core.Deck({
  canvas: 'deck-canvas',
  width: '100%',
  height: '100%',
  initialViewState: INITIAL_VIEW_STATE,
  controller: true,
  onViewStateChange: function onViewStateChange(_ref) {
    var viewState = _ref.viewState;
    map.jumpTo({
      center: [viewState.longitude, viewState.latitude],
      zoom: viewState.zoom,
      bearing: viewState.bearing,
      pitch: viewState.pitch
    });
  },
  layers: [new _layers.GeoJsonLayer({
    id: 'airports',
    data: AIR_PORTS,
    // Styles
    filled: true,
    pointRadiusMinPixels: 2,
    pointRadiusScale: 2000,
    getPointRadius: function getPointRadius(f) {
      return 11 - f.properties.scalerank;
    },
    getFillColor: [200, 0, 80, 180],
    // Interactive props
    pickable: true,
    autoHighlight: true,
    onClick: function onClick(info) {
      return (// eslint-disable-next-line
        info.object && alert("".concat(info.object.properties.name, " (").concat(info.object.properties.abbrev, ")"))
      );
    }
  }), new _layers.ArcLayer({
    id: 'arcs',
    data: AIR_PORTS,
    dataTransform: function dataTransform(d) {
      return d.features.filter(function (f) {
        return f.properties.scalerank < 4;
      });
    },
    // Styles
    getSourcePosition: function getSourcePosition(f) {
      return [-0.4531566, 51.4709959];
    },
    // London
    getTargetPosition: function getTargetPosition(f) {
      return f.geometry.coordinates;
    },
    getSourceColor: [0, 128, 200],
    getTargetColor: [200, 0, 80],
    getWidth: 1
  })]
});
exports.deck = deck;
},{"@deck.gl/core":"node_modules/@deck.gl/core/dist/esm/index.js","@deck.gl/layers":"node_modules/@deck.gl/layers/dist/esm/index.js","mapbox-gl":"node_modules/mapbox-gl/dist/mapbox-gl.js"}],"../../.nvm/versions/node/v16.15.0/lib/node_modules/parcel-bundler/src/builtins/hmr-runtime.js":[function(require,module,exports) {
var global = arguments[3];
var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;

function Module(moduleName) {
  OldModule.call(this, moduleName);
  this.hot = {
    data: module.bundle.hotData,
    _acceptCallbacks: [],
    _disposeCallbacks: [],
    accept: function (fn) {
      this._acceptCallbacks.push(fn || function () {});
    },
    dispose: function (fn) {
      this._disposeCallbacks.push(fn);
    }
  };
  module.bundle.hotData = null;
}

module.bundle.Module = Module;
var checkedAssets, assetsToAccept;
var parent = module.bundle.parent;

if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
  var hostname = "" || location.hostname;
  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';
  var ws = new WebSocket(protocol + '://' + hostname + ':' + "62656" + '/');

  ws.onmessage = function (event) {
    checkedAssets = {};
    assetsToAccept = [];
    var data = JSON.parse(event.data);

    if (data.type === 'update') {
      var handled = false;
      data.assets.forEach(function (asset) {
        if (!asset.isNew) {
          var didAccept = hmrAcceptCheck(global.parcelRequire, asset.id);

          if (didAccept) {
            handled = true;
          }
        }
      }); // Enable HMR for CSS by default.

      handled = handled || data.assets.every(function (asset) {
        return asset.type === 'css' && asset.generated.js;
      });

      if (handled) {
        console.clear();
        data.assets.forEach(function (asset) {
          hmrApply(global.parcelRequire, asset);
        });
        assetsToAccept.forEach(function (v) {
          hmrAcceptRun(v[0], v[1]);
        });
      } else if (location.reload) {
        // `location` global exists in a web worker context but lacks `.reload()` function.
        location.reload();
      }
    }

    if (data.type === 'reload') {
      ws.close();

      ws.onclose = function () {
        location.reload();
      };
    }

    if (data.type === 'error-resolved') {
      console.log('[parcel] ✨ Error resolved');
      removeErrorOverlay();
    }

    if (data.type === 'error') {
      console.error('[parcel] 🚨  ' + data.error.message + '\n' + data.error.stack);
      removeErrorOverlay();
      var overlay = createErrorOverlay(data);
      document.body.appendChild(overlay);
    }
  };
}

function removeErrorOverlay() {
  var overlay = document.getElementById(OVERLAY_ID);

  if (overlay) {
    overlay.remove();
  }
}

function createErrorOverlay(data) {
  var overlay = document.createElement('div');
  overlay.id = OVERLAY_ID; // html encode message and stack trace

  var message = document.createElement('div');
  var stackTrace = document.createElement('pre');
  message.innerText = data.error.message;
  stackTrace.innerText = data.error.stack;
  overlay.innerHTML = '<div style="background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;">' + '<span style="background: red; padding: 2px 4px; border-radius: 2px;">ERROR</span>' + '<span style="top: 2px; margin-left: 5px; position: relative;">🚨</span>' + '<div style="font-size: 18px; font-weight: bold; margin-top: 20px;">' + message.innerHTML + '</div>' + '<pre>' + stackTrace.innerHTML + '</pre>' + '</div>';
  return overlay;
}

function getParents(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return [];
  }

  var parents = [];
  var k, d, dep;

  for (k in modules) {
    for (d in modules[k][1]) {
      dep = modules[k][1][d];

      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {
        parents.push(k);
      }
    }
  }

  if (bundle.parent) {
    parents = parents.concat(getParents(bundle.parent, id));
  }

  return parents;
}

function hmrApply(bundle, asset) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (modules[asset.id] || !bundle.parent) {
    var fn = new Function('require', 'module', 'exports', asset.generated.js);
    asset.isNew = !modules[asset.id];
    modules[asset.id] = [fn, asset.deps];
  } else if (bundle.parent) {
    hmrApply(bundle.parent, asset);
  }
}

function hmrAcceptCheck(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (!modules[id] && bundle.parent) {
    return hmrAcceptCheck(bundle.parent, id);
  }

  if (checkedAssets[id]) {
    return;
  }

  checkedAssets[id] = true;
  var cached = bundle.cache[id];
  assetsToAccept.push([bundle, id]);

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    return true;
  }

  return getParents(global.parcelRequire, id).some(function (id) {
    return hmrAcceptCheck(global.parcelRequire, id);
  });
}

function hmrAcceptRun(bundle, id) {
  var cached = bundle.cache[id];
  bundle.hotData = {};

  if (cached) {
    cached.hot.data = bundle.hotData;
  }

  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {
    cached.hot._disposeCallbacks.forEach(function (cb) {
      cb(bundle.hotData);
    });
  }

  delete bundle.cache[id];
  bundle(id);
  cached = bundle.cache[id];

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    cached.hot._acceptCallbacks.forEach(function (cb) {
      cb();
    });

    return true;
  }
}
},{}]},{},["../../.nvm/versions/node/v16.15.0/lib/node_modules/parcel-bundler/src/builtins/hmr-runtime.js","index.js"], null)
//# sourceMappingURL=/train-data.e31bb0bc.js.map